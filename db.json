{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/assets/hbe.style.css","path":"assets/hbe.style.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/assets/odometer-theme-minimal.css","path":"assets/odometer-theme-minimal.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/tailwind.source.css","path":"css/tailwind.source.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/all.min.css","path":"fontawesome/all.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/brands.min.css","path":"fontawesome/brands.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/duotone.min.css","path":"fontawesome/duotone.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/fontawesome.min.css","path":"fontawesome/fontawesome.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/light.min.css","path":"fontawesome/light.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/regular.min.css","path":"fontawesome/regular.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/sharp-solid.min.css","path":"fontawesome/sharp-solid.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/solid.min.css","path":"fontawesome/solid.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/svg-with-js.min.css","path":"fontawesome/svg-with-js.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/thin.min.css","path":"fontawesome/thin.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-font-face.min.css","path":"fontawesome/v4-font-face.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-shims.min.css","path":"fontawesome/v4-shims.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v5-font-face.min.css","path":"fontawesome/v5-font-face.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/bookmark-placeholder.svg","path":"images/bookmark-placeholder.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-avatar.svg","path":"images/redefine-avatar.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/loading.svg","path":"images/loading.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-favicon.svg","path":"images/redefine-favicon.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.svg","path":"images/redefine-logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.webp","path":"images/redefine-logo.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-og.webp","path":"images/redefine-og.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-dark.webp","path":"images/wallhaven-wqery6-dark.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-light.webp","path":"images/wallhaven-wqery6-light.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build.js","path":"js/build.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.ttf","path":"webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.ttf","path":"webfonts/fa-duotone-900.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.woff2","path":"webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.woff2","path":"webfonts/fa-duotone-900.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.ttf","path":"webfonts/fa-light-300.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.woff2","path":"webfonts/fa-light-300.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.ttf","path":"webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.woff2","path":"webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.ttf","path":"webfonts/fa-sharp-solid-900.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.woff2","path":"webfonts/fa-sharp-solid-900.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.ttf","path":"webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.woff2","path":"webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.ttf","path":"webfonts/fa-thin-100.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.woff2","path":"webfonts/fa-thin-100.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.ttf","path":"webfonts/fa-v4compatibility.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.woff2","path":"webfonts/fa-v4compatibility.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/build/tailwind.css","path":"css/build/tailwind.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/animated.styl","path":"css/common/animated.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/colors.styl","path":"css/common/colors.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/basic.styl","path":"css/common/basic.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/markdown.styl","path":"css/common/markdown.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/redefine-theme.styl","path":"css/common/redefine-theme.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/theme.styl","path":"css/common/theme.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/variables.styl","path":"css/common/variables.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/animations.styl","path":"css/layout/animations.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/archive-content.styl","path":"css/layout/archive-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/bookmarks.styl","path":"css/layout/bookmarks.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-content.styl","path":"css/layout/category-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-list.styl","path":"css/layout/category-list.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/article-content.styl","path":"css/layout/article-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-content.styl","path":"css/layout/home-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-sidebar.styl","path":"css/layout/home-sidebar.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/tag-content.styl","path":"css/layout/tag-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/page.styl","path":"css/layout/page.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.eot","path":"fonts/Chillax/Chillax-Variable.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff","path":"fonts/Chillax/Chillax-Variable.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.ttf","path":"fonts/Chillax/Chillax-Variable.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff2","path":"fonts/Chillax/Chillax-Variable.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/chillax.css","path":"fonts/Chillax/chillax.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.ttf","path":"fonts/Geist/GeistVF.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.woff2","path":"fonts/Geist/GeistVF.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.woff","path":"fonts/Geist/GeistVF.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/geist.css","path":"fonts/Geist/geist.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.ttf","path":"fonts/GeistMono/GeistMonoVF.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.woff","path":"fonts/GeistMono/GeistMonoVF.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.woff2","path":"fonts/GeistMono/GeistMonoVF.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/geist-mono.css","path":"fonts/GeistMono/geist-mono.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/main.js","path":"js/build/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/main.js.map","path":"js/build/main.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/utils.js.map","path":"js/build/utils.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/utils.js","path":"js/build/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/bookmarkNav.js","path":"js/layouts/bookmarkNav.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/essays.js","path":"js/layouts/essays.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/categoryList.js","path":"js/layouts/categoryList.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/lazyload.js","path":"js/layouts/lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/navbarShrink.js","path":"js/layouts/navbarShrink.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/toc.js","path":"js/layouts/toc.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js","path":"js/libs/APlayer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js.map","path":"js/libs/APlayer.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js","path":"js/libs/Swup.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js.map","path":"js/libs/Swup.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js","path":"js/libs/SwupPreloadPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js.map","path":"js/libs/SwupPreloadPlugin.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScriptsPlugin.min.js","path":"js/libs/SwupScriptsPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js","path":"js/libs/SwupScrollPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupProgressPlugin.min.js","path":"js/libs/SwupProgressPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js.map","path":"js/libs/SwupScrollPlugin.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Typed.min.js","path":"js/libs/Typed.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupSlideTheme.min.js","path":"js/libs/SwupSlideTheme.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/anime.min.js","path":"js/libs/anime.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js","path":"js/libs/mermaid.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js.map","path":"js/libs/mermaid.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/moment-with-locales.min.js","path":"js/libs/moment-with-locales.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/minimasonry.min.js","path":"js/libs/minimasonry.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/moment.min.js","path":"js/libs/moment.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/odometer.min.js","path":"js/libs/odometer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/pjax.min.js","path":"js/libs/pjax.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs","path":"js/libs/waline.mjs","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs.map","path":"js/libs/waline.mjs.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/pangu.min.js","path":"js/libs/pangu.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/aplayer.js","path":"js/plugins/aplayer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/hbe.js","path":"js/plugins/hbe.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/masonry.js","path":"js/plugins/masonry.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/mermaid.js","path":"js/plugins/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/tabs.js","path":"js/plugins/tabs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/typed.js","path":"js/plugins/typed.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/pangu.js","path":"js/plugins/pangu.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/codeBlock.js","path":"js/tools/codeBlock.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/imageViewer.js","path":"js/tools/imageViewer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/lightDarkSwitch.js","path":"js/tools/lightDarkSwitch.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/localSearch.js","path":"js/tools/localSearch.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/scrollTopBottom.js","path":"js/tools/scrollTopBottom.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/tocToggle.js","path":"js/tools/tocToggle.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/runtime.js","path":"js/tools/runtime.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-block.styl","path":"css/common/codeblock/code-block.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-theme.styl","path":"css/common/codeblock/code-theme.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/highlight.styl","path":"css/common/codeblock/highlight.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/bookmarkNav.js","path":"js/build/layouts/bookmarkNav.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/bookmarkNav.js.map","path":"js/build/layouts/bookmarkNav.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/categoryList.js","path":"js/build/layouts/categoryList.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/categoryList.js.map","path":"js/build/layouts/categoryList.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/essays.js","path":"js/build/layouts/essays.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/essays.js.map","path":"js/build/layouts/essays.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/lazyload.js","path":"js/build/layouts/lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/lazyload.js.map","path":"js/build/layouts/lazyload.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/navbarShrink.js","path":"js/build/layouts/navbarShrink.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/navbarShrink.js.map","path":"js/build/layouts/navbarShrink.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/toc.js","path":"js/build/layouts/toc.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/toc.js.map","path":"js/build/layouts/toc.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/APlayer.min.js","path":"js/build/libs/APlayer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/Swup.min.js","path":"js/build/libs/Swup.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupPreloadPlugin.min.js","path":"js/build/libs/SwupPreloadPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupProgressPlugin.min.js","path":"js/build/libs/SwupProgressPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupScriptsPlugin.min.js","path":"js/build/libs/SwupScriptsPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupScrollPlugin.min.js","path":"js/build/libs/SwupScrollPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupSlideTheme.min.js","path":"js/build/libs/SwupSlideTheme.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/Typed.min.js","path":"js/build/libs/Typed.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/anime.min.js","path":"js/build/libs/anime.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/mermaid.min.js","path":"js/build/libs/mermaid.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/minimasonry.min.js","path":"js/build/libs/minimasonry.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/moment-with-locales.min.js","path":"js/build/libs/moment-with-locales.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/moment.min.js","path":"js/build/libs/moment.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/odometer.min.js","path":"js/build/libs/odometer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/pangu.min.js","path":"js/build/libs/pangu.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/pjax.min.js","path":"js/build/libs/pjax.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/codeBlock.js","path":"js/build/tools/codeBlock.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/codeBlock.js.map","path":"js/build/tools/codeBlock.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/imageViewer.js","path":"js/build/tools/imageViewer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/imageViewer.js.map","path":"js/build/tools/imageViewer.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/lightDarkSwitch.js","path":"js/build/tools/lightDarkSwitch.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/lightDarkSwitch.js.map","path":"js/build/tools/lightDarkSwitch.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/localSearch.js","path":"js/build/tools/localSearch.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/localSearch.js.map","path":"js/build/tools/localSearch.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/runtime.js","path":"js/build/tools/runtime.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/runtime.js.map","path":"js/build/tools/runtime.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/scrollTopBottom.js","path":"js/build/tools/scrollTopBottom.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/scrollTopBottom.js.map","path":"js/build/tools/scrollTopBottom.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/tocToggle.js","path":"js/build/tools/tocToggle.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/tocToggle.js.map","path":"js/build/tools/tocToggle.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/aplayer.js","path":"js/build/plugins/aplayer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/aplayer.js.map","path":"js/build/plugins/aplayer.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/hbe.js","path":"js/build/plugins/hbe.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/hbe.js.map","path":"js/build/plugins/hbe.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/masonry.js","path":"js/build/plugins/masonry.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/masonry.js.map","path":"js/build/plugins/masonry.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/mermaid.js","path":"js/build/plugins/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/mermaid.js.map","path":"js/build/plugins/mermaid.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/pangu.js","path":"js/build/plugins/pangu.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/pangu.js.map","path":"js/build/plugins/pangu.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/tabs.js","path":"js/build/plugins/tabs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/tabs.js.map","path":"js/build/plugins/tabs.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/typed.js","path":"js/build/plugins/typed.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/typed.js.map","path":"js/build/plugins/typed.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/a11y-dark.styl","path":"css/common/codeblock/hljs-themes/dark/a11y-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/agate.styl","path":"css/common/codeblock/hljs-themes/dark/agate.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/atom-one-dark.styl","path":"css/common/codeblock/hljs-themes/dark/atom-one-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/github-dark.styl","path":"css/common/codeblock/hljs-themes/dark/github-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/monokai-sublime.styl","path":"css/common/codeblock/hljs-themes/dark/monokai-sublime.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/night-owl.styl","path":"css/common/codeblock/hljs-themes/dark/night-owl.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/nord.styl","path":"css/common/codeblock/hljs-themes/dark/nord.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/tokyo-night-dark.styl","path":"css/common/codeblock/hljs-themes/dark/tokyo-night-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/vs2015.styl","path":"css/common/codeblock/hljs-themes/dark/vs2015.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/atom-one-light.styl","path":"css/common/codeblock/hljs-themes/light/atom-one-light.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/default.styl","path":"css/common/codeblock/hljs-themes/light/default.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/github.styl","path":"css/common/codeblock/hljs-themes/light/github.styl","modified":0,"renderable":1},{"_id":"source/images/CI流程.svg","path":"images/CI流程.svg","modified":0,"renderable":0},{"_id":"source/images/堡垒机工作流程.svg","path":"images/堡垒机工作流程.svg","modified":0,"renderable":0},{"_id":"source/images/yjt中SaaS的前端部署方式.svg","path":"images/yjt中SaaS的前端部署方式.svg","modified":0,"renderable":0},{"_id":"source/images/OpenVpn+堡垒机结合前端部署.svg","path":"images/OpenVpn+堡垒机结合前端部署.svg","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/吗喽.jpg","path":"images/吗喽.jpg","modified":0,"renderable":0},{"_id":"source/images/nuxt核心工作流.png","path":"images/nuxt核心工作流.png","modified":0,"renderable":0},{"_id":"source/images/微前端.png","path":"images/微前端.png","modified":0,"renderable":0},{"_id":"source/images/微前端架构.png","path":"images/微前端架构.png","modified":0,"renderable":0},{"_id":"source/images/客户端渲染流程.png","path":"images/客户端渲染流程.png","modified":0,"renderable":0},{"_id":"source/images/服务端渲染流程.png","path":"images/服务端渲染流程.png","modified":0,"renderable":0},{"_id":"source/images/pitching_loader_1.png","path":"images/pitching_loader_1.png","modified":0,"renderable":0},{"_id":"source/images/pitching_loader_2.png","path":"images/pitching_loader_2.png","modified":0,"renderable":0},{"_id":"source/images/pic_HMR.png","path":"images/pic_HMR.png","modified":0,"renderable":0},{"_id":"source/images/热更新.png","path":"images/热更新.png","modified":0,"renderable":0},{"_id":"source/images/vue_prototype.png","path":"images/vue_prototype.png","modified":0,"renderable":0},{"_id":"source/images/vue-cli默认配置.png","path":"images/vue-cli默认配置.png","modified":0,"renderable":0},{"_id":"source/images/Watcher工作流程.svg","path":"images/Watcher工作流程.svg","modified":0,"renderable":0},{"_id":"source/images/浏览器渲染流程.png","path":"images/浏览器渲染流程.png","modified":0,"renderable":0},{"_id":"source/images/关键渲染路径.png","path":"images/关键渲染路径.png","modified":1,"renderable":0},{"_id":"source/images/callstack.webp","path":"images/callstack.webp","modified":1,"renderable":0},{"_id":"source/images/主线程中的eventloop.png","path":"images/主线程中的eventloop.png","modified":1,"renderable":0},{"_id":"source/images/eventloop流程.png","path":"images/eventloop流程.png","modified":1,"renderable":0},{"_id":"source/images/async和微任务.png","path":"images/async和微任务.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1757842258599},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"a93d7b3990e45bc7247eecf01888f71674887a63","modified":1757842276618},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"6497b70356271fd6f9f1dc862353be844c457a53","modified":1757842276596},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"06889bee30e4c39479467021da434d3a6a0990fc","modified":1757842276595},{"_id":"node_modules/hexo-theme-landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1757842276619},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1757842276620},{"_id":"node_modules/hexo-theme-landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1757842276620},{"_id":"node_modules/hexo-theme-landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1757842276621},{"_id":"node_modules/hexo-theme-landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1757842276621},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1757842276432},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1757842276621},{"_id":"node_modules/hexo-theme-landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1757842276622},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1757842276622},{"_id":"node_modules/hexo-theme-landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1757842276622},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1757842276623},{"_id":"node_modules/hexo-theme-landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1757842276623},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1757842276623},{"_id":"node_modules/hexo-theme-landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1757842276624},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1757842276624},{"_id":"node_modules/hexo-theme-landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1757842276625},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1757842276625},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1757842276626},{"_id":"node_modules/hexo-theme-landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1757842276626},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1757842276626},{"_id":"node_modules/hexo-theme-landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1757842276626},{"_id":"node_modules/hexo-theme-landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1757842276627},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1757842276627},{"_id":"node_modules/hexo-theme-landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1757842276628},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1757842276628},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1757842276628},{"_id":"node_modules/hexo-theme-landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1757842276629},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1757842276629},{"_id":"node_modules/hexo-theme-landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1757842276630},{"_id":"node_modules/hexo-theme-landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1757842276630},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1757842276630},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1757842276631},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1757842276631},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"57281fc3812c877ec2d8e89ec87ede57b9789d4c","modified":1757842276558},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1757842276558},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1757842276561},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1757842276539},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1757842276584},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1757842276526},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1757842276560},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1757842276565},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"1b89d0caba03a66a43d9c290a5e94fa438a89210","modified":1757842276488},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"0039146b8ccbdf9b9f8bee58fc6c238f0e9921fc","modified":1757842276499},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1757842276496},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1757842276545},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1757842276542},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"0e94f5722d4c44d3cc91be2f4fd30b9ab503b868","modified":1757842276554},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1757842276562},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"e9d4678e14be5e3cd5e34d783e5af6d6626092f5","modified":1757842276531},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1757842276562},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1757842276559},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1757842276564},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1757842276566},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1757842276600},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1757842276601},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1757842276618},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1757842276556},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1757842276594},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1757842276537},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1757842276514},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1757842276463},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1757842276536},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1757842276563},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1757842276567},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1757842276610},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1757842276612},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1757842276602},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"f608400a08cf137ab15ec1f44bac551950afe879","modified":1757842276603},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1757842276604},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1757842276606},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1757842276611},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1757842276611},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1757842276612},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1757842276613},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1757842276614},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1757842276617},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1757842276541},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1757842276560},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1757842276543},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1757842276546},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1757842276594},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1757842276589},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1757842276583},{"_id":"public/2025/09/14/hello-world/index.html","hash":"7805ffd9f331b13f0809de74fdb0899d242fad7a","modified":1757843626261},{"_id":"public/archives/index.html","hash":"637660aa1f4914e67c14a1de7a5b25b2752e390a","modified":1757843626261},{"_id":"public/archives/2025/index.html","hash":"3851464fbbd3af13a3d7aa16ee99a07491276c57","modified":1757843626261},{"_id":"public/archives/2025/09/index.html","hash":"8a874516b413bb1395d1de9275da11471ceb1b1e","modified":1757843626261},{"_id":"public/index.html","hash":"3fa5028fe9536bf3db3bd31f7a99e6d33a5be2b2","modified":1757843626261},{"_id":"public/css/style.css","hash":"ecc329be740a220cc188ff49b02da4847cb7ee5e","modified":1757843626261},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1757843626261},{"_id":"public/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1757843626261},{"_id":"public/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1757843626261},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1757843626261},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1757843626261},{"_id":"source/.DS_Store","hash":"b17bceeda9cbb18d8ba9ad4b61e7e3e0c701d823","modified":1757863928664},{"_id":"source/_posts/.DS_Store","hash":"e1aec83ae5a170dc1b0ebafc3446e393956162d5","modified":1757863933676},{"_id":"source/_posts/Nuxt.js.md","hash":"de6ff34424330d2be56042690ec4329813ca61ff","modified":1757857002793},{"_id":"source/_posts/微前端.md","hash":"6adb4448042d1c4ee8db7622f847f9b41eab093c","modified":1757857819615},{"_id":"source/_posts/前端部署详解.md","hash":"47ade42a06815de054afacb82fcca1b632802c6a","modified":1757853119223},{"_id":"node_modules/hexo-theme-redefine/.coderabbit.yaml","hash":"ba28a5250f22db9a8eb9cd1ee282285eddd848a8","modified":1757848811479},{"_id":"node_modules/hexo-theme-redefine/DONATION.md","hash":"08e105bad07d733efb98543a034f930c569f5c2f","modified":1757848808973},{"_id":"node_modules/hexo-theme-redefine/README_zh-CN.md","hash":"1456215db749caca6f2dab3d70b9182a7d0c69c8","modified":1757848808973},{"_id":"node_modules/hexo-theme-redefine/README.md","hash":"6f47fb08c3a3353f6735e064be117f33d1e66540","modified":1757848808973},{"_id":"node_modules/hexo-theme-redefine/CONTRIBUTING.md","hash":"c6ef834f602b7ae02e2863a2a857e0ce8d392f15","modified":1757848808973},{"_id":"node_modules/hexo-theme-redefine/CODE_OF_CONDUCT.md","hash":"61a6276ef54989b7a1325f3ecb3183a4dfdf50cb","modified":1757848808973},{"_id":"node_modules/hexo-theme-redefine/README_zh-TW.md","hash":"5ac48e225ad90bdc0265f496e4c4ffb251b74a89","modified":1757848808973},{"_id":"node_modules/hexo-theme-redefine/package.json","hash":"d1c68a3b597d971dc31812430706307364214a67","modified":1757848807254},{"_id":"node_modules/hexo-theme-redefine/_config.yml","hash":"9cc3ea9bf18474dc2ed140631a737f9fac2a22fe","modified":1757848811481},{"_id":"node_modules/hexo-theme-redefine/LICENSE","hash":"1de7bacb4fbbd7b6d391a69abfe174c2509ec303","modified":1757848806017},{"_id":"node_modules/hexo-theme-redefine/languages/en.yml","hash":"4cc09fff6895fd864044d7c11f8638ab92d98453","modified":1757848811484},{"_id":"node_modules/hexo-theme-redefine/languages/es.yml","hash":"b244609cd9349791883b28cad0fb05a26c1cd0fe","modified":1757848811487},{"_id":"node_modules/hexo-theme-redefine/languages/fr.yml","hash":"a249af0bd206f10ce78b186b8f0ef6c483ddfcad","modified":1757848811487},{"_id":"node_modules/hexo-theme-redefine/vercel.json","hash":"357c1fd2678f8ae4a9a852a1a6888c8eca774551","modified":1757848807254},{"_id":"node_modules/hexo-theme-redefine/.husky/pre-commit","hash":"843996b47615c2f8c1037db9183de3006166ac1d","modified":1757848806019},{"_id":"node_modules/hexo-theme-redefine/scripts/config-export.js","hash":"b10185069cd3f3fd7873982e259e402d5f146a58","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/scripts/data-handle.js","hash":"c72188b7dd0596d618ecbd3deb1b49ef257014df","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/languages/zh-TW.yml","hash":"16b4abceec032d5e66cd6431b35900740d4d8e3b","modified":1757848811492},{"_id":"node_modules/hexo-theme-redefine/languages/zh-CN.yml","hash":"67d93982759d79f38afadeef871c80b08c21c7ca","modified":1757848811490},{"_id":"node_modules/hexo-theme-redefine/languages/ja.yml","hash":"6da103d89685ddf6da4c367efd699c6fc1a15f84","modified":1757848811488},{"_id":"node_modules/hexo-theme-redefine/layout/index.ejs","hash":"f5fee4e079a9c2c23059ebde4cd89ec723e310c6","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/layout.ejs","hash":"ecf818cd11e363c1a33e7105ac415d8c192c1f73","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/archive.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1757848806359},{"_id":"node_modules/hexo-theme-redefine/layout/404.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1757848806359},{"_id":"node_modules/hexo-theme-redefine/layout/page.ejs","hash":"3dc83dae73b48b3e6ae65bdaf6106ec711c88ecd","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/bug-english.yml","hash":"bf91936a78a2e444dbaf916755f502cc0abe7be3","modified":1757848811484},{"_id":"node_modules/hexo-theme-redefine/layout/category.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1757848806361},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/bug-chinese.yml","hash":"73df1f0aabb527a9e3c131d0f0eda0db8b7a1f3b","modified":1757848811484},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/enhancement-english.yml","hash":"d072e75c10673fb70be74f89dff8b1bae6df0c8f","modified":1757848811487},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/enhancement-chinese.yml","hash":"1ea9f2b52f53e5d1525bb22709bcf37da5a6da01","modified":1757848811486},{"_id":"node_modules/hexo-theme-redefine/layout/tag.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/aliyun-cdn-publish.yml","hash":"18975c5422509b0fb7c3b6ddd788eac65802781a","modified":1757848811483},{"_id":"node_modules/hexo-theme-redefine/layout/tags.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/production-deployment.yml","hash":"78ed9a5458cd8aa21edd0a03789575089f922364","modified":1757848811490},{"_id":"node_modules/hexo-theme-redefine/layout/post.ejs","hash":"f5fee4e079a9c2c23059ebde4cd89ec723e310c6","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/preview-deployment.yml","hash":"25068f67bb279c374e578a568d1e600d41e197f9","modified":1757848811489},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/npm-publish.yml","hash":"3379098cb32de9ee4f6e69eb91505a4d3a2f37e6","modified":1757848811488},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/build-and-commit.yml","hash":"6cb6834cd753e38dadb25c6492347ddd247935ea","modified":1757848811484},{"_id":"node_modules/hexo-theme-redefine/scripts/events/404.js","hash":"a444a2ef3af3e2dc9ebc0b92d76a323dc02c6023","modified":1757848806421},{"_id":"node_modules/hexo-theme-redefine/scripts/events/welcome.js","hash":"7b1e16ef62edfc63ab06b390867aad0ede9589fb","modified":1757848807254},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/delete-mask-handle.js","hash":"088e205976a09c8ee7afec6445847ed4b3aef71f","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/link-handle.js","hash":"d168d78034c5fa5a75978f47185b50fd79ba54cf","modified":1757848806452},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/encrypt.js","hash":"bf6b90842991a25af590af76f10d7164ea34abcb","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/img-handle.js","hash":"b396fe7b6cbc331f2952aa7561f96c1f250d8c52","modified":1757848806446},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/lazyload-handle.js","hash":"f8ae44311e6463e887c07a41910ebade8766bac2","modified":1757848806446},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/table-handle.js","hash":"c500c45cd9221788df1f31939c5399eabb62ebb5","modified":1757848807247},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/meta-helpers.js","hash":"5484677eb8064880019642f139e4a29f21cab495","modified":1757848807072},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/theme-helpers.js","hash":"028b3d18816011dc8e4efa9f4d8cf0e033a72942","modified":1757848807247},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/stylus-handle.js","hash":"8a8bf069ce096bd7b42952c8e50c3c89758cbc13","modified":1757848807233},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/page-helpers.js","hash":"beaeb760eaa92bb63272d21d0d99ab64b78980e8","modified":1757848807229},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/stale-issues.yml","hash":"4ae03f0bd4aaf5ccaa08205af07218d406e921da","modified":1757848811490},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/recommendation-helpers.js","hash":"f704100a3571a4a5da18cc3b1adbcf53c29e779d","modified":1757848807232},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/btn.js","hash":"19b57d6cc01b73e5d6a01330d6baefb8d05872ae","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/waline-helpers.js","hash":"c1c53e269c9d24642152dcced99f85b6a1baaec9","modified":1757848807254},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/btns.js","hash":"c3de03c07a24062781cafd741bcc4c6631c662be","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/note-large.js","hash":"09df0058cd22f1fbfcfcce687938d7ec33f194ad","modified":1757848807228},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/note.js","hash":"85115ba4e08022048bede81fd92570e536cc24a3","modified":1757848807228},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/tabs.js","hash":"74e3b0cdd009206f7b78b04dcb96eccd86e7a996","modified":1757848807247},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/folding.js","hash":"01d03fdf4a071c9e92cc2239356004e06458b834","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/source/css/style.styl","hash":"0d78bda29a5b0446074ed724f4f9fe772d4b15cc","modified":1757848809215},{"_id":"node_modules/hexo-theme-redefine/source/assets/hbe.style.css","hash":"29be8fc47be885e9954e310cbc68dfadd3b4cee6","modified":1757848806264},{"_id":"node_modules/hexo-theme-redefine/source/assets/odometer-theme-minimal.css","hash":"793c31feb38e241a5ff6ecc5e65e61751507d728","modified":1757848806264},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/brands.min.css","hash":"5119c35bbd273d2ea2501997827f6d644da93164","modified":1757848806197},{"_id":"node_modules/hexo-theme-redefine/source/css/tailwind.source.css","hash":"b109b7e9decb8978bb6f010727d0779dbc9a3a9b","modified":1757848806349},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/regular.min.css","hash":"d27c4fed54dacff688010e51f611d950dd6e0aca","modified":1757848806264},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/solid.min.css","hash":"e727feabedb171fb0b398151870d7739ef4e2432","modified":1757848806264},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/sharp-solid.min.css","hash":"7d1a13c6b8178b29f5bcb1a639a1998fc9de16c4","modified":1757848806264},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/light.min.css","hash":"18a176eb2486db4e938e568083fa578b641ccc83","modified":1757848806264},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/thin.min.css","hash":"3d46be31379b07ffb24d69c6c915725eaa2e89e9","modified":1757848806349},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-font-face.min.css","hash":"0be987628c8b485b39f064da41c90f15c0596c1f","modified":1757848806349},{"_id":"node_modules/hexo-theme-redefine/source/images/bookmark-placeholder.svg","hash":"255a1236bab60d2871da31e4f0db947b44931df6","modified":1757848809217},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/svg-with-js.min.css","hash":"f4c08e37c4d44b3ed7a3f377d1cb5d7fca4d04bc","modified":1757848806264},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v5-font-face.min.css","hash":"260ea7a5e0b89963a5dcf2600a4decdf0f408f3f","modified":1757848806359},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-avatar.svg","hash":"d0d20061bda08894a82d7691b660be7c6aaa0608","modified":1757848809218},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-shims.min.css","hash":"96f037860b8e9b59af8e47571ea98791616dbfd8","modified":1757848806358},{"_id":"node_modules/hexo-theme-redefine/source/images/loading.svg","hash":"938c2a41c8ba18e37ed659e481696e40a4c8f3a4","modified":1757848809217},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-favicon.svg","hash":"420f930a1df64a3c4391ff80326a8a2d7d5a6418","modified":1757848809218},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.svg","hash":"472776b6f013aad44706fee6c94201c96ee83932","modified":1757848809218},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-og.webp","hash":"44fb793383da185808ed682d7dd916e10eb65b4d","modified":1757848810073},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.webp","hash":"0a07e3fb6d9125dee44798c8c110187b16fb42a9","modified":1757848810059},{"_id":"node_modules/hexo-theme-redefine/source/js/build.js","hash":"61eb4760cefeffa79550f3f7387e701d554a0709","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/source/js/main.js","hash":"cee5f0dcb5b1f0f7f952e24d31cce2bd785b29cc","modified":1757848806453},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-dark.webp","hash":"d0066e0b025ae748448a3d6a96165d45a55d2f22","modified":1757848810103},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-light.webp","hash":"d25389973d0359b78f1e9c74a850ef425690ba40","modified":1757848810120},{"_id":"node_modules/hexo-theme-redefine/source/js/utils.js","hash":"4452f6e2d0b46f2b2574b3ac5236d2fc80d59435","modified":1757848807254},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.ttf","hash":"b54531dd09c5089eb93b12ce8f90ff521855ff8a","modified":1757848809956},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.woff2","hash":"d02b1adc81fd5bec023e25a7770779b99d6dd742","modified":1757848811463},{"_id":"node_modules/hexo-theme-redefine/layout/pages/page-template.ejs","hash":"75a41b963a4ed3fcae846163bc674d8d185a27a9","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/layout/components/scripts.ejs","hash":"373cbbf8fe0a39fc3de14579e0b3ae20cb429998","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/lib/hbe.default.js","hash":"fee2c92011ef007121b992193bbab0f3b196d873","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/layout/components/swup.ejs","hash":"ac0263cdb945ad99876a246db43801213b45b309","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/layout/utils/side-tools.ejs","hash":"42f0c677c3ee74fedfd5ca40d1b64c490c3cb3d7","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/layout/utils/local-search.ejs","hash":"06ad51a60648100fcf8a750c471a48bd1c9b31b8","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/utils/image-viewer.ejs","hash":"2f31d56e7ed88dadeacffa5af69931461f4fb4f9","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/source/css/common/animated.styl","hash":"1d5a026f3a023031772fdca7d7359bbe7a28548a","modified":1757848809202},{"_id":"node_modules/hexo-theme-redefine/layout/utils/paginator.ejs","hash":"cb0a8fca60575195f65510c1a52a7145c819de14","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/layout/utils/posts-list.ejs","hash":"80dd9ff9b135b582c32c5506d237db71fa742be5","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/source/css/common/basic.styl","hash":"27884d570ce220cf93063c72f117486db365dc68","modified":1757848809207},{"_id":"node_modules/hexo-theme-redefine/source/css/common/colors.styl","hash":"e4a5336757de7b04c01d8c2a2b4bb1de885c6ae0","modified":1757848809209},{"_id":"node_modules/hexo-theme-redefine/source/css/build/tailwind.css","hash":"3986e2bb4666d70908d0c47a23d3eafc7b34040d","modified":1757848806266},{"_id":"node_modules/hexo-theme-redefine/source/css/common/theme.styl","hash":"0c5eedb57874c91babdb603b1daef35d70a7c150","modified":1757848809215},{"_id":"node_modules/hexo-theme-redefine/source/css/common/redefine-theme.styl","hash":"068b95881387ee2b70ba94a6489ee21171f26bf3","modified":1757848809214},{"_id":"node_modules/hexo-theme-redefine/source/css/common/markdown.styl","hash":"62853721fb71613f6574adf9fac9b627a273fe23","modified":1757848809211},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/animations.styl","hash":"2c48fec80bd56164bff297727d06ab5c343b3b41","modified":1757848809202},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/bookmarks.styl","hash":"a89f96f73d9f1d51e455b53bbcf13d003d672d33","modified":1757848809207},{"_id":"node_modules/hexo-theme-redefine/source/css/common/variables.styl","hash":"961f936e6d08372bdc1e9379e7d1288410e4a319","modified":1757848809216},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-list.styl","hash":"aaccab4fb21e25086323e7e418e7fea945f551be","modified":1757848809208},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/archive-content.styl","hash":"4e329547447c716c986e0b4a4f54afc59fc6b486","modified":1757848809205},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-content.styl","hash":"1221a4e0fa2ab5c49e886e0a5bb6dc1d23d969e8","modified":1757848809208},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/tag-content.styl","hash":"3d08edcfbd866627f5681c368d5c61270ba2f682","modified":1757848809215},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/article-content.styl","hash":"94771695782abe5e723918a1319a953fbd2031e0","modified":1757848809205},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-content.styl","hash":"65a5184a667966f5c5387662de77da512faa4e0e","modified":1757848809210},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-sidebar.styl","hash":"daad28f2c004f7afe335080d67e977660829d63e","modified":1757848809211},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/page.styl","hash":"ffc2622357f1556a95fc8f138b7e8ac27b0bba2c","modified":1757848809214},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff","hash":"fc0e791429c274c4c9312d810e7ae9503cab34ab","modified":1757848810125},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff2","hash":"fc5d99b40db9deca7d151f9bd16b96ff160828b7","modified":1757848810197},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/chillax.css","hash":"210179f53c6bce91a12ca6db9129184cc1549c36","modified":1757848806197},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.woff2","hash":"772998a8569a6caa04927d876fbe9e0fb859658b","modified":1757848811478},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/geist.css","hash":"17f37a09d6192f06b2190f8319114238b0a2ec8c","modified":1757848806263},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/geist-mono.css","hash":"b89d5af7e04df579c8ad62c0ea445ff7d16eec11","modified":1757848806263},{"_id":"node_modules/hexo-theme-redefine/source/js/build/main.js.map","hash":"b089351e96e8f99395ac9b44aea257364a475dca","modified":1757848807258},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.woff2","hash":"11e9a061ce255fc4cc45ac3eeb8cab09a49f5ccc","modified":1757848811476},{"_id":"node_modules/hexo-theme-redefine/source/js/build/utils.js.map","hash":"fb09747f1b82adaa7f1078d02fc1a03cfa2b3e12","modified":1757848808968},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/bookmarkNav.js","hash":"3155ed3e6e2aa2e32dbd9e4e06b863e63c2a9b9d","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/source/js/build/main.js","hash":"2fcd1ce192bb34997c2e962d9c98a389573969ac","modified":1757848806453},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/lazyload.js","hash":"c06323d68bbdebbb685db5010e7655b8ed0caf42","modified":1757848806452},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/toc.js","hash":"7a768982f6cb1f40552cce063d5743fe862db762","modified":1757848807248},{"_id":"node_modules/hexo-theme-redefine/source/js/build/utils.js","hash":"f9d03c2029e59c347facb0b6e76296b9c3c83c62","modified":1757848807253},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/essays.js","hash":"df82365c7287710dd876e452f8ef4e1d87b8c09e","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/categoryList.js","hash":"eb1af2cd0726f56ff7861222ea543315fe295a17","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/navbarShrink.js","hash":"3e80bf9ef719b2ddb2d1c4b67eb169d2ef52dbb8","modified":1757848807228},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1757848806443},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScriptsPlugin.min.js","hash":"b17f3434035f1339d6f9cd5c8a055d2a1b6602e9","modified":1757848807246},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js","hash":"cc054d34e74a1feecfae75064f6a4d6107607396","modified":1757848807233},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js.map","hash":"40513fec1323b601667876a97a9ef8a0c88bff63","modified":1757848808968},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupSlideTheme.min.js","hash":"e9d143780e879d958164b1356b7f918ec25e838a","modified":1757848807247},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js","hash":"d911512891ecbe1935203bcd3d93427ad75e45c8","modified":1757848807234},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js","hash":"6c3afca9bb98f79d14516c093f27e3e50a3fd82e","modified":1757848807246},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupProgressPlugin.min.js","hash":"fd30fe1c43072017f67bbaac18b962a5ac218711","modified":1757848807245},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Typed.min.js","hash":"e8ce2b674a637b0c0396a3106c1aedf10186249c","modified":1757848807252},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js.map","hash":"63cf04ba556b256379e103ef7d3ba12d629449a4","modified":1757848808968},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1757848806422},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/odometer.min.js","hash":"fe5beb60997c84ab2f91b54535c4221443cdd21f","modified":1757848807229},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/moment.min.js","hash":"20bd76acf8e950e5cf7243f60e1192705dacca7d","modified":1757848807226},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/minimasonry.min.js","hash":"9681cc509cb8aa733d36aad032e6e8acdb33c08c","modified":1757848807073},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/pjax.min.js","hash":"3d796e5be9cdd4067c94e190ea2482d7fdb4856c","modified":1757848807232},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/aplayer.js","hash":"f2818445cfbdbf936f136c3d0f983583c581d77e","modified":1757848806422},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/pangu.min.js","hash":"ebc25ecdbf464407c5886f024d13f1f6da51ec85","modified":1757848807230},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/tabs.js","hash":"964ec5c25a8d78763ba2ba9bfbd5b1b49ed05381","modified":1757848807247},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/hbe.js","hash":"f7bd9258359dc8f70c6faec3f4fe22a1852d9bf1","modified":1757848806446},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/masonry.js","hash":"92734a30a21f8b16f20aa75208f6c082890275fb","modified":1757848806453},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/typed.js","hash":"f46f636a32e7569a9ff8b8b301bf860e598bd4fe","modified":1757848807250},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/mermaid.js","hash":"303254d382869ed618025fcb328426bd10314583","modified":1757848806453},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/pangu.js","hash":"25af6a33c9176a00f21f45cf5cfad0eb7d473841","modified":1757848807229},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/codeBlock.js","hash":"344e6c83e6ffda22f6e5bc724d603066b49a7d8b","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/localSearch.js","hash":"f6e59f65c676457198c2cf5d78bd06052499ee38","modified":1757848806453},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/imageViewer.js","hash":"33c4e4a28cf66be0cb3f181acae082a5a5404a89","modified":1757848806446},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/tocToggle.js","hash":"c2224ff0370fcf109e94194613b9480a3913c82d","modified":1757848807249},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/scrollTopBottom.js","hash":"9e54fa4310bb98ea5ba61780a9ef56d05d475203","modified":1757848807233},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/lightDarkSwitch.js","hash":"97b7e68f871dc218fceca77b85ac051c7c6306af","modified":1757848806452},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/runtime.js","hash":"eb0374b6f033f7ac25f49b1b079aa163e14b0fcd","modified":1757848807233},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/twikoo.ejs","hash":"49d230c1a732e0f3504a57dfd169738156ed22ba","modified":1757848806374},{"_id":"node_modules/hexo-theme-redefine/layout/components/header/head.ejs","hash":"81f4be0a8b07a4773423f4b8c23b4a36aa8ec34c","modified":1757848806370},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/waline.ejs","hash":"c24dce20a3924adf56753144f17adc1a6fc51190","modified":1757848806374},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/comment.ejs","hash":"98c2db06626a82f24886cd8b77118014ef8aa6e2","modified":1757848806361},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/giscus.ejs","hash":"afa08ddc80ae3f1c57d9b85d2625f11751801540","modified":1757848806362},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/gitalk.ejs","hash":"f94607c4bb12f5c2325e674e25a428dae742e99e","modified":1757848806362},{"_id":"node_modules/hexo-theme-redefine/layout/components/footer/footer.ejs","hash":"acb56ecba5c231f5c8c6701de6d54e3d654948a2","modified":1757848806361},{"_id":"node_modules/hexo-theme-redefine/layout/components/header/preloader.ejs","hash":"a450ba1381dd43d348a3f538bb17ffbd1d332cad","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/layout/components/plugins/aplayer.ejs","hash":"2d34a3583ac0b2b08b6ae035e8d3f97c51db070c","modified":1757848806359},{"_id":"node_modules/hexo-theme-redefine/layout/components/sidebar/author.ejs","hash":"422aed0f3f67529c1ea87ee43f8f680ffc531b45","modified":1757848806360},{"_id":"node_modules/hexo-theme-redefine/layout/components/header/navbar.ejs","hash":"9eb814d67d5d66fb39523c147ad56c10348b70f4","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/layout/components/header/progress-bar.ejs","hash":"e552f0f5e6ab6398ab42eef1788f7c0dcb8f4c18","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/layout/components/sidebar/statistics.ejs","hash":"4329363d232de541e1cb8f24eb59c1a8bacc9b9c","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/layout/pages/category/categories.ejs","hash":"fe6e11590c28cc8462a04580868aa6b8b472a9d1","modified":1757848806361},{"_id":"node_modules/hexo-theme-redefine/layout/pages/archive/archive.ejs","hash":"11fb21fe971157a1a6053ecbd6de9ffbe8ba88a8","modified":1757848806360},{"_id":"node_modules/hexo-theme-redefine/layout/pages/category/category-detail.ejs","hash":"ee99263b6761e9865b06d427597435e69b40dda9","modified":1757848806361},{"_id":"node_modules/hexo-theme-redefine/layout/pages/bookmarks/bookmarks.ejs","hash":"6a52f8f6bd5b0d5e8f9af07124a265fd58b2bdff","modified":1757848806361},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-background.ejs","hash":"dd120259ab091b8087d0194ea2291676556efad8","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/components/sidebar/avatar.ejs","hash":"47cd8318471493c82f5e5983550145d4fd0a2ddc","modified":1757848806360},{"_id":"node_modules/hexo-theme-redefine/layout/pages/friends/friends-link.ejs","hash":"c4a8555880ab546a9bc829386c4fc2b43cdcece2","modified":1757848806362},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-banner.ejs","hash":"b64ba5bb654950e3c430f7429b5f60993e0f6fa0","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-sidebar.ejs","hash":"8df645c6e1878187909d749639ecce6edc0ee72c","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-article.ejs","hash":"b54a0df26341fa5f26a6e1eedb91cd11014d50c5","modified":1757848806370},{"_id":"node_modules/hexo-theme-redefine/layout/pages/masonry/masonry.ejs","hash":"c45f6faf5ccd4db3bd5533eacb6333744a480e27","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/pages/notfound/notfound.ejs","hash":"5e90d8519d19a31234de10a33983b8d70aed94a2","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/layout/pages/shuoshuo/essays.ejs","hash":"0a27aebeba9a9aa56b705b4c84bc24d1874ddb18","modified":1757848806361},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/article-content.ejs","hash":"65bc4194754a0473931014f53d997447e613a530","modified":1757848806360},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-content.ejs","hash":"6985ec3528866f90ce882564556c30c151050061","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/toc.ejs","hash":"c3bd7f4632ded1b59a2479028070fa2b292d8c5e","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/article-copyright.ejs","hash":"8e97d76ded33d1e334c376451e2f3d5fd177a958","modified":1757848806360},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/article-info.ejs","hash":"f42db25cc0f4e3bbce5b8602365025dd37d643d0","modified":1757848806360},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/post-tools.ejs","hash":"5336e36394250d2f25d26432262061c752b1868a","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/layout/pages/tag/tag-detail.ejs","hash":"8864356337a301a123e85fb3aec6f3d9b1f2197c","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/layout/pages/tag/tags.ejs","hash":"ff59878833eb2a72fda7c78690a36a9c0c522c76","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-theme.styl","hash":"79d13151f771a7a967fbf18eab955354466335a8","modified":1757848809208},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/highlight.styl","hash":"35cfa277f1f2ea3c3876e50ac56c7401e1b8a4c7","modified":1757848809210},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-block.styl","hash":"e6a793c6b2c54549db8226fcb13ee3c4b3a1c45d","modified":1757848809208},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/aplayer.styl","hash":"5d9b58f0d5226ef2a2a67502577539115ae29942","modified":1757848809203},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/buttons.styl","hash":"32be9cf72f19b588b6e0db6b6e23146293b64268","modified":1757848809207},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/folding.styl","hash":"b5e5c2407eb83ae4b3ee4ed73490dcd41edef705","modified":1757848809209},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/notes.styl","hash":"37b2a4a0669414c74498ed0ecae873c90b15fe6e","modified":1757848809213},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/404.styl","hash":"16215f6fe664d1ddc5744a626405bc774dc30f70","modified":1757848809200},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/tabs.styl","hash":"fb5f2f223f7d4ed86d3693fdc0977362f456212e","modified":1757848809215},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/archive-list.styl","hash":"d57516e1723b807d38cb7955a9a1422dd03ac820","modified":1757848809205},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/article-meta-info.styl","hash":"141ae2639ac760ced89887cce139adbc76c18cea","modified":1757848809206},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/footer.styl","hash":"0dc8796e312215e45e1daf566a495c00480b68e3","modified":1757848809209},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/home-banner.styl","hash":"9f0fb6bd26e73bf07c556a3c1f552997234cb81c","modified":1757848809210},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/image-viewer.styl","hash":"6c8eeb7a96cae110cd9a684a3a5076148b8154d8","modified":1757848809211},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/article-copyright-info.styl","hash":"12fad2f674e8a7ad009cabecf4e98b65d5ed8b1e","modified":1757848809205},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/local-search.styl","hash":"45e7580258bc2d85cc12313abcc24cba9e531e00","modified":1757848809211},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/post-tools.styl","hash":"d602c2fe191d2c639f7cd8c4d0ee618f8c80f5c1","modified":1757848809214},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/paginator.styl","hash":"53421b731f3d7ed34a3a4c87405e06ae3d6519e0","modified":1757848809214},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/page-template.styl","hash":"e2e1826427e1fc5f88d4c31ddd508818a0b0d87d","modified":1757848809213},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/progress-bar.styl","hash":"d3715280d9b62d89ccd1b79ab5e5f030669f4d88","modified":1757848809214},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/side-tools.styl","hash":"995982b8c228f7386d352042f64587d06663716e","modified":1757848809214},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/bookmarkNav.js","hash":"a92d80fb49180a2700e069451c3ee9fde3f7cde0","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/toc.styl","hash":"13949981a5afa2b0483da1836af5999d992961f9","modified":1757848809216},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/categoryList.js","hash":"cd8e7825b6dce79cac97e6047f9a80f0fb893213","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/tagcloud.styl","hash":"cb12c8ef44b5e597eb971d3341919fe9569da709","modified":1757848809215},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/bookmarkNav.js.map","hash":"ba215231cccf6495570205bf974a83142592a22b","modified":1757848807256},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/categoryList.js.map","hash":"fb9f8f83a1d0510eaa510fe58891de555d4839a8","modified":1757848807256},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/essays.js.map","hash":"60c58a3fc229cd497ad782e6f2b642e6be600e4c","modified":1757848807256},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/navbar.styl","hash":"b95efbade2b4cfd8000fd8238bdbd3de522b319e","modified":1757848809212},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/essays.js","hash":"fbd5599508c60dc20fa90a9f37db27770e3773d5","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/lazyload.js.map","hash":"d365d984dfa37411397b36c69e24e4d5d0b32bee","modified":1757848807257},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/lazyload.js","hash":"eacb006bd852a3c9881438b75d45e72d87914ad7","modified":1757848806446},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/navbarShrink.js.map","hash":"275dbb4ded89c2d2d805edbbf678475139bcc442","modified":1757848808967},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/navbarShrink.js","hash":"181c0c7e45f0c3a099d272b7c531559cd0d4fdbf","modified":1757848807228},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/toc.js","hash":"892929c5bb2293804f4c5f911dd901969f08ef67","modified":1757848807248},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/toc.js.map","hash":"9a413e8dbc2ff2a6fc21eb2899e59d5af75942a3","modified":1757848808968},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupScriptsPlugin.min.js","hash":"b17f3434035f1339d6f9cd5c8a055d2a1b6602e9","modified":1757848807245},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/Swup.min.js","hash":"cc054d34e74a1feecfae75064f6a4d6107607396","modified":1757848807233},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1757848806432},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupScrollPlugin.min.js","hash":"6c3afca9bb98f79d14516c093f27e3e50a3fd82e","modified":1757848807246},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupPreloadPlugin.min.js","hash":"d911512891ecbe1935203bcd3d93427ad75e45c8","modified":1757848807234},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupSlideTheme.min.js","hash":"e9d143780e879d958164b1356b7f918ec25e838a","modified":1757848807247},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupProgressPlugin.min.js","hash":"fd30fe1c43072017f67bbaac18b962a5ac218711","modified":1757848807242},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/Typed.min.js","hash":"e8ce2b674a637b0c0396a3106c1aedf10186249c","modified":1757848807251},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1757848806421},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/odometer.min.js","hash":"fe5beb60997c84ab2f91b54535c4221443cdd21f","modified":1757848807229},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/minimasonry.min.js","hash":"9681cc509cb8aa733d36aad032e6e8acdb33c08c","modified":1757848807073},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/pjax.min.js","hash":"3d796e5be9cdd4067c94e190ea2482d7fdb4856c","modified":1757848807231},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/pangu.min.js","hash":"ebc25ecdbf464407c5886f024d13f1f6da51ec85","modified":1757848807230},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/codeBlock.js","hash":"8aa8e62cdc3891c9c608c1f52866aeab8cef0457","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/imageViewer.js","hash":"310f06d38245235e1a65a5a7f1a6f673647faa6f","modified":1757848806446},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/moment.min.js","hash":"20bd76acf8e950e5cf7243f60e1192705dacca7d","modified":1757848807206},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/imageViewer.js.map","hash":"6bf89edc74bc48b0e6f616d1ac0b0bb52df09353","modified":1757848807257},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/lightDarkSwitch.js","hash":"dee772cad8a9ab42d54b6ea99599534524c47f18","modified":1757848806452},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/lightDarkSwitch.js.map","hash":"0fd195af186727b3b6f8a7d29035f35f7375e5a1","modified":1757848807257},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/codeBlock.js.map","hash":"fe609e1f8c1d028eca5e131b6a98cd71547be39c","modified":1757848807256},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/runtime.js","hash":"99d9fbc2022a12dd7f9bab4f88384f563f3f51e8","modified":1757848807232},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/localSearch.js","hash":"4ddb3808f9216b848a14e66c813ae883d0f883b1","modified":1757848806452},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/runtime.js.map","hash":"43ed778e985cbf71e7d62c5960da98a431ad43e3","modified":1757848808967},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/localSearch.js.map","hash":"86630e1b406ad10fe0450ccc49fbf07154fab9e5","modified":1757848807257},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/tocToggle.js.map","hash":"6fd262220a32c784f194d21c7e514f21122bde2f","modified":1757848808968},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/scrollTopBottom.js.map","hash":"76a041bbbd0d49426322c4fc1ee05bf327ffb7bd","modified":1757848808967},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/scrollTopBottom.js","hash":"037720022f64622f244682c176c5f0ab8f1efb54","modified":1757848807233},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/hbe.js","hash":"383a946a2be735bc30c0bb331bbee335fe5b6942","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/tocToggle.js","hash":"978bc1a31f8026ac9522198bca3c892ebf3551bc","modified":1757848807249},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/aplayer.js.map","hash":"daefe65fb99e2f7699f3fd25ec90b7f38469da5d","modified":1757848807254},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/aplayer.js","hash":"bef8536cb25306f78f80c1744c07544a46dac970","modified":1757848806422},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/masonry.js.map","hash":"b2d93754a64f84ef67528d320de69561fc763525","modified":1757848807258},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/mermaid.js.map","hash":"5a8b4e15316517af607d3c12cf4a6e3447cfec22","modified":1757848807258},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/masonry.js","hash":"b5b44a6d4b74beea1938334b3558bd3d1caec07a","modified":1757848806453},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/pangu.js.map","hash":"27d5318b81541274c3026e4892ee43ba2c410951","modified":1757848808967},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/pangu.js","hash":"e96959eb39ca702242aca08c75f2230aa1bda7e4","modified":1757848807229},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/tabs.js","hash":"b14b70e316e3151d591f03cbaf3c70c11ae5aad5","modified":1757848807247},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/mermaid.js","hash":"2deee4201b637c54c1be0e1b686a97050fb37cce","modified":1757848806453},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/tabs.js.map","hash":"218abee3893ecdee6f6c633b9fd13520a4eefabf","modified":1757848808968},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/typed.js","hash":"d8999de0b92fe1e1c9061040d6e95a9b607caa23","modified":1757848807250},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/hbe.js.map","hash":"53deed7e9b802b964ff90d3303f957238f2b1421","modified":1757848807256},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/gitalk.styl","hash":"85f26189ec6dee13a0a743687e7b5391f170c33f","modified":1757848809210},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/twikoo.styl","hash":"448cbc045bcffa2d666094b81dd99eb980676fff","modified":1757848809216},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/typed.js.map","hash":"4840c94f7639cee4615916ce2cabd172a565a71c","modified":1757848808968},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/a11y-dark.styl","hash":"457e0df301f4dc1cc96371e65173b94bec0161fe","modified":1757848809201},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/agate.styl","hash":"a33ce49622c788e5d8bba32573e0b701e4cb7ead","modified":1757848809202},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/comment.styl","hash":"71529ec72f356c78f75a752e5400c1197aa5ea96","modified":1757848809209},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/atom-one-dark.styl","hash":"8802725310cf86c4a179d874072188f31d10b224","modified":1757848809206},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/monokai-sublime.styl","hash":"803773d8c6dd5ecf957596ca57584a6618f373ac","modified":1757848809211},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/night-owl.styl","hash":"07c331a0c45051e93d24e10688425f1e30f0e99f","modified":1757848809212},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/waline.styl","hash":"0663e8e50eff65afb4dbcbc7c4758d8acdd1d368","modified":1757848809217},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/tokyo-night-dark.styl","hash":"2ae8e43a87b18bb899ac9c802d3774232160b8e7","modified":1757848809216},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/vs2015.styl","hash":"c54d91bf767efe0671c4dfbe874fac678cfde117","modified":1757848809216},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/atom-one-light.styl","hash":"99de67d507bd6ffed5993097a6ce2be6422480b1","modified":1757848809207},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/nord.styl","hash":"9b88c9e8bca2b8995fdc71519c01a9c80121161c","modified":1757848809212},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/default.styl","hash":"c2b8d16ba4dffdd3bae4db4f817bc18cdd7c1d60","modified":1757848809209},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/github.styl","hash":"a2a15ed938b319c369569845bf35d00c6624d136","modified":1757848809210},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/github-dark.styl","hash":"fab5f7f62407b66f8b5f2837b178ef5b09a4badc","modified":1757848809210},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.woff2","hash":"a358912d781e6249a8d291e4ce9ebd0a9ab9452e","modified":1757848810230},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.woff","hash":"d06c767b3837999a8b98426e4eb16ca0a8080880","modified":1757848810167},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.ttf","hash":"9a531509e4e768e9102d11f5d7d293e3f04d9c64","modified":1757848810056},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.woff","hash":"fd8c986a8767d59a36e2d194299466720c916ee2","modified":1757848810148},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.ttf","hash":"d72ec9d729305fc24f38e1ba69174e93b700cd69","modified":1757848810003},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js.map","hash":"f74755d9318a86939791027767f631472b876207","modified":1757848808967},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/fontawesome.min.css","hash":"44e6d666b45a6875e4fce11159876129e7a1cceb","modified":1757848806262},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.ttf","hash":"ba9322d66c19f635e15e458cc39fcb509818332f","modified":1757848809240},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.eot","hash":"50a4e2ab17155fe7449e0ee488a6242180f3b256","modified":1757848806416},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.ttf","hash":"01aafadc0ca4ace59127a5594a8f534e83b84879","modified":1757848809223},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1757848807256},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs","hash":"bb3d9180d8c3aae39bd9aacd2bdde1aef9363da7","modified":1757848809198},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.woff2","hash":"74d0af1108ab8157993ca03cef80e89e35e2408d","modified":1757848810869},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/duotone.min.css","hash":"0becc4b085bd9d377a8ff4b5160f8e19c8ec27a0","modified":1757848806233},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.woff2","hash":"e73d164db2aff2c91d18c07da03e8db9d0c5dfd4","modified":1757848810998},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/moment-with-locales.min.js","hash":"dd1c67b36c800c00b7901f17af6200b26f2bb42c","modified":1757848807197},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/moment-with-locales.min.js","hash":"dd1c67b36c800c00b7901f17af6200b26f2bb42c","modified":1757848807106},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.woff2","hash":"2cc24434345b80a844a6bda1139539fe41e4df53","modified":1757848810394},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.woff2","hash":"def760895375328ccdcf62b2b9b9001a21947acd","modified":1757848810557},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.woff2","hash":"486fed640153de1de84f460834c73daef060ed20","modified":1757848810733},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/all.min.css","hash":"630bf0e29410ec27622f65d1270c6bc435cdff21","modified":1757848806195},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.woff2","hash":"e0a4482c20f6b67784df54965539a317a3bd681b","modified":1757848811462},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.ttf","hash":"0d710cd7bd1b7ff574e88bb812de82babe45e415","modified":1757848809688},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.ttf","hash":"40b536c3667547db70ee9ca6f3c94fbc33e0cab7","modified":1757848809758},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.ttf","hash":"cdec068700dc440530e5bbeff7e8bb33a01b4132","modified":1757848809679},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.ttf","hash":"cc5d9f4f994c82e23f58cdde1eec8792d81633c7","modified":1757848809581},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.ttf","hash":"c1fee6e6986b14533ce022afada5fbe10c0f6562","modified":1757848809955},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.ttf","hash":"e0313a772ea710cb5ea4bd08f5dedb0a0025f8ca","modified":1757848809252},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs.map","hash":"9ffe1d8eacf5adc4ffbfa12e6294161d4b528734","modified":1757848808972},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js","hash":"22eeb45e4dfff78a42bc8dad60d3a8ff64968a9d","modified":1757848807071},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/mermaid.min.js","hash":"22eeb45e4dfff78a42bc8dad60d3a8ff64968a9d","modified":1757848806761},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js.map","hash":"2e1a632f0588c4370188887d79a10ff8b38a49b5","modified":1757848808966},{"_id":"source/images/.DS_Store","hash":"c6056cced52b40ae7118e9e8eee339cffab3ad70","modified":1757862526552},{"_id":"source/images/CI流程.svg","hash":"603f92a27e989f28ca81ed954c5f169210fc57f1","modified":1757851316101},{"_id":"source/images/OpenVpn+堡垒机结合前端部署.svg","hash":"d01ee5b21e1b74b30505a20853c87d4bb29f1379","modified":1757852921775},{"_id":"source/images/yjt中SaaS的前端部署方式.svg","hash":"b2e626962bd600660915ddd14e16f176e4b41049","modified":1757852743811},{"_id":"source/images/堡垒机工作流程.svg","hash":"b579164e459dff4b5eb313d26f0b497a47e9af6f","modified":1757852497399},{"_id":"source/images/avatar.jpg","hash":"12dce7f91c1523b2b5732a48a6393d9a86ca923b","modified":1757855908260},{"_id":"source/images/吗喽.jpg","hash":"b5b43630d118b77b415b53e24d72a463bc1734e0","modified":1757856069088},{"_id":"source/images/nuxt核心工作流.png","hash":"06297ad21b6689e093449919cfa944494cfb638a","modified":1757856605693},{"_id":"source/_posts/SSR渲染.md","hash":"4bfddf91c2b7b50adc59b6dbc7b9ce56eb4d069e","modified":1757858461211},{"_id":"source/images/客户端渲染流程.png","hash":"80d3fa984bc8fbf7e4d8d3d6374258de877e6e4f","modified":1757858247593},{"_id":"source/images/服务端渲染流程.png","hash":"cbb3101ec5009cfdd8c5285c3c8ce8c8d2219374","modified":1757858346314},{"_id":"source/images/微前端架构.png","hash":"7cc037181209a1485942739f61c23e6990d6bf98","modified":1757857677075},{"_id":"source/images/微前端.png","hash":"16aa34a3511680941fd6c66780b35da10c19b717","modified":1757857585883},{"_id":"source/images/Watcher工作流程.svg","hash":"040dcf2dd74f7fc164c4db3b9e7ca56c7c717e54","modified":1757860652795},{"_id":"source/images/pitching_loader_1.png","hash":"539b9355d9b3606e22b443fbdd5ef8a98fcf4a27","modified":1757858573029},{"_id":"source/images/pitching_loader_2.png","hash":"2b3e1866bdc63d1ab4f8419c168388ad18430463","modified":1757858577985},{"_id":"source/images/浏览器渲染流程.png","hash":"a5606b5fb579060834d06ded8bbb24b2b28efd0f","modified":1757860943040},{"_id":"source/_posts/浏览器渲染机制.md","hash":"1828ea52014fae29fdad05a1d8482a376110adcf","modified":1757861818859},{"_id":"source/_posts/vue.md","hash":"5d9afef8b5ff3689f60b02faed381195041747e3","modified":1757860753868},{"_id":"source/_posts/关于Webpack.md","hash":"425edf78d8d70b91c9f4d2fcbf873a746288d81f","modified":1757860309971},{"_id":"source/images/pic_HMR.png","hash":"78dde81b6b82b7568b61cc20463a12381a2dda06","modified":1757858591535},{"_id":"source/images/vue-cli默认配置.png","hash":"fcf1cf20b3620bfd1a6e248f98170d5a0f62ade1","modified":1757860580715},{"_id":"source/images/vue_prototype.png","hash":"da35d8d126bf3f37a41ed2869f4af66c19c37b13","modified":1757860467758},{"_id":"source/images/热更新.png","hash":"a0a253b6f01b63367076b271088649ea80eee54e","modified":1757860125758},{"_id":"source/_posts/浏览器缓存.md","hash":"dfded8005e7f4437669d7e777e1eda2cce991f3c","modified":1757864010267},{"_id":"source/_posts/关于eventloop.md","hash":"23f021eec3e3c23b1f5942de380911e7fb300155","modified":1757863854900},{"_id":"source/images/eventloop流程.png","hash":"f78a66013df7839f30bb3e87c051e2e807bef448","modified":1757862507782},{"_id":"source/images/callstack.webp","hash":"9f9547df96603a053cb6857610499811f71f4796","modified":1757862110176},{"_id":"source/images/async和微任务.png","hash":"43990474e8dd04282e13e7ebd5166d481ac62718","modified":1757862616180},{"_id":"source/images/关键渲染路径.png","hash":"b6275f4e48f015d4fc65e083df0f55cdea6601b1","modified":1757861587864},{"_id":"source/images/主线程中的eventloop.png","hash":"12f33af9e1b32d642faffb1744723848e5feaf12","modified":1757862221575}],"Category":[{"name":"前端","_id":"cmfjktvt50001tx5w3zva8wch"},{"name":"微前端","_id":"cmfjkx02r0000y35w563tb1n6"},{"name":"Nuxt","_id":"cmfjlykvk0000h65whul24ryt"},{"name":"SSR渲染","_id":"cmfjrcmo50001175weacmd6b8"},{"name":"关于Webpack","_id":"cmfjrnhj70001n05w30dsauh8"},{"name":"Webpack","_id":"cmfjscemt0009n05w1zithvcn"},{"name":"Vue","_id":"cmfjspu9c000ln05wbww681ga"},{"name":"浏览器渲染机制","_id":"cmfjszzkg000pn05wbkrh0wpq"},{"name":"关于eventloop","_id":"cmfjtja4a0001l95wertk2pak"},{"name":"eventloop","_id":"cmfjtowun000il95wdtmud2ou"},{"name":"浏览器缓存","_id":"cmfjuuf46000ul95weq4r2bo5"}],"Data":[],"Page":[],"Post":[{"title":"Nuxt","date":"2025-08-14T16:00:00.000Z","_content":"\n## Nuxt.js的ssr服务端渲染原理\nNuxt.js 的 SSR（服务端渲染）原理是一个非常核心且有趣的话题。它并不是简单的“在服务器上跑 Vue”，而是一套完整的、精心设计的架构。\n\n简单来说，它的核心原理是：**“首屏在服务器提前渲染成 HTML，之后在客户端‘激活’为 SPA”。**\n\n下面我们分步拆解这个过程的原理、优势和关键实现。\n\n---\n\n### 一、核心目标：解决什么問題？\n1. **SEO（搜索引擎优化）**：传统 SPA（单页应用）返回的是一个空的 HTML 壳，内容由 JavaScript 动态填充。搜索引擎爬虫可能无法等待和执行 JS，导致无法收录内容。SSR 直接返回渲染好的完整 HTML，利于爬虫抓取。\n2. **更快的内容到达时间**：用户浏览器无需等待所有 JavaScript 下载和执行完毕才能看到内容。服务器直接返回了渲染好的 HTML，首屏内容可以立即展示，感知性能极大提升。\n\n### 二、Nuxt.js SSR 的核心工作流程\nNuxt.js 的 SSR 过程可以清晰地分为两个阶段：**服务端渲染**和**客户端激活**。下图展示了从用户请求到页面可交互的完整生命周期：\n\n<img src=\"/images/nuxt核心工作流.png\" alt=\"nuxt核心工作流\" width=\"60%\" height=\"auto\" style=\"display:block;\">\n\n#### 第一阶段：服务端渲染（Server-Side）\n这个过程发生在 **Nuxt 服务器**（一个 Node.js 服务器）上。\n\n1. **接收请求**：用户浏览器请求一个 URL，请求到达 Nuxt 服务器。\n2. **创建应用实例**：Nuxt 服务器为这次请求**创建一个全新的 Vue 应用实例、Router 和 Store**。这是关键，确保了每个请求的隔离性。\n3. **路由匹配**：根据请求的 URL，Nuxt Router 确定要渲染哪个页面组件（如 `pages/about.vue`）。\n4. **数据预取**：Nuxt 会调用页面组件中定义的**异步数据获取方法**（如 `asyncData`、`useAsyncData`、`useFetch`）。**这些方法会在服务端执行**。\n    - 服务器会等待这些异步操作完成，再去渲染组件。这确保了渲染出的 HTML 是包含数据的。\n5. **渲染 HTML**：\n    - 将获取到的数据**注入到 Vuex Store 或组件状态**中。\n    - 调用 Vue 的 `vue-server-renderer`（Vue 2）或 `@vue/server-renderer`（Vue 3）的 `renderToString()` 函数。\n    - 这个函数会运行 Vue 组件，但它**不是在浏览器中创建真实 DOM，而是在内存中生成一个完整的 HTML 字符串**。\n6. **构建最终文档**：Nuxt 将这个 HTML 字符串插入到HTML模板（`app.html`）中。同时，**将预取的数据序列化后内联到 HTML 中**（通常是在一个 `<script>` 标签里，如 `window.__NUXT__ = {...}`），这个过程称为 **状态脱水**。\n7. **响应**：将这个完整的、包含数据和内容的 HTML 文档发送给客户端。\n\n#### 第二阶段：客户端激活（Client-Side Hydration）\n这个过程发生在**用户浏览器**上。\n\n1. **静态内容展示**：浏览器收到服务器返回的 HTML 后，**无需等待任何 JavaScript，就能立即解析和显示页面内容**。这是首屏速度快的根本原因。\n2. **加载资源**：浏览器开始加载页面中引用的 JavaScript 和 CSS 资源（Nuxt 打包好的客户端 bundle）。\n3. **Vue 接管（Hydration -“混合”）**：这是最精妙的一步。\n    - 客户端的 Vue 应用也会被创建和初始化。\n    - Vue 不会像传统 SPA 那样清空 DOM 再重新渲染。相反，它会**将虚拟 DOM 与服务器渲染好的现有静态 HTML 结构进行“混合”**。\n    - 它会将事件监听器、Vue 的响应式系统等“激活”到这些静态元素上，使其变成一个完全交互式的 Vue 应用。\n4. **变为 SPA**：激活完成后，应用就切换到了正常的 SPA 模式。后续的页面导航不会再向服务器请求完整的 HTML，而是由客户端 Router 管理，只获取必要的数据，实现无刷新跳转。\n\n---\n\n### 三、Nuxt.js 实现 SSR 的关键技术点\n1. **双入口构建（Dual Entry Points）**：\n    - Nuxt 使用 Webpack/Vite 分别打包**两个版本**的代码：\n        * **服务端 Bundle**：用于 `renderToString`，它知道如何在 Node.js 环境中渲染组件。\n        * **客户端 Bundle**：用于在浏览器中“激活”静态页面并处理后续交互。\n    - 这是通过 `webpack` 的 `target: 'node'` 和 `target: 'web'` 分别配置实现的。\n2. **数据预取与状态同步**：\n    - 服务端获取的数据必须**安全地传递到客户端**，否则客户端 Vue 在初始化时没有数据，会导致虚拟 DOM 与服务器渲染的 HTML 不匹配，激活失败。\n    - Nuxt 通过 `window.__NUXT__` 对象将数据从服务器“脱水”到客户端“补水”，保证两端状态一致。\n3. **生命周期**：\n    - 在 SSR 过程中，**只有**** **`**beforeCreate**`** ****和**** **`**created**`** ****这两个生命周期钩子会在服务端执行**。\n    - `mounted`、`beforeMount` 等只在客户端执行。因此，**在**** **`**created**`** ****中操作**** **`**window**`** ****或 DOM 会报错**。\n\n---\n\n### 四、Universal Mode (同构渲染)\nNuxt.js 的 SSR 通常被称为 **“Universal”应用**或**“同构”应用**。\n\n+ **同构代码**：同一份 Vue 组件代码（`.vue` 文件）既可以在**服务器**上运行（用于首屏生成 HTML），也可以在**客户端**运行（用于激活和后续交互）。\n+ **优势**：开发者只需写一套代码，Nuxt 负责处理双端的构建和渲染协调，开发体验非常流畅。\n\n### 总结\nNuxt.js 的 SSR 原理可以概括为：\n\n1. **服务端**：为每个请求即时创建 Vue 应用，预先获取数据，渲染出包含内容的 HTML 字符串，并将数据状态一同返回。\n2. **客户端**：快速展示静态内容，然后加载 JS，由 Vue 将静态页面“激活”为可交互的 SPA，最后接管所有后续导航。\n\n它完美地结合了**传统服务端渲染首屏快、SEO 好**的优势和**单页应用用户体验流畅、交互丰富**的优势，是现代 Web 应用开发的绝佳选择。\n\n## nuxt中调后端接口怎么做，要注意什么？\n在 Nuxt.js 中调用后端接口是其核心功能之一，但根据你使用的 API 风格（Composition API 或 Options API）和渲染模式（SSR 或 SPA），做法和注意事项有所不同。\n\n下面将为你提供全面的指南，包括方法、最佳实践和常见陷阱。\n\n---\n\n### 一、如何调用后端接口？\nNuxt 3 推荐使用 Composition API，并提供了强大的组合式函数。\n\n#### 1. 使用 `useFetch` / `useAsyncData` (Composition API - 首选)\n这是 Nuxt 3 中最现代、最推荐的方式，它完美处理了服务端和客户端的数据获取。\n\n**基本用法 (**`**useFetch**`**)：**  \n`useFetch` 是专门为获取数据而设计的语法糖。\n\n```vue\n<script setup>\n// 直接在模板中使用，无需 .value\nconst { data: posts, pending, error, refresh } = useFetch('/api/posts')\n\n// 或者指定完整 URL（注意配置代理或 CORS）\nconst { data: users } = useFetch('https://api.example.com/users', {\n  // 可选项：在客户端才获取数据（代替 onMounted + ref）\n  // lazy: true,\n  // server: false\n})\n</script>\n\n<template>\n  <div v-if=\"pending\">Loading...</div>\n  <div v-else-if=\"error\">Error: {{ error.message }}</div>\n  <ul v-else>\n    <li v-for=\"post in posts\" :key=\"post.id\">{{ post.title }}</li>\n  </ul>\n  <button @click=\"refresh\">Refresh</button>\n</template>\n```\n\n**高级用法 (**`**useAsyncData**`** + **`**$fetch**`**)：**  \n当你需要更复杂的逻辑时（如多个请求、数据处理），使用 `useAsyncData`。\n\n```vue\n<script setup>\nconst { data: combinedData, refresh } = useAsyncData('unique-key', async () => {\n  // 这里可以写任何复杂的异步逻辑\n  const [posts, users] = await Promise.all([\n    $fetch('/api/posts'),\n    $fetch('/api/users')\n  ])\n  \n  // 对数据进行转换\n  return {\n    posts: posts.map(post => ({ ...post, title: post.title.toUpperCase() })),\n    users\n  }\n})\n</script>\n```\n\n#### 2. 使用 `$fetch` 直接调用\nNuxt 3 内置了基于 [ofetch](https://github.com/unjs/ofetch) 的 `$fetch` 工具，可以在任何地方使用（如事件处理函数中）。\n\n```vue\n<script setup>\nconst handleSubmit = async () => {\n  try {\n    const response = await $fetch('/api/submit', {\n      method: 'POST',\n      body: { name: 'John Doe' }\n    })\n    console.log('Success:', response)\n  } catch (error) {\n    console.error('Error:', error)\n  }\n}\n</script>\n```\n\n#### 3. 使用 `useLazyFetch` / `useLazyAsyncData`\n它们是 `useFetch` 和 `useAsyncData` 的变体，`lazy: true` 是默认行为。**不会阻塞导航**，适用于非关键数据。\n\n```vue\n<script setup>\n// 不会阻塞路由导航，你需要自己处理 data 为 null 的情况\nconst { data: nonCriticalData } = useLazyFetch('/api/non-critical-data')\n</script>\n\n<template>\n  <div v-if=\"data\">\n    <!-- 渲染数据 -->\n  </div>\n</template>\n```\n\n### 二、最重要的注意事项\n#### 1. 服务端渲染 (SSR) vs 客户端渲染 (CSR) 行为\n这是 **最核心、最容易出错** 的点！\n\n+ **默认行为**：`useFetch` 和 `useAsyncData` **会在服务端执行**。这意味着：\n    - **好处**：返回的 HTML 直接包含数据，利于 SEO 和首屏加载。\n    - **陷阱**：**不能在它们内部或**** **`**created**`** ****生命周期中使用浏览器API**（如 `window`, `document`, `localStorage`）。\n+ **如何控制**：\n\n```javascript\n// 选项 1: 强制只在客户端执行\nconst { data } = useFetch('/api/data', { server: false })\n\n// 选项 2: 使用 useLazyFetch (默认不会阻塞导航，且在客户端执行)\nconst { data } = useLazyFetch('/api/data')\n\n// 选项 3: 在 onMounted 钩子中用 $fetch\nimport { onMounted } from 'vue'\nconst data = ref(null)\nonMounted(async () => {\n  data.value = await $fetch('/api/data')\n})\n```\n\n#### 2. 处理 CORS (跨域资源共享)\n如果你调用的接口不在同一个域下，会遇到 CORS 问题。\n\n+ **开发环境**：在 `nuxt.config.ts` 中配置代理是最佳实践。\n\n```typescript\n// nuxt.config.ts\nexport default defineNuxtConfig({\n  // ... 其他配置\n  nitro: {\n    routeRules: {\n      '/api/**': { proxy: 'https://api.example.com/**' }, // 代理 API 请求\n    },\n  },\n  // 或者使用旧的 devServer 配置 (v3.0+ 推荐使用 nitro)\n  // devServer: {\n  //   proxy: {\n  //     '/api': 'https://api.example.com'\n  //   }\n  // }\n})\n```\n\n+ 然后你在代码中请求 `/api/users`，开发服务器会将其代理到 `https://api.example.com/api/users`，避免 CORS。\n+ **生产环境**：\n    - **最佳方案**：配置你的**反向代理**（如 Nginx）来处理跨域请求。\n    - **备选方案**：确保后端 API 正确配置了 CORS 头 (`Access-Control-Allow-Origin` 等)。\n\n#### 3. 认证和令牌 (Authentication)\n如何安全地传递身份验证信息（如 JWT Token）。\n\n+ **使用请求拦截器**：利用 `ofetch` 的自动全局拦截器。\n+ 如何安全地传递身份验证信息（如 JWT Token）。\n\n```typescript\n// plugins/api.ts\nexport default defineNuxtPlugin(() => {\n  const { token } = useAuth() // 假设你有一个获取 token 的 composable\n\n  // 全局拦截 $fetch 请求\n  globalThis.$fetch = $fetch.create({\n    onRequest({ request, options }) {\n      // 添加认证头\n      if (token.value) {\n        options.headers = {\n          ...options.headers,\n          Authorization: `Bearer ${token.value}`\n        }\n      }\n    },\n    onRequestError({ error }) {\n      console.error('Request error:', error)\n    },\n    onResponseError({ response }) {\n      // 统一处理 401 未授权错误\n      if (response.status === 401) {\n        // 跳转到登录页\n        navigateTo('/login')\n      }\n    }\n  })\n})\n```\n\n#### 4. 错误处理\n永远不要假设请求一定会成功。\n\n+ **使用 try-catch**：\n\n```javascript\ntry {\n  const data = await $fetch('/api/endpoint')\n} catch (error) {\n  // Nuxt 3 的 $fetch 会自动抛出错误\n  console.error('API call failed:', error)\n  // 在这里显示用户友好的错误信息\n}\n```\n\n+ **使用 **`**useFetch**`** 的状态**：\n\n```vue\n<script setup>\nconst { data, error } = useFetch('/api/endpoint')\n</script>\n\n<template>\n  <div v-if=\"error\">\n    Failed to load data: {{ error.message }}\n    <button @click=\"refresh\">Try Again</button>\n  </div>\n</template>\n```\n\n#### 5. 性能优化：避免重复请求\n+ **Key 的妙用**：`useAsyncData` 和 `useFetch` 会**自动去重**具有相同 key 的请求。确保为唯一的数据集提供唯一的 key。\n\n```javascript\n// 如果两个组件使用相同的 key，只会发出一个请求\nconst { data } = useAsyncData('user-profile', () => $fetch('/api/profile'))\n```\n\n+ **缓存**：`$fetch` 默认不会缓存 HTTP 缓存。如果你需要利用 HTTP 缓存，可以在 headers 中设置，或者使用更高级的缓存策略。\n\n---\n\n### 三、最佳实践总结\n1. **首选**** **`**useFetch**`**/**`**useAsyncData**`：用于在组件中获取数据，它们能智能处理 SSR 和 hydration。\n2. **明确数据获取时机**：想清楚你需要的数**据是应该在服务端获取（SEO 关键）还是客户端获取（用户相关）**，并用 `server: false` 或 `useLazyFetch` 控制。\n3. **开发环境用代理解决 CORS**：在 `nuxt.config.ts` 中配置代理，避免跨域问题。\n4. **统一处理认证和错误**：通过插件创建配置好的 `$fetch` 实例，全局处理 token 和错误。\n5. **善待你的 API**：合理使用 key 去重，避免重复请求；考虑分页、限流和缓存。\n\n遵循这些指南，你就能在 Nuxt 应用中高效、可靠地与后端 API 进行交互。\n\n## 开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\n**你这个问题问得非常好，直击要害！你的理解完全正确。**\n\n是的，你的推理是精准的：\n\n+ **服务端（Node.js）发起的请求**：没有跨域概念。跨域是**浏览器**强加的安全策略。Node.js 发请求就像你用 `curl` 或 Postman 一样，可以去任何地方，不存在 CORS 问题。\n+ **客户端（浏览器）发起的请求**：受跨域限制。浏览器会拦截违反同源策略的请求。\n\n**因此，“开发环境配置代理” 主要就是为了解决 —— 在客户端发起请求时遇到的跨域问题。**\n\n---\n\n### 为什么开发环境会有客户端请求？\n在 Nuxt 3 的 SSR 模式下，一个页面渲染通常涉及**两次**数据获取：\n\n1. **第一次（服务端请求 - 无 CORS）**：\n    - 当用户直接访问页面 URL 时，请求会先到达你的 Nuxt 服务器。\n    - Nuxt 服务器执行 `useFetch` 或 `useAsyncData`，**在服务器环境**（Node.js）中向后端 API 发起请求。\n    - 此时是 **服务器对服务器** 的通信，没有浏览器参与，所以**没有 CORS 问题**。\n    - 服务器拿到数据后，渲染出包含内容的 HTML 并返回给浏览器。\n2. **第二次（客户端请求 - 有 CORS 风险）**：\n    - 浏览器收到 HTML 并展示后，会加载 Nuxt 的客户端 JS Bundle。\n    - Vue 开始 **“激活” (Hydration)** 过程。\n    - 在这个过程中，`useFetch` 和 `useAsyncData` 的代码会在**客户端浏览器环境**中再次运行，以确保数据状态一致。\n    - 如果它们的 URL 是**绝对路径**（如 `https://api.example.com/data`），那么这次请求就是由**浏览器**直接发起的，就会触发 CORS 检查。\n    - 如果后端 API 没有正确配置 CORS 头，浏览器就会拦截这次请求，导致错误。\n\n此外，还有几种常见的**纯客户端请求**场景：\n\n+ 用户交互（如点击按钮）触发的 `$fetch` 请求。\n+ 在 `onMounted` 钩子中发起的请求。\n+ 使用 `useLazyFetch`（它默认在客户端执行）。\n\n### 总结与最佳实践\n| 场景 | 请求发起方 | 是否有 CORS 问题？ | 解决方案 |\n| --- | --- | --- | --- |\n| **SSR 首屏渲染** | Nuxt Server (Node.js) | **否** | 无需额外配置。但需确保服务器能访问到 API（网络连通性）。 |\n| **CSR Hydration/交互** | 浏览器 | **是** | **配置开发服务器代理**（如下方代码）。这是最推荐的方法。 |\n| **生产环境** | 浏览器 | **是** | **配置生产级反向代理**（如 Nginx），或确保后端 API 正确设置 CORS 头。 |\n\n\n## nuxt中的$fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\n非常好的问题！这是理解 Nuxt 3 数据获取的关键。它们的执行环境行为是核心区别。\n\n简单直接的答案是：**不，**`**$fetch**`** ****可以在服务端和客户端调用。而**** **`**useFetch**`** ****和**** **`**useAsyncData**`** ****的行为是智能的，默认在服务端执行。**\n\n下面我们来详细拆解这三者的区别。\n\n---\n\n### 一、`$fetch`：双环境通用的请求工具\n`$fetch` 是 Nuxt 3 基于 [ofetch](https://github.com/unjs/ofetch) 提供的全局工具函数。它本身**没有环境限制**，你在哪里调用它，它就在哪个环境执行。\n\n+ **在服务端（Node.js）调用**：它就像一个普通的 Node.js HTTP 客户端（比如 `axios`），直接向后端发起请求，**没有跨域概念**。\n+ **在客户端（浏览器）调用**：它的行为类似于原生的 `fetch()`，但功能更强大（自动处理 JSON、更好的错误处理等），并且**受浏览器跨域策略限制**。\n\n**示例：**\n\n```javascript\n// 1. 在组件 setup 中直接调用 - 根据渲染环境决定\n// 如果在服务端渲染，它在服务端执行；如果在客户端激活或导航，它在客户端执行。\nconst data = await $fetch('/api/items');\n\n// 2. 在明确的服务端环境调用 - 只在服务端执行\n// 例如：在 API 路由、服务器中间件或 plugin 中\nexport default defineEventHandler(async (event) => {\n  const data = await $fetch('https://external-api.com/data'); // 在服务器上运行\n  return { data };\n});\n\n// 3. 在明确的客户端环境调用 - 只在客户端执行\n// 例如：在事件处理函数或 onMounted 中\nconst handleClick = async () => {\n  const data = await $fetch('/api/items'); // 在浏览器中运行，受 CORS 限制\n};\n```\n\n`**$fetch**`** ****的陷阱**：如果你在组件顶层直接使用 `$fetch`（没有包裹在 `useAsyncData` 或 `useFetch` 中），并且该组件在服务端渲染，那么请求会在服务端执行。但当客户端激活（Hydration）时，**同样的**** **`**$fetch**`** ****代码又会在客户端再执行一次**，造成重复请求。\n\n---\n\n### 二、`useAsyncData` & `useFetch`：智能的双环境数据获取器\n这两个组合函数是 Nuxt 数据获取的“智能大脑”。它们的关键特性是：**“在服务端预取数据，并自动将数据序列化到客户端，避免重复请求”**。\n\n#### 核心行为：\n1. **默认在服务端执行**：在 SSR 模式下，当页面首次加载时，它们会在 Nuxt 服务器内部执行，获取数据并直接将数据嵌入到最终返回的 HTML 中。\n2. **在客户端激活**：当 Vue 在客户端“激活”静态页面时，`useAsyncData` 和 `useFetch` 会识别到数据已经存在于从服务器传递过来的 payload 中，因此**不会在客户端再次发起请求**，而是直接使用已有的数据。\n3. **后续导航**：当你在客户端通过导航跳转到另一个也使用了这些函数的页面时，它们会在**客户端**执行。\n\n#### 如何控制执行环境？\n它们提供了一个 `server` 选项让你精确控制：\n\n```javascript\n// 默认：true - 在服务端执行（SSR 首屏）\nconst { data } = useFetch('/api/items');\n\n// 强制在客户端执行（CSR）\n// 适合：用户相关的数据、不需要 SEO 的数据、访问浏览器 API 的数据\nconst { data } = useFetch('/api/user-data', {\n  server: false\n});\n\n// useAsyncData 用法相同\nconst { data } = useAsyncData('user-key', () => $fetch('/api/user'), {\n  server: false\n});\n```\n\n### 三、三者的对比总结\n为了更直观地理解，下面的流程图展示了不同调用方式在 Nuxt 应用生命周期中的执行时机和数据流向：\n\n这个图清晰地展示了：\n\n1. `**useFetch**`**/**`**useAsyncData**` 是贯穿服务端和客户端的“智能通道”，保证了数据的高效同步和无重复请求。\n2. **直接使用**** **`**$fetch**` 在组件顶层会导致重复请求，是需要避免的反模式。\n3. **在事件中使用的**** **`**$fetch**` 是纯客户端行为。\n\n### 最佳实践与选择指南\n| 场景 | 推荐使用的工具 | 原因 |\n| --- | --- | --- |\n| **获取页面组件所需数据** | `**useFetch**`<br/>** ****或**** **`**useAsyncData**` | 自动处理 SSR/CSR，避免重复请求，数据序列化到客户端。 |\n| **在事件处理、**`**onMounted**`<br/>** ****中获取数据** | `**$fetch**` | 明确需要在客户端触发的请求。 |\n| **在 API 路由或服务器中间件中** | `**$fetch**` | 明确的服务端环境，无需 `useAsyncData`<br/> 的额外功能。 |\n| **需要复杂的数据获取逻辑** | `**useAsyncData**`<br/>** ****+**** **`**$fetch**` | `useAsyncData`<br/> 提供状态管理，内部函数可使用 `$fetch`<br/> 进行复杂操作。 |\n| **简单的 URL 请求** | `**useFetch**` | 最简洁的写法。 |\n\n\n**一句话总结：**\n\n+ **用**** **`**useFetch**`**/**`**useAsyncData**` 来获取**组件初始化时所需的数据**，让 Nuxt 智能决定执行环境。\n+ **用**** **`**$fetch**` 在**明确的客户端交互**或**明确的服务端环境**中主动发起请求。\n\n遵循这个原则，你就能高效且正确地在 Nuxt 应用中处理数据获取。\n\n## 激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\n这些问题触及了 Nuxt.js SSR 的核心魔法。好消息是，**这个过程绝大部分是自动化的，开发者几乎不需要手动干预**。Nuxt 和 Vue 底层已经为你处理好了一切。\n\n下面我来逐一解答你的问题，你会看到 Nuxt 的设计是多么巧妙。\n\n---\n\n### 一、激活客户端需要开发手动调用什么 API 吗？\n**答：完全不需要。这是 Vue 和 Nuxt 自动完成的。**\n\n这个过程称为 **Hydration（混合）**。它的流程是：\n\n1. **自动执行**：当浏览器加载完 Nuxt 发送过来的 HTML 和客户端 JavaScript 包后，Vue 会自动启动。\n2. **自动匹配**：Vue 会将它的虚拟 DOM 与服务器渲染好的、已经存在的静态 HTML 结构进行对比和匹配。\n3. **自动“激活”**：Vue 不会重新创建 DOM 元素，而是会将事件监听器、响应式数据系统等“附加”到这些现有的 DOM 元素上，使静态页面瞬间变为一个完全交互式的 Vue 应用。\n\n**作为开发者，你唯一要做的就是：**\n\n+ 确保你的代码是**同构的**（即同一份代码既能在 Node.js 环境运行，也能在浏览器环境运行）。\n+ 避免在 `created` 或 `setup` 等生命周期中使用浏览器特有的 API（如 `window`, `document`），或者使用 `onMounted`（仅在客户端执行）来包裹它们。\n\n**你不用写任何像**** **`**app.hydrate()**`** ****这样的代码，一切都是开箱即用、自动发生的。**\n\n---\n\n### 二、服务端异步获取的数据注入到 HTML 这一步开发需要做什么？\n**答：你只需要使用正确的 API（**`**useAsyncData**`** ****或**** **`**useFetch**`**），Nuxt 就会自动完成注入。**\n\n这个“注入”过程在 Nuxt 中被称为 **State Serialization（状态序列化）** 或 ** dehydration（脱水）**。\n\n**你的工作（非常简单）：**\n\n1. **使用 **`**useAsyncData**`** 或 **`**useFetch**`：在你的页面组件中，用它们来获取数据。\n\n```vue\n<script setup>\n  // pages/posts.vue\n  const { data: posts } = await useFetch('/api/posts')\n</script>\n```\n\n2. **Nuxt 自动完成后续所有事情**：\n    - Nuxt 在服务端执行完 `useFetch` 后，会**自动**将 `posts` 数据序列化为 JSON 字符串。\n    - 将这个 JSON 字符串**自动嵌入**到最终 HTML 的 `<head>` 部分的一个 `<script>` 标签中。\n    - 这个标签的内容通常是 `window.__NUXT__ = { ... }`，其中就包含了所有页面的预取数据。\n\n**你不需要手动操作 DOM 去注入数据，Nuxt 的渲染引擎为你包办了一切。**\n\n---\n\n### 三、到客户端时如何获取数据呢？\n**答：客户端 Vue 应用会自动从**** **`**window.__NUXT__**`** ****中提取并复用数据，无需再次请求。**\n\n这个过程是 **State Deserialization（状态反序列化）** 或 **rehydration（补水）**。\n\n**它的自动流程如下：**\n\n1. **数据随 HTML 到达浏览器**：HTML 中的 `<script>window.__NUXT__ = {...}</script>` 会先被执行，将数据挂载到全局对象上。\n2. **客户端 Vue 应用启动**：客户端的 JavaScript 包加载完毕后，Vue 和 Nuxt 开始初始化。\n3. **自动提取数据**：当客户端的 `useFetch('/api/posts')` 代码执行时，它不会真正去发起网络请求，而是会**先自动去**** **`**window.__NUXT__**`** ****对象里查找**，看是否存在服务端已经为它准备好的数据。\n4. **直接复用数据**：如果找到了，它就直接使用这份数据，完全跳过网络请求。这样就保证了客户端和服务端的数据状态**绝对一致**，这也是 Hydration 能成功的前提。\n\n**你可以通过 **`**useNuxtData**`** 这个工具函数来验证和访问这些被缓存的数据：**\n\n```vue\n<script setup>\n// 在客户端，你可以这样访问之前服务端获取的、被缓存的数据\nconst { data: posts } = useNuxtData('posts') // 使用 useFetch 时自动生成的 key\n\n// 这不会导致第二次请求，它只是从客户端缓存中读取\nconsole.log(posts.value)\n</script>\n```\n\n## 服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\n**你这个问题问得非常非常关键，切中了SSR安全的核心！你的直觉完全正确。**\n\n**绝对不应该将任何敏感信息（如用户凭证、Token、个人身份信息PII等）内联到HTML的**** **`**<script>**`** ****标签中，并通过**** **`**window.__NUXT__**`** ****暴露给客户端。**\n\n这样做会带来严重的安全风险：\n\n1. **数据泄露**：任何能打开浏览器开发者工具的人，都可以直接看到 `window.__NUXT__` 里的全部内容。\n2. **XSS攻击加剧**：如果你的应用存在XSS（跨站脚本）漏洞，攻击者可以更容易地编写脚本窃取 `window.__NUXT__` 中的所有数据，而不必费力去窃取多个API请求的返回结果。\n3. **缓存风险**：HTML页面可能会被CDN、代理服务器或浏览器缓存。如果其中包含了用户敏感信息，就意味着这些信息也可能被缓存并泄露给其他用户。\n\n---\n\n### 那么，如何处理需要认证的敏感数据？\n正确的做法是将敏感数据与非敏感数据**分离**，并遵循“**按需索取**”和“**最小化暴露**”的原则。以下是几种安全策略：\n\n#### 策略一：敏感数据绝不预取，仅在客户端获取\n这是最常用、最安全的策略。用户登录状态、个人资料等高度敏感的数据，**不应该**在服务端的 `useFetch`/`useAsyncData` 中获取。\n\n```vue\n<script setup>\n// 1. 非敏感、SEO需要的数据：在服务端预取（安全）\nconst { data: publicPosts } = await useFetch('/api/public-posts')\n\n// 2. 敏感的用户数据：不在服务端预取，只在客户端获取\nconst user = ref(null)\nconst token = useCookie('auth-token') // Token应存放在HttpOnly Cookie中\n\n// 在客户端挂载后，再安全地获取用户数据\nonMounted(async () => {\n  if (token.value) {\n    // 此请求在客户端发起，携带Cookie中的token\n    user.value = await $fetch('/api/me', {\n      headers: {\n        // 通常Token会自动通过Cookie发送，无需手动设置，这里演示逻辑\n        Authorization: `Bearer ${token.value}`\n      }\n    })\n  }\n})\n</script>\n\n<template>\n  <!-- 公开数据直接渲染 -->\n  <div v-for=\"post in publicPosts\" :key=\"post.id\">{{ post.title }}</div>\n  \n  <!-- 用户数据，等客户端获取后再显示 -->\n  <div v-if=\"user\">Welcome, {{ user.name }}</div>\n</template>\n```\n\n#### 策略二：使用 `useState` 进行状态管理，区分服务端与客户端状态\n你可以利用 `useState` 的灵活性来管理不同环境的状态。\n\n```vue\n<script setup>\n// 创建一个响应式状态，服务端先初始化为 null\nconst secretData = useState('secret-data', () => null)\n\n// 在客户端再获取真实数据\nonMounted(async () => {\n  if (!secretData.value) { // 避免在服务端执行\n    secretData.value = await $fetch('/api/secret-data')\n  }\n})\n</script>\n```\n\n#### 策略三：API 设计分离 - 提供公开和私密端点\n从后端设计上就进行分离：\n\n+ `/api/public/data`：返回不敏感的数据，可以安全地在服务端渲染。\n+ `/api/private/user-data`：返回敏感数据，必须认证且在客户端获取。\n\n---\n\n### Nuxt 如何安全地处理认证？\n认证的最佳实践是使用 **HttpOnly Cookies** 来传输令牌（Token），而不是通过 `window.__NUXT__` 或 JS 可读的 Cookie。\n\n1. **登录流程**：\n    - 用户提交登录表单，客户端 `$fetch` 发送到 `/api/auth/login`。\n    - **后端**验证成功后，设置一个 **HttpOnly、Secure、SameSite=Strict** 的 Cookie（包含认证Token）。这个 Cookie 对 JavaScript 不可见，极大地增强了安全性。\n    - 前端只需知道登录成功，无需接触 Token 本身。\n2. **获取用户数据**：\n    - 在客户端，调用 `$fetch('/api/me')`。\n    - 浏览器会**自动**在请求中带上 HttpOnly Cookie。\n    - 后端验证 Cookie 中的 Token 有效性后，返回对应用户的数据。\n3. **服务端渲染中的认证**：\n    - 如果服务端需要根据用户状态渲染不同内容（例如“您好，用户名”），可以通过**服务器中间件**或 **API 路由**来处理。\n    - 服务端可以读取请求中的 Cookie，去后端验证用户身份，然后决定返回什么数据。但这个验证过程发生在后端，结果信息需要是**非敏感**的（例如只返回 `username`，而不是返回 `token` 或 `email`）。\n\n```vue\n<script setup>\n// 服务端可以安全地读取Cookie并获取非敏感的用户显示信息\nconst { data: userInfo } = await useFetch('/api/user-display-info')\n// 这个 `/api/user-display-info` 接口在后端会验证Cookie，\n// 但只返回 { name: 'John' } 这样的非敏感信息用于界面显示。\n</script>\n```\n\n### 总结\n1. **核心原则**：**绝不将敏感数据内联到 HTML 中**。`window.__NUXT__` 应该是“公开的”或“非敏感的”。\n2. **数据分离**：将数据分为“公开”和“私密”两类。公开数据用 `useFetch` 服务端预取；私密数据在客户端用 `$fetch` 按需获取。\n3. **认证最佳实践**：使用 **HttpOnly Cookies** 来安全地传输认证凭证，而不是将其暴露给客户端 JavaScript 或 `window` 对象。\n4. **信任后端**：敏感的权限检查和数据处理逻辑应该始终放在后端 API 中。前端（包括SSR服务端）只负责展示非敏感的结果。\n\n你的安全意识非常到位，遵循这些原则可以让你构建出既高效又安全的 Nuxt.js 应用。\n\n## 除此之外，服务端渲染还有什么不能实现的呢？canvas？\n说得非常对！**Canvas** 是一个绝佳的例子，它完美地揭示了服务端渲染（SSR）的“盲区”。\n\nSSR 的核心是**生成静态的 HTML 和 CSS 字符串**。因此，任何**动态的、依赖于浏览器 JavaScript 运行时环境**的功能，在纯 SSR 阶段都无法实现或功能不全。\n\n除了 Canvas，还有很多类似的限制。我们可以将它们分为几大类：\n\n---\n\n### 一、浏览器特有的 API 和全局对象\n这是最直接的一类。在 Node.js 服务器环境中，根本没有 `window`, `document`, `navigator` 等对象。\n\n| API/功能 | 原因 | 解决方案 |\n| --- | --- | --- |\n| `**window**`**、**`**document**` | Node.js 中不存在。 | 使用 `onMounted`钩子或 `clientOnly`组件确保只在客户端访问。 |\n| `**alert**`**、**`**confirm**`**、**`**prompt**` | 浏览器交互对话框。 | 逻辑移至客户端，或使用基于组件的替代品（如模态框）。 |\n| **Canvas (**`**<canvas>**`**) / WebGL** | 需要浏览器渲染上下文来绘图和操作像素。 | **只能在客户端初始化和使用**。SSR 只能渲染一个空画布。 |\n| **地理位置 (**`**navigator.geolocation**`**)** | 需要用户的浏览器授权和设备硬件支持。 | 仅在客户端通过 `onMounted`或用户交互触发。 |\n| **本地存储 (**`**localStorage**`**, **`**sessionStorage**`**, **`**IndexedDB**`**)** | 是浏览器的持久化存储机制。 | 在 `onMounted`中访问，或使用 `useLocalStorage`等组合式函数（内部做了客户端检查）。 |\n| **媒体设备 (**`**navigator.mediaDevices**`**)** | 需要访问麦克风、摄像头等硬件。 | 完全的用户客户端行为。 |\n\n\n---\n\n### 二、依赖浏览器渲染或布局的功能\n这类功能需要知道元素的真实尺寸和位置，而这些信息在纯字符串的 SSR 阶段是无法获得的。\n\n| 功能 | 原因 | 解决方案 |\n| --- | --- | --- |\n| **元素尺寸/位置** (如 `element.offsetWidth`<br/>, `getBoundingClientRect()`<br/>) | SSR 只有 HTML 字符串，没有真实的布局和渲染。 | 在 `onMounted`<br/> 后使用，或使用 Vue 的 `nextTick`<br/> 确保 DOM 已更新。 |\n| **基于尺寸的渲染** (如图表库 ECharts、D3.js) | 需要挂载到真实 DOM 元素并获取其宽高才能渲染。 | 在 `onMounted`<br/> 中初始化图表实例。 |\n| **动画 (CSS 动画除外)** | 许多 JS 动画库需要操作 DOM 样式。 | 使用 `onMounted`<br/> 启动动画，或使用 CSS 动画（SSR 支持）。 |\n\n\n---\n\n### 三、用户交互和状态\nSSR 输出的是一个“快照”，无法预知用户未来的行为。\n\n| 功能 | 原因 | 解决方案 |\n| --- | --- | --- |\n| **用户输入** (表单输入、焦点状态) | SSR 无法预知用户会输入什么。 | SSR 可以渲染表单结构，但交互和值绑定必须在客户端完成。 |\n| **鼠标事件、键盘事件** | 纯静态环境，无用户交互。 | 完全由客户端 JavaScript 处理。 |\n| **浏览器标签页可见性** (`document.visibilityState`) | 依赖于用户当前的浏览器状态。 | 纯客户端逻辑。 |\n\n\n---\n\n### 四、第三方库\n许多强大的第三方库在设计时就是为浏览器而生的。\n\n| 库类型 | 问题 | 解决方案 |\n| --- | --- | --- |\n| **地图库** (如 Leaflet, Google Maps) | 需要挂载到 DOM 并初始化地图渲染上下文。 | 使用 `onMounted`<br/> 初始化，或使用 Nuxt 模块（如 `nuxt-leaflet`<br/>）。 |\n| **可视化库** (如 D3, Three.js) | 严重依赖 Canvas、WebGL 或 SVG 操作。 | **只能在客户端运行**。 |\n| **分析/广告库** (如 Google Analytics) | 依赖 `window`<br/> 对象和浏览器环境来跟踪用户。 | 使用 Nuxt 插件（`client: true`<br/> 选项）或直接在 `onMounted`<br/> 中加载。 |\n\n\n---\n\n### 如何安全地处理这些限制？Nuxt 提供的解决方案\nNuxt 提供了一系列模式来优雅地解决这些问题：\n\n#### 1. `onMounted` 钩子 (最常用)\n确保代码只在客户端执行。\n\n```vue\n<script setup>\nimport { onMounted } from 'vue'\n\nconst canvas = ref(null)\n\nonMounted(() => {\n  // 现在可以安全地访问 DOM 和浏览器 API 了\n  const ctx = canvas.value.getContext('2d')\n  ctx.fillStyle = 'green'\n  ctx.fillRect(10, 10, 150, 100)\n})\n</script>\n\n<template>\n  <!-- SSR 会渲染一个空画布 -->\n  <canvas ref=\"canvas\" width=\"200\" height=\"200\"></canvas>\n</template>\n```\n\n#### 2. 条件渲染与 `<ClientOnly>` 组件\n防止不支持 SSR 的组件在服务器端渲染时出错。\n\n```vue\n<template>\n  <!-- 默认插槽只在客户端渲染 -->\n  <ClientOnly>\n    <MyChartThatUsesWindow />\n    <!-- 可以设置回退内容，在SSR阶段显示 -->\n    <template #fallback>\n      <div>Loading chart...</div>\n    </template>\n  </ClientOnly>\n</template>\n```\n\n#### 3. 使用 `process.client` 标志进行运行时检查\n```vue\n<script setup>\nif (process.client) {\n  // 此代码块只在客户端打包时包含，并在客户端执行\n  console.log('I am on the client!', window.innerWidth)\n}\n</script>\n```\n\n#### 4. 为第三方库创建客户端插件\n```javascript\n// plugins/analytics.client.js - 注意 .client 后缀\nexport default defineNuxtPlugin(() => {\n  // 这个插件只会在客户端运行\n  window.dataLayer = window.dataLayer || []\n  function gtag(){ dataLayer.push(arguments) }\n  gtag('js', new Date())\n  gtag('config', 'GA_MEASUREMENT_ID')\n})\n```\n\n### 总结\n服务端渲染 (SSR) 的本质是**静态化**，它擅长的是：\n\n+ **生成初始 HTML 内容**\n+ **提供更好的 SEO**\n+ **提升首屏加载性能**\n\n而**动态交互**和**浏览器依赖**永远是 SSR 的盲区，必须交给客户端处理。\n\n**因此，一个成熟的 Nuxt 应用是两者结合的“混合体”：**\n\n1. **服务端**：生成静态结构和首屏内容。\n2. **客户端**：“激活”页面，接管所有交互，并加载那些依赖浏览器环境的动态功能。\n\n你的工作就是清晰地界定哪些逻辑属于服务端，哪些属于客户端，并使用 Nuxt 提供的模式（`onMounted`, `<ClientOnly>`, `.client` 插件）将它们优雅地结合起来。\n\n## nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\n这是一个非常好的问题，它触及了 Nuxt 全栈架构的核心优势。\n\n**简单而直接的答案是：不会。在客户端激活后，向同源的 Nuxt 中间件或 API 路由发起请求，绝对不会产生跨域问题。**\n\n这是因为你发起请求的目标和你的页面来源是**完全同源的**。\n\n---\n\n### 为什么不会跨域？—— 同源策略详解\n让我们回顾一下“同源策略”：当协议、域名、端口都相同时，即为同源，浏览器允许请求。\n\n假设你的 Nuxt 应用部署在：  \n`https://www.my-app.com`\n\n1. **你的页面来源**：  \n浏览器中显示的地址是：`https://www.my-app.com/some-page`\n2. **你请求的目标**：  \n你在代码中发起的请求是：\n\n```javascript\n// 使用相对路径，目标自动补全为：https://www.my-app.com/api/hello\nawait $fetch('/api/hello');\n\n// 或者使用 useFetch（同样基于相对路径）\nconst { data } = useFetch('/api/auth/user');\n```\n\n3. **对比**：\n    - **协议**：都是 `https`\n    - **域名**：都是 `www.my-app.com`\n    - **端口**：都是 `443` (HTTPS 默认端口)\n\n**结论**：**完全同源**，浏览器欣然放行，没有任何跨域限制。\n\n---\n\n### Nuxt 如何处理这些请求？—— 请求生命周期\n理解这个过程能让你更清楚为什么这是安全的：\n\n如图所示，无论是开发还是生产环境，**你的 API 请求和前端页面都由同一个主机处理**。它们处于同一个“生态系统”内，通信是内部的、安全的，不存在跨域问题。\n\n---\n\n### 什么情况下会有跨域问题？\n只有当你的**页面来源**和**请求目标**不同源时，才会触发跨域。例如：\n\n| 你的页面在 | 你请求的目标 | 是否跨域 | 原因 |\n| --- | --- | --- | --- |\n| `https://www.my-app.com` | `https://www.my-app.com/api/hello` | **否** | 同源 |\n| `https://www.my-app.com` | `https://api.my-app.com` | **是** | 子域名不同 (`www` vs `api`) |\n| `http://localhost:3000` | `https://api.third-party.com` | **是** | 完全不同的域名 |\n| `https://www.my-app.com` | `http://www.my-app.com/api/hello` | **是** | 协议不同 (`https`vs `http`) |\n\n\n**对于最后一种情况（生产环境前后端分离），解决方案是：**\n\n1. **后端配置 CORS**：在你的 `api.my-app.com` 服务器上设置 `Access-Control-Allow-Origin: https://www.my-app.com` 响应头。\n2. **使用反向代理**：配置你的生产服务器（如 Nginx），将对 `/api/` 的请求代理到 `api.my-app.com`，让浏览器始终觉得是在请求同源地址。这是更推荐的做法。\n\n### 总结\n+ **在 Nuxt 应用中，请求自身的 API 路由 (**`**/api/xxx**`**) 或服务器中间件是绝对同源的，没有跨域问题。**\n+ 这是 Nuxt 全栈框架的巨大优势之一，它简化了开发，让你无需在开发阶段为 CORS 烦恼。\n+ 跨域问题只会在你请求**外部第三方 API** 且对方未正确配置 CORS 时出现。\n+ 如果你的生产环境是前后端完全分离的（不同域），那么需要在生产环境的**后端配置 CORS** 或通过**反向代理**来解决。\n\n所以，请放心地在你的 Nuxt 应用内部调用 API，这是最安全、最正确的做法。\n\n## 那如果对后端接口(另一台服务器上)的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\n**你的这个思路非常棒，完全正确！** 这正是构建现代 Web 应用的一种核心架构模式，被称为 **“BFF（Backend For Frontend）模式”** 或 **“API 网关模式”**。\n\n你的推理链条是：\n\n1. **所有客户端请求**都只发往**同源**的 Nuxt 服务器（`/api/proxy`）。\n2. Nuxt 服务器上的**中间件**接收到请求后，**代为转发**给真正的后端服务器。\n3. 由于服务器之间通信（Nuxt Server -> Your Backend Server）**没有跨域限制**，所以问题迎刃而解。\n\n这个方案**在理论上是完全可行且非常优雅的**，它确实可以让你**完全摆脱 CORS 的困扰**。\n\n---\n\n### 这种架构的详细工作流程\n如图所示，浏览器始终只与 `my-nuxt-app.com` 通信，完美符合同源策略。\n\n---\n\n### 优缺点分析：这是否是“万能药”？\n虽然这个方案能根治跨域，但它也引入了一些新的考虑因素：\n\n#### 优点 ✅\n1. **彻底解决 CORS**：前端开发者完全无需再关心跨域配置，开发体验极其流畅。\n2. **隐藏后端架构**：真正的后端地址、端口、API 结构对客户端完全隐藏，更安全。\n3. **协议转换**：可以轻松地在 Nuxt 中处理 HTTPS -> HTTP 的请求（服务器间通信允许）。\n4. **数据处理与聚合**：你可以在 Nuxt 中间件中对多个后端服务的返回值进行聚合、过滤、转换，为前端提供最合适的数据结构，减少前端请求次数。\n\n#### 缺点与需要考虑的因素 ⚠️\n1. **额外的网络跳转**：所有请求都多经过一环（浏览器 -> Nuxt -> 真实后端），**会增加微小的延迟**。对于延迟敏感的应用需要优化。\n2. **单点压力与故障点**：Nuxt 服务器现在成为了所有 API 流量的入口。如果它宕机，所有请求都会失败。需要保证其高可用性。\n3. **复杂性转移**：虽然前端变简单了，但 Nuxt 层（BFF 层）的逻辑变复杂了。你需要在这里编写转发、错误处理、认证等逻辑。\n4. **认证问题**：如果后端 API 需要认证，你需要决定如何传递认证信息。\n    - **方案A（推荐）**：浏览器将认证 Token 发给 Nuxt，Nuxt 再原样转发给后端。\n    - **方案B**：Nuxt 服务器自己持有访问后端的凭证，替用户与后端通信。但这需要非常小心地管理权限。\n\n---\n\n### 如何实现？\n在 Nuxt 中，你通常使用 **API 路由** 或 **服务器中间件** 来实现，而不是普通的中间件，因为它们专门处理服务器逻辑。\n\n**示例：在 **`**server/api/proxy/[...].ts**`** 中创建一个捕获所有路由的 API**\n\n```typescript\n// server/api/proxy/[...].ts\nexport default defineEventHandler(async (event) => {\n  // 1. 获取请求路径和方法\n  const path = getRouterParam(event, 'path') // 获取 ... 通配符参数\n  const method = getMethod(event)\n  const body = method === 'GET' ? undefined : await readBody(event)\n\n  // 2. 定义你的真实后端基础 URL（应从环境变量读取！）\n  const baseURL = 'https://your-real-backend.com/api'\n  const targetURL = `${baseURL}/${path}`\n\n  // 3. 可选：处理认证（例如，将前端传来的 token 转发给后端）\n  const headers = {}\n  const authHeader = getHeader(event, 'authorization')\n  if (authHeader) {\n    headers['Authorization'] = authHeader\n  }\n\n  // 4. 代理请求到真实后端\n  try {\n    const response = await $fetch.raw(targetURL, {\n      method,\n      body,\n      headers,\n      // 重要：转发查询参数 (?foo=bar)\n      query: getQuery(event),\n    })\n\n    // 5. 可选：根据需要设置响应头\n    setHeaders(event, response.headers)\n\n    // 6. 返回后端响应的数据\n    return response._data\n  } catch (error) {\n    // 7. 错误处理，将后端错误返回给前端\n    throw createError({\n      statusCode: error.statusCode || 500,\n      statusMessage: error.statusMessage || 'Internal Server Error',\n    })\n  }\n})\n```\n\n这样，前端所有发往 `/api/proxy/items`、`/api/proxy/user/profile` 的请求，都会被这个 handler 捕获，并转发到 `https://your-real-backend.com/api/items` 和 `https://your-real-backend.com/api/user/profile`。\n\n### 结论\n**是的，你的想法是完全正确且高效的。通过让 Nuxt 服务器作为所有后端请求的代理，你可以一劳永逸地解决跨域问题，无需在开发或生产环境配置任何 CORS 或代理规则。**\n\n这不仅是解决跨域的手段，更是一种先进的**架构设计选择**（BFF）。它特别适用于：\n\n+ 中大型前后端分离项目。\n+ 需要集成多个后端微服务的复杂前端。\n+ 希望简化前端开发流程，将复杂性集中到 BFF 层的团队。\n\n你只需要评估其带来的**额外延迟**和**单点压力**是否在你的应用可接受范围内即可。对于绝大多数应用来说，这个方案的利远大于弊。\n\n","source":"_posts/Nuxt.js.md","raw":"---\ntitle: Nuxt\ndate: 2025-08-15\ntags: [Nuxt, 服务端渲染, Vue]\ncategories: Nuxt\n---\n\n## Nuxt.js的ssr服务端渲染原理\nNuxt.js 的 SSR（服务端渲染）原理是一个非常核心且有趣的话题。它并不是简单的“在服务器上跑 Vue”，而是一套完整的、精心设计的架构。\n\n简单来说，它的核心原理是：**“首屏在服务器提前渲染成 HTML，之后在客户端‘激活’为 SPA”。**\n\n下面我们分步拆解这个过程的原理、优势和关键实现。\n\n---\n\n### 一、核心目标：解决什么問題？\n1. **SEO（搜索引擎优化）**：传统 SPA（单页应用）返回的是一个空的 HTML 壳，内容由 JavaScript 动态填充。搜索引擎爬虫可能无法等待和执行 JS，导致无法收录内容。SSR 直接返回渲染好的完整 HTML，利于爬虫抓取。\n2. **更快的内容到达时间**：用户浏览器无需等待所有 JavaScript 下载和执行完毕才能看到内容。服务器直接返回了渲染好的 HTML，首屏内容可以立即展示，感知性能极大提升。\n\n### 二、Nuxt.js SSR 的核心工作流程\nNuxt.js 的 SSR 过程可以清晰地分为两个阶段：**服务端渲染**和**客户端激活**。下图展示了从用户请求到页面可交互的完整生命周期：\n\n<img src=\"/images/nuxt核心工作流.png\" alt=\"nuxt核心工作流\" width=\"60%\" height=\"auto\" style=\"display:block;\">\n\n#### 第一阶段：服务端渲染（Server-Side）\n这个过程发生在 **Nuxt 服务器**（一个 Node.js 服务器）上。\n\n1. **接收请求**：用户浏览器请求一个 URL，请求到达 Nuxt 服务器。\n2. **创建应用实例**：Nuxt 服务器为这次请求**创建一个全新的 Vue 应用实例、Router 和 Store**。这是关键，确保了每个请求的隔离性。\n3. **路由匹配**：根据请求的 URL，Nuxt Router 确定要渲染哪个页面组件（如 `pages/about.vue`）。\n4. **数据预取**：Nuxt 会调用页面组件中定义的**异步数据获取方法**（如 `asyncData`、`useAsyncData`、`useFetch`）。**这些方法会在服务端执行**。\n    - 服务器会等待这些异步操作完成，再去渲染组件。这确保了渲染出的 HTML 是包含数据的。\n5. **渲染 HTML**：\n    - 将获取到的数据**注入到 Vuex Store 或组件状态**中。\n    - 调用 Vue 的 `vue-server-renderer`（Vue 2）或 `@vue/server-renderer`（Vue 3）的 `renderToString()` 函数。\n    - 这个函数会运行 Vue 组件，但它**不是在浏览器中创建真实 DOM，而是在内存中生成一个完整的 HTML 字符串**。\n6. **构建最终文档**：Nuxt 将这个 HTML 字符串插入到HTML模板（`app.html`）中。同时，**将预取的数据序列化后内联到 HTML 中**（通常是在一个 `<script>` 标签里，如 `window.__NUXT__ = {...}`），这个过程称为 **状态脱水**。\n7. **响应**：将这个完整的、包含数据和内容的 HTML 文档发送给客户端。\n\n#### 第二阶段：客户端激活（Client-Side Hydration）\n这个过程发生在**用户浏览器**上。\n\n1. **静态内容展示**：浏览器收到服务器返回的 HTML 后，**无需等待任何 JavaScript，就能立即解析和显示页面内容**。这是首屏速度快的根本原因。\n2. **加载资源**：浏览器开始加载页面中引用的 JavaScript 和 CSS 资源（Nuxt 打包好的客户端 bundle）。\n3. **Vue 接管（Hydration -“混合”）**：这是最精妙的一步。\n    - 客户端的 Vue 应用也会被创建和初始化。\n    - Vue 不会像传统 SPA 那样清空 DOM 再重新渲染。相反，它会**将虚拟 DOM 与服务器渲染好的现有静态 HTML 结构进行“混合”**。\n    - 它会将事件监听器、Vue 的响应式系统等“激活”到这些静态元素上，使其变成一个完全交互式的 Vue 应用。\n4. **变为 SPA**：激活完成后，应用就切换到了正常的 SPA 模式。后续的页面导航不会再向服务器请求完整的 HTML，而是由客户端 Router 管理，只获取必要的数据，实现无刷新跳转。\n\n---\n\n### 三、Nuxt.js 实现 SSR 的关键技术点\n1. **双入口构建（Dual Entry Points）**：\n    - Nuxt 使用 Webpack/Vite 分别打包**两个版本**的代码：\n        * **服务端 Bundle**：用于 `renderToString`，它知道如何在 Node.js 环境中渲染组件。\n        * **客户端 Bundle**：用于在浏览器中“激活”静态页面并处理后续交互。\n    - 这是通过 `webpack` 的 `target: 'node'` 和 `target: 'web'` 分别配置实现的。\n2. **数据预取与状态同步**：\n    - 服务端获取的数据必须**安全地传递到客户端**，否则客户端 Vue 在初始化时没有数据，会导致虚拟 DOM 与服务器渲染的 HTML 不匹配，激活失败。\n    - Nuxt 通过 `window.__NUXT__` 对象将数据从服务器“脱水”到客户端“补水”，保证两端状态一致。\n3. **生命周期**：\n    - 在 SSR 过程中，**只有**** **`**beforeCreate**`** ****和**** **`**created**`** ****这两个生命周期钩子会在服务端执行**。\n    - `mounted`、`beforeMount` 等只在客户端执行。因此，**在**** **`**created**`** ****中操作**** **`**window**`** ****或 DOM 会报错**。\n\n---\n\n### 四、Universal Mode (同构渲染)\nNuxt.js 的 SSR 通常被称为 **“Universal”应用**或**“同构”应用**。\n\n+ **同构代码**：同一份 Vue 组件代码（`.vue` 文件）既可以在**服务器**上运行（用于首屏生成 HTML），也可以在**客户端**运行（用于激活和后续交互）。\n+ **优势**：开发者只需写一套代码，Nuxt 负责处理双端的构建和渲染协调，开发体验非常流畅。\n\n### 总结\nNuxt.js 的 SSR 原理可以概括为：\n\n1. **服务端**：为每个请求即时创建 Vue 应用，预先获取数据，渲染出包含内容的 HTML 字符串，并将数据状态一同返回。\n2. **客户端**：快速展示静态内容，然后加载 JS，由 Vue 将静态页面“激活”为可交互的 SPA，最后接管所有后续导航。\n\n它完美地结合了**传统服务端渲染首屏快、SEO 好**的优势和**单页应用用户体验流畅、交互丰富**的优势，是现代 Web 应用开发的绝佳选择。\n\n## nuxt中调后端接口怎么做，要注意什么？\n在 Nuxt.js 中调用后端接口是其核心功能之一，但根据你使用的 API 风格（Composition API 或 Options API）和渲染模式（SSR 或 SPA），做法和注意事项有所不同。\n\n下面将为你提供全面的指南，包括方法、最佳实践和常见陷阱。\n\n---\n\n### 一、如何调用后端接口？\nNuxt 3 推荐使用 Composition API，并提供了强大的组合式函数。\n\n#### 1. 使用 `useFetch` / `useAsyncData` (Composition API - 首选)\n这是 Nuxt 3 中最现代、最推荐的方式，它完美处理了服务端和客户端的数据获取。\n\n**基本用法 (**`**useFetch**`**)：**  \n`useFetch` 是专门为获取数据而设计的语法糖。\n\n```vue\n<script setup>\n// 直接在模板中使用，无需 .value\nconst { data: posts, pending, error, refresh } = useFetch('/api/posts')\n\n// 或者指定完整 URL（注意配置代理或 CORS）\nconst { data: users } = useFetch('https://api.example.com/users', {\n  // 可选项：在客户端才获取数据（代替 onMounted + ref）\n  // lazy: true,\n  // server: false\n})\n</script>\n\n<template>\n  <div v-if=\"pending\">Loading...</div>\n  <div v-else-if=\"error\">Error: {{ error.message }}</div>\n  <ul v-else>\n    <li v-for=\"post in posts\" :key=\"post.id\">{{ post.title }}</li>\n  </ul>\n  <button @click=\"refresh\">Refresh</button>\n</template>\n```\n\n**高级用法 (**`**useAsyncData**`** + **`**$fetch**`**)：**  \n当你需要更复杂的逻辑时（如多个请求、数据处理），使用 `useAsyncData`。\n\n```vue\n<script setup>\nconst { data: combinedData, refresh } = useAsyncData('unique-key', async () => {\n  // 这里可以写任何复杂的异步逻辑\n  const [posts, users] = await Promise.all([\n    $fetch('/api/posts'),\n    $fetch('/api/users')\n  ])\n  \n  // 对数据进行转换\n  return {\n    posts: posts.map(post => ({ ...post, title: post.title.toUpperCase() })),\n    users\n  }\n})\n</script>\n```\n\n#### 2. 使用 `$fetch` 直接调用\nNuxt 3 内置了基于 [ofetch](https://github.com/unjs/ofetch) 的 `$fetch` 工具，可以在任何地方使用（如事件处理函数中）。\n\n```vue\n<script setup>\nconst handleSubmit = async () => {\n  try {\n    const response = await $fetch('/api/submit', {\n      method: 'POST',\n      body: { name: 'John Doe' }\n    })\n    console.log('Success:', response)\n  } catch (error) {\n    console.error('Error:', error)\n  }\n}\n</script>\n```\n\n#### 3. 使用 `useLazyFetch` / `useLazyAsyncData`\n它们是 `useFetch` 和 `useAsyncData` 的变体，`lazy: true` 是默认行为。**不会阻塞导航**，适用于非关键数据。\n\n```vue\n<script setup>\n// 不会阻塞路由导航，你需要自己处理 data 为 null 的情况\nconst { data: nonCriticalData } = useLazyFetch('/api/non-critical-data')\n</script>\n\n<template>\n  <div v-if=\"data\">\n    <!-- 渲染数据 -->\n  </div>\n</template>\n```\n\n### 二、最重要的注意事项\n#### 1. 服务端渲染 (SSR) vs 客户端渲染 (CSR) 行为\n这是 **最核心、最容易出错** 的点！\n\n+ **默认行为**：`useFetch` 和 `useAsyncData` **会在服务端执行**。这意味着：\n    - **好处**：返回的 HTML 直接包含数据，利于 SEO 和首屏加载。\n    - **陷阱**：**不能在它们内部或**** **`**created**`** ****生命周期中使用浏览器API**（如 `window`, `document`, `localStorage`）。\n+ **如何控制**：\n\n```javascript\n// 选项 1: 强制只在客户端执行\nconst { data } = useFetch('/api/data', { server: false })\n\n// 选项 2: 使用 useLazyFetch (默认不会阻塞导航，且在客户端执行)\nconst { data } = useLazyFetch('/api/data')\n\n// 选项 3: 在 onMounted 钩子中用 $fetch\nimport { onMounted } from 'vue'\nconst data = ref(null)\nonMounted(async () => {\n  data.value = await $fetch('/api/data')\n})\n```\n\n#### 2. 处理 CORS (跨域资源共享)\n如果你调用的接口不在同一个域下，会遇到 CORS 问题。\n\n+ **开发环境**：在 `nuxt.config.ts` 中配置代理是最佳实践。\n\n```typescript\n// nuxt.config.ts\nexport default defineNuxtConfig({\n  // ... 其他配置\n  nitro: {\n    routeRules: {\n      '/api/**': { proxy: 'https://api.example.com/**' }, // 代理 API 请求\n    },\n  },\n  // 或者使用旧的 devServer 配置 (v3.0+ 推荐使用 nitro)\n  // devServer: {\n  //   proxy: {\n  //     '/api': 'https://api.example.com'\n  //   }\n  // }\n})\n```\n\n+ 然后你在代码中请求 `/api/users`，开发服务器会将其代理到 `https://api.example.com/api/users`，避免 CORS。\n+ **生产环境**：\n    - **最佳方案**：配置你的**反向代理**（如 Nginx）来处理跨域请求。\n    - **备选方案**：确保后端 API 正确配置了 CORS 头 (`Access-Control-Allow-Origin` 等)。\n\n#### 3. 认证和令牌 (Authentication)\n如何安全地传递身份验证信息（如 JWT Token）。\n\n+ **使用请求拦截器**：利用 `ofetch` 的自动全局拦截器。\n+ 如何安全地传递身份验证信息（如 JWT Token）。\n\n```typescript\n// plugins/api.ts\nexport default defineNuxtPlugin(() => {\n  const { token } = useAuth() // 假设你有一个获取 token 的 composable\n\n  // 全局拦截 $fetch 请求\n  globalThis.$fetch = $fetch.create({\n    onRequest({ request, options }) {\n      // 添加认证头\n      if (token.value) {\n        options.headers = {\n          ...options.headers,\n          Authorization: `Bearer ${token.value}`\n        }\n      }\n    },\n    onRequestError({ error }) {\n      console.error('Request error:', error)\n    },\n    onResponseError({ response }) {\n      // 统一处理 401 未授权错误\n      if (response.status === 401) {\n        // 跳转到登录页\n        navigateTo('/login')\n      }\n    }\n  })\n})\n```\n\n#### 4. 错误处理\n永远不要假设请求一定会成功。\n\n+ **使用 try-catch**：\n\n```javascript\ntry {\n  const data = await $fetch('/api/endpoint')\n} catch (error) {\n  // Nuxt 3 的 $fetch 会自动抛出错误\n  console.error('API call failed:', error)\n  // 在这里显示用户友好的错误信息\n}\n```\n\n+ **使用 **`**useFetch**`** 的状态**：\n\n```vue\n<script setup>\nconst { data, error } = useFetch('/api/endpoint')\n</script>\n\n<template>\n  <div v-if=\"error\">\n    Failed to load data: {{ error.message }}\n    <button @click=\"refresh\">Try Again</button>\n  </div>\n</template>\n```\n\n#### 5. 性能优化：避免重复请求\n+ **Key 的妙用**：`useAsyncData` 和 `useFetch` 会**自动去重**具有相同 key 的请求。确保为唯一的数据集提供唯一的 key。\n\n```javascript\n// 如果两个组件使用相同的 key，只会发出一个请求\nconst { data } = useAsyncData('user-profile', () => $fetch('/api/profile'))\n```\n\n+ **缓存**：`$fetch` 默认不会缓存 HTTP 缓存。如果你需要利用 HTTP 缓存，可以在 headers 中设置，或者使用更高级的缓存策略。\n\n---\n\n### 三、最佳实践总结\n1. **首选**** **`**useFetch**`**/**`**useAsyncData**`：用于在组件中获取数据，它们能智能处理 SSR 和 hydration。\n2. **明确数据获取时机**：想清楚你需要的数**据是应该在服务端获取（SEO 关键）还是客户端获取（用户相关）**，并用 `server: false` 或 `useLazyFetch` 控制。\n3. **开发环境用代理解决 CORS**：在 `nuxt.config.ts` 中配置代理，避免跨域问题。\n4. **统一处理认证和错误**：通过插件创建配置好的 `$fetch` 实例，全局处理 token 和错误。\n5. **善待你的 API**：合理使用 key 去重，避免重复请求；考虑分页、限流和缓存。\n\n遵循这些指南，你就能在 Nuxt 应用中高效、可靠地与后端 API 进行交互。\n\n## 开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\n**你这个问题问得非常好，直击要害！你的理解完全正确。**\n\n是的，你的推理是精准的：\n\n+ **服务端（Node.js）发起的请求**：没有跨域概念。跨域是**浏览器**强加的安全策略。Node.js 发请求就像你用 `curl` 或 Postman 一样，可以去任何地方，不存在 CORS 问题。\n+ **客户端（浏览器）发起的请求**：受跨域限制。浏览器会拦截违反同源策略的请求。\n\n**因此，“开发环境配置代理” 主要就是为了解决 —— 在客户端发起请求时遇到的跨域问题。**\n\n---\n\n### 为什么开发环境会有客户端请求？\n在 Nuxt 3 的 SSR 模式下，一个页面渲染通常涉及**两次**数据获取：\n\n1. **第一次（服务端请求 - 无 CORS）**：\n    - 当用户直接访问页面 URL 时，请求会先到达你的 Nuxt 服务器。\n    - Nuxt 服务器执行 `useFetch` 或 `useAsyncData`，**在服务器环境**（Node.js）中向后端 API 发起请求。\n    - 此时是 **服务器对服务器** 的通信，没有浏览器参与，所以**没有 CORS 问题**。\n    - 服务器拿到数据后，渲染出包含内容的 HTML 并返回给浏览器。\n2. **第二次（客户端请求 - 有 CORS 风险）**：\n    - 浏览器收到 HTML 并展示后，会加载 Nuxt 的客户端 JS Bundle。\n    - Vue 开始 **“激活” (Hydration)** 过程。\n    - 在这个过程中，`useFetch` 和 `useAsyncData` 的代码会在**客户端浏览器环境**中再次运行，以确保数据状态一致。\n    - 如果它们的 URL 是**绝对路径**（如 `https://api.example.com/data`），那么这次请求就是由**浏览器**直接发起的，就会触发 CORS 检查。\n    - 如果后端 API 没有正确配置 CORS 头，浏览器就会拦截这次请求，导致错误。\n\n此外，还有几种常见的**纯客户端请求**场景：\n\n+ 用户交互（如点击按钮）触发的 `$fetch` 请求。\n+ 在 `onMounted` 钩子中发起的请求。\n+ 使用 `useLazyFetch`（它默认在客户端执行）。\n\n### 总结与最佳实践\n| 场景 | 请求发起方 | 是否有 CORS 问题？ | 解决方案 |\n| --- | --- | --- | --- |\n| **SSR 首屏渲染** | Nuxt Server (Node.js) | **否** | 无需额外配置。但需确保服务器能访问到 API（网络连通性）。 |\n| **CSR Hydration/交互** | 浏览器 | **是** | **配置开发服务器代理**（如下方代码）。这是最推荐的方法。 |\n| **生产环境** | 浏览器 | **是** | **配置生产级反向代理**（如 Nginx），或确保后端 API 正确设置 CORS 头。 |\n\n\n## nuxt中的$fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\n非常好的问题！这是理解 Nuxt 3 数据获取的关键。它们的执行环境行为是核心区别。\n\n简单直接的答案是：**不，**`**$fetch**`** ****可以在服务端和客户端调用。而**** **`**useFetch**`** ****和**** **`**useAsyncData**`** ****的行为是智能的，默认在服务端执行。**\n\n下面我们来详细拆解这三者的区别。\n\n---\n\n### 一、`$fetch`：双环境通用的请求工具\n`$fetch` 是 Nuxt 3 基于 [ofetch](https://github.com/unjs/ofetch) 提供的全局工具函数。它本身**没有环境限制**，你在哪里调用它，它就在哪个环境执行。\n\n+ **在服务端（Node.js）调用**：它就像一个普通的 Node.js HTTP 客户端（比如 `axios`），直接向后端发起请求，**没有跨域概念**。\n+ **在客户端（浏览器）调用**：它的行为类似于原生的 `fetch()`，但功能更强大（自动处理 JSON、更好的错误处理等），并且**受浏览器跨域策略限制**。\n\n**示例：**\n\n```javascript\n// 1. 在组件 setup 中直接调用 - 根据渲染环境决定\n// 如果在服务端渲染，它在服务端执行；如果在客户端激活或导航，它在客户端执行。\nconst data = await $fetch('/api/items');\n\n// 2. 在明确的服务端环境调用 - 只在服务端执行\n// 例如：在 API 路由、服务器中间件或 plugin 中\nexport default defineEventHandler(async (event) => {\n  const data = await $fetch('https://external-api.com/data'); // 在服务器上运行\n  return { data };\n});\n\n// 3. 在明确的客户端环境调用 - 只在客户端执行\n// 例如：在事件处理函数或 onMounted 中\nconst handleClick = async () => {\n  const data = await $fetch('/api/items'); // 在浏览器中运行，受 CORS 限制\n};\n```\n\n`**$fetch**`** ****的陷阱**：如果你在组件顶层直接使用 `$fetch`（没有包裹在 `useAsyncData` 或 `useFetch` 中），并且该组件在服务端渲染，那么请求会在服务端执行。但当客户端激活（Hydration）时，**同样的**** **`**$fetch**`** ****代码又会在客户端再执行一次**，造成重复请求。\n\n---\n\n### 二、`useAsyncData` & `useFetch`：智能的双环境数据获取器\n这两个组合函数是 Nuxt 数据获取的“智能大脑”。它们的关键特性是：**“在服务端预取数据，并自动将数据序列化到客户端，避免重复请求”**。\n\n#### 核心行为：\n1. **默认在服务端执行**：在 SSR 模式下，当页面首次加载时，它们会在 Nuxt 服务器内部执行，获取数据并直接将数据嵌入到最终返回的 HTML 中。\n2. **在客户端激活**：当 Vue 在客户端“激活”静态页面时，`useAsyncData` 和 `useFetch` 会识别到数据已经存在于从服务器传递过来的 payload 中，因此**不会在客户端再次发起请求**，而是直接使用已有的数据。\n3. **后续导航**：当你在客户端通过导航跳转到另一个也使用了这些函数的页面时，它们会在**客户端**执行。\n\n#### 如何控制执行环境？\n它们提供了一个 `server` 选项让你精确控制：\n\n```javascript\n// 默认：true - 在服务端执行（SSR 首屏）\nconst { data } = useFetch('/api/items');\n\n// 强制在客户端执行（CSR）\n// 适合：用户相关的数据、不需要 SEO 的数据、访问浏览器 API 的数据\nconst { data } = useFetch('/api/user-data', {\n  server: false\n});\n\n// useAsyncData 用法相同\nconst { data } = useAsyncData('user-key', () => $fetch('/api/user'), {\n  server: false\n});\n```\n\n### 三、三者的对比总结\n为了更直观地理解，下面的流程图展示了不同调用方式在 Nuxt 应用生命周期中的执行时机和数据流向：\n\n这个图清晰地展示了：\n\n1. `**useFetch**`**/**`**useAsyncData**` 是贯穿服务端和客户端的“智能通道”，保证了数据的高效同步和无重复请求。\n2. **直接使用**** **`**$fetch**` 在组件顶层会导致重复请求，是需要避免的反模式。\n3. **在事件中使用的**** **`**$fetch**` 是纯客户端行为。\n\n### 最佳实践与选择指南\n| 场景 | 推荐使用的工具 | 原因 |\n| --- | --- | --- |\n| **获取页面组件所需数据** | `**useFetch**`<br/>** ****或**** **`**useAsyncData**` | 自动处理 SSR/CSR，避免重复请求，数据序列化到客户端。 |\n| **在事件处理、**`**onMounted**`<br/>** ****中获取数据** | `**$fetch**` | 明确需要在客户端触发的请求。 |\n| **在 API 路由或服务器中间件中** | `**$fetch**` | 明确的服务端环境，无需 `useAsyncData`<br/> 的额外功能。 |\n| **需要复杂的数据获取逻辑** | `**useAsyncData**`<br/>** ****+**** **`**$fetch**` | `useAsyncData`<br/> 提供状态管理，内部函数可使用 `$fetch`<br/> 进行复杂操作。 |\n| **简单的 URL 请求** | `**useFetch**` | 最简洁的写法。 |\n\n\n**一句话总结：**\n\n+ **用**** **`**useFetch**`**/**`**useAsyncData**` 来获取**组件初始化时所需的数据**，让 Nuxt 智能决定执行环境。\n+ **用**** **`**$fetch**` 在**明确的客户端交互**或**明确的服务端环境**中主动发起请求。\n\n遵循这个原则，你就能高效且正确地在 Nuxt 应用中处理数据获取。\n\n## 激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\n这些问题触及了 Nuxt.js SSR 的核心魔法。好消息是，**这个过程绝大部分是自动化的，开发者几乎不需要手动干预**。Nuxt 和 Vue 底层已经为你处理好了一切。\n\n下面我来逐一解答你的问题，你会看到 Nuxt 的设计是多么巧妙。\n\n---\n\n### 一、激活客户端需要开发手动调用什么 API 吗？\n**答：完全不需要。这是 Vue 和 Nuxt 自动完成的。**\n\n这个过程称为 **Hydration（混合）**。它的流程是：\n\n1. **自动执行**：当浏览器加载完 Nuxt 发送过来的 HTML 和客户端 JavaScript 包后，Vue 会自动启动。\n2. **自动匹配**：Vue 会将它的虚拟 DOM 与服务器渲染好的、已经存在的静态 HTML 结构进行对比和匹配。\n3. **自动“激活”**：Vue 不会重新创建 DOM 元素，而是会将事件监听器、响应式数据系统等“附加”到这些现有的 DOM 元素上，使静态页面瞬间变为一个完全交互式的 Vue 应用。\n\n**作为开发者，你唯一要做的就是：**\n\n+ 确保你的代码是**同构的**（即同一份代码既能在 Node.js 环境运行，也能在浏览器环境运行）。\n+ 避免在 `created` 或 `setup` 等生命周期中使用浏览器特有的 API（如 `window`, `document`），或者使用 `onMounted`（仅在客户端执行）来包裹它们。\n\n**你不用写任何像**** **`**app.hydrate()**`** ****这样的代码，一切都是开箱即用、自动发生的。**\n\n---\n\n### 二、服务端异步获取的数据注入到 HTML 这一步开发需要做什么？\n**答：你只需要使用正确的 API（**`**useAsyncData**`** ****或**** **`**useFetch**`**），Nuxt 就会自动完成注入。**\n\n这个“注入”过程在 Nuxt 中被称为 **State Serialization（状态序列化）** 或 ** dehydration（脱水）**。\n\n**你的工作（非常简单）：**\n\n1. **使用 **`**useAsyncData**`** 或 **`**useFetch**`：在你的页面组件中，用它们来获取数据。\n\n```vue\n<script setup>\n  // pages/posts.vue\n  const { data: posts } = await useFetch('/api/posts')\n</script>\n```\n\n2. **Nuxt 自动完成后续所有事情**：\n    - Nuxt 在服务端执行完 `useFetch` 后，会**自动**将 `posts` 数据序列化为 JSON 字符串。\n    - 将这个 JSON 字符串**自动嵌入**到最终 HTML 的 `<head>` 部分的一个 `<script>` 标签中。\n    - 这个标签的内容通常是 `window.__NUXT__ = { ... }`，其中就包含了所有页面的预取数据。\n\n**你不需要手动操作 DOM 去注入数据，Nuxt 的渲染引擎为你包办了一切。**\n\n---\n\n### 三、到客户端时如何获取数据呢？\n**答：客户端 Vue 应用会自动从**** **`**window.__NUXT__**`** ****中提取并复用数据，无需再次请求。**\n\n这个过程是 **State Deserialization（状态反序列化）** 或 **rehydration（补水）**。\n\n**它的自动流程如下：**\n\n1. **数据随 HTML 到达浏览器**：HTML 中的 `<script>window.__NUXT__ = {...}</script>` 会先被执行，将数据挂载到全局对象上。\n2. **客户端 Vue 应用启动**：客户端的 JavaScript 包加载完毕后，Vue 和 Nuxt 开始初始化。\n3. **自动提取数据**：当客户端的 `useFetch('/api/posts')` 代码执行时，它不会真正去发起网络请求，而是会**先自动去**** **`**window.__NUXT__**`** ****对象里查找**，看是否存在服务端已经为它准备好的数据。\n4. **直接复用数据**：如果找到了，它就直接使用这份数据，完全跳过网络请求。这样就保证了客户端和服务端的数据状态**绝对一致**，这也是 Hydration 能成功的前提。\n\n**你可以通过 **`**useNuxtData**`** 这个工具函数来验证和访问这些被缓存的数据：**\n\n```vue\n<script setup>\n// 在客户端，你可以这样访问之前服务端获取的、被缓存的数据\nconst { data: posts } = useNuxtData('posts') // 使用 useFetch 时自动生成的 key\n\n// 这不会导致第二次请求，它只是从客户端缓存中读取\nconsole.log(posts.value)\n</script>\n```\n\n## 服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\n**你这个问题问得非常非常关键，切中了SSR安全的核心！你的直觉完全正确。**\n\n**绝对不应该将任何敏感信息（如用户凭证、Token、个人身份信息PII等）内联到HTML的**** **`**<script>**`** ****标签中，并通过**** **`**window.__NUXT__**`** ****暴露给客户端。**\n\n这样做会带来严重的安全风险：\n\n1. **数据泄露**：任何能打开浏览器开发者工具的人，都可以直接看到 `window.__NUXT__` 里的全部内容。\n2. **XSS攻击加剧**：如果你的应用存在XSS（跨站脚本）漏洞，攻击者可以更容易地编写脚本窃取 `window.__NUXT__` 中的所有数据，而不必费力去窃取多个API请求的返回结果。\n3. **缓存风险**：HTML页面可能会被CDN、代理服务器或浏览器缓存。如果其中包含了用户敏感信息，就意味着这些信息也可能被缓存并泄露给其他用户。\n\n---\n\n### 那么，如何处理需要认证的敏感数据？\n正确的做法是将敏感数据与非敏感数据**分离**，并遵循“**按需索取**”和“**最小化暴露**”的原则。以下是几种安全策略：\n\n#### 策略一：敏感数据绝不预取，仅在客户端获取\n这是最常用、最安全的策略。用户登录状态、个人资料等高度敏感的数据，**不应该**在服务端的 `useFetch`/`useAsyncData` 中获取。\n\n```vue\n<script setup>\n// 1. 非敏感、SEO需要的数据：在服务端预取（安全）\nconst { data: publicPosts } = await useFetch('/api/public-posts')\n\n// 2. 敏感的用户数据：不在服务端预取，只在客户端获取\nconst user = ref(null)\nconst token = useCookie('auth-token') // Token应存放在HttpOnly Cookie中\n\n// 在客户端挂载后，再安全地获取用户数据\nonMounted(async () => {\n  if (token.value) {\n    // 此请求在客户端发起，携带Cookie中的token\n    user.value = await $fetch('/api/me', {\n      headers: {\n        // 通常Token会自动通过Cookie发送，无需手动设置，这里演示逻辑\n        Authorization: `Bearer ${token.value}`\n      }\n    })\n  }\n})\n</script>\n\n<template>\n  <!-- 公开数据直接渲染 -->\n  <div v-for=\"post in publicPosts\" :key=\"post.id\">{{ post.title }}</div>\n  \n  <!-- 用户数据，等客户端获取后再显示 -->\n  <div v-if=\"user\">Welcome, {{ user.name }}</div>\n</template>\n```\n\n#### 策略二：使用 `useState` 进行状态管理，区分服务端与客户端状态\n你可以利用 `useState` 的灵活性来管理不同环境的状态。\n\n```vue\n<script setup>\n// 创建一个响应式状态，服务端先初始化为 null\nconst secretData = useState('secret-data', () => null)\n\n// 在客户端再获取真实数据\nonMounted(async () => {\n  if (!secretData.value) { // 避免在服务端执行\n    secretData.value = await $fetch('/api/secret-data')\n  }\n})\n</script>\n```\n\n#### 策略三：API 设计分离 - 提供公开和私密端点\n从后端设计上就进行分离：\n\n+ `/api/public/data`：返回不敏感的数据，可以安全地在服务端渲染。\n+ `/api/private/user-data`：返回敏感数据，必须认证且在客户端获取。\n\n---\n\n### Nuxt 如何安全地处理认证？\n认证的最佳实践是使用 **HttpOnly Cookies** 来传输令牌（Token），而不是通过 `window.__NUXT__` 或 JS 可读的 Cookie。\n\n1. **登录流程**：\n    - 用户提交登录表单，客户端 `$fetch` 发送到 `/api/auth/login`。\n    - **后端**验证成功后，设置一个 **HttpOnly、Secure、SameSite=Strict** 的 Cookie（包含认证Token）。这个 Cookie 对 JavaScript 不可见，极大地增强了安全性。\n    - 前端只需知道登录成功，无需接触 Token 本身。\n2. **获取用户数据**：\n    - 在客户端，调用 `$fetch('/api/me')`。\n    - 浏览器会**自动**在请求中带上 HttpOnly Cookie。\n    - 后端验证 Cookie 中的 Token 有效性后，返回对应用户的数据。\n3. **服务端渲染中的认证**：\n    - 如果服务端需要根据用户状态渲染不同内容（例如“您好，用户名”），可以通过**服务器中间件**或 **API 路由**来处理。\n    - 服务端可以读取请求中的 Cookie，去后端验证用户身份，然后决定返回什么数据。但这个验证过程发生在后端，结果信息需要是**非敏感**的（例如只返回 `username`，而不是返回 `token` 或 `email`）。\n\n```vue\n<script setup>\n// 服务端可以安全地读取Cookie并获取非敏感的用户显示信息\nconst { data: userInfo } = await useFetch('/api/user-display-info')\n// 这个 `/api/user-display-info` 接口在后端会验证Cookie，\n// 但只返回 { name: 'John' } 这样的非敏感信息用于界面显示。\n</script>\n```\n\n### 总结\n1. **核心原则**：**绝不将敏感数据内联到 HTML 中**。`window.__NUXT__` 应该是“公开的”或“非敏感的”。\n2. **数据分离**：将数据分为“公开”和“私密”两类。公开数据用 `useFetch` 服务端预取；私密数据在客户端用 `$fetch` 按需获取。\n3. **认证最佳实践**：使用 **HttpOnly Cookies** 来安全地传输认证凭证，而不是将其暴露给客户端 JavaScript 或 `window` 对象。\n4. **信任后端**：敏感的权限检查和数据处理逻辑应该始终放在后端 API 中。前端（包括SSR服务端）只负责展示非敏感的结果。\n\n你的安全意识非常到位，遵循这些原则可以让你构建出既高效又安全的 Nuxt.js 应用。\n\n## 除此之外，服务端渲染还有什么不能实现的呢？canvas？\n说得非常对！**Canvas** 是一个绝佳的例子，它完美地揭示了服务端渲染（SSR）的“盲区”。\n\nSSR 的核心是**生成静态的 HTML 和 CSS 字符串**。因此，任何**动态的、依赖于浏览器 JavaScript 运行时环境**的功能，在纯 SSR 阶段都无法实现或功能不全。\n\n除了 Canvas，还有很多类似的限制。我们可以将它们分为几大类：\n\n---\n\n### 一、浏览器特有的 API 和全局对象\n这是最直接的一类。在 Node.js 服务器环境中，根本没有 `window`, `document`, `navigator` 等对象。\n\n| API/功能 | 原因 | 解决方案 |\n| --- | --- | --- |\n| `**window**`**、**`**document**` | Node.js 中不存在。 | 使用 `onMounted`钩子或 `clientOnly`组件确保只在客户端访问。 |\n| `**alert**`**、**`**confirm**`**、**`**prompt**` | 浏览器交互对话框。 | 逻辑移至客户端，或使用基于组件的替代品（如模态框）。 |\n| **Canvas (**`**<canvas>**`**) / WebGL** | 需要浏览器渲染上下文来绘图和操作像素。 | **只能在客户端初始化和使用**。SSR 只能渲染一个空画布。 |\n| **地理位置 (**`**navigator.geolocation**`**)** | 需要用户的浏览器授权和设备硬件支持。 | 仅在客户端通过 `onMounted`或用户交互触发。 |\n| **本地存储 (**`**localStorage**`**, **`**sessionStorage**`**, **`**IndexedDB**`**)** | 是浏览器的持久化存储机制。 | 在 `onMounted`中访问，或使用 `useLocalStorage`等组合式函数（内部做了客户端检查）。 |\n| **媒体设备 (**`**navigator.mediaDevices**`**)** | 需要访问麦克风、摄像头等硬件。 | 完全的用户客户端行为。 |\n\n\n---\n\n### 二、依赖浏览器渲染或布局的功能\n这类功能需要知道元素的真实尺寸和位置，而这些信息在纯字符串的 SSR 阶段是无法获得的。\n\n| 功能 | 原因 | 解决方案 |\n| --- | --- | --- |\n| **元素尺寸/位置** (如 `element.offsetWidth`<br/>, `getBoundingClientRect()`<br/>) | SSR 只有 HTML 字符串，没有真实的布局和渲染。 | 在 `onMounted`<br/> 后使用，或使用 Vue 的 `nextTick`<br/> 确保 DOM 已更新。 |\n| **基于尺寸的渲染** (如图表库 ECharts、D3.js) | 需要挂载到真实 DOM 元素并获取其宽高才能渲染。 | 在 `onMounted`<br/> 中初始化图表实例。 |\n| **动画 (CSS 动画除外)** | 许多 JS 动画库需要操作 DOM 样式。 | 使用 `onMounted`<br/> 启动动画，或使用 CSS 动画（SSR 支持）。 |\n\n\n---\n\n### 三、用户交互和状态\nSSR 输出的是一个“快照”，无法预知用户未来的行为。\n\n| 功能 | 原因 | 解决方案 |\n| --- | --- | --- |\n| **用户输入** (表单输入、焦点状态) | SSR 无法预知用户会输入什么。 | SSR 可以渲染表单结构，但交互和值绑定必须在客户端完成。 |\n| **鼠标事件、键盘事件** | 纯静态环境，无用户交互。 | 完全由客户端 JavaScript 处理。 |\n| **浏览器标签页可见性** (`document.visibilityState`) | 依赖于用户当前的浏览器状态。 | 纯客户端逻辑。 |\n\n\n---\n\n### 四、第三方库\n许多强大的第三方库在设计时就是为浏览器而生的。\n\n| 库类型 | 问题 | 解决方案 |\n| --- | --- | --- |\n| **地图库** (如 Leaflet, Google Maps) | 需要挂载到 DOM 并初始化地图渲染上下文。 | 使用 `onMounted`<br/> 初始化，或使用 Nuxt 模块（如 `nuxt-leaflet`<br/>）。 |\n| **可视化库** (如 D3, Three.js) | 严重依赖 Canvas、WebGL 或 SVG 操作。 | **只能在客户端运行**。 |\n| **分析/广告库** (如 Google Analytics) | 依赖 `window`<br/> 对象和浏览器环境来跟踪用户。 | 使用 Nuxt 插件（`client: true`<br/> 选项）或直接在 `onMounted`<br/> 中加载。 |\n\n\n---\n\n### 如何安全地处理这些限制？Nuxt 提供的解决方案\nNuxt 提供了一系列模式来优雅地解决这些问题：\n\n#### 1. `onMounted` 钩子 (最常用)\n确保代码只在客户端执行。\n\n```vue\n<script setup>\nimport { onMounted } from 'vue'\n\nconst canvas = ref(null)\n\nonMounted(() => {\n  // 现在可以安全地访问 DOM 和浏览器 API 了\n  const ctx = canvas.value.getContext('2d')\n  ctx.fillStyle = 'green'\n  ctx.fillRect(10, 10, 150, 100)\n})\n</script>\n\n<template>\n  <!-- SSR 会渲染一个空画布 -->\n  <canvas ref=\"canvas\" width=\"200\" height=\"200\"></canvas>\n</template>\n```\n\n#### 2. 条件渲染与 `<ClientOnly>` 组件\n防止不支持 SSR 的组件在服务器端渲染时出错。\n\n```vue\n<template>\n  <!-- 默认插槽只在客户端渲染 -->\n  <ClientOnly>\n    <MyChartThatUsesWindow />\n    <!-- 可以设置回退内容，在SSR阶段显示 -->\n    <template #fallback>\n      <div>Loading chart...</div>\n    </template>\n  </ClientOnly>\n</template>\n```\n\n#### 3. 使用 `process.client` 标志进行运行时检查\n```vue\n<script setup>\nif (process.client) {\n  // 此代码块只在客户端打包时包含，并在客户端执行\n  console.log('I am on the client!', window.innerWidth)\n}\n</script>\n```\n\n#### 4. 为第三方库创建客户端插件\n```javascript\n// plugins/analytics.client.js - 注意 .client 后缀\nexport default defineNuxtPlugin(() => {\n  // 这个插件只会在客户端运行\n  window.dataLayer = window.dataLayer || []\n  function gtag(){ dataLayer.push(arguments) }\n  gtag('js', new Date())\n  gtag('config', 'GA_MEASUREMENT_ID')\n})\n```\n\n### 总结\n服务端渲染 (SSR) 的本质是**静态化**，它擅长的是：\n\n+ **生成初始 HTML 内容**\n+ **提供更好的 SEO**\n+ **提升首屏加载性能**\n\n而**动态交互**和**浏览器依赖**永远是 SSR 的盲区，必须交给客户端处理。\n\n**因此，一个成熟的 Nuxt 应用是两者结合的“混合体”：**\n\n1. **服务端**：生成静态结构和首屏内容。\n2. **客户端**：“激活”页面，接管所有交互，并加载那些依赖浏览器环境的动态功能。\n\n你的工作就是清晰地界定哪些逻辑属于服务端，哪些属于客户端，并使用 Nuxt 提供的模式（`onMounted`, `<ClientOnly>`, `.client` 插件）将它们优雅地结合起来。\n\n## nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\n这是一个非常好的问题，它触及了 Nuxt 全栈架构的核心优势。\n\n**简单而直接的答案是：不会。在客户端激活后，向同源的 Nuxt 中间件或 API 路由发起请求，绝对不会产生跨域问题。**\n\n这是因为你发起请求的目标和你的页面来源是**完全同源的**。\n\n---\n\n### 为什么不会跨域？—— 同源策略详解\n让我们回顾一下“同源策略”：当协议、域名、端口都相同时，即为同源，浏览器允许请求。\n\n假设你的 Nuxt 应用部署在：  \n`https://www.my-app.com`\n\n1. **你的页面来源**：  \n浏览器中显示的地址是：`https://www.my-app.com/some-page`\n2. **你请求的目标**：  \n你在代码中发起的请求是：\n\n```javascript\n// 使用相对路径，目标自动补全为：https://www.my-app.com/api/hello\nawait $fetch('/api/hello');\n\n// 或者使用 useFetch（同样基于相对路径）\nconst { data } = useFetch('/api/auth/user');\n```\n\n3. **对比**：\n    - **协议**：都是 `https`\n    - **域名**：都是 `www.my-app.com`\n    - **端口**：都是 `443` (HTTPS 默认端口)\n\n**结论**：**完全同源**，浏览器欣然放行，没有任何跨域限制。\n\n---\n\n### Nuxt 如何处理这些请求？—— 请求生命周期\n理解这个过程能让你更清楚为什么这是安全的：\n\n如图所示，无论是开发还是生产环境，**你的 API 请求和前端页面都由同一个主机处理**。它们处于同一个“生态系统”内，通信是内部的、安全的，不存在跨域问题。\n\n---\n\n### 什么情况下会有跨域问题？\n只有当你的**页面来源**和**请求目标**不同源时，才会触发跨域。例如：\n\n| 你的页面在 | 你请求的目标 | 是否跨域 | 原因 |\n| --- | --- | --- | --- |\n| `https://www.my-app.com` | `https://www.my-app.com/api/hello` | **否** | 同源 |\n| `https://www.my-app.com` | `https://api.my-app.com` | **是** | 子域名不同 (`www` vs `api`) |\n| `http://localhost:3000` | `https://api.third-party.com` | **是** | 完全不同的域名 |\n| `https://www.my-app.com` | `http://www.my-app.com/api/hello` | **是** | 协议不同 (`https`vs `http`) |\n\n\n**对于最后一种情况（生产环境前后端分离），解决方案是：**\n\n1. **后端配置 CORS**：在你的 `api.my-app.com` 服务器上设置 `Access-Control-Allow-Origin: https://www.my-app.com` 响应头。\n2. **使用反向代理**：配置你的生产服务器（如 Nginx），将对 `/api/` 的请求代理到 `api.my-app.com`，让浏览器始终觉得是在请求同源地址。这是更推荐的做法。\n\n### 总结\n+ **在 Nuxt 应用中，请求自身的 API 路由 (**`**/api/xxx**`**) 或服务器中间件是绝对同源的，没有跨域问题。**\n+ 这是 Nuxt 全栈框架的巨大优势之一，它简化了开发，让你无需在开发阶段为 CORS 烦恼。\n+ 跨域问题只会在你请求**外部第三方 API** 且对方未正确配置 CORS 时出现。\n+ 如果你的生产环境是前后端完全分离的（不同域），那么需要在生产环境的**后端配置 CORS** 或通过**反向代理**来解决。\n\n所以，请放心地在你的 Nuxt 应用内部调用 API，这是最安全、最正确的做法。\n\n## 那如果对后端接口(另一台服务器上)的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\n**你的这个思路非常棒，完全正确！** 这正是构建现代 Web 应用的一种核心架构模式，被称为 **“BFF（Backend For Frontend）模式”** 或 **“API 网关模式”**。\n\n你的推理链条是：\n\n1. **所有客户端请求**都只发往**同源**的 Nuxt 服务器（`/api/proxy`）。\n2. Nuxt 服务器上的**中间件**接收到请求后，**代为转发**给真正的后端服务器。\n3. 由于服务器之间通信（Nuxt Server -> Your Backend Server）**没有跨域限制**，所以问题迎刃而解。\n\n这个方案**在理论上是完全可行且非常优雅的**，它确实可以让你**完全摆脱 CORS 的困扰**。\n\n---\n\n### 这种架构的详细工作流程\n如图所示，浏览器始终只与 `my-nuxt-app.com` 通信，完美符合同源策略。\n\n---\n\n### 优缺点分析：这是否是“万能药”？\n虽然这个方案能根治跨域，但它也引入了一些新的考虑因素：\n\n#### 优点 ✅\n1. **彻底解决 CORS**：前端开发者完全无需再关心跨域配置，开发体验极其流畅。\n2. **隐藏后端架构**：真正的后端地址、端口、API 结构对客户端完全隐藏，更安全。\n3. **协议转换**：可以轻松地在 Nuxt 中处理 HTTPS -> HTTP 的请求（服务器间通信允许）。\n4. **数据处理与聚合**：你可以在 Nuxt 中间件中对多个后端服务的返回值进行聚合、过滤、转换，为前端提供最合适的数据结构，减少前端请求次数。\n\n#### 缺点与需要考虑的因素 ⚠️\n1. **额外的网络跳转**：所有请求都多经过一环（浏览器 -> Nuxt -> 真实后端），**会增加微小的延迟**。对于延迟敏感的应用需要优化。\n2. **单点压力与故障点**：Nuxt 服务器现在成为了所有 API 流量的入口。如果它宕机，所有请求都会失败。需要保证其高可用性。\n3. **复杂性转移**：虽然前端变简单了，但 Nuxt 层（BFF 层）的逻辑变复杂了。你需要在这里编写转发、错误处理、认证等逻辑。\n4. **认证问题**：如果后端 API 需要认证，你需要决定如何传递认证信息。\n    - **方案A（推荐）**：浏览器将认证 Token 发给 Nuxt，Nuxt 再原样转发给后端。\n    - **方案B**：Nuxt 服务器自己持有访问后端的凭证，替用户与后端通信。但这需要非常小心地管理权限。\n\n---\n\n### 如何实现？\n在 Nuxt 中，你通常使用 **API 路由** 或 **服务器中间件** 来实现，而不是普通的中间件，因为它们专门处理服务器逻辑。\n\n**示例：在 **`**server/api/proxy/[...].ts**`** 中创建一个捕获所有路由的 API**\n\n```typescript\n// server/api/proxy/[...].ts\nexport default defineEventHandler(async (event) => {\n  // 1. 获取请求路径和方法\n  const path = getRouterParam(event, 'path') // 获取 ... 通配符参数\n  const method = getMethod(event)\n  const body = method === 'GET' ? undefined : await readBody(event)\n\n  // 2. 定义你的真实后端基础 URL（应从环境变量读取！）\n  const baseURL = 'https://your-real-backend.com/api'\n  const targetURL = `${baseURL}/${path}`\n\n  // 3. 可选：处理认证（例如，将前端传来的 token 转发给后端）\n  const headers = {}\n  const authHeader = getHeader(event, 'authorization')\n  if (authHeader) {\n    headers['Authorization'] = authHeader\n  }\n\n  // 4. 代理请求到真实后端\n  try {\n    const response = await $fetch.raw(targetURL, {\n      method,\n      body,\n      headers,\n      // 重要：转发查询参数 (?foo=bar)\n      query: getQuery(event),\n    })\n\n    // 5. 可选：根据需要设置响应头\n    setHeaders(event, response.headers)\n\n    // 6. 返回后端响应的数据\n    return response._data\n  } catch (error) {\n    // 7. 错误处理，将后端错误返回给前端\n    throw createError({\n      statusCode: error.statusCode || 500,\n      statusMessage: error.statusMessage || 'Internal Server Error',\n    })\n  }\n})\n```\n\n这样，前端所有发往 `/api/proxy/items`、`/api/proxy/user/profile` 的请求，都会被这个 handler 捕获，并转发到 `https://your-real-backend.com/api/items` 和 `https://your-real-backend.com/api/user/profile`。\n\n### 结论\n**是的，你的想法是完全正确且高效的。通过让 Nuxt 服务器作为所有后端请求的代理，你可以一劳永逸地解决跨域问题，无需在开发或生产环境配置任何 CORS 或代理规则。**\n\n这不仅是解决跨域的手段，更是一种先进的**架构设计选择**（BFF）。它特别适用于：\n\n+ 中大型前后端分离项目。\n+ 需要集成多个后端微服务的复杂前端。\n+ 希望简化前端开发流程，将复杂性集中到 BFF 层的团队。\n\n你只需要评估其带来的**额外延迟**和**单点压力**是否在你的应用可接受范围内即可。对于绝大多数应用来说，这个方案的利远大于弊。\n\n","slug":"Nuxt.js","published":1,"updated":"2025-09-14T13:36:42.793Z","_id":"cmfjk7nik0000d65w4wct3bto","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"Nuxt-js的ssr服务端渲染原理\"><a href=\"#Nuxt-js的ssr服务端渲染原理\" class=\"headerlink\" title=\"Nuxt.js的ssr服务端渲染原理\"></a>Nuxt.js的ssr服务端渲染原理</h2><p>Nuxt.js 的 SSR（服务端渲染）原理是一个非常核心且有趣的话题。它并不是简单的“在服务器上跑 Vue”，而是一套完整的、精心设计的架构。</p>\n<p>简单来说，它的核心原理是：<strong>“首屏在服务器提前渲染成 HTML，之后在客户端‘激活’为 SPA”。</strong></p>\n<p>下面我们分步拆解这个过程的原理、优势和关键实现。</p>\n<hr>\n<h3 id=\"一、核心目标：解决什么問題？\"><a href=\"#一、核心目标：解决什么問題？\" class=\"headerlink\" title=\"一、核心目标：解决什么問題？\"></a>一、核心目标：解决什么問題？</h3><ol>\n<li><strong>SEO（搜索引擎优化）</strong>：传统 SPA（单页应用）返回的是一个空的 HTML 壳，内容由 JavaScript 动态填充。搜索引擎爬虫可能无法等待和执行 JS，导致无法收录内容。SSR 直接返回渲染好的完整 HTML，利于爬虫抓取。</li>\n<li><strong>更快的内容到达时间</strong>：用户浏览器无需等待所有 JavaScript 下载和执行完毕才能看到内容。服务器直接返回了渲染好的 HTML，首屏内容可以立即展示，感知性能极大提升。</li>\n</ol>\n<h3 id=\"二、Nuxt-js-SSR-的核心工作流程\"><a href=\"#二、Nuxt-js-SSR-的核心工作流程\" class=\"headerlink\" title=\"二、Nuxt.js SSR 的核心工作流程\"></a>二、Nuxt.js SSR 的核心工作流程</h3><p>Nuxt.js 的 SSR 过程可以清晰地分为两个阶段：<strong>服务端渲染</strong>和<strong>客户端激活</strong>。下图展示了从用户请求到页面可交互的完整生命周期：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/nuxt核心工作流.png\"\n                      alt=\"nuxt核心工作流\" width=\"60%\" height=\"auto\" style=\"display:block;\"\n                >\n\n<h4 id=\"第一阶段：服务端渲染（Server-Side）\"><a href=\"#第一阶段：服务端渲染（Server-Side）\" class=\"headerlink\" title=\"第一阶段：服务端渲染（Server-Side）\"></a>第一阶段：服务端渲染（Server-Side）</h4><p>这个过程发生在 <strong>Nuxt 服务器</strong>（一个 Node.js 服务器）上。</p>\n<ol>\n<li><strong>接收请求</strong>：用户浏览器请求一个 URL，请求到达 Nuxt 服务器。</li>\n<li><strong>创建应用实例</strong>：Nuxt 服务器为这次请求<strong>创建一个全新的 Vue 应用实例、Router 和 Store</strong>。这是关键，确保了每个请求的隔离性。</li>\n<li><strong>路由匹配</strong>：根据请求的 URL，Nuxt Router 确定要渲染哪个页面组件（如 <code>pages/about.vue</code>）。</li>\n<li><strong>数据预取</strong>：Nuxt 会调用页面组件中定义的<strong>异步数据获取方法</strong>（如 <code>asyncData</code>、<code>useAsyncData</code>、<code>useFetch</code>）。<strong>这些方法会在服务端执行</strong>。<ul>\n<li>服务器会等待这些异步操作完成，再去渲染组件。这确保了渲染出的 HTML 是包含数据的。</li>\n</ul>\n</li>\n<li><strong>渲染 HTML</strong>：<ul>\n<li>将获取到的数据<strong>注入到 Vuex Store 或组件状态</strong>中。</li>\n<li>调用 Vue 的 <code>vue-server-renderer</code>（Vue 2）或 <code>@vue/server-renderer</code>（Vue 3）的 <code>renderToString()</code> 函数。</li>\n<li>这个函数会运行 Vue 组件，但它<strong>不是在浏览器中创建真实 DOM，而是在内存中生成一个完整的 HTML 字符串</strong>。</li>\n</ul>\n</li>\n<li><strong>构建最终文档</strong>：Nuxt 将这个 HTML 字符串插入到HTML模板（<code>app.html</code>）中。同时，<strong>将预取的数据序列化后内联到 HTML 中</strong>（通常是在一个 <code>&lt;script&gt;</code> 标签里，如 <code>window.__NUXT__ = &#123;...&#125;</code>），这个过程称为 <strong>状态脱水</strong>。</li>\n<li><strong>响应</strong>：将这个完整的、包含数据和内容的 HTML 文档发送给客户端。</li>\n</ol>\n<h4 id=\"第二阶段：客户端激活（Client-Side-Hydration）\"><a href=\"#第二阶段：客户端激活（Client-Side-Hydration）\" class=\"headerlink\" title=\"第二阶段：客户端激活（Client-Side Hydration）\"></a>第二阶段：客户端激活（Client-Side Hydration）</h4><p>这个过程发生在<strong>用户浏览器</strong>上。</p>\n<ol>\n<li><strong>静态内容展示</strong>：浏览器收到服务器返回的 HTML 后，<strong>无需等待任何 JavaScript，就能立即解析和显示页面内容</strong>。这是首屏速度快的根本原因。</li>\n<li><strong>加载资源</strong>：浏览器开始加载页面中引用的 JavaScript 和 CSS 资源（Nuxt 打包好的客户端 bundle）。</li>\n<li><strong>Vue 接管（Hydration -“混合”）</strong>：这是最精妙的一步。<ul>\n<li>客户端的 Vue 应用也会被创建和初始化。</li>\n<li>Vue 不会像传统 SPA 那样清空 DOM 再重新渲染。相反，它会<strong>将虚拟 DOM 与服务器渲染好的现有静态 HTML 结构进行“混合”</strong>。</li>\n<li>它会将事件监听器、Vue 的响应式系统等“激活”到这些静态元素上，使其变成一个完全交互式的 Vue 应用。</li>\n</ul>\n</li>\n<li><strong>变为 SPA</strong>：激活完成后，应用就切换到了正常的 SPA 模式。后续的页面导航不会再向服务器请求完整的 HTML，而是由客户端 Router 管理，只获取必要的数据，实现无刷新跳转。</li>\n</ol>\n<hr>\n<h3 id=\"三、Nuxt-js-实现-SSR-的关键技术点\"><a href=\"#三、Nuxt-js-实现-SSR-的关键技术点\" class=\"headerlink\" title=\"三、Nuxt.js 实现 SSR 的关键技术点\"></a>三、Nuxt.js 实现 SSR 的关键技术点</h3><ol>\n<li><strong>双入口构建（Dual Entry Points）</strong>：<ul>\n<li>Nuxt 使用 Webpack&#x2F;Vite 分别打包<strong>两个版本</strong>的代码：<ul>\n<li><strong>服务端 Bundle</strong>：用于 <code>renderToString</code>，它知道如何在 Node.js 环境中渲染组件。</li>\n<li><strong>客户端 Bundle</strong>：用于在浏览器中“激活”静态页面并处理后续交互。</li>\n</ul>\n</li>\n<li>这是通过 <code>webpack</code> 的 <code>target: &#39;node&#39;</code> 和 <code>target: &#39;web&#39;</code> 分别配置实现的。</li>\n</ul>\n</li>\n<li><strong>数据预取与状态同步</strong>：<ul>\n<li>服务端获取的数据必须<strong>安全地传递到客户端</strong>，否则客户端 Vue 在初始化时没有数据，会导致虚拟 DOM 与服务器渲染的 HTML 不匹配，激活失败。</li>\n<li>Nuxt 通过 <code>window.__NUXT__</code> 对象将数据从服务器“脱水”到客户端“补水”，保证两端状态一致。</li>\n</ul>\n</li>\n<li><strong>生命周期</strong>：<ul>\n<li>在 SSR 过程中，<strong>只有</strong>** <strong><code>**beforeCreate**</code></strong> <strong><strong>和</strong></strong> <strong><code>**created**</code></strong> **<strong>这两个生命周期钩子会在服务端执行</strong>。</li>\n<li><code>mounted</code>、<code>beforeMount</code> 等只在客户端执行。因此，<strong>在</strong>** <strong><code>**created**</code></strong> <strong><strong>中操作</strong></strong> <strong><code>**window**</code></strong> **<strong>或 DOM 会报错</strong>。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"四、Universal-Mode-同构渲染\"><a href=\"#四、Universal-Mode-同构渲染\" class=\"headerlink\" title=\"四、Universal Mode (同构渲染)\"></a>四、Universal Mode (同构渲染)</h3><p>Nuxt.js 的 SSR 通常被称为 <strong>“Universal”应用</strong>或**“同构”应用**。</p>\n<ul>\n<li><strong>同构代码</strong>：同一份 Vue 组件代码（<code>.vue</code> 文件）既可以在<strong>服务器</strong>上运行（用于首屏生成 HTML），也可以在<strong>客户端</strong>运行（用于激活和后续交互）。</li>\n<li><strong>优势</strong>：开发者只需写一套代码，Nuxt 负责处理双端的构建和渲染协调，开发体验非常流畅。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Nuxt.js 的 SSR 原理可以概括为：</p>\n<ol>\n<li><strong>服务端</strong>：为每个请求即时创建 Vue 应用，预先获取数据，渲染出包含内容的 HTML 字符串，并将数据状态一同返回。</li>\n<li><strong>客户端</strong>：快速展示静态内容，然后加载 JS，由 Vue 将静态页面“激活”为可交互的 SPA，最后接管所有后续导航。</li>\n</ol>\n<p>它完美地结合了<strong>传统服务端渲染首屏快、SEO 好</strong>的优势和<strong>单页应用用户体验流畅、交互丰富</strong>的优势，是现代 Web 应用开发的绝佳选择。</p>\n<h2 id=\"nuxt中调后端接口怎么做，要注意什么？\"><a href=\"#nuxt中调后端接口怎么做，要注意什么？\" class=\"headerlink\" title=\"nuxt中调后端接口怎么做，要注意什么？\"></a>nuxt中调后端接口怎么做，要注意什么？</h2><p>在 Nuxt.js 中调用后端接口是其核心功能之一，但根据你使用的 API 风格（Composition API 或 Options API）和渲染模式（SSR 或 SPA），做法和注意事项有所不同。</p>\n<p>下面将为你提供全面的指南，包括方法、最佳实践和常见陷阱。</p>\n<hr>\n<h3 id=\"一、如何调用后端接口？\"><a href=\"#一、如何调用后端接口？\" class=\"headerlink\" title=\"一、如何调用后端接口？\"></a>一、如何调用后端接口？</h3><p>Nuxt 3 推荐使用 Composition API，并提供了强大的组合式函数。</p>\n<h4 id=\"1-使用-useFetch-useAsyncData-Composition-API-首选\"><a href=\"#1-使用-useFetch-useAsyncData-Composition-API-首选\" class=\"headerlink\" title=\"1. 使用 useFetch &#x2F; useAsyncData (Composition API - 首选)\"></a>1. 使用 <code>useFetch</code> &#x2F; <code>useAsyncData</code> (Composition API - 首选)</h4><p>这是 Nuxt 3 中最现代、最推荐的方式，它完美处理了服务端和客户端的数据获取。</p>\n<p><strong>基本用法 (</strong><code>**useFetch**</code><strong>)：</strong><br><code>useFetch</code> 是专门为获取数据而设计的语法糖。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 直接在模板中使用，无需 .value</span><br><span class=\"line\">const &#123; data: posts, pending, error, refresh &#125; = useFetch(&#x27;/api/posts&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者指定完整 URL（注意配置代理或 CORS）</span><br><span class=\"line\">const &#123; data: users &#125; = useFetch(&#x27;https://api.example.com/users&#x27;, &#123;</span><br><span class=\"line\">  // 可选项：在客户端才获取数据（代替 onMounted + ref）</span><br><span class=\"line\">  // lazy: true,</span><br><span class=\"line\">  // server: false</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;pending&quot;&gt;Loading...&lt;/div&gt;</span><br><span class=\"line\">  &lt;div v-else-if=&quot;error&quot;&gt;Error: &#123;&#123; error.message &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">  &lt;ul v-else&gt;</span><br><span class=\"line\">    &lt;li v-for=&quot;post in posts&quot; :key=&quot;post.id&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/li&gt;</span><br><span class=\"line\">  &lt;/ul&gt;</span><br><span class=\"line\">  &lt;button @click=&quot;refresh&quot;&gt;Refresh&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>高级用法 (</strong><code>**useAsyncData**</code>** + <strong><code>**$fetch**</code></strong>)：**<br>当你需要更复杂的逻辑时（如多个请求、数据处理），使用 <code>useAsyncData</code>。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">const &#123; data: combinedData, refresh &#125; = useAsyncData(&#x27;unique-key&#x27;, async () =&gt; &#123;</span><br><span class=\"line\">  // 这里可以写任何复杂的异步逻辑</span><br><span class=\"line\">  const [posts, users] = await Promise.all([</span><br><span class=\"line\">    $fetch(&#x27;/api/posts&#x27;),</span><br><span class=\"line\">    $fetch(&#x27;/api/users&#x27;)</span><br><span class=\"line\">  ])</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 对数据进行转换</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    posts: posts.map(post =&gt; (&#123; ...post, title: post.title.toUpperCase() &#125;)),</span><br><span class=\"line\">    users</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"2-使用-fetch-直接调用\"><a href=\"#2-使用-fetch-直接调用\" class=\"headerlink\" title=\"2. 使用 $fetch 直接调用\"></a>2. 使用 <code>$fetch</code> 直接调用</h4><p>Nuxt 3 内置了基于 <a class=\"link\"   href=\"https://github.com/unjs/ofetch\" >ofetch<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 的 <code>$fetch</code> 工具，可以在任何地方使用（如事件处理函数中）。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">const handleSubmit = async () =&gt; &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    const response = await $fetch(&#x27;/api/submit&#x27;, &#123;</span><br><span class=\"line\">      method: &#x27;POST&#x27;,</span><br><span class=\"line\">      body: &#123; name: &#x27;John Doe&#x27; &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    console.log(&#x27;Success:&#x27;, response)</span><br><span class=\"line\">  &#125; catch (error) &#123;</span><br><span class=\"line\">    console.error(&#x27;Error:&#x27;, error)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"3-使用-useLazyFetch-useLazyAsyncData\"><a href=\"#3-使用-useLazyFetch-useLazyAsyncData\" class=\"headerlink\" title=\"3. 使用 useLazyFetch &#x2F; useLazyAsyncData\"></a>3. 使用 <code>useLazyFetch</code> &#x2F; <code>useLazyAsyncData</code></h4><p>它们是 <code>useFetch</code> 和 <code>useAsyncData</code> 的变体，<code>lazy: true</code> 是默认行为。<strong>不会阻塞导航</strong>，适用于非关键数据。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 不会阻塞路由导航，你需要自己处理 data 为 null 的情况</span><br><span class=\"line\">const &#123; data: nonCriticalData &#125; = useLazyFetch(&#x27;/api/non-critical-data&#x27;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;data&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 渲染数据 --&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"二、最重要的注意事项\"><a href=\"#二、最重要的注意事项\" class=\"headerlink\" title=\"二、最重要的注意事项\"></a>二、最重要的注意事项</h3><h4 id=\"1-服务端渲染-SSR-vs-客户端渲染-CSR-行为\"><a href=\"#1-服务端渲染-SSR-vs-客户端渲染-CSR-行为\" class=\"headerlink\" title=\"1. 服务端渲染 (SSR) vs 客户端渲染 (CSR) 行为\"></a>1. 服务端渲染 (SSR) vs 客户端渲染 (CSR) 行为</h4><p>这是 <strong>最核心、最容易出错</strong> 的点！</p>\n<ul>\n<li><strong>默认行为</strong>：<code>useFetch</code> 和 <code>useAsyncData</code> <strong>会在服务端执行</strong>。这意味着：<ul>\n<li><strong>好处</strong>：返回的 HTML 直接包含数据，利于 SEO 和首屏加载。</li>\n<li><strong>陷阱</strong>：<strong>不能在它们内部或</strong>** <strong><code>**created**</code></strong> **<strong>生命周期中使用浏览器API</strong>（如 <code>window</code>, <code>document</code>, <code>localStorage</code>）。</li>\n</ul>\n</li>\n<li><strong>如何控制</strong>：</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 选项 1: 强制只在客户端执行</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/data&#x27;</span>, &#123; <span class=\"attr\">server</span>: <span class=\"literal\">false</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 选项 2: 使用 useLazyFetch (默认不会阻塞导航，且在客户端执行)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useLazyFetch</span>(<span class=\"string\">&#x27;/api/data&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 选项 3: 在 onMounted 钩子中用 $fetch</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = <span class=\"title function_\">ref</span>(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"title function_\">onMounted</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  data.<span class=\"property\">value</span> = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/data&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"2-处理-CORS-跨域资源共享\"><a href=\"#2-处理-CORS-跨域资源共享\" class=\"headerlink\" title=\"2. 处理 CORS (跨域资源共享)\"></a>2. 处理 CORS (跨域资源共享)</h4><p>如果你调用的接口不在同一个域下，会遇到 CORS 问题。</p>\n<ul>\n<li><strong>开发环境</strong>：在 <code>nuxt.config.ts</code> 中配置代理是最佳实践。</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// nuxt.config.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineNuxtConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 其他配置</span></span><br><span class=\"line\">  <span class=\"attr\">nitro</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">routeRules</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;/api/**&#x27;</span>: &#123; <span class=\"attr\">proxy</span>: <span class=\"string\">&#x27;https://api.example.com/**&#x27;</span> &#125;, <span class=\"comment\">// 代理 API 请求</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 或者使用旧的 devServer 配置 (v3.0+ 推荐使用 nitro)</span></span><br><span class=\"line\">  <span class=\"comment\">// devServer: &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   proxy: &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//     &#x27;/api&#x27;: &#x27;https://api.example.com&#x27;</span></span><br><span class=\"line\">  <span class=\"comment\">//   &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>然后你在代码中请求 <code>/api/users</code>，开发服务器会将其代理到 <code>https://api.example.com/api/users</code>，避免 CORS。</li>\n<li><strong>生产环境</strong>：<ul>\n<li><strong>最佳方案</strong>：配置你的<strong>反向代理</strong>（如 Nginx）来处理跨域请求。</li>\n<li><strong>备选方案</strong>：确保后端 API 正确配置了 CORS 头 (<code>Access-Control-Allow-Origin</code> 等)。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-认证和令牌-Authentication\"><a href=\"#3-认证和令牌-Authentication\" class=\"headerlink\" title=\"3. 认证和令牌 (Authentication)\"></a>3. 认证和令牌 (Authentication)</h4><p>如何安全地传递身份验证信息（如 JWT Token）。</p>\n<ul>\n<li><strong>使用请求拦截器</strong>：利用 <code>ofetch</code> 的自动全局拦截器。</li>\n<li>如何安全地传递身份验证信息（如 JWT Token）。</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// plugins/api.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineNuxtPlugin</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; token &#125; = <span class=\"title function_\">useAuth</span>() <span class=\"comment\">// 假设你有一个获取 token 的 composable</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 全局拦截 $fetch 请求</span></span><br><span class=\"line\">  globalThis.<span class=\"property\">$fetch</span> = $fetch.<span class=\"title function_\">create</span>(&#123;</span><br><span class=\"line\">    <span class=\"title function_\">onRequest</span>(<span class=\"params\">&#123; request, options &#125;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 添加认证头</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (token.<span class=\"property\">value</span>) &#123;</span><br><span class=\"line\">        options.<span class=\"property\">headers</span> = &#123;</span><br><span class=\"line\">          ...options.<span class=\"property\">headers</span>,</span><br><span class=\"line\">          <span class=\"title class_\">Authorization</span>: <span class=\"string\">`Bearer <span class=\"subst\">$&#123;token.value&#125;</span>`</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">onRequestError</span>(<span class=\"params\">&#123; error &#125;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;Request error:&#x27;</span>, error)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">onResponseError</span>(<span class=\"params\">&#123; response &#125;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 统一处理 401 未授权错误</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (response.<span class=\"property\">status</span> === <span class=\"number\">401</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 跳转到登录页</span></span><br><span class=\"line\">        <span class=\"title function_\">navigateTo</span>(<span class=\"string\">&#x27;/login&#x27;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"4-错误处理\"><a href=\"#4-错误处理\" class=\"headerlink\" title=\"4. 错误处理\"></a>4. 错误处理</h4><p>永远不要假设请求一定会成功。</p>\n<ul>\n<li><strong>使用 try-catch</strong>：</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/endpoint&#x27;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Nuxt 3 的 $fetch 会自动抛出错误</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;API call failed:&#x27;</span>, error)</span><br><span class=\"line\">  <span class=\"comment\">// 在这里显示用户友好的错误信息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><strong>使用 <strong><code>**useFetch**</code></strong> 的状态</strong>：</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">const &#123; data, error &#125; = useFetch(&#x27;/api/endpoint&#x27;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;error&quot;&gt;</span><br><span class=\"line\">    Failed to load data: &#123;&#123; error.message &#125;&#125;</span><br><span class=\"line\">    &lt;button @click=&quot;refresh&quot;&gt;Try Again&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"5-性能优化：避免重复请求\"><a href=\"#5-性能优化：避免重复请求\" class=\"headerlink\" title=\"5. 性能优化：避免重复请求\"></a>5. 性能优化：避免重复请求</h4><ul>\n<li><strong>Key 的妙用</strong>：<code>useAsyncData</code> 和 <code>useFetch</code> 会<strong>自动去重</strong>具有相同 key 的请求。确保为唯一的数据集提供唯一的 key。</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果两个组件使用相同的 key，只会发出一个请求</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useAsyncData</span>(<span class=\"string\">&#x27;user-profile&#x27;</span>, <span class=\"function\">() =&gt;</span> $fetch(<span class=\"string\">&#x27;/api/profile&#x27;</span>))</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><strong>缓存</strong>：<code>$fetch</code> 默认不会缓存 HTTP 缓存。如果你需要利用 HTTP 缓存，可以在 headers 中设置，或者使用更高级的缓存策略。</li>\n</ul>\n<hr>\n<h3 id=\"三、最佳实践总结\"><a href=\"#三、最佳实践总结\" class=\"headerlink\" title=\"三、最佳实践总结\"></a>三、最佳实践总结</h3><ol>\n<li><strong>首选</strong>** <strong><code>**useFetch**</code></strong>&#x2F;**<code>**useAsyncData**</code>：用于在组件中获取数据，它们能智能处理 SSR 和 hydration。</li>\n<li><strong>明确数据获取时机</strong>：想清楚你需要的数<strong>据是应该在服务端获取（SEO 关键）还是客户端获取（用户相关）</strong>，并用 <code>server: false</code> 或 <code>useLazyFetch</code> 控制。</li>\n<li><strong>开发环境用代理解决 CORS</strong>：在 <code>nuxt.config.ts</code> 中配置代理，避免跨域问题。</li>\n<li><strong>统一处理认证和错误</strong>：通过插件创建配置好的 <code>$fetch</code> 实例，全局处理 token 和错误。</li>\n<li><strong>善待你的 API</strong>：合理使用 key 去重，避免重复请求；考虑分页、限流和缓存。</li>\n</ol>\n<p>遵循这些指南，你就能在 Nuxt 应用中高效、可靠地与后端 API 进行交互。</p>\n<h2 id=\"开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\"><a href=\"#开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\" class=\"headerlink\" title=\"开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\"></a>开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？</h2><p><strong>你这个问题问得非常好，直击要害！你的理解完全正确。</strong></p>\n<p>是的，你的推理是精准的：</p>\n<ul>\n<li><strong>服务端（Node.js）发起的请求</strong>：没有跨域概念。跨域是<strong>浏览器</strong>强加的安全策略。Node.js 发请求就像你用 <code>curl</code> 或 Postman 一样，可以去任何地方，不存在 CORS 问题。</li>\n<li><strong>客户端（浏览器）发起的请求</strong>：受跨域限制。浏览器会拦截违反同源策略的请求。</li>\n</ul>\n<p><strong>因此，“开发环境配置代理” 主要就是为了解决 —— 在客户端发起请求时遇到的跨域问题。</strong></p>\n<hr>\n<h3 id=\"为什么开发环境会有客户端请求？\"><a href=\"#为什么开发环境会有客户端请求？\" class=\"headerlink\" title=\"为什么开发环境会有客户端请求？\"></a>为什么开发环境会有客户端请求？</h3><p>在 Nuxt 3 的 SSR 模式下，一个页面渲染通常涉及<strong>两次</strong>数据获取：</p>\n<ol>\n<li><strong>第一次（服务端请求 - 无 CORS）</strong>：<ul>\n<li>当用户直接访问页面 URL 时，请求会先到达你的 Nuxt 服务器。</li>\n<li>Nuxt 服务器执行 <code>useFetch</code> 或 <code>useAsyncData</code>，<strong>在服务器环境</strong>（Node.js）中向后端 API 发起请求。</li>\n<li>此时是 <strong>服务器对服务器</strong> 的通信，没有浏览器参与，所以<strong>没有 CORS 问题</strong>。</li>\n<li>服务器拿到数据后，渲染出包含内容的 HTML 并返回给浏览器。</li>\n</ul>\n</li>\n<li><strong>第二次（客户端请求 - 有 CORS 风险）</strong>：<ul>\n<li>浏览器收到 HTML 并展示后，会加载 Nuxt 的客户端 JS Bundle。</li>\n<li>Vue 开始 <strong>“激活” (Hydration)</strong> 过程。</li>\n<li>在这个过程中，<code>useFetch</code> 和 <code>useAsyncData</code> 的代码会在<strong>客户端浏览器环境</strong>中再次运行，以确保数据状态一致。</li>\n<li>如果它们的 URL 是<strong>绝对路径</strong>（如 <code>https://api.example.com/data</code>），那么这次请求就是由<strong>浏览器</strong>直接发起的，就会触发 CORS 检查。</li>\n<li>如果后端 API 没有正确配置 CORS 头，浏览器就会拦截这次请求，导致错误。</li>\n</ul>\n</li>\n</ol>\n<p>此外，还有几种常见的<strong>纯客户端请求</strong>场景：</p>\n<ul>\n<li>用户交互（如点击按钮）触发的 <code>$fetch</code> 请求。</li>\n<li>在 <code>onMounted</code> 钩子中发起的请求。</li>\n<li>使用 <code>useLazyFetch</code>（它默认在客户端执行）。</li>\n</ul>\n<h3 id=\"总结与最佳实践\"><a href=\"#总结与最佳实践\" class=\"headerlink\" title=\"总结与最佳实践\"></a>总结与最佳实践</h3><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>请求发起方</th>\n<th>是否有 CORS 问题？</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>SSR 首屏渲染</strong></td>\n<td>Nuxt Server (Node.js)</td>\n<td><strong>否</strong></td>\n<td>无需额外配置。但需确保服务器能访问到 API（网络连通性）。</td>\n</tr>\n<tr>\n<td><strong>CSR Hydration&#x2F;交互</strong></td>\n<td>浏览器</td>\n<td><strong>是</strong></td>\n<td><strong>配置开发服务器代理</strong>（如下方代码）。这是最推荐的方法。</td>\n</tr>\n<tr>\n<td><strong>生产环境</strong></td>\n<td>浏览器</td>\n<td><strong>是</strong></td>\n<td><strong>配置生产级反向代理</strong>（如 Nginx），或确保后端 API 正确设置 CORS 头。</td>\n</tr>\n</tbody></table>\n<h2 id=\"nuxt中的-fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\"><a href=\"#nuxt中的-fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\" class=\"headerlink\" title=\"nuxt中的$fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\"></a>nuxt中的$fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？</h2><p>非常好的问题！这是理解 Nuxt 3 数据获取的关键。它们的执行环境行为是核心区别。</p>\n<p>简单直接的答案是：<strong>不，</strong><code>**$fetch**</code>** <strong><strong>可以在服务端和客户端调用。而</strong></strong> <strong><code>**useFetch**</code></strong> <strong><strong>和</strong></strong> <strong><code>**useAsyncData**</code></strong> **<strong>的行为是智能的，默认在服务端执行。</strong></p>\n<p>下面我们来详细拆解这三者的区别。</p>\n<hr>\n<h3 id=\"一、-fetch：双环境通用的请求工具\"><a href=\"#一、-fetch：双环境通用的请求工具\" class=\"headerlink\" title=\"一、$fetch：双环境通用的请求工具\"></a>一、<code>$fetch</code>：双环境通用的请求工具</h3><p><code>$fetch</code> 是 Nuxt 3 基于 <a class=\"link\"   href=\"https://github.com/unjs/ofetch\" >ofetch<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 提供的全局工具函数。它本身<strong>没有环境限制</strong>，你在哪里调用它，它就在哪个环境执行。</p>\n<ul>\n<li><strong>在服务端（Node.js）调用</strong>：它就像一个普通的 Node.js HTTP 客户端（比如 <code>axios</code>），直接向后端发起请求，<strong>没有跨域概念</strong>。</li>\n<li><strong>在客户端（浏览器）调用</strong>：它的行为类似于原生的 <code>fetch()</code>，但功能更强大（自动处理 JSON、更好的错误处理等），并且<strong>受浏览器跨域策略限制</strong>。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 在组件 setup 中直接调用 - 根据渲染环境决定</span></span><br><span class=\"line\"><span class=\"comment\">// 如果在服务端渲染，它在服务端执行；如果在客户端激活或导航，它在客户端执行。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/items&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在明确的服务端环境调用 - 只在服务端执行</span></span><br><span class=\"line\"><span class=\"comment\">// 例如：在 API 路由、服务器中间件或 plugin 中</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineEventHandler</span>(<span class=\"title function_\">async</span> (event) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;https://external-api.com/data&#x27;</span>); <span class=\"comment\">// 在服务器上运行</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; data &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 在明确的客户端环境调用 - 只在客户端执行</span></span><br><span class=\"line\"><span class=\"comment\">// 例如：在事件处理函数或 onMounted 中</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handleClick</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/items&#x27;</span>); <span class=\"comment\">// 在浏览器中运行，受 CORS 限制</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<p><code>**$fetch**</code>** <strong><strong>的陷阱</strong>：如果你在组件顶层直接使用 <code>$fetch</code>（没有包裹在 <code>useAsyncData</code> 或 <code>useFetch</code> 中），并且该组件在服务端渲染，那么请求会在服务端执行。但当客户端激活（Hydration）时，<strong>同样的</strong></strong> <strong><code>**$fetch**</code></strong> **<strong>代码又会在客户端再执行一次</strong>，造成重复请求。</p>\n<hr>\n<h3 id=\"二、useAsyncData-useFetch：智能的双环境数据获取器\"><a href=\"#二、useAsyncData-useFetch：智能的双环境数据获取器\" class=\"headerlink\" title=\"二、useAsyncData &amp; useFetch：智能的双环境数据获取器\"></a>二、<code>useAsyncData</code> &amp; <code>useFetch</code>：智能的双环境数据获取器</h3><p>这两个组合函数是 Nuxt 数据获取的“智能大脑”。它们的关键特性是：<strong>“在服务端预取数据，并自动将数据序列化到客户端，避免重复请求”</strong>。</p>\n<h4 id=\"核心行为：\"><a href=\"#核心行为：\" class=\"headerlink\" title=\"核心行为：\"></a>核心行为：</h4><ol>\n<li><strong>默认在服务端执行</strong>：在 SSR 模式下，当页面首次加载时，它们会在 Nuxt 服务器内部执行，获取数据并直接将数据嵌入到最终返回的 HTML 中。</li>\n<li><strong>在客户端激活</strong>：当 Vue 在客户端“激活”静态页面时，<code>useAsyncData</code> 和 <code>useFetch</code> 会识别到数据已经存在于从服务器传递过来的 payload 中，因此<strong>不会在客户端再次发起请求</strong>，而是直接使用已有的数据。</li>\n<li><strong>后续导航</strong>：当你在客户端通过导航跳转到另一个也使用了这些函数的页面时，它们会在<strong>客户端</strong>执行。</li>\n</ol>\n<h4 id=\"如何控制执行环境？\"><a href=\"#如何控制执行环境？\" class=\"headerlink\" title=\"如何控制执行环境？\"></a>如何控制执行环境？</h4><p>它们提供了一个 <code>server</code> 选项让你精确控制：</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认：true - 在服务端执行（SSR 首屏）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/items&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 强制在客户端执行（CSR）</span></span><br><span class=\"line\"><span class=\"comment\">// 适合：用户相关的数据、不需要 SEO 的数据、访问浏览器 API 的数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/user-data&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">server</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// useAsyncData 用法相同</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useAsyncData</span>(<span class=\"string\">&#x27;user-key&#x27;</span>, <span class=\"function\">() =&gt;</span> $fetch(<span class=\"string\">&#x27;/api/user&#x27;</span>), &#123;</span><br><span class=\"line\">  <span class=\"attr\">server</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"三、三者的对比总结\"><a href=\"#三、三者的对比总结\" class=\"headerlink\" title=\"三、三者的对比总结\"></a>三、三者的对比总结</h3><p>为了更直观地理解，下面的流程图展示了不同调用方式在 Nuxt 应用生命周期中的执行时机和数据流向：</p>\n<p>这个图清晰地展示了：</p>\n<ol>\n<li><code>**useFetch**</code><strong>&#x2F;</strong><code>**useAsyncData**</code> 是贯穿服务端和客户端的“智能通道”，保证了数据的高效同步和无重复请求。</li>\n<li><strong>直接使用</strong>** **<code>**$fetch**</code> 在组件顶层会导致重复请求，是需要避免的反模式。</li>\n<li><strong>在事件中使用的</strong>** **<code>**$fetch**</code> 是纯客户端行为。</li>\n</ol>\n<h3 id=\"最佳实践与选择指南\"><a href=\"#最佳实践与选择指南\" class=\"headerlink\" title=\"最佳实践与选择指南\"></a>最佳实践与选择指南</h3><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐使用的工具</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>获取页面组件所需数据</strong></td>\n<td><code>**useFetch**</code><br/>** <strong><strong>或</strong></strong> **<code>**useAsyncData**</code></td>\n<td>自动处理 SSR&#x2F;CSR，避免重复请求，数据序列化到客户端。</td>\n</tr>\n<tr>\n<td><strong>在事件处理、</strong><code>**onMounted**</code><br/>** **<strong>中获取数据</strong></td>\n<td><code>**$fetch**</code></td>\n<td>明确需要在客户端触发的请求。</td>\n</tr>\n<tr>\n<td><strong>在 API 路由或服务器中间件中</strong></td>\n<td><code>**$fetch**</code></td>\n<td>明确的服务端环境，无需 <code>useAsyncData</code><br/> 的额外功能。</td>\n</tr>\n<tr>\n<td><strong>需要复杂的数据获取逻辑</strong></td>\n<td><code>**useAsyncData**</code><br/>** <strong><strong>+</strong></strong> **<code>**$fetch**</code></td>\n<td><code>useAsyncData</code><br/> 提供状态管理，内部函数可使用 <code>$fetch</code><br/> 进行复杂操作。</td>\n</tr>\n<tr>\n<td><strong>简单的 URL 请求</strong></td>\n<td><code>**useFetch**</code></td>\n<td>最简洁的写法。</td>\n</tr>\n</tbody></table>\n<p><strong>一句话总结：</strong></p>\n<ul>\n<li><strong>用</strong>** <strong><code>**useFetch**</code></strong>&#x2F;<strong><code>**useAsyncData**</code> 来获取</strong>组件初始化时所需的数据**，让 Nuxt 智能决定执行环境。</li>\n<li><strong>用</strong>** <strong><code>**$fetch**</code> 在</strong>明确的客户端交互<strong>或</strong>明确的服务端环境**中主动发起请求。</li>\n</ul>\n<p>遵循这个原则，你就能高效且正确地在 Nuxt 应用中处理数据获取。</p>\n<h2 id=\"激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\"><a href=\"#激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\" class=\"headerlink\" title=\"激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\"></a>激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？</h2><p>这些问题触及了 Nuxt.js SSR 的核心魔法。好消息是，<strong>这个过程绝大部分是自动化的，开发者几乎不需要手动干预</strong>。Nuxt 和 Vue 底层已经为你处理好了一切。</p>\n<p>下面我来逐一解答你的问题，你会看到 Nuxt 的设计是多么巧妙。</p>\n<hr>\n<h3 id=\"一、激活客户端需要开发手动调用什么-API-吗？\"><a href=\"#一、激活客户端需要开发手动调用什么-API-吗？\" class=\"headerlink\" title=\"一、激活客户端需要开发手动调用什么 API 吗？\"></a>一、激活客户端需要开发手动调用什么 API 吗？</h3><p><strong>答：完全不需要。这是 Vue 和 Nuxt 自动完成的。</strong></p>\n<p>这个过程称为 <strong>Hydration（混合）</strong>。它的流程是：</p>\n<ol>\n<li><strong>自动执行</strong>：当浏览器加载完 Nuxt 发送过来的 HTML 和客户端 JavaScript 包后，Vue 会自动启动。</li>\n<li><strong>自动匹配</strong>：Vue 会将它的虚拟 DOM 与服务器渲染好的、已经存在的静态 HTML 结构进行对比和匹配。</li>\n<li><strong>自动“激活”</strong>：Vue 不会重新创建 DOM 元素，而是会将事件监听器、响应式数据系统等“附加”到这些现有的 DOM 元素上，使静态页面瞬间变为一个完全交互式的 Vue 应用。</li>\n</ol>\n<p><strong>作为开发者，你唯一要做的就是：</strong></p>\n<ul>\n<li>确保你的代码是<strong>同构的</strong>（即同一份代码既能在 Node.js 环境运行，也能在浏览器环境运行）。</li>\n<li>避免在 <code>created</code> 或 <code>setup</code> 等生命周期中使用浏览器特有的 API（如 <code>window</code>, <code>document</code>），或者使用 <code>onMounted</code>（仅在客户端执行）来包裹它们。</li>\n</ul>\n<p><strong>你不用写任何像</strong>** <strong><code>**app.hydrate()**</code></strong> **<strong>这样的代码，一切都是开箱即用、自动发生的。</strong></p>\n<hr>\n<h3 id=\"二、服务端异步获取的数据注入到-HTML-这一步开发需要做什么？\"><a href=\"#二、服务端异步获取的数据注入到-HTML-这一步开发需要做什么？\" class=\"headerlink\" title=\"二、服务端异步获取的数据注入到 HTML 这一步开发需要做什么？\"></a>二、服务端异步获取的数据注入到 HTML 这一步开发需要做什么？</h3><p><strong>答：你只需要使用正确的 API（</strong><code>**useAsyncData**</code>** <strong><strong>或</strong></strong> <strong><code>**useFetch**</code></strong>），Nuxt 就会自动完成注入。**</p>\n<p>这个“注入”过程在 Nuxt 中被称为 <strong>State Serialization（状态序列化）</strong> 或 ** dehydration（脱水）**。</p>\n<p><strong>你的工作（非常简单）：</strong></p>\n<ol>\n<li>**使用 <strong><code>**useAsyncData**</code></strong> 或 **<code>**useFetch**</code>：在你的页面组件中，用它们来获取数据。</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">  // pages/posts.vue</span><br><span class=\"line\">  const &#123; data: posts &#125; = await useFetch(&#x27;/api/posts&#x27;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li><strong>Nuxt 自动完成后续所有事情</strong>：<ul>\n<li>Nuxt 在服务端执行完 <code>useFetch</code> 后，会<strong>自动</strong>将 <code>posts</code> 数据序列化为 JSON 字符串。</li>\n<li>将这个 JSON 字符串<strong>自动嵌入</strong>到最终 HTML 的 <code>&lt;head&gt;</code> 部分的一个 <code>&lt;script&gt;</code> 标签中。</li>\n<li>这个标签的内容通常是 <code>window.__NUXT__ = &#123; ... &#125;</code>，其中就包含了所有页面的预取数据。</li>\n</ul>\n</li>\n</ol>\n<p><strong>你不需要手动操作 DOM 去注入数据，Nuxt 的渲染引擎为你包办了一切。</strong></p>\n<hr>\n<h3 id=\"三、到客户端时如何获取数据呢？\"><a href=\"#三、到客户端时如何获取数据呢？\" class=\"headerlink\" title=\"三、到客户端时如何获取数据呢？\"></a>三、到客户端时如何获取数据呢？</h3><p><strong>答：客户端 Vue 应用会自动从</strong>** <strong><code>**window.__NUXT__**</code></strong> **<strong>中提取并复用数据，无需再次请求。</strong></p>\n<p>这个过程是 <strong>State Deserialization（状态反序列化）</strong> 或 <strong>rehydration（补水）</strong>。</p>\n<p><strong>它的自动流程如下：</strong></p>\n<ol>\n<li><strong>数据随 HTML 到达浏览器</strong>：HTML 中的 <code>&lt;script&gt;window.__NUXT__ = &#123;...&#125;&lt;/script&gt;</code> 会先被执行，将数据挂载到全局对象上。</li>\n<li><strong>客户端 Vue 应用启动</strong>：客户端的 JavaScript 包加载完毕后，Vue 和 Nuxt 开始初始化。</li>\n<li><strong>自动提取数据</strong>：当客户端的 <code>useFetch(&#39;/api/posts&#39;)</code> 代码执行时，它不会真正去发起网络请求，而是会<strong>先自动去</strong>** <strong><code>**window.__NUXT__**</code></strong> **<strong>对象里查找</strong>，看是否存在服务端已经为它准备好的数据。</li>\n<li><strong>直接复用数据</strong>：如果找到了，它就直接使用这份数据，完全跳过网络请求。这样就保证了客户端和服务端的数据状态<strong>绝对一致</strong>，这也是 Hydration 能成功的前提。</li>\n</ol>\n<p><strong>你可以通过 <strong><code>**useNuxtData**</code></strong> 这个工具函数来验证和访问这些被缓存的数据：</strong></p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 在客户端，你可以这样访问之前服务端获取的、被缓存的数据</span><br><span class=\"line\">const &#123; data: posts &#125; = useNuxtData(&#x27;posts&#x27;) // 使用 useFetch 时自动生成的 key</span><br><span class=\"line\"></span><br><span class=\"line\">// 这不会导致第二次请求，它只是从客户端缓存中读取</span><br><span class=\"line\">console.log(posts.value)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\"><a href=\"#服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\" class=\"headerlink\" title=\"服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\"></a>服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？</h2><p><strong>你这个问题问得非常非常关键，切中了SSR安全的核心！你的直觉完全正确。</strong></p>\n<p><strong>绝对不应该将任何敏感信息（如用户凭证、Token、个人身份信息PII等）内联到HTML的</strong>** <strong><code>**&lt;script&gt;**</code></strong> <strong><strong>标签中，并通过</strong></strong> <strong><code>**window.__NUXT__**</code></strong> **<strong>暴露给客户端。</strong></p>\n<p>这样做会带来严重的安全风险：</p>\n<ol>\n<li><strong>数据泄露</strong>：任何能打开浏览器开发者工具的人，都可以直接看到 <code>window.__NUXT__</code> 里的全部内容。</li>\n<li><strong>XSS攻击加剧</strong>：如果你的应用存在XSS（跨站脚本）漏洞，攻击者可以更容易地编写脚本窃取 <code>window.__NUXT__</code> 中的所有数据，而不必费力去窃取多个API请求的返回结果。</li>\n<li><strong>缓存风险</strong>：HTML页面可能会被CDN、代理服务器或浏览器缓存。如果其中包含了用户敏感信息，就意味着这些信息也可能被缓存并泄露给其他用户。</li>\n</ol>\n<hr>\n<h3 id=\"那么，如何处理需要认证的敏感数据？\"><a href=\"#那么，如何处理需要认证的敏感数据？\" class=\"headerlink\" title=\"那么，如何处理需要认证的敏感数据？\"></a>那么，如何处理需要认证的敏感数据？</h3><p>正确的做法是将敏感数据与非敏感数据<strong>分离</strong>，并遵循“<strong>按需索取</strong>”和“<strong>最小化暴露</strong>”的原则。以下是几种安全策略：</p>\n<h4 id=\"策略一：敏感数据绝不预取，仅在客户端获取\"><a href=\"#策略一：敏感数据绝不预取，仅在客户端获取\" class=\"headerlink\" title=\"策略一：敏感数据绝不预取，仅在客户端获取\"></a>策略一：敏感数据绝不预取，仅在客户端获取</h4><p>这是最常用、最安全的策略。用户登录状态、个人资料等高度敏感的数据，<strong>不应该</strong>在服务端的 <code>useFetch</code>&#x2F;<code>useAsyncData</code> 中获取。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 1. 非敏感、SEO需要的数据：在服务端预取（安全）</span><br><span class=\"line\">const &#123; data: publicPosts &#125; = await useFetch(&#x27;/api/public-posts&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. 敏感的用户数据：不在服务端预取，只在客户端获取</span><br><span class=\"line\">const user = ref(null)</span><br><span class=\"line\">const token = useCookie(&#x27;auth-token&#x27;) // Token应存放在HttpOnly Cookie中</span><br><span class=\"line\"></span><br><span class=\"line\">// 在客户端挂载后，再安全地获取用户数据</span><br><span class=\"line\">onMounted(async () =&gt; &#123;</span><br><span class=\"line\">  if (token.value) &#123;</span><br><span class=\"line\">    // 此请求在客户端发起，携带Cookie中的token</span><br><span class=\"line\">    user.value = await $fetch(&#x27;/api/me&#x27;, &#123;</span><br><span class=\"line\">      headers: &#123;</span><br><span class=\"line\">        // 通常Token会自动通过Cookie发送，无需手动设置，这里演示逻辑</span><br><span class=\"line\">        Authorization: `Bearer $&#123;token.value&#125;`</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;!-- 公开数据直接渲染 --&gt;</span><br><span class=\"line\">  &lt;div v-for=&quot;post in publicPosts&quot; :key=&quot;post.id&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;!-- 用户数据，等客户端获取后再显示 --&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;user&quot;&gt;Welcome, &#123;&#123; user.name &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"策略二：使用-useState-进行状态管理，区分服务端与客户端状态\"><a href=\"#策略二：使用-useState-进行状态管理，区分服务端与客户端状态\" class=\"headerlink\" title=\"策略二：使用 useState 进行状态管理，区分服务端与客户端状态\"></a>策略二：使用 <code>useState</code> 进行状态管理，区分服务端与客户端状态</h4><p>你可以利用 <code>useState</code> 的灵活性来管理不同环境的状态。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 创建一个响应式状态，服务端先初始化为 null</span><br><span class=\"line\">const secretData = useState(&#x27;secret-data&#x27;, () =&gt; null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 在客户端再获取真实数据</span><br><span class=\"line\">onMounted(async () =&gt; &#123;</span><br><span class=\"line\">  if (!secretData.value) &#123; // 避免在服务端执行</span><br><span class=\"line\">    secretData.value = await $fetch(&#x27;/api/secret-data&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"策略三：API-设计分离-提供公开和私密端点\"><a href=\"#策略三：API-设计分离-提供公开和私密端点\" class=\"headerlink\" title=\"策略三：API 设计分离 - 提供公开和私密端点\"></a>策略三：API 设计分离 - 提供公开和私密端点</h4><p>从后端设计上就进行分离：</p>\n<ul>\n<li><code>/api/public/data</code>：返回不敏感的数据，可以安全地在服务端渲染。</li>\n<li><code>/api/private/user-data</code>：返回敏感数据，必须认证且在客户端获取。</li>\n</ul>\n<hr>\n<h3 id=\"Nuxt-如何安全地处理认证？\"><a href=\"#Nuxt-如何安全地处理认证？\" class=\"headerlink\" title=\"Nuxt 如何安全地处理认证？\"></a>Nuxt 如何安全地处理认证？</h3><p>认证的最佳实践是使用 <strong>HttpOnly Cookies</strong> 来传输令牌（Token），而不是通过 <code>window.__NUXT__</code> 或 JS 可读的 Cookie。</p>\n<ol>\n<li><strong>登录流程</strong>：<ul>\n<li>用户提交登录表单，客户端 <code>$fetch</code> 发送到 <code>/api/auth/login</code>。</li>\n<li><strong>后端</strong>验证成功后，设置一个 <strong>HttpOnly、Secure、SameSite&#x3D;Strict</strong> 的 Cookie（包含认证Token）。这个 Cookie 对 JavaScript 不可见，极大地增强了安全性。</li>\n<li>前端只需知道登录成功，无需接触 Token 本身。</li>\n</ul>\n</li>\n<li><strong>获取用户数据</strong>：<ul>\n<li>在客户端，调用 <code>$fetch(&#39;/api/me&#39;)</code>。</li>\n<li>浏览器会<strong>自动</strong>在请求中带上 HttpOnly Cookie。</li>\n<li>后端验证 Cookie 中的 Token 有效性后，返回对应用户的数据。</li>\n</ul>\n</li>\n<li><strong>服务端渲染中的认证</strong>：<ul>\n<li>如果服务端需要根据用户状态渲染不同内容（例如“您好，用户名”），可以通过<strong>服务器中间件</strong>或 <strong>API 路由</strong>来处理。</li>\n<li>服务端可以读取请求中的 Cookie，去后端验证用户身份，然后决定返回什么数据。但这个验证过程发生在后端，结果信息需要是<strong>非敏感</strong>的（例如只返回 <code>username</code>，而不是返回 <code>token</code> 或 <code>email</code>）。</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 服务端可以安全地读取Cookie并获取非敏感的用户显示信息</span><br><span class=\"line\">const &#123; data: userInfo &#125; = await useFetch(&#x27;/api/user-display-info&#x27;)</span><br><span class=\"line\">// 这个 `/api/user-display-info` 接口在后端会验证Cookie，</span><br><span class=\"line\">// 但只返回 &#123; name: &#x27;John&#x27; &#125; 这样的非敏感信息用于界面显示。</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><strong>核心原则</strong>：<strong>绝不将敏感数据内联到 HTML 中</strong>。<code>window.__NUXT__</code> 应该是“公开的”或“非敏感的”。</li>\n<li><strong>数据分离</strong>：将数据分为“公开”和“私密”两类。公开数据用 <code>useFetch</code> 服务端预取；私密数据在客户端用 <code>$fetch</code> 按需获取。</li>\n<li><strong>认证最佳实践</strong>：使用 <strong>HttpOnly Cookies</strong> 来安全地传输认证凭证，而不是将其暴露给客户端 JavaScript 或 <code>window</code> 对象。</li>\n<li><strong>信任后端</strong>：敏感的权限检查和数据处理逻辑应该始终放在后端 API 中。前端（包括SSR服务端）只负责展示非敏感的结果。</li>\n</ol>\n<p>你的安全意识非常到位，遵循这些原则可以让你构建出既高效又安全的 Nuxt.js 应用。</p>\n<h2 id=\"除此之外，服务端渲染还有什么不能实现的呢？canvas？\"><a href=\"#除此之外，服务端渲染还有什么不能实现的呢？canvas？\" class=\"headerlink\" title=\"除此之外，服务端渲染还有什么不能实现的呢？canvas？\"></a>除此之外，服务端渲染还有什么不能实现的呢？canvas？</h2><p>说得非常对！<strong>Canvas</strong> 是一个绝佳的例子，它完美地揭示了服务端渲染（SSR）的“盲区”。</p>\n<p>SSR 的核心是<strong>生成静态的 HTML 和 CSS 字符串</strong>。因此，任何<strong>动态的、依赖于浏览器 JavaScript 运行时环境</strong>的功能，在纯 SSR 阶段都无法实现或功能不全。</p>\n<p>除了 Canvas，还有很多类似的限制。我们可以将它们分为几大类：</p>\n<hr>\n<h3 id=\"一、浏览器特有的-API-和全局对象\"><a href=\"#一、浏览器特有的-API-和全局对象\" class=\"headerlink\" title=\"一、浏览器特有的 API 和全局对象\"></a>一、浏览器特有的 API 和全局对象</h3><p>这是最直接的一类。在 Node.js 服务器环境中，根本没有 <code>window</code>, <code>document</code>, <code>navigator</code> 等对象。</p>\n<table>\n<thead>\n<tr>\n<th>API&#x2F;功能</th>\n<th>原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>**window**</code><strong>、</strong><code>**document**</code></td>\n<td>Node.js 中不存在。</td>\n<td>使用 <code>onMounted</code>钩子或 <code>clientOnly</code>组件确保只在客户端访问。</td>\n</tr>\n<tr>\n<td><code>**alert**</code><strong>、</strong><code>**confirm**</code><strong>、</strong><code>**prompt**</code></td>\n<td>浏览器交互对话框。</td>\n<td>逻辑移至客户端，或使用基于组件的替代品（如模态框）。</td>\n</tr>\n<tr>\n<td><strong>Canvas (</strong><code>**&lt;canvas&gt;**</code><strong>) &#x2F; WebGL</strong></td>\n<td>需要浏览器渲染上下文来绘图和操作像素。</td>\n<td><strong>只能在客户端初始化和使用</strong>。SSR 只能渲染一个空画布。</td>\n</tr>\n<tr>\n<td><strong>地理位置 (</strong><code>**navigator.geolocation**</code><strong>)</strong></td>\n<td>需要用户的浏览器授权和设备硬件支持。</td>\n<td>仅在客户端通过 <code>onMounted</code>或用户交互触发。</td>\n</tr>\n<tr>\n<td><strong>本地存储 (</strong><code>**localStorage**</code><strong>, <strong><code>**sessionStorage**</code></strong>, <strong><code>**IndexedDB**</code></strong>)</strong></td>\n<td>是浏览器的持久化存储机制。</td>\n<td>在 <code>onMounted</code>中访问，或使用 <code>useLocalStorage</code>等组合式函数（内部做了客户端检查）。</td>\n</tr>\n<tr>\n<td><strong>媒体设备 (</strong><code>**navigator.mediaDevices**</code><strong>)</strong></td>\n<td>需要访问麦克风、摄像头等硬件。</td>\n<td>完全的用户客户端行为。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"二、依赖浏览器渲染或布局的功能\"><a href=\"#二、依赖浏览器渲染或布局的功能\" class=\"headerlink\" title=\"二、依赖浏览器渲染或布局的功能\"></a>二、依赖浏览器渲染或布局的功能</h3><p>这类功能需要知道元素的真实尺寸和位置，而这些信息在纯字符串的 SSR 阶段是无法获得的。</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>元素尺寸&#x2F;位置</strong> (如 <code>element.offsetWidth</code><br/>, <code>getBoundingClientRect()</code><br/>)</td>\n<td>SSR 只有 HTML 字符串，没有真实的布局和渲染。</td>\n<td>在 <code>onMounted</code><br/> 后使用，或使用 Vue 的 <code>nextTick</code><br/> 确保 DOM 已更新。</td>\n</tr>\n<tr>\n<td><strong>基于尺寸的渲染</strong> (如图表库 ECharts、D3.js)</td>\n<td>需要挂载到真实 DOM 元素并获取其宽高才能渲染。</td>\n<td>在 <code>onMounted</code><br/> 中初始化图表实例。</td>\n</tr>\n<tr>\n<td><strong>动画 (CSS 动画除外)</strong></td>\n<td>许多 JS 动画库需要操作 DOM 样式。</td>\n<td>使用 <code>onMounted</code><br/> 启动动画，或使用 CSS 动画（SSR 支持）。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"三、用户交互和状态\"><a href=\"#三、用户交互和状态\" class=\"headerlink\" title=\"三、用户交互和状态\"></a>三、用户交互和状态</h3><p>SSR 输出的是一个“快照”，无法预知用户未来的行为。</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>用户输入</strong> (表单输入、焦点状态)</td>\n<td>SSR 无法预知用户会输入什么。</td>\n<td>SSR 可以渲染表单结构，但交互和值绑定必须在客户端完成。</td>\n</tr>\n<tr>\n<td><strong>鼠标事件、键盘事件</strong></td>\n<td>纯静态环境，无用户交互。</td>\n<td>完全由客户端 JavaScript 处理。</td>\n</tr>\n<tr>\n<td><strong>浏览器标签页可见性</strong> (<code>document.visibilityState</code>)</td>\n<td>依赖于用户当前的浏览器状态。</td>\n<td>纯客户端逻辑。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"四、第三方库\"><a href=\"#四、第三方库\" class=\"headerlink\" title=\"四、第三方库\"></a>四、第三方库</h3><p>许多强大的第三方库在设计时就是为浏览器而生的。</p>\n<table>\n<thead>\n<tr>\n<th>库类型</th>\n<th>问题</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>地图库</strong> (如 Leaflet, Google Maps)</td>\n<td>需要挂载到 DOM 并初始化地图渲染上下文。</td>\n<td>使用 <code>onMounted</code><br/> 初始化，或使用 Nuxt 模块（如 <code>nuxt-leaflet</code><br/>）。</td>\n</tr>\n<tr>\n<td><strong>可视化库</strong> (如 D3, Three.js)</td>\n<td>严重依赖 Canvas、WebGL 或 SVG 操作。</td>\n<td><strong>只能在客户端运行</strong>。</td>\n</tr>\n<tr>\n<td><strong>分析&#x2F;广告库</strong> (如 Google Analytics)</td>\n<td>依赖 <code>window</code><br/> 对象和浏览器环境来跟踪用户。</td>\n<td>使用 Nuxt 插件（<code>client: true</code><br/> 选项）或直接在 <code>onMounted</code><br/> 中加载。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"如何安全地处理这些限制？Nuxt-提供的解决方案\"><a href=\"#如何安全地处理这些限制？Nuxt-提供的解决方案\" class=\"headerlink\" title=\"如何安全地处理这些限制？Nuxt 提供的解决方案\"></a>如何安全地处理这些限制？Nuxt 提供的解决方案</h3><p>Nuxt 提供了一系列模式来优雅地解决这些问题：</p>\n<h4 id=\"1-onMounted-钩子-最常用\"><a href=\"#1-onMounted-钩子-最常用\" class=\"headerlink\" title=\"1. onMounted 钩子 (最常用)\"></a>1. <code>onMounted</code> 钩子 (最常用)</h4><p>确保代码只在客户端执行。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">import &#123; onMounted &#125; from &#x27;vue&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const canvas = ref(null)</span><br><span class=\"line\"></span><br><span class=\"line\">onMounted(() =&gt; &#123;</span><br><span class=\"line\">  // 现在可以安全地访问 DOM 和浏览器 API 了</span><br><span class=\"line\">  const ctx = canvas.value.getContext(&#x27;2d&#x27;)</span><br><span class=\"line\">  ctx.fillStyle = &#x27;green&#x27;</span><br><span class=\"line\">  ctx.fillRect(10, 10, 150, 100)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;!-- SSR 会渲染一个空画布 --&gt;</span><br><span class=\"line\">  &lt;canvas ref=&quot;canvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"2-条件渲染与-组件\"><a href=\"#2-条件渲染与-组件\" class=\"headerlink\" title=\"2. 条件渲染与 &lt;ClientOnly&gt; 组件\"></a>2. 条件渲染与 <code>&lt;ClientOnly&gt;</code> 组件</h4><p>防止不支持 SSR 的组件在服务器端渲染时出错。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;!-- 默认插槽只在客户端渲染 --&gt;</span><br><span class=\"line\">  &lt;ClientOnly&gt;</span><br><span class=\"line\">    &lt;MyChartThatUsesWindow /&gt;</span><br><span class=\"line\">    &lt;!-- 可以设置回退内容，在SSR阶段显示 --&gt;</span><br><span class=\"line\">    &lt;template #fallback&gt;</span><br><span class=\"line\">      &lt;div&gt;Loading chart...&lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">  &lt;/ClientOnly&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"3-使用-process-client-标志进行运行时检查\"><a href=\"#3-使用-process-client-标志进行运行时检查\" class=\"headerlink\" title=\"3. 使用 process.client 标志进行运行时检查\"></a>3. 使用 <code>process.client</code> 标志进行运行时检查</h4><div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">if (process.client) &#123;</span><br><span class=\"line\">  // 此代码块只在客户端打包时包含，并在客户端执行</span><br><span class=\"line\">  console.log(&#x27;I am on the client!&#x27;, window.innerWidth)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"4-为第三方库创建客户端插件\"><a href=\"#4-为第三方库创建客户端插件\" class=\"headerlink\" title=\"4. 为第三方库创建客户端插件\"></a>4. 为第三方库创建客户端插件</h4><div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// plugins/analytics.client.js - 注意 .client 后缀</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineNuxtPlugin</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这个插件只会在客户端运行</span></span><br><span class=\"line\">  <span class=\"variable language_\">window</span>.<span class=\"property\">dataLayer</span> = <span class=\"variable language_\">window</span>.<span class=\"property\">dataLayer</span> || []</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">gtag</span>(<span class=\"params\"></span>)&#123; dataLayer.<span class=\"title function_\">push</span>(<span class=\"variable language_\">arguments</span>) &#125;</span><br><span class=\"line\">  <span class=\"title function_\">gtag</span>(<span class=\"string\">&#x27;js&#x27;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>())</span><br><span class=\"line\">  <span class=\"title function_\">gtag</span>(<span class=\"string\">&#x27;config&#x27;</span>, <span class=\"string\">&#x27;GA_MEASUREMENT_ID&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>服务端渲染 (SSR) 的本质是<strong>静态化</strong>，它擅长的是：</p>\n<ul>\n<li><strong>生成初始 HTML 内容</strong></li>\n<li><strong>提供更好的 SEO</strong></li>\n<li><strong>提升首屏加载性能</strong></li>\n</ul>\n<p>而<strong>动态交互</strong>和<strong>浏览器依赖</strong>永远是 SSR 的盲区，必须交给客户端处理。</p>\n<p><strong>因此，一个成熟的 Nuxt 应用是两者结合的“混合体”：</strong></p>\n<ol>\n<li><strong>服务端</strong>：生成静态结构和首屏内容。</li>\n<li><strong>客户端</strong>：“激活”页面，接管所有交互，并加载那些依赖浏览器环境的动态功能。</li>\n</ol>\n<p>你的工作就是清晰地界定哪些逻辑属于服务端，哪些属于客户端，并使用 Nuxt 提供的模式（<code>onMounted</code>, <code>&lt;ClientOnly&gt;</code>, <code>.client</code> 插件）将它们优雅地结合起来。</p>\n<h2 id=\"nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\"><a href=\"#nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\" class=\"headerlink\" title=\"nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\"></a>nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？</h2><p>这是一个非常好的问题，它触及了 Nuxt 全栈架构的核心优势。</p>\n<p><strong>简单而直接的答案是：不会。在客户端激活后，向同源的 Nuxt 中间件或 API 路由发起请求，绝对不会产生跨域问题。</strong></p>\n<p>这是因为你发起请求的目标和你的页面来源是<strong>完全同源的</strong>。</p>\n<hr>\n<h3 id=\"为什么不会跨域？——-同源策略详解\"><a href=\"#为什么不会跨域？——-同源策略详解\" class=\"headerlink\" title=\"为什么不会跨域？—— 同源策略详解\"></a>为什么不会跨域？—— 同源策略详解</h3><p>让我们回顾一下“同源策略”：当协议、域名、端口都相同时，即为同源，浏览器允许请求。</p>\n<p>假设你的 Nuxt 应用部署在：<br><code>https://www.my-app.com</code></p>\n<ol>\n<li><strong>你的页面来源</strong>：<br>浏览器中显示的地址是：<code>https://www.my-app.com/some-page</code></li>\n<li><strong>你请求的目标</strong>：<br>你在代码中发起的请求是：</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用相对路径，目标自动补全为：https://www.my-app.com/api/hello</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/hello&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用 useFetch（同样基于相对路径）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/auth/user&#x27;</span>);</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"3\">\n<li><strong>对比</strong>：<ul>\n<li><strong>协议</strong>：都是 <code>https</code></li>\n<li><strong>域名</strong>：都是 <code>www.my-app.com</code></li>\n<li><strong>端口</strong>：都是 <code>443</code> (HTTPS 默认端口)</li>\n</ul>\n</li>\n</ol>\n<p><strong>结论</strong>：<strong>完全同源</strong>，浏览器欣然放行，没有任何跨域限制。</p>\n<hr>\n<h3 id=\"Nuxt-如何处理这些请求？——-请求生命周期\"><a href=\"#Nuxt-如何处理这些请求？——-请求生命周期\" class=\"headerlink\" title=\"Nuxt 如何处理这些请求？—— 请求生命周期\"></a>Nuxt 如何处理这些请求？—— 请求生命周期</h3><p>理解这个过程能让你更清楚为什么这是安全的：</p>\n<p>如图所示，无论是开发还是生产环境，<strong>你的 API 请求和前端页面都由同一个主机处理</strong>。它们处于同一个“生态系统”内，通信是内部的、安全的，不存在跨域问题。</p>\n<hr>\n<h3 id=\"什么情况下会有跨域问题？\"><a href=\"#什么情况下会有跨域问题？\" class=\"headerlink\" title=\"什么情况下会有跨域问题？\"></a>什么情况下会有跨域问题？</h3><p>只有当你的<strong>页面来源</strong>和<strong>请求目标</strong>不同源时，才会触发跨域。例如：</p>\n<table>\n<thead>\n<tr>\n<th>你的页面在</th>\n<th>你请求的目标</th>\n<th>是否跨域</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>https://www.my-app.com</code></td>\n<td><code>https://www.my-app.com/api/hello</code></td>\n<td><strong>否</strong></td>\n<td>同源</td>\n</tr>\n<tr>\n<td><code>https://www.my-app.com</code></td>\n<td><code>https://api.my-app.com</code></td>\n<td><strong>是</strong></td>\n<td>子域名不同 (<code>www</code> vs <code>api</code>)</td>\n</tr>\n<tr>\n<td><code>http://localhost:3000</code></td>\n<td><code>https://api.third-party.com</code></td>\n<td><strong>是</strong></td>\n<td>完全不同的域名</td>\n</tr>\n<tr>\n<td><code>https://www.my-app.com</code></td>\n<td><code>http://www.my-app.com/api/hello</code></td>\n<td><strong>是</strong></td>\n<td>协议不同 (<code>https</code>vs <code>http</code>)</td>\n</tr>\n</tbody></table>\n<p><strong>对于最后一种情况（生产环境前后端分离），解决方案是：</strong></p>\n<ol>\n<li><strong>后端配置 CORS</strong>：在你的 <code>api.my-app.com</code> 服务器上设置 <code>Access-Control-Allow-Origin: https://www.my-app.com</code> 响应头。</li>\n<li><strong>使用反向代理</strong>：配置你的生产服务器（如 Nginx），将对 <code>/api/</code> 的请求代理到 <code>api.my-app.com</code>，让浏览器始终觉得是在请求同源地址。这是更推荐的做法。</li>\n</ol>\n<h3 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>在 Nuxt 应用中，请求自身的 API 路由 (</strong><code>**/api/xxx**</code><strong>) 或服务器中间件是绝对同源的，没有跨域问题。</strong></li>\n<li>这是 Nuxt 全栈框架的巨大优势之一，它简化了开发，让你无需在开发阶段为 CORS 烦恼。</li>\n<li>跨域问题只会在你请求<strong>外部第三方 API</strong> 且对方未正确配置 CORS 时出现。</li>\n<li>如果你的生产环境是前后端完全分离的（不同域），那么需要在生产环境的<strong>后端配置 CORS</strong> 或通过<strong>反向代理</strong>来解决。</li>\n</ul>\n<p>所以，请放心地在你的 Nuxt 应用内部调用 API，这是最安全、最正确的做法。</p>\n<h2 id=\"那如果对后端接口-另一台服务器上-的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\"><a href=\"#那如果对后端接口-另一台服务器上-的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\" class=\"headerlink\" title=\"那如果对后端接口(另一台服务器上)的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\"></a>那如果对后端接口(另一台服务器上)的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？</h2><p><strong>你的这个思路非常棒，完全正确！</strong> 这正是构建现代 Web 应用的一种核心架构模式，被称为 <strong>“BFF（Backend For Frontend）模式”</strong> 或 <strong>“API 网关模式”</strong>。</p>\n<p>你的推理链条是：</p>\n<ol>\n<li><strong>所有客户端请求</strong>都只发往<strong>同源</strong>的 Nuxt 服务器（<code>/api/proxy</code>）。</li>\n<li>Nuxt 服务器上的<strong>中间件</strong>接收到请求后，<strong>代为转发</strong>给真正的后端服务器。</li>\n<li>由于服务器之间通信（Nuxt Server -&gt; Your Backend Server）<strong>没有跨域限制</strong>，所以问题迎刃而解。</li>\n</ol>\n<p>这个方案<strong>在理论上是完全可行且非常优雅的</strong>，它确实可以让你<strong>完全摆脱 CORS 的困扰</strong>。</p>\n<hr>\n<h3 id=\"这种架构的详细工作流程\"><a href=\"#这种架构的详细工作流程\" class=\"headerlink\" title=\"这种架构的详细工作流程\"></a>这种架构的详细工作流程</h3><p>如图所示，浏览器始终只与 <code>my-nuxt-app.com</code> 通信，完美符合同源策略。</p>\n<hr>\n<h3 id=\"优缺点分析：这是否是“万能药”？\"><a href=\"#优缺点分析：这是否是“万能药”？\" class=\"headerlink\" title=\"优缺点分析：这是否是“万能药”？\"></a>优缺点分析：这是否是“万能药”？</h3><p>虽然这个方案能根治跨域，但它也引入了一些新的考虑因素：</p>\n<h4 id=\"优点-✅\"><a href=\"#优点-✅\" class=\"headerlink\" title=\"优点 ✅\"></a>优点 ✅</h4><ol>\n<li><strong>彻底解决 CORS</strong>：前端开发者完全无需再关心跨域配置，开发体验极其流畅。</li>\n<li><strong>隐藏后端架构</strong>：真正的后端地址、端口、API 结构对客户端完全隐藏，更安全。</li>\n<li><strong>协议转换</strong>：可以轻松地在 Nuxt 中处理 HTTPS -&gt; HTTP 的请求（服务器间通信允许）。</li>\n<li><strong>数据处理与聚合</strong>：你可以在 Nuxt 中间件中对多个后端服务的返回值进行聚合、过滤、转换，为前端提供最合适的数据结构，减少前端请求次数。</li>\n</ol>\n<h4 id=\"缺点与需要考虑的因素-⚠️\"><a href=\"#缺点与需要考虑的因素-⚠️\" class=\"headerlink\" title=\"缺点与需要考虑的因素 ⚠️\"></a>缺点与需要考虑的因素 ⚠️</h4><ol>\n<li><strong>额外的网络跳转</strong>：所有请求都多经过一环（浏览器 -&gt; Nuxt -&gt; 真实后端），<strong>会增加微小的延迟</strong>。对于延迟敏感的应用需要优化。</li>\n<li><strong>单点压力与故障点</strong>：Nuxt 服务器现在成为了所有 API 流量的入口。如果它宕机，所有请求都会失败。需要保证其高可用性。</li>\n<li><strong>复杂性转移</strong>：虽然前端变简单了，但 Nuxt 层（BFF 层）的逻辑变复杂了。你需要在这里编写转发、错误处理、认证等逻辑。</li>\n<li><strong>认证问题</strong>：如果后端 API 需要认证，你需要决定如何传递认证信息。<ul>\n<li><strong>方案A（推荐）</strong>：浏览器将认证 Token 发给 Nuxt，Nuxt 再原样转发给后端。</li>\n<li><strong>方案B</strong>：Nuxt 服务器自己持有访问后端的凭证，替用户与后端通信。但这需要非常小心地管理权限。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"如何实现？\"><a href=\"#如何实现？\" class=\"headerlink\" title=\"如何实现？\"></a>如何实现？</h3><p>在 Nuxt 中，你通常使用 <strong>API 路由</strong> 或 <strong>服务器中间件</strong> 来实现，而不是普通的中间件，因为它们专门处理服务器逻辑。</p>\n<p><strong>示例：在 <strong><code>**server/api/proxy/[...].ts**</code></strong> 中创建一个捕获所有路由的 API</strong></p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server/api/proxy/[...].ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineEventHandler</span>(<span class=\"title function_\">async</span> (event) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 获取请求路径和方法</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = <span class=\"title function_\">getRouterParam</span>(event, <span class=\"string\">&#x27;path&#x27;</span>) <span class=\"comment\">// 获取 ... 通配符参数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> method = <span class=\"title function_\">getMethod</span>(event)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> body = method === <span class=\"string\">&#x27;GET&#x27;</span> ? <span class=\"literal\">undefined</span> : <span class=\"keyword\">await</span> <span class=\"title function_\">readBody</span>(event)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 定义你的真实后端基础 URL（应从环境变量读取！）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> baseURL = <span class=\"string\">&#x27;https://your-real-backend.com/api&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> targetURL = <span class=\"string\">`<span class=\"subst\">$&#123;baseURL&#125;</span>/<span class=\"subst\">$&#123;path&#125;</span>`</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 可选：处理认证（例如，将前端传来的 token 转发给后端）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> headers = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> authHeader = <span class=\"title function_\">getHeader</span>(event, <span class=\"string\">&#x27;authorization&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (authHeader) &#123;</span><br><span class=\"line\">    headers[<span class=\"string\">&#x27;Authorization&#x27;</span>] = authHeader</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 4. 代理请求到真实后端</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> $fetch.<span class=\"title function_\">raw</span>(targetURL, &#123;</span><br><span class=\"line\">      method,</span><br><span class=\"line\">      body,</span><br><span class=\"line\">      headers,</span><br><span class=\"line\">      <span class=\"comment\">// 重要：转发查询参数 (?foo=bar)</span></span><br><span class=\"line\">      <span class=\"attr\">query</span>: <span class=\"title function_\">getQuery</span>(event),</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 5. 可选：根据需要设置响应头</span></span><br><span class=\"line\">    <span class=\"title function_\">setHeaders</span>(event, response.<span class=\"property\">headers</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 6. 返回后端响应的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.<span class=\"property\">_data</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 7. 错误处理，将后端错误返回给前端</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"title function_\">createError</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">statusCode</span>: error.<span class=\"property\">statusCode</span> || <span class=\"number\">500</span>,</span><br><span class=\"line\">      <span class=\"attr\">statusMessage</span>: error.<span class=\"property\">statusMessage</span> || <span class=\"string\">&#x27;Internal Server Error&#x27;</span>,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n\n<p>这样，前端所有发往 <code>/api/proxy/items</code>、<code>/api/proxy/user/profile</code> 的请求，都会被这个 handler 捕获，并转发到 <code>https://your-real-backend.com/api/items</code> 和 <code>https://your-real-backend.com/api/user/profile</code>。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p><strong>是的，你的想法是完全正确且高效的。通过让 Nuxt 服务器作为所有后端请求的代理，你可以一劳永逸地解决跨域问题，无需在开发或生产环境配置任何 CORS 或代理规则。</strong></p>\n<p>这不仅是解决跨域的手段，更是一种先进的<strong>架构设计选择</strong>（BFF）。它特别适用于：</p>\n<ul>\n<li>中大型前后端分离项目。</li>\n<li>需要集成多个后端微服务的复杂前端。</li>\n<li>希望简化前端开发流程，将复杂性集中到 BFF 层的团队。</li>\n</ul>\n<p>你只需要评估其带来的<strong>额外延迟</strong>和<strong>单点压力</strong>是否在你的应用可接受范围内即可。对于绝大多数应用来说，这个方案的利远大于弊。</p>\n","excerpt":"","more":"<h2 id=\"Nuxt-js的ssr服务端渲染原理\"><a href=\"#Nuxt-js的ssr服务端渲染原理\" class=\"headerlink\" title=\"Nuxt.js的ssr服务端渲染原理\"></a>Nuxt.js的ssr服务端渲染原理</h2><p>Nuxt.js 的 SSR（服务端渲染）原理是一个非常核心且有趣的话题。它并不是简单的“在服务器上跑 Vue”，而是一套完整的、精心设计的架构。</p>\n<p>简单来说，它的核心原理是：<strong>“首屏在服务器提前渲染成 HTML，之后在客户端‘激活’为 SPA”。</strong></p>\n<p>下面我们分步拆解这个过程的原理、优势和关键实现。</p>\n<hr>\n<h3 id=\"一、核心目标：解决什么問題？\"><a href=\"#一、核心目标：解决什么問題？\" class=\"headerlink\" title=\"一、核心目标：解决什么問題？\"></a>一、核心目标：解决什么問題？</h3><ol>\n<li><strong>SEO（搜索引擎优化）</strong>：传统 SPA（单页应用）返回的是一个空的 HTML 壳，内容由 JavaScript 动态填充。搜索引擎爬虫可能无法等待和执行 JS，导致无法收录内容。SSR 直接返回渲染好的完整 HTML，利于爬虫抓取。</li>\n<li><strong>更快的内容到达时间</strong>：用户浏览器无需等待所有 JavaScript 下载和执行完毕才能看到内容。服务器直接返回了渲染好的 HTML，首屏内容可以立即展示，感知性能极大提升。</li>\n</ol>\n<h3 id=\"二、Nuxt-js-SSR-的核心工作流程\"><a href=\"#二、Nuxt-js-SSR-的核心工作流程\" class=\"headerlink\" title=\"二、Nuxt.js SSR 的核心工作流程\"></a>二、Nuxt.js SSR 的核心工作流程</h3><p>Nuxt.js 的 SSR 过程可以清晰地分为两个阶段：<strong>服务端渲染</strong>和<strong>客户端激活</strong>。下图展示了从用户请求到页面可交互的完整生命周期：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/nuxt核心工作流.png\"\n                      alt=\"nuxt核心工作流\" width=\"60%\" height=\"auto\" style=\"display:block;\"\n                >\n\n<h4 id=\"第一阶段：服务端渲染（Server-Side）\"><a href=\"#第一阶段：服务端渲染（Server-Side）\" class=\"headerlink\" title=\"第一阶段：服务端渲染（Server-Side）\"></a>第一阶段：服务端渲染（Server-Side）</h4><p>这个过程发生在 <strong>Nuxt 服务器</strong>（一个 Node.js 服务器）上。</p>\n<ol>\n<li><strong>接收请求</strong>：用户浏览器请求一个 URL，请求到达 Nuxt 服务器。</li>\n<li><strong>创建应用实例</strong>：Nuxt 服务器为这次请求<strong>创建一个全新的 Vue 应用实例、Router 和 Store</strong>。这是关键，确保了每个请求的隔离性。</li>\n<li><strong>路由匹配</strong>：根据请求的 URL，Nuxt Router 确定要渲染哪个页面组件（如 <code>pages/about.vue</code>）。</li>\n<li><strong>数据预取</strong>：Nuxt 会调用页面组件中定义的<strong>异步数据获取方法</strong>（如 <code>asyncData</code>、<code>useAsyncData</code>、<code>useFetch</code>）。<strong>这些方法会在服务端执行</strong>。<ul>\n<li>服务器会等待这些异步操作完成，再去渲染组件。这确保了渲染出的 HTML 是包含数据的。</li>\n</ul>\n</li>\n<li><strong>渲染 HTML</strong>：<ul>\n<li>将获取到的数据<strong>注入到 Vuex Store 或组件状态</strong>中。</li>\n<li>调用 Vue 的 <code>vue-server-renderer</code>（Vue 2）或 <code>@vue/server-renderer</code>（Vue 3）的 <code>renderToString()</code> 函数。</li>\n<li>这个函数会运行 Vue 组件，但它<strong>不是在浏览器中创建真实 DOM，而是在内存中生成一个完整的 HTML 字符串</strong>。</li>\n</ul>\n</li>\n<li><strong>构建最终文档</strong>：Nuxt 将这个 HTML 字符串插入到HTML模板（<code>app.html</code>）中。同时，<strong>将预取的数据序列化后内联到 HTML 中</strong>（通常是在一个 <code>&lt;script&gt;</code> 标签里，如 <code>window.__NUXT__ = &#123;...&#125;</code>），这个过程称为 <strong>状态脱水</strong>。</li>\n<li><strong>响应</strong>：将这个完整的、包含数据和内容的 HTML 文档发送给客户端。</li>\n</ol>\n<h4 id=\"第二阶段：客户端激活（Client-Side-Hydration）\"><a href=\"#第二阶段：客户端激活（Client-Side-Hydration）\" class=\"headerlink\" title=\"第二阶段：客户端激活（Client-Side Hydration）\"></a>第二阶段：客户端激活（Client-Side Hydration）</h4><p>这个过程发生在<strong>用户浏览器</strong>上。</p>\n<ol>\n<li><strong>静态内容展示</strong>：浏览器收到服务器返回的 HTML 后，<strong>无需等待任何 JavaScript，就能立即解析和显示页面内容</strong>。这是首屏速度快的根本原因。</li>\n<li><strong>加载资源</strong>：浏览器开始加载页面中引用的 JavaScript 和 CSS 资源（Nuxt 打包好的客户端 bundle）。</li>\n<li><strong>Vue 接管（Hydration -“混合”）</strong>：这是最精妙的一步。<ul>\n<li>客户端的 Vue 应用也会被创建和初始化。</li>\n<li>Vue 不会像传统 SPA 那样清空 DOM 再重新渲染。相反，它会<strong>将虚拟 DOM 与服务器渲染好的现有静态 HTML 结构进行“混合”</strong>。</li>\n<li>它会将事件监听器、Vue 的响应式系统等“激活”到这些静态元素上，使其变成一个完全交互式的 Vue 应用。</li>\n</ul>\n</li>\n<li><strong>变为 SPA</strong>：激活完成后，应用就切换到了正常的 SPA 模式。后续的页面导航不会再向服务器请求完整的 HTML，而是由客户端 Router 管理，只获取必要的数据，实现无刷新跳转。</li>\n</ol>\n<hr>\n<h3 id=\"三、Nuxt-js-实现-SSR-的关键技术点\"><a href=\"#三、Nuxt-js-实现-SSR-的关键技术点\" class=\"headerlink\" title=\"三、Nuxt.js 实现 SSR 的关键技术点\"></a>三、Nuxt.js 实现 SSR 的关键技术点</h3><ol>\n<li><strong>双入口构建（Dual Entry Points）</strong>：<ul>\n<li>Nuxt 使用 Webpack&#x2F;Vite 分别打包<strong>两个版本</strong>的代码：<ul>\n<li><strong>服务端 Bundle</strong>：用于 <code>renderToString</code>，它知道如何在 Node.js 环境中渲染组件。</li>\n<li><strong>客户端 Bundle</strong>：用于在浏览器中“激活”静态页面并处理后续交互。</li>\n</ul>\n</li>\n<li>这是通过 <code>webpack</code> 的 <code>target: &#39;node&#39;</code> 和 <code>target: &#39;web&#39;</code> 分别配置实现的。</li>\n</ul>\n</li>\n<li><strong>数据预取与状态同步</strong>：<ul>\n<li>服务端获取的数据必须<strong>安全地传递到客户端</strong>，否则客户端 Vue 在初始化时没有数据，会导致虚拟 DOM 与服务器渲染的 HTML 不匹配，激活失败。</li>\n<li>Nuxt 通过 <code>window.__NUXT__</code> 对象将数据从服务器“脱水”到客户端“补水”，保证两端状态一致。</li>\n</ul>\n</li>\n<li><strong>生命周期</strong>：<ul>\n<li>在 SSR 过程中，<strong>只有</strong>** <strong><code>**beforeCreate**</code></strong> <strong><strong>和</strong></strong> <strong><code>**created**</code></strong> **<strong>这两个生命周期钩子会在服务端执行</strong>。</li>\n<li><code>mounted</code>、<code>beforeMount</code> 等只在客户端执行。因此，<strong>在</strong>** <strong><code>**created**</code></strong> <strong><strong>中操作</strong></strong> <strong><code>**window**</code></strong> **<strong>或 DOM 会报错</strong>。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"四、Universal-Mode-同构渲染\"><a href=\"#四、Universal-Mode-同构渲染\" class=\"headerlink\" title=\"四、Universal Mode (同构渲染)\"></a>四、Universal Mode (同构渲染)</h3><p>Nuxt.js 的 SSR 通常被称为 <strong>“Universal”应用</strong>或**“同构”应用**。</p>\n<ul>\n<li><strong>同构代码</strong>：同一份 Vue 组件代码（<code>.vue</code> 文件）既可以在<strong>服务器</strong>上运行（用于首屏生成 HTML），也可以在<strong>客户端</strong>运行（用于激活和后续交互）。</li>\n<li><strong>优势</strong>：开发者只需写一套代码，Nuxt 负责处理双端的构建和渲染协调，开发体验非常流畅。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Nuxt.js 的 SSR 原理可以概括为：</p>\n<ol>\n<li><strong>服务端</strong>：为每个请求即时创建 Vue 应用，预先获取数据，渲染出包含内容的 HTML 字符串，并将数据状态一同返回。</li>\n<li><strong>客户端</strong>：快速展示静态内容，然后加载 JS，由 Vue 将静态页面“激活”为可交互的 SPA，最后接管所有后续导航。</li>\n</ol>\n<p>它完美地结合了<strong>传统服务端渲染首屏快、SEO 好</strong>的优势和<strong>单页应用用户体验流畅、交互丰富</strong>的优势，是现代 Web 应用开发的绝佳选择。</p>\n<h2 id=\"nuxt中调后端接口怎么做，要注意什么？\"><a href=\"#nuxt中调后端接口怎么做，要注意什么？\" class=\"headerlink\" title=\"nuxt中调后端接口怎么做，要注意什么？\"></a>nuxt中调后端接口怎么做，要注意什么？</h2><p>在 Nuxt.js 中调用后端接口是其核心功能之一，但根据你使用的 API 风格（Composition API 或 Options API）和渲染模式（SSR 或 SPA），做法和注意事项有所不同。</p>\n<p>下面将为你提供全面的指南，包括方法、最佳实践和常见陷阱。</p>\n<hr>\n<h3 id=\"一、如何调用后端接口？\"><a href=\"#一、如何调用后端接口？\" class=\"headerlink\" title=\"一、如何调用后端接口？\"></a>一、如何调用后端接口？</h3><p>Nuxt 3 推荐使用 Composition API，并提供了强大的组合式函数。</p>\n<h4 id=\"1-使用-useFetch-useAsyncData-Composition-API-首选\"><a href=\"#1-使用-useFetch-useAsyncData-Composition-API-首选\" class=\"headerlink\" title=\"1. 使用 useFetch &#x2F; useAsyncData (Composition API - 首选)\"></a>1. 使用 <code>useFetch</code> &#x2F; <code>useAsyncData</code> (Composition API - 首选)</h4><p>这是 Nuxt 3 中最现代、最推荐的方式，它完美处理了服务端和客户端的数据获取。</p>\n<p><strong>基本用法 (</strong><code>**useFetch**</code><strong>)：</strong><br><code>useFetch</code> 是专门为获取数据而设计的语法糖。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 直接在模板中使用，无需 .value</span><br><span class=\"line\">const &#123; data: posts, pending, error, refresh &#125; = useFetch(&#x27;/api/posts&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者指定完整 URL（注意配置代理或 CORS）</span><br><span class=\"line\">const &#123; data: users &#125; = useFetch(&#x27;https://api.example.com/users&#x27;, &#123;</span><br><span class=\"line\">  // 可选项：在客户端才获取数据（代替 onMounted + ref）</span><br><span class=\"line\">  // lazy: true,</span><br><span class=\"line\">  // server: false</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;pending&quot;&gt;Loading...&lt;/div&gt;</span><br><span class=\"line\">  &lt;div v-else-if=&quot;error&quot;&gt;Error: &#123;&#123; error.message &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">  &lt;ul v-else&gt;</span><br><span class=\"line\">    &lt;li v-for=&quot;post in posts&quot; :key=&quot;post.id&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/li&gt;</span><br><span class=\"line\">  &lt;/ul&gt;</span><br><span class=\"line\">  &lt;button @click=&quot;refresh&quot;&gt;Refresh&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>高级用法 (</strong><code>**useAsyncData**</code>** + <strong><code>**$fetch**</code></strong>)：**<br>当你需要更复杂的逻辑时（如多个请求、数据处理），使用 <code>useAsyncData</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">const &#123; data: combinedData, refresh &#125; = useAsyncData(&#x27;unique-key&#x27;, async () =&gt; &#123;</span><br><span class=\"line\">  // 这里可以写任何复杂的异步逻辑</span><br><span class=\"line\">  const [posts, users] = await Promise.all([</span><br><span class=\"line\">    $fetch(&#x27;/api/posts&#x27;),</span><br><span class=\"line\">    $fetch(&#x27;/api/users&#x27;)</span><br><span class=\"line\">  ])</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 对数据进行转换</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    posts: posts.map(post =&gt; (&#123; ...post, title: post.title.toUpperCase() &#125;)),</span><br><span class=\"line\">    users</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-使用-fetch-直接调用\"><a href=\"#2-使用-fetch-直接调用\" class=\"headerlink\" title=\"2. 使用 $fetch 直接调用\"></a>2. 使用 <code>$fetch</code> 直接调用</h4><p>Nuxt 3 内置了基于 <a class=\"link\"   href=\"https://github.com/unjs/ofetch\" >ofetch<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 的 <code>$fetch</code> 工具，可以在任何地方使用（如事件处理函数中）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">const handleSubmit = async () =&gt; &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    const response = await $fetch(&#x27;/api/submit&#x27;, &#123;</span><br><span class=\"line\">      method: &#x27;POST&#x27;,</span><br><span class=\"line\">      body: &#123; name: &#x27;John Doe&#x27; &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    console.log(&#x27;Success:&#x27;, response)</span><br><span class=\"line\">  &#125; catch (error) &#123;</span><br><span class=\"line\">    console.error(&#x27;Error:&#x27;, error)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-使用-useLazyFetch-useLazyAsyncData\"><a href=\"#3-使用-useLazyFetch-useLazyAsyncData\" class=\"headerlink\" title=\"3. 使用 useLazyFetch &#x2F; useLazyAsyncData\"></a>3. 使用 <code>useLazyFetch</code> &#x2F; <code>useLazyAsyncData</code></h4><p>它们是 <code>useFetch</code> 和 <code>useAsyncData</code> 的变体，<code>lazy: true</code> 是默认行为。<strong>不会阻塞导航</strong>，适用于非关键数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 不会阻塞路由导航，你需要自己处理 data 为 null 的情况</span><br><span class=\"line\">const &#123; data: nonCriticalData &#125; = useLazyFetch(&#x27;/api/non-critical-data&#x27;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;data&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 渲染数据 --&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、最重要的注意事项\"><a href=\"#二、最重要的注意事项\" class=\"headerlink\" title=\"二、最重要的注意事项\"></a>二、最重要的注意事项</h3><h4 id=\"1-服务端渲染-SSR-vs-客户端渲染-CSR-行为\"><a href=\"#1-服务端渲染-SSR-vs-客户端渲染-CSR-行为\" class=\"headerlink\" title=\"1. 服务端渲染 (SSR) vs 客户端渲染 (CSR) 行为\"></a>1. 服务端渲染 (SSR) vs 客户端渲染 (CSR) 行为</h4><p>这是 <strong>最核心、最容易出错</strong> 的点！</p>\n<ul>\n<li><strong>默认行为</strong>：<code>useFetch</code> 和 <code>useAsyncData</code> <strong>会在服务端执行</strong>。这意味着：<ul>\n<li><strong>好处</strong>：返回的 HTML 直接包含数据，利于 SEO 和首屏加载。</li>\n<li><strong>陷阱</strong>：<strong>不能在它们内部或</strong>** <strong><code>**created**</code></strong> **<strong>生命周期中使用浏览器API</strong>（如 <code>window</code>, <code>document</code>, <code>localStorage</code>）。</li>\n</ul>\n</li>\n<li><strong>如何控制</strong>：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 选项 1: 强制只在客户端执行</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/data&#x27;</span>, &#123; <span class=\"attr\">server</span>: <span class=\"literal\">false</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 选项 2: 使用 useLazyFetch (默认不会阻塞导航，且在客户端执行)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useLazyFetch</span>(<span class=\"string\">&#x27;/api/data&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 选项 3: 在 onMounted 钩子中用 $fetch</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = <span class=\"title function_\">ref</span>(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"title function_\">onMounted</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  data.<span class=\"property\">value</span> = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/data&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-处理-CORS-跨域资源共享\"><a href=\"#2-处理-CORS-跨域资源共享\" class=\"headerlink\" title=\"2. 处理 CORS (跨域资源共享)\"></a>2. 处理 CORS (跨域资源共享)</h4><p>如果你调用的接口不在同一个域下，会遇到 CORS 问题。</p>\n<ul>\n<li><strong>开发环境</strong>：在 <code>nuxt.config.ts</code> 中配置代理是最佳实践。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// nuxt.config.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineNuxtConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 其他配置</span></span><br><span class=\"line\">  <span class=\"attr\">nitro</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">routeRules</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;/api/**&#x27;</span>: &#123; <span class=\"attr\">proxy</span>: <span class=\"string\">&#x27;https://api.example.com/**&#x27;</span> &#125;, <span class=\"comment\">// 代理 API 请求</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 或者使用旧的 devServer 配置 (v3.0+ 推荐使用 nitro)</span></span><br><span class=\"line\">  <span class=\"comment\">// devServer: &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   proxy: &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//     &#x27;/api&#x27;: &#x27;https://api.example.com&#x27;</span></span><br><span class=\"line\">  <span class=\"comment\">//   &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后你在代码中请求 <code>/api/users</code>，开发服务器会将其代理到 <code>https://api.example.com/api/users</code>，避免 CORS。</li>\n<li><strong>生产环境</strong>：<ul>\n<li><strong>最佳方案</strong>：配置你的<strong>反向代理</strong>（如 Nginx）来处理跨域请求。</li>\n<li><strong>备选方案</strong>：确保后端 API 正确配置了 CORS 头 (<code>Access-Control-Allow-Origin</code> 等)。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-认证和令牌-Authentication\"><a href=\"#3-认证和令牌-Authentication\" class=\"headerlink\" title=\"3. 认证和令牌 (Authentication)\"></a>3. 认证和令牌 (Authentication)</h4><p>如何安全地传递身份验证信息（如 JWT Token）。</p>\n<ul>\n<li><strong>使用请求拦截器</strong>：利用 <code>ofetch</code> 的自动全局拦截器。</li>\n<li>如何安全地传递身份验证信息（如 JWT Token）。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// plugins/api.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineNuxtPlugin</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; token &#125; = <span class=\"title function_\">useAuth</span>() <span class=\"comment\">// 假设你有一个获取 token 的 composable</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 全局拦截 $fetch 请求</span></span><br><span class=\"line\">  globalThis.<span class=\"property\">$fetch</span> = $fetch.<span class=\"title function_\">create</span>(&#123;</span><br><span class=\"line\">    <span class=\"title function_\">onRequest</span>(<span class=\"params\">&#123; request, options &#125;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 添加认证头</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (token.<span class=\"property\">value</span>) &#123;</span><br><span class=\"line\">        options.<span class=\"property\">headers</span> = &#123;</span><br><span class=\"line\">          ...options.<span class=\"property\">headers</span>,</span><br><span class=\"line\">          <span class=\"title class_\">Authorization</span>: <span class=\"string\">`Bearer <span class=\"subst\">$&#123;token.value&#125;</span>`</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">onRequestError</span>(<span class=\"params\">&#123; error &#125;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;Request error:&#x27;</span>, error)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">onResponseError</span>(<span class=\"params\">&#123; response &#125;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 统一处理 401 未授权错误</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (response.<span class=\"property\">status</span> === <span class=\"number\">401</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 跳转到登录页</span></span><br><span class=\"line\">        <span class=\"title function_\">navigateTo</span>(<span class=\"string\">&#x27;/login&#x27;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-错误处理\"><a href=\"#4-错误处理\" class=\"headerlink\" title=\"4. 错误处理\"></a>4. 错误处理</h4><p>永远不要假设请求一定会成功。</p>\n<ul>\n<li><strong>使用 try-catch</strong>：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/endpoint&#x27;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Nuxt 3 的 $fetch 会自动抛出错误</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;API call failed:&#x27;</span>, error)</span><br><span class=\"line\">  <span class=\"comment\">// 在这里显示用户友好的错误信息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>使用 <strong><code>**useFetch**</code></strong> 的状态</strong>：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">const &#123; data, error &#125; = useFetch(&#x27;/api/endpoint&#x27;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;error&quot;&gt;</span><br><span class=\"line\">    Failed to load data: &#123;&#123; error.message &#125;&#125;</span><br><span class=\"line\">    &lt;button @click=&quot;refresh&quot;&gt;Try Again&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-性能优化：避免重复请求\"><a href=\"#5-性能优化：避免重复请求\" class=\"headerlink\" title=\"5. 性能优化：避免重复请求\"></a>5. 性能优化：避免重复请求</h4><ul>\n<li><strong>Key 的妙用</strong>：<code>useAsyncData</code> 和 <code>useFetch</code> 会<strong>自动去重</strong>具有相同 key 的请求。确保为唯一的数据集提供唯一的 key。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果两个组件使用相同的 key，只会发出一个请求</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useAsyncData</span>(<span class=\"string\">&#x27;user-profile&#x27;</span>, <span class=\"function\">() =&gt;</span> $fetch(<span class=\"string\">&#x27;/api/profile&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>缓存</strong>：<code>$fetch</code> 默认不会缓存 HTTP 缓存。如果你需要利用 HTTP 缓存，可以在 headers 中设置，或者使用更高级的缓存策略。</li>\n</ul>\n<hr>\n<h3 id=\"三、最佳实践总结\"><a href=\"#三、最佳实践总结\" class=\"headerlink\" title=\"三、最佳实践总结\"></a>三、最佳实践总结</h3><ol>\n<li><strong>首选</strong>** <strong><code>**useFetch**</code></strong>&#x2F;**<code>**useAsyncData**</code>：用于在组件中获取数据，它们能智能处理 SSR 和 hydration。</li>\n<li><strong>明确数据获取时机</strong>：想清楚你需要的数<strong>据是应该在服务端获取（SEO 关键）还是客户端获取（用户相关）</strong>，并用 <code>server: false</code> 或 <code>useLazyFetch</code> 控制。</li>\n<li><strong>开发环境用代理解决 CORS</strong>：在 <code>nuxt.config.ts</code> 中配置代理，避免跨域问题。</li>\n<li><strong>统一处理认证和错误</strong>：通过插件创建配置好的 <code>$fetch</code> 实例，全局处理 token 和错误。</li>\n<li><strong>善待你的 API</strong>：合理使用 key 去重，避免重复请求；考虑分页、限流和缓存。</li>\n</ol>\n<p>遵循这些指南，你就能在 Nuxt 应用中高效、可靠地与后端 API 进行交互。</p>\n<h2 id=\"开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\"><a href=\"#开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\" class=\"headerlink\" title=\"开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\"></a>开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？</h2><p><strong>你这个问题问得非常好，直击要害！你的理解完全正确。</strong></p>\n<p>是的，你的推理是精准的：</p>\n<ul>\n<li><strong>服务端（Node.js）发起的请求</strong>：没有跨域概念。跨域是<strong>浏览器</strong>强加的安全策略。Node.js 发请求就像你用 <code>curl</code> 或 Postman 一样，可以去任何地方，不存在 CORS 问题。</li>\n<li><strong>客户端（浏览器）发起的请求</strong>：受跨域限制。浏览器会拦截违反同源策略的请求。</li>\n</ul>\n<p><strong>因此，“开发环境配置代理” 主要就是为了解决 —— 在客户端发起请求时遇到的跨域问题。</strong></p>\n<hr>\n<h3 id=\"为什么开发环境会有客户端请求？\"><a href=\"#为什么开发环境会有客户端请求？\" class=\"headerlink\" title=\"为什么开发环境会有客户端请求？\"></a>为什么开发环境会有客户端请求？</h3><p>在 Nuxt 3 的 SSR 模式下，一个页面渲染通常涉及<strong>两次</strong>数据获取：</p>\n<ol>\n<li><strong>第一次（服务端请求 - 无 CORS）</strong>：<ul>\n<li>当用户直接访问页面 URL 时，请求会先到达你的 Nuxt 服务器。</li>\n<li>Nuxt 服务器执行 <code>useFetch</code> 或 <code>useAsyncData</code>，<strong>在服务器环境</strong>（Node.js）中向后端 API 发起请求。</li>\n<li>此时是 <strong>服务器对服务器</strong> 的通信，没有浏览器参与，所以<strong>没有 CORS 问题</strong>。</li>\n<li>服务器拿到数据后，渲染出包含内容的 HTML 并返回给浏览器。</li>\n</ul>\n</li>\n<li><strong>第二次（客户端请求 - 有 CORS 风险）</strong>：<ul>\n<li>浏览器收到 HTML 并展示后，会加载 Nuxt 的客户端 JS Bundle。</li>\n<li>Vue 开始 <strong>“激活” (Hydration)</strong> 过程。</li>\n<li>在这个过程中，<code>useFetch</code> 和 <code>useAsyncData</code> 的代码会在<strong>客户端浏览器环境</strong>中再次运行，以确保数据状态一致。</li>\n<li>如果它们的 URL 是<strong>绝对路径</strong>（如 <code>https://api.example.com/data</code>），那么这次请求就是由<strong>浏览器</strong>直接发起的，就会触发 CORS 检查。</li>\n<li>如果后端 API 没有正确配置 CORS 头，浏览器就会拦截这次请求，导致错误。</li>\n</ul>\n</li>\n</ol>\n<p>此外，还有几种常见的<strong>纯客户端请求</strong>场景：</p>\n<ul>\n<li>用户交互（如点击按钮）触发的 <code>$fetch</code> 请求。</li>\n<li>在 <code>onMounted</code> 钩子中发起的请求。</li>\n<li>使用 <code>useLazyFetch</code>（它默认在客户端执行）。</li>\n</ul>\n<h3 id=\"总结与最佳实践\"><a href=\"#总结与最佳实践\" class=\"headerlink\" title=\"总结与最佳实践\"></a>总结与最佳实践</h3><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>请求发起方</th>\n<th>是否有 CORS 问题？</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>SSR 首屏渲染</strong></td>\n<td>Nuxt Server (Node.js)</td>\n<td><strong>否</strong></td>\n<td>无需额外配置。但需确保服务器能访问到 API（网络连通性）。</td>\n</tr>\n<tr>\n<td><strong>CSR Hydration&#x2F;交互</strong></td>\n<td>浏览器</td>\n<td><strong>是</strong></td>\n<td><strong>配置开发服务器代理</strong>（如下方代码）。这是最推荐的方法。</td>\n</tr>\n<tr>\n<td><strong>生产环境</strong></td>\n<td>浏览器</td>\n<td><strong>是</strong></td>\n<td><strong>配置生产级反向代理</strong>（如 Nginx），或确保后端 API 正确设置 CORS 头。</td>\n</tr>\n</tbody></table>\n<h2 id=\"nuxt中的-fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\"><a href=\"#nuxt中的-fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\" class=\"headerlink\" title=\"nuxt中的$fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\"></a>nuxt中的$fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？</h2><p>非常好的问题！这是理解 Nuxt 3 数据获取的关键。它们的执行环境行为是核心区别。</p>\n<p>简单直接的答案是：<strong>不，</strong><code>**$fetch**</code>** <strong><strong>可以在服务端和客户端调用。而</strong></strong> <strong><code>**useFetch**</code></strong> <strong><strong>和</strong></strong> <strong><code>**useAsyncData**</code></strong> **<strong>的行为是智能的，默认在服务端执行。</strong></p>\n<p>下面我们来详细拆解这三者的区别。</p>\n<hr>\n<h3 id=\"一、-fetch：双环境通用的请求工具\"><a href=\"#一、-fetch：双环境通用的请求工具\" class=\"headerlink\" title=\"一、$fetch：双环境通用的请求工具\"></a>一、<code>$fetch</code>：双环境通用的请求工具</h3><p><code>$fetch</code> 是 Nuxt 3 基于 <a class=\"link\"   href=\"https://github.com/unjs/ofetch\" >ofetch<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 提供的全局工具函数。它本身<strong>没有环境限制</strong>，你在哪里调用它，它就在哪个环境执行。</p>\n<ul>\n<li><strong>在服务端（Node.js）调用</strong>：它就像一个普通的 Node.js HTTP 客户端（比如 <code>axios</code>），直接向后端发起请求，<strong>没有跨域概念</strong>。</li>\n<li><strong>在客户端（浏览器）调用</strong>：它的行为类似于原生的 <code>fetch()</code>，但功能更强大（自动处理 JSON、更好的错误处理等），并且<strong>受浏览器跨域策略限制</strong>。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 在组件 setup 中直接调用 - 根据渲染环境决定</span></span><br><span class=\"line\"><span class=\"comment\">// 如果在服务端渲染，它在服务端执行；如果在客户端激活或导航，它在客户端执行。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/items&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在明确的服务端环境调用 - 只在服务端执行</span></span><br><span class=\"line\"><span class=\"comment\">// 例如：在 API 路由、服务器中间件或 plugin 中</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineEventHandler</span>(<span class=\"title function_\">async</span> (event) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;https://external-api.com/data&#x27;</span>); <span class=\"comment\">// 在服务器上运行</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; data &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 在明确的客户端环境调用 - 只在客户端执行</span></span><br><span class=\"line\"><span class=\"comment\">// 例如：在事件处理函数或 onMounted 中</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handleClick</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/items&#x27;</span>); <span class=\"comment\">// 在浏览器中运行，受 CORS 限制</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>**$fetch**</code>** <strong><strong>的陷阱</strong>：如果你在组件顶层直接使用 <code>$fetch</code>（没有包裹在 <code>useAsyncData</code> 或 <code>useFetch</code> 中），并且该组件在服务端渲染，那么请求会在服务端执行。但当客户端激活（Hydration）时，<strong>同样的</strong></strong> <strong><code>**$fetch**</code></strong> **<strong>代码又会在客户端再执行一次</strong>，造成重复请求。</p>\n<hr>\n<h3 id=\"二、useAsyncData-useFetch：智能的双环境数据获取器\"><a href=\"#二、useAsyncData-useFetch：智能的双环境数据获取器\" class=\"headerlink\" title=\"二、useAsyncData &amp; useFetch：智能的双环境数据获取器\"></a>二、<code>useAsyncData</code> &amp; <code>useFetch</code>：智能的双环境数据获取器</h3><p>这两个组合函数是 Nuxt 数据获取的“智能大脑”。它们的关键特性是：<strong>“在服务端预取数据，并自动将数据序列化到客户端，避免重复请求”</strong>。</p>\n<h4 id=\"核心行为：\"><a href=\"#核心行为：\" class=\"headerlink\" title=\"核心行为：\"></a>核心行为：</h4><ol>\n<li><strong>默认在服务端执行</strong>：在 SSR 模式下，当页面首次加载时，它们会在 Nuxt 服务器内部执行，获取数据并直接将数据嵌入到最终返回的 HTML 中。</li>\n<li><strong>在客户端激活</strong>：当 Vue 在客户端“激活”静态页面时，<code>useAsyncData</code> 和 <code>useFetch</code> 会识别到数据已经存在于从服务器传递过来的 payload 中，因此<strong>不会在客户端再次发起请求</strong>，而是直接使用已有的数据。</li>\n<li><strong>后续导航</strong>：当你在客户端通过导航跳转到另一个也使用了这些函数的页面时，它们会在<strong>客户端</strong>执行。</li>\n</ol>\n<h4 id=\"如何控制执行环境？\"><a href=\"#如何控制执行环境？\" class=\"headerlink\" title=\"如何控制执行环境？\"></a>如何控制执行环境？</h4><p>它们提供了一个 <code>server</code> 选项让你精确控制：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认：true - 在服务端执行（SSR 首屏）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/items&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 强制在客户端执行（CSR）</span></span><br><span class=\"line\"><span class=\"comment\">// 适合：用户相关的数据、不需要 SEO 的数据、访问浏览器 API 的数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/user-data&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">server</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// useAsyncData 用法相同</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useAsyncData</span>(<span class=\"string\">&#x27;user-key&#x27;</span>, <span class=\"function\">() =&gt;</span> $fetch(<span class=\"string\">&#x27;/api/user&#x27;</span>), &#123;</span><br><span class=\"line\">  <span class=\"attr\">server</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、三者的对比总结\"><a href=\"#三、三者的对比总结\" class=\"headerlink\" title=\"三、三者的对比总结\"></a>三、三者的对比总结</h3><p>为了更直观地理解，下面的流程图展示了不同调用方式在 Nuxt 应用生命周期中的执行时机和数据流向：</p>\n<p>这个图清晰地展示了：</p>\n<ol>\n<li><code>**useFetch**</code><strong>&#x2F;</strong><code>**useAsyncData**</code> 是贯穿服务端和客户端的“智能通道”，保证了数据的高效同步和无重复请求。</li>\n<li><strong>直接使用</strong>** **<code>**$fetch**</code> 在组件顶层会导致重复请求，是需要避免的反模式。</li>\n<li><strong>在事件中使用的</strong>** **<code>**$fetch**</code> 是纯客户端行为。</li>\n</ol>\n<h3 id=\"最佳实践与选择指南\"><a href=\"#最佳实践与选择指南\" class=\"headerlink\" title=\"最佳实践与选择指南\"></a>最佳实践与选择指南</h3><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐使用的工具</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>获取页面组件所需数据</strong></td>\n<td><code>**useFetch**</code><br/>** <strong><strong>或</strong></strong> **<code>**useAsyncData**</code></td>\n<td>自动处理 SSR&#x2F;CSR，避免重复请求，数据序列化到客户端。</td>\n</tr>\n<tr>\n<td><strong>在事件处理、</strong><code>**onMounted**</code><br/>** **<strong>中获取数据</strong></td>\n<td><code>**$fetch**</code></td>\n<td>明确需要在客户端触发的请求。</td>\n</tr>\n<tr>\n<td><strong>在 API 路由或服务器中间件中</strong></td>\n<td><code>**$fetch**</code></td>\n<td>明确的服务端环境，无需 <code>useAsyncData</code><br/> 的额外功能。</td>\n</tr>\n<tr>\n<td><strong>需要复杂的数据获取逻辑</strong></td>\n<td><code>**useAsyncData**</code><br/>** <strong><strong>+</strong></strong> **<code>**$fetch**</code></td>\n<td><code>useAsyncData</code><br/> 提供状态管理，内部函数可使用 <code>$fetch</code><br/> 进行复杂操作。</td>\n</tr>\n<tr>\n<td><strong>简单的 URL 请求</strong></td>\n<td><code>**useFetch**</code></td>\n<td>最简洁的写法。</td>\n</tr>\n</tbody></table>\n<p><strong>一句话总结：</strong></p>\n<ul>\n<li><strong>用</strong>** <strong><code>**useFetch**</code></strong>&#x2F;<strong><code>**useAsyncData**</code> 来获取</strong>组件初始化时所需的数据**，让 Nuxt 智能决定执行环境。</li>\n<li><strong>用</strong>** <strong><code>**$fetch**</code> 在</strong>明确的客户端交互<strong>或</strong>明确的服务端环境**中主动发起请求。</li>\n</ul>\n<p>遵循这个原则，你就能高效且正确地在 Nuxt 应用中处理数据获取。</p>\n<h2 id=\"激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\"><a href=\"#激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\" class=\"headerlink\" title=\"激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\"></a>激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？</h2><p>这些问题触及了 Nuxt.js SSR 的核心魔法。好消息是，<strong>这个过程绝大部分是自动化的，开发者几乎不需要手动干预</strong>。Nuxt 和 Vue 底层已经为你处理好了一切。</p>\n<p>下面我来逐一解答你的问题，你会看到 Nuxt 的设计是多么巧妙。</p>\n<hr>\n<h3 id=\"一、激活客户端需要开发手动调用什么-API-吗？\"><a href=\"#一、激活客户端需要开发手动调用什么-API-吗？\" class=\"headerlink\" title=\"一、激活客户端需要开发手动调用什么 API 吗？\"></a>一、激活客户端需要开发手动调用什么 API 吗？</h3><p><strong>答：完全不需要。这是 Vue 和 Nuxt 自动完成的。</strong></p>\n<p>这个过程称为 <strong>Hydration（混合）</strong>。它的流程是：</p>\n<ol>\n<li><strong>自动执行</strong>：当浏览器加载完 Nuxt 发送过来的 HTML 和客户端 JavaScript 包后，Vue 会自动启动。</li>\n<li><strong>自动匹配</strong>：Vue 会将它的虚拟 DOM 与服务器渲染好的、已经存在的静态 HTML 结构进行对比和匹配。</li>\n<li><strong>自动“激活”</strong>：Vue 不会重新创建 DOM 元素，而是会将事件监听器、响应式数据系统等“附加”到这些现有的 DOM 元素上，使静态页面瞬间变为一个完全交互式的 Vue 应用。</li>\n</ol>\n<p><strong>作为开发者，你唯一要做的就是：</strong></p>\n<ul>\n<li>确保你的代码是<strong>同构的</strong>（即同一份代码既能在 Node.js 环境运行，也能在浏览器环境运行）。</li>\n<li>避免在 <code>created</code> 或 <code>setup</code> 等生命周期中使用浏览器特有的 API（如 <code>window</code>, <code>document</code>），或者使用 <code>onMounted</code>（仅在客户端执行）来包裹它们。</li>\n</ul>\n<p><strong>你不用写任何像</strong>** <strong><code>**app.hydrate()**</code></strong> **<strong>这样的代码，一切都是开箱即用、自动发生的。</strong></p>\n<hr>\n<h3 id=\"二、服务端异步获取的数据注入到-HTML-这一步开发需要做什么？\"><a href=\"#二、服务端异步获取的数据注入到-HTML-这一步开发需要做什么？\" class=\"headerlink\" title=\"二、服务端异步获取的数据注入到 HTML 这一步开发需要做什么？\"></a>二、服务端异步获取的数据注入到 HTML 这一步开发需要做什么？</h3><p><strong>答：你只需要使用正确的 API（</strong><code>**useAsyncData**</code>** <strong><strong>或</strong></strong> <strong><code>**useFetch**</code></strong>），Nuxt 就会自动完成注入。**</p>\n<p>这个“注入”过程在 Nuxt 中被称为 <strong>State Serialization（状态序列化）</strong> 或 ** dehydration（脱水）**。</p>\n<p><strong>你的工作（非常简单）：</strong></p>\n<ol>\n<li>**使用 <strong><code>**useAsyncData**</code></strong> 或 **<code>**useFetch**</code>：在你的页面组件中，用它们来获取数据。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">  // pages/posts.vue</span><br><span class=\"line\">  const &#123; data: posts &#125; = await useFetch(&#x27;/api/posts&#x27;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>Nuxt 自动完成后续所有事情</strong>：<ul>\n<li>Nuxt 在服务端执行完 <code>useFetch</code> 后，会<strong>自动</strong>将 <code>posts</code> 数据序列化为 JSON 字符串。</li>\n<li>将这个 JSON 字符串<strong>自动嵌入</strong>到最终 HTML 的 <code>&lt;head&gt;</code> 部分的一个 <code>&lt;script&gt;</code> 标签中。</li>\n<li>这个标签的内容通常是 <code>window.__NUXT__ = &#123; ... &#125;</code>，其中就包含了所有页面的预取数据。</li>\n</ul>\n</li>\n</ol>\n<p><strong>你不需要手动操作 DOM 去注入数据，Nuxt 的渲染引擎为你包办了一切。</strong></p>\n<hr>\n<h3 id=\"三、到客户端时如何获取数据呢？\"><a href=\"#三、到客户端时如何获取数据呢？\" class=\"headerlink\" title=\"三、到客户端时如何获取数据呢？\"></a>三、到客户端时如何获取数据呢？</h3><p><strong>答：客户端 Vue 应用会自动从</strong>** <strong><code>**window.__NUXT__**</code></strong> **<strong>中提取并复用数据，无需再次请求。</strong></p>\n<p>这个过程是 <strong>State Deserialization（状态反序列化）</strong> 或 <strong>rehydration（补水）</strong>。</p>\n<p><strong>它的自动流程如下：</strong></p>\n<ol>\n<li><strong>数据随 HTML 到达浏览器</strong>：HTML 中的 <code>&lt;script&gt;window.__NUXT__ = &#123;...&#125;&lt;/script&gt;</code> 会先被执行，将数据挂载到全局对象上。</li>\n<li><strong>客户端 Vue 应用启动</strong>：客户端的 JavaScript 包加载完毕后，Vue 和 Nuxt 开始初始化。</li>\n<li><strong>自动提取数据</strong>：当客户端的 <code>useFetch(&#39;/api/posts&#39;)</code> 代码执行时，它不会真正去发起网络请求，而是会<strong>先自动去</strong>** <strong><code>**window.__NUXT__**</code></strong> **<strong>对象里查找</strong>，看是否存在服务端已经为它准备好的数据。</li>\n<li><strong>直接复用数据</strong>：如果找到了，它就直接使用这份数据，完全跳过网络请求。这样就保证了客户端和服务端的数据状态<strong>绝对一致</strong>，这也是 Hydration 能成功的前提。</li>\n</ol>\n<p><strong>你可以通过 <strong><code>**useNuxtData**</code></strong> 这个工具函数来验证和访问这些被缓存的数据：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 在客户端，你可以这样访问之前服务端获取的、被缓存的数据</span><br><span class=\"line\">const &#123; data: posts &#125; = useNuxtData(&#x27;posts&#x27;) // 使用 useFetch 时自动生成的 key</span><br><span class=\"line\"></span><br><span class=\"line\">// 这不会导致第二次请求，它只是从客户端缓存中读取</span><br><span class=\"line\">console.log(posts.value)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\"><a href=\"#服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\" class=\"headerlink\" title=\"服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\"></a>服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？</h2><p><strong>你这个问题问得非常非常关键，切中了SSR安全的核心！你的直觉完全正确。</strong></p>\n<p><strong>绝对不应该将任何敏感信息（如用户凭证、Token、个人身份信息PII等）内联到HTML的</strong>** <strong><code>**&lt;script&gt;**</code></strong> <strong><strong>标签中，并通过</strong></strong> <strong><code>**window.__NUXT__**</code></strong> **<strong>暴露给客户端。</strong></p>\n<p>这样做会带来严重的安全风险：</p>\n<ol>\n<li><strong>数据泄露</strong>：任何能打开浏览器开发者工具的人，都可以直接看到 <code>window.__NUXT__</code> 里的全部内容。</li>\n<li><strong>XSS攻击加剧</strong>：如果你的应用存在XSS（跨站脚本）漏洞，攻击者可以更容易地编写脚本窃取 <code>window.__NUXT__</code> 中的所有数据，而不必费力去窃取多个API请求的返回结果。</li>\n<li><strong>缓存风险</strong>：HTML页面可能会被CDN、代理服务器或浏览器缓存。如果其中包含了用户敏感信息，就意味着这些信息也可能被缓存并泄露给其他用户。</li>\n</ol>\n<hr>\n<h3 id=\"那么，如何处理需要认证的敏感数据？\"><a href=\"#那么，如何处理需要认证的敏感数据？\" class=\"headerlink\" title=\"那么，如何处理需要认证的敏感数据？\"></a>那么，如何处理需要认证的敏感数据？</h3><p>正确的做法是将敏感数据与非敏感数据<strong>分离</strong>，并遵循“<strong>按需索取</strong>”和“<strong>最小化暴露</strong>”的原则。以下是几种安全策略：</p>\n<h4 id=\"策略一：敏感数据绝不预取，仅在客户端获取\"><a href=\"#策略一：敏感数据绝不预取，仅在客户端获取\" class=\"headerlink\" title=\"策略一：敏感数据绝不预取，仅在客户端获取\"></a>策略一：敏感数据绝不预取，仅在客户端获取</h4><p>这是最常用、最安全的策略。用户登录状态、个人资料等高度敏感的数据，<strong>不应该</strong>在服务端的 <code>useFetch</code>&#x2F;<code>useAsyncData</code> 中获取。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 1. 非敏感、SEO需要的数据：在服务端预取（安全）</span><br><span class=\"line\">const &#123; data: publicPosts &#125; = await useFetch(&#x27;/api/public-posts&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. 敏感的用户数据：不在服务端预取，只在客户端获取</span><br><span class=\"line\">const user = ref(null)</span><br><span class=\"line\">const token = useCookie(&#x27;auth-token&#x27;) // Token应存放在HttpOnly Cookie中</span><br><span class=\"line\"></span><br><span class=\"line\">// 在客户端挂载后，再安全地获取用户数据</span><br><span class=\"line\">onMounted(async () =&gt; &#123;</span><br><span class=\"line\">  if (token.value) &#123;</span><br><span class=\"line\">    // 此请求在客户端发起，携带Cookie中的token</span><br><span class=\"line\">    user.value = await $fetch(&#x27;/api/me&#x27;, &#123;</span><br><span class=\"line\">      headers: &#123;</span><br><span class=\"line\">        // 通常Token会自动通过Cookie发送，无需手动设置，这里演示逻辑</span><br><span class=\"line\">        Authorization: `Bearer $&#123;token.value&#125;`</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;!-- 公开数据直接渲染 --&gt;</span><br><span class=\"line\">  &lt;div v-for=&quot;post in publicPosts&quot; :key=&quot;post.id&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;!-- 用户数据，等客户端获取后再显示 --&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;user&quot;&gt;Welcome, &#123;&#123; user.name &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"策略二：使用-useState-进行状态管理，区分服务端与客户端状态\"><a href=\"#策略二：使用-useState-进行状态管理，区分服务端与客户端状态\" class=\"headerlink\" title=\"策略二：使用 useState 进行状态管理，区分服务端与客户端状态\"></a>策略二：使用 <code>useState</code> 进行状态管理，区分服务端与客户端状态</h4><p>你可以利用 <code>useState</code> 的灵活性来管理不同环境的状态。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 创建一个响应式状态，服务端先初始化为 null</span><br><span class=\"line\">const secretData = useState(&#x27;secret-data&#x27;, () =&gt; null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 在客户端再获取真实数据</span><br><span class=\"line\">onMounted(async () =&gt; &#123;</span><br><span class=\"line\">  if (!secretData.value) &#123; // 避免在服务端执行</span><br><span class=\"line\">    secretData.value = await $fetch(&#x27;/api/secret-data&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"策略三：API-设计分离-提供公开和私密端点\"><a href=\"#策略三：API-设计分离-提供公开和私密端点\" class=\"headerlink\" title=\"策略三：API 设计分离 - 提供公开和私密端点\"></a>策略三：API 设计分离 - 提供公开和私密端点</h4><p>从后端设计上就进行分离：</p>\n<ul>\n<li><code>/api/public/data</code>：返回不敏感的数据，可以安全地在服务端渲染。</li>\n<li><code>/api/private/user-data</code>：返回敏感数据，必须认证且在客户端获取。</li>\n</ul>\n<hr>\n<h3 id=\"Nuxt-如何安全地处理认证？\"><a href=\"#Nuxt-如何安全地处理认证？\" class=\"headerlink\" title=\"Nuxt 如何安全地处理认证？\"></a>Nuxt 如何安全地处理认证？</h3><p>认证的最佳实践是使用 <strong>HttpOnly Cookies</strong> 来传输令牌（Token），而不是通过 <code>window.__NUXT__</code> 或 JS 可读的 Cookie。</p>\n<ol>\n<li><strong>登录流程</strong>：<ul>\n<li>用户提交登录表单，客户端 <code>$fetch</code> 发送到 <code>/api/auth/login</code>。</li>\n<li><strong>后端</strong>验证成功后，设置一个 <strong>HttpOnly、Secure、SameSite&#x3D;Strict</strong> 的 Cookie（包含认证Token）。这个 Cookie 对 JavaScript 不可见，极大地增强了安全性。</li>\n<li>前端只需知道登录成功，无需接触 Token 本身。</li>\n</ul>\n</li>\n<li><strong>获取用户数据</strong>：<ul>\n<li>在客户端，调用 <code>$fetch(&#39;/api/me&#39;)</code>。</li>\n<li>浏览器会<strong>自动</strong>在请求中带上 HttpOnly Cookie。</li>\n<li>后端验证 Cookie 中的 Token 有效性后，返回对应用户的数据。</li>\n</ul>\n</li>\n<li><strong>服务端渲染中的认证</strong>：<ul>\n<li>如果服务端需要根据用户状态渲染不同内容（例如“您好，用户名”），可以通过<strong>服务器中间件</strong>或 <strong>API 路由</strong>来处理。</li>\n<li>服务端可以读取请求中的 Cookie，去后端验证用户身份，然后决定返回什么数据。但这个验证过程发生在后端，结果信息需要是<strong>非敏感</strong>的（例如只返回 <code>username</code>，而不是返回 <code>token</code> 或 <code>email</code>）。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 服务端可以安全地读取Cookie并获取非敏感的用户显示信息</span><br><span class=\"line\">const &#123; data: userInfo &#125; = await useFetch(&#x27;/api/user-display-info&#x27;)</span><br><span class=\"line\">// 这个 `/api/user-display-info` 接口在后端会验证Cookie，</span><br><span class=\"line\">// 但只返回 &#123; name: &#x27;John&#x27; &#125; 这样的非敏感信息用于界面显示。</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><strong>核心原则</strong>：<strong>绝不将敏感数据内联到 HTML 中</strong>。<code>window.__NUXT__</code> 应该是“公开的”或“非敏感的”。</li>\n<li><strong>数据分离</strong>：将数据分为“公开”和“私密”两类。公开数据用 <code>useFetch</code> 服务端预取；私密数据在客户端用 <code>$fetch</code> 按需获取。</li>\n<li><strong>认证最佳实践</strong>：使用 <strong>HttpOnly Cookies</strong> 来安全地传输认证凭证，而不是将其暴露给客户端 JavaScript 或 <code>window</code> 对象。</li>\n<li><strong>信任后端</strong>：敏感的权限检查和数据处理逻辑应该始终放在后端 API 中。前端（包括SSR服务端）只负责展示非敏感的结果。</li>\n</ol>\n<p>你的安全意识非常到位，遵循这些原则可以让你构建出既高效又安全的 Nuxt.js 应用。</p>\n<h2 id=\"除此之外，服务端渲染还有什么不能实现的呢？canvas？\"><a href=\"#除此之外，服务端渲染还有什么不能实现的呢？canvas？\" class=\"headerlink\" title=\"除此之外，服务端渲染还有什么不能实现的呢？canvas？\"></a>除此之外，服务端渲染还有什么不能实现的呢？canvas？</h2><p>说得非常对！<strong>Canvas</strong> 是一个绝佳的例子，它完美地揭示了服务端渲染（SSR）的“盲区”。</p>\n<p>SSR 的核心是<strong>生成静态的 HTML 和 CSS 字符串</strong>。因此，任何<strong>动态的、依赖于浏览器 JavaScript 运行时环境</strong>的功能，在纯 SSR 阶段都无法实现或功能不全。</p>\n<p>除了 Canvas，还有很多类似的限制。我们可以将它们分为几大类：</p>\n<hr>\n<h3 id=\"一、浏览器特有的-API-和全局对象\"><a href=\"#一、浏览器特有的-API-和全局对象\" class=\"headerlink\" title=\"一、浏览器特有的 API 和全局对象\"></a>一、浏览器特有的 API 和全局对象</h3><p>这是最直接的一类。在 Node.js 服务器环境中，根本没有 <code>window</code>, <code>document</code>, <code>navigator</code> 等对象。</p>\n<table>\n<thead>\n<tr>\n<th>API&#x2F;功能</th>\n<th>原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>**window**</code><strong>、</strong><code>**document**</code></td>\n<td>Node.js 中不存在。</td>\n<td>使用 <code>onMounted</code>钩子或 <code>clientOnly</code>组件确保只在客户端访问。</td>\n</tr>\n<tr>\n<td><code>**alert**</code><strong>、</strong><code>**confirm**</code><strong>、</strong><code>**prompt**</code></td>\n<td>浏览器交互对话框。</td>\n<td>逻辑移至客户端，或使用基于组件的替代品（如模态框）。</td>\n</tr>\n<tr>\n<td><strong>Canvas (</strong><code>**&lt;canvas&gt;**</code><strong>) &#x2F; WebGL</strong></td>\n<td>需要浏览器渲染上下文来绘图和操作像素。</td>\n<td><strong>只能在客户端初始化和使用</strong>。SSR 只能渲染一个空画布。</td>\n</tr>\n<tr>\n<td><strong>地理位置 (</strong><code>**navigator.geolocation**</code><strong>)</strong></td>\n<td>需要用户的浏览器授权和设备硬件支持。</td>\n<td>仅在客户端通过 <code>onMounted</code>或用户交互触发。</td>\n</tr>\n<tr>\n<td><strong>本地存储 (</strong><code>**localStorage**</code><strong>, <strong><code>**sessionStorage**</code></strong>, <strong><code>**IndexedDB**</code></strong>)</strong></td>\n<td>是浏览器的持久化存储机制。</td>\n<td>在 <code>onMounted</code>中访问，或使用 <code>useLocalStorage</code>等组合式函数（内部做了客户端检查）。</td>\n</tr>\n<tr>\n<td><strong>媒体设备 (</strong><code>**navigator.mediaDevices**</code><strong>)</strong></td>\n<td>需要访问麦克风、摄像头等硬件。</td>\n<td>完全的用户客户端行为。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"二、依赖浏览器渲染或布局的功能\"><a href=\"#二、依赖浏览器渲染或布局的功能\" class=\"headerlink\" title=\"二、依赖浏览器渲染或布局的功能\"></a>二、依赖浏览器渲染或布局的功能</h3><p>这类功能需要知道元素的真实尺寸和位置，而这些信息在纯字符串的 SSR 阶段是无法获得的。</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>元素尺寸&#x2F;位置</strong> (如 <code>element.offsetWidth</code><br/>, <code>getBoundingClientRect()</code><br/>)</td>\n<td>SSR 只有 HTML 字符串，没有真实的布局和渲染。</td>\n<td>在 <code>onMounted</code><br/> 后使用，或使用 Vue 的 <code>nextTick</code><br/> 确保 DOM 已更新。</td>\n</tr>\n<tr>\n<td><strong>基于尺寸的渲染</strong> (如图表库 ECharts、D3.js)</td>\n<td>需要挂载到真实 DOM 元素并获取其宽高才能渲染。</td>\n<td>在 <code>onMounted</code><br/> 中初始化图表实例。</td>\n</tr>\n<tr>\n<td><strong>动画 (CSS 动画除外)</strong></td>\n<td>许多 JS 动画库需要操作 DOM 样式。</td>\n<td>使用 <code>onMounted</code><br/> 启动动画，或使用 CSS 动画（SSR 支持）。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"三、用户交互和状态\"><a href=\"#三、用户交互和状态\" class=\"headerlink\" title=\"三、用户交互和状态\"></a>三、用户交互和状态</h3><p>SSR 输出的是一个“快照”，无法预知用户未来的行为。</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>用户输入</strong> (表单输入、焦点状态)</td>\n<td>SSR 无法预知用户会输入什么。</td>\n<td>SSR 可以渲染表单结构，但交互和值绑定必须在客户端完成。</td>\n</tr>\n<tr>\n<td><strong>鼠标事件、键盘事件</strong></td>\n<td>纯静态环境，无用户交互。</td>\n<td>完全由客户端 JavaScript 处理。</td>\n</tr>\n<tr>\n<td><strong>浏览器标签页可见性</strong> (<code>document.visibilityState</code>)</td>\n<td>依赖于用户当前的浏览器状态。</td>\n<td>纯客户端逻辑。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"四、第三方库\"><a href=\"#四、第三方库\" class=\"headerlink\" title=\"四、第三方库\"></a>四、第三方库</h3><p>许多强大的第三方库在设计时就是为浏览器而生的。</p>\n<table>\n<thead>\n<tr>\n<th>库类型</th>\n<th>问题</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>地图库</strong> (如 Leaflet, Google Maps)</td>\n<td>需要挂载到 DOM 并初始化地图渲染上下文。</td>\n<td>使用 <code>onMounted</code><br/> 初始化，或使用 Nuxt 模块（如 <code>nuxt-leaflet</code><br/>）。</td>\n</tr>\n<tr>\n<td><strong>可视化库</strong> (如 D3, Three.js)</td>\n<td>严重依赖 Canvas、WebGL 或 SVG 操作。</td>\n<td><strong>只能在客户端运行</strong>。</td>\n</tr>\n<tr>\n<td><strong>分析&#x2F;广告库</strong> (如 Google Analytics)</td>\n<td>依赖 <code>window</code><br/> 对象和浏览器环境来跟踪用户。</td>\n<td>使用 Nuxt 插件（<code>client: true</code><br/> 选项）或直接在 <code>onMounted</code><br/> 中加载。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"如何安全地处理这些限制？Nuxt-提供的解决方案\"><a href=\"#如何安全地处理这些限制？Nuxt-提供的解决方案\" class=\"headerlink\" title=\"如何安全地处理这些限制？Nuxt 提供的解决方案\"></a>如何安全地处理这些限制？Nuxt 提供的解决方案</h3><p>Nuxt 提供了一系列模式来优雅地解决这些问题：</p>\n<h4 id=\"1-onMounted-钩子-最常用\"><a href=\"#1-onMounted-钩子-最常用\" class=\"headerlink\" title=\"1. onMounted 钩子 (最常用)\"></a>1. <code>onMounted</code> 钩子 (最常用)</h4><p>确保代码只在客户端执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">import &#123; onMounted &#125; from &#x27;vue&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const canvas = ref(null)</span><br><span class=\"line\"></span><br><span class=\"line\">onMounted(() =&gt; &#123;</span><br><span class=\"line\">  // 现在可以安全地访问 DOM 和浏览器 API 了</span><br><span class=\"line\">  const ctx = canvas.value.getContext(&#x27;2d&#x27;)</span><br><span class=\"line\">  ctx.fillStyle = &#x27;green&#x27;</span><br><span class=\"line\">  ctx.fillRect(10, 10, 150, 100)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;!-- SSR 会渲染一个空画布 --&gt;</span><br><span class=\"line\">  &lt;canvas ref=&quot;canvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-条件渲染与-组件\"><a href=\"#2-条件渲染与-组件\" class=\"headerlink\" title=\"2. 条件渲染与 &lt;ClientOnly&gt; 组件\"></a>2. 条件渲染与 <code>&lt;ClientOnly&gt;</code> 组件</h4><p>防止不支持 SSR 的组件在服务器端渲染时出错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;!-- 默认插槽只在客户端渲染 --&gt;</span><br><span class=\"line\">  &lt;ClientOnly&gt;</span><br><span class=\"line\">    &lt;MyChartThatUsesWindow /&gt;</span><br><span class=\"line\">    &lt;!-- 可以设置回退内容，在SSR阶段显示 --&gt;</span><br><span class=\"line\">    &lt;template #fallback&gt;</span><br><span class=\"line\">      &lt;div&gt;Loading chart...&lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">  &lt;/ClientOnly&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-使用-process-client-标志进行运行时检查\"><a href=\"#3-使用-process-client-标志进行运行时检查\" class=\"headerlink\" title=\"3. 使用 process.client 标志进行运行时检查\"></a>3. 使用 <code>process.client</code> 标志进行运行时检查</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">if (process.client) &#123;</span><br><span class=\"line\">  // 此代码块只在客户端打包时包含，并在客户端执行</span><br><span class=\"line\">  console.log(&#x27;I am on the client!&#x27;, window.innerWidth)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-为第三方库创建客户端插件\"><a href=\"#4-为第三方库创建客户端插件\" class=\"headerlink\" title=\"4. 为第三方库创建客户端插件\"></a>4. 为第三方库创建客户端插件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// plugins/analytics.client.js - 注意 .client 后缀</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineNuxtPlugin</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这个插件只会在客户端运行</span></span><br><span class=\"line\">  <span class=\"variable language_\">window</span>.<span class=\"property\">dataLayer</span> = <span class=\"variable language_\">window</span>.<span class=\"property\">dataLayer</span> || []</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">gtag</span>(<span class=\"params\"></span>)&#123; dataLayer.<span class=\"title function_\">push</span>(<span class=\"variable language_\">arguments</span>) &#125;</span><br><span class=\"line\">  <span class=\"title function_\">gtag</span>(<span class=\"string\">&#x27;js&#x27;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>())</span><br><span class=\"line\">  <span class=\"title function_\">gtag</span>(<span class=\"string\">&#x27;config&#x27;</span>, <span class=\"string\">&#x27;GA_MEASUREMENT_ID&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>服务端渲染 (SSR) 的本质是<strong>静态化</strong>，它擅长的是：</p>\n<ul>\n<li><strong>生成初始 HTML 内容</strong></li>\n<li><strong>提供更好的 SEO</strong></li>\n<li><strong>提升首屏加载性能</strong></li>\n</ul>\n<p>而<strong>动态交互</strong>和<strong>浏览器依赖</strong>永远是 SSR 的盲区，必须交给客户端处理。</p>\n<p><strong>因此，一个成熟的 Nuxt 应用是两者结合的“混合体”：</strong></p>\n<ol>\n<li><strong>服务端</strong>：生成静态结构和首屏内容。</li>\n<li><strong>客户端</strong>：“激活”页面，接管所有交互，并加载那些依赖浏览器环境的动态功能。</li>\n</ol>\n<p>你的工作就是清晰地界定哪些逻辑属于服务端，哪些属于客户端，并使用 Nuxt 提供的模式（<code>onMounted</code>, <code>&lt;ClientOnly&gt;</code>, <code>.client</code> 插件）将它们优雅地结合起来。</p>\n<h2 id=\"nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\"><a href=\"#nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\" class=\"headerlink\" title=\"nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\"></a>nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？</h2><p>这是一个非常好的问题，它触及了 Nuxt 全栈架构的核心优势。</p>\n<p><strong>简单而直接的答案是：不会。在客户端激活后，向同源的 Nuxt 中间件或 API 路由发起请求，绝对不会产生跨域问题。</strong></p>\n<p>这是因为你发起请求的目标和你的页面来源是<strong>完全同源的</strong>。</p>\n<hr>\n<h3 id=\"为什么不会跨域？——-同源策略详解\"><a href=\"#为什么不会跨域？——-同源策略详解\" class=\"headerlink\" title=\"为什么不会跨域？—— 同源策略详解\"></a>为什么不会跨域？—— 同源策略详解</h3><p>让我们回顾一下“同源策略”：当协议、域名、端口都相同时，即为同源，浏览器允许请求。</p>\n<p>假设你的 Nuxt 应用部署在：<br><code>https://www.my-app.com</code></p>\n<ol>\n<li><strong>你的页面来源</strong>：<br>浏览器中显示的地址是：<code>https://www.my-app.com/some-page</code></li>\n<li><strong>你请求的目标</strong>：<br>你在代码中发起的请求是：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用相对路径，目标自动补全为：https://www.my-app.com/api/hello</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/hello&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用 useFetch（同样基于相对路径）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/auth/user&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>对比</strong>：<ul>\n<li><strong>协议</strong>：都是 <code>https</code></li>\n<li><strong>域名</strong>：都是 <code>www.my-app.com</code></li>\n<li><strong>端口</strong>：都是 <code>443</code> (HTTPS 默认端口)</li>\n</ul>\n</li>\n</ol>\n<p><strong>结论</strong>：<strong>完全同源</strong>，浏览器欣然放行，没有任何跨域限制。</p>\n<hr>\n<h3 id=\"Nuxt-如何处理这些请求？——-请求生命周期\"><a href=\"#Nuxt-如何处理这些请求？——-请求生命周期\" class=\"headerlink\" title=\"Nuxt 如何处理这些请求？—— 请求生命周期\"></a>Nuxt 如何处理这些请求？—— 请求生命周期</h3><p>理解这个过程能让你更清楚为什么这是安全的：</p>\n<p>如图所示，无论是开发还是生产环境，<strong>你的 API 请求和前端页面都由同一个主机处理</strong>。它们处于同一个“生态系统”内，通信是内部的、安全的，不存在跨域问题。</p>\n<hr>\n<h3 id=\"什么情况下会有跨域问题？\"><a href=\"#什么情况下会有跨域问题？\" class=\"headerlink\" title=\"什么情况下会有跨域问题？\"></a>什么情况下会有跨域问题？</h3><p>只有当你的<strong>页面来源</strong>和<strong>请求目标</strong>不同源时，才会触发跨域。例如：</p>\n<table>\n<thead>\n<tr>\n<th>你的页面在</th>\n<th>你请求的目标</th>\n<th>是否跨域</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>https://www.my-app.com</code></td>\n<td><code>https://www.my-app.com/api/hello</code></td>\n<td><strong>否</strong></td>\n<td>同源</td>\n</tr>\n<tr>\n<td><code>https://www.my-app.com</code></td>\n<td><code>https://api.my-app.com</code></td>\n<td><strong>是</strong></td>\n<td>子域名不同 (<code>www</code> vs <code>api</code>)</td>\n</tr>\n<tr>\n<td><code>http://localhost:3000</code></td>\n<td><code>https://api.third-party.com</code></td>\n<td><strong>是</strong></td>\n<td>完全不同的域名</td>\n</tr>\n<tr>\n<td><code>https://www.my-app.com</code></td>\n<td><code>http://www.my-app.com/api/hello</code></td>\n<td><strong>是</strong></td>\n<td>协议不同 (<code>https</code>vs <code>http</code>)</td>\n</tr>\n</tbody></table>\n<p><strong>对于最后一种情况（生产环境前后端分离），解决方案是：</strong></p>\n<ol>\n<li><strong>后端配置 CORS</strong>：在你的 <code>api.my-app.com</code> 服务器上设置 <code>Access-Control-Allow-Origin: https://www.my-app.com</code> 响应头。</li>\n<li><strong>使用反向代理</strong>：配置你的生产服务器（如 Nginx），将对 <code>/api/</code> 的请求代理到 <code>api.my-app.com</code>，让浏览器始终觉得是在请求同源地址。这是更推荐的做法。</li>\n</ol>\n<h3 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>在 Nuxt 应用中，请求自身的 API 路由 (</strong><code>**/api/xxx**</code><strong>) 或服务器中间件是绝对同源的，没有跨域问题。</strong></li>\n<li>这是 Nuxt 全栈框架的巨大优势之一，它简化了开发，让你无需在开发阶段为 CORS 烦恼。</li>\n<li>跨域问题只会在你请求<strong>外部第三方 API</strong> 且对方未正确配置 CORS 时出现。</li>\n<li>如果你的生产环境是前后端完全分离的（不同域），那么需要在生产环境的<strong>后端配置 CORS</strong> 或通过<strong>反向代理</strong>来解决。</li>\n</ul>\n<p>所以，请放心地在你的 Nuxt 应用内部调用 API，这是最安全、最正确的做法。</p>\n<h2 id=\"那如果对后端接口-另一台服务器上-的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\"><a href=\"#那如果对后端接口-另一台服务器上-的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\" class=\"headerlink\" title=\"那如果对后端接口(另一台服务器上)的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\"></a>那如果对后端接口(另一台服务器上)的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？</h2><p><strong>你的这个思路非常棒，完全正确！</strong> 这正是构建现代 Web 应用的一种核心架构模式，被称为 <strong>“BFF（Backend For Frontend）模式”</strong> 或 <strong>“API 网关模式”</strong>。</p>\n<p>你的推理链条是：</p>\n<ol>\n<li><strong>所有客户端请求</strong>都只发往<strong>同源</strong>的 Nuxt 服务器（<code>/api/proxy</code>）。</li>\n<li>Nuxt 服务器上的<strong>中间件</strong>接收到请求后，<strong>代为转发</strong>给真正的后端服务器。</li>\n<li>由于服务器之间通信（Nuxt Server -&gt; Your Backend Server）<strong>没有跨域限制</strong>，所以问题迎刃而解。</li>\n</ol>\n<p>这个方案<strong>在理论上是完全可行且非常优雅的</strong>，它确实可以让你<strong>完全摆脱 CORS 的困扰</strong>。</p>\n<hr>\n<h3 id=\"这种架构的详细工作流程\"><a href=\"#这种架构的详细工作流程\" class=\"headerlink\" title=\"这种架构的详细工作流程\"></a>这种架构的详细工作流程</h3><p>如图所示，浏览器始终只与 <code>my-nuxt-app.com</code> 通信，完美符合同源策略。</p>\n<hr>\n<h3 id=\"优缺点分析：这是否是“万能药”？\"><a href=\"#优缺点分析：这是否是“万能药”？\" class=\"headerlink\" title=\"优缺点分析：这是否是“万能药”？\"></a>优缺点分析：这是否是“万能药”？</h3><p>虽然这个方案能根治跨域，但它也引入了一些新的考虑因素：</p>\n<h4 id=\"优点-✅\"><a href=\"#优点-✅\" class=\"headerlink\" title=\"优点 ✅\"></a>优点 ✅</h4><ol>\n<li><strong>彻底解决 CORS</strong>：前端开发者完全无需再关心跨域配置，开发体验极其流畅。</li>\n<li><strong>隐藏后端架构</strong>：真正的后端地址、端口、API 结构对客户端完全隐藏，更安全。</li>\n<li><strong>协议转换</strong>：可以轻松地在 Nuxt 中处理 HTTPS -&gt; HTTP 的请求（服务器间通信允许）。</li>\n<li><strong>数据处理与聚合</strong>：你可以在 Nuxt 中间件中对多个后端服务的返回值进行聚合、过滤、转换，为前端提供最合适的数据结构，减少前端请求次数。</li>\n</ol>\n<h4 id=\"缺点与需要考虑的因素-⚠️\"><a href=\"#缺点与需要考虑的因素-⚠️\" class=\"headerlink\" title=\"缺点与需要考虑的因素 ⚠️\"></a>缺点与需要考虑的因素 ⚠️</h4><ol>\n<li><strong>额外的网络跳转</strong>：所有请求都多经过一环（浏览器 -&gt; Nuxt -&gt; 真实后端），<strong>会增加微小的延迟</strong>。对于延迟敏感的应用需要优化。</li>\n<li><strong>单点压力与故障点</strong>：Nuxt 服务器现在成为了所有 API 流量的入口。如果它宕机，所有请求都会失败。需要保证其高可用性。</li>\n<li><strong>复杂性转移</strong>：虽然前端变简单了，但 Nuxt 层（BFF 层）的逻辑变复杂了。你需要在这里编写转发、错误处理、认证等逻辑。</li>\n<li><strong>认证问题</strong>：如果后端 API 需要认证，你需要决定如何传递认证信息。<ul>\n<li><strong>方案A（推荐）</strong>：浏览器将认证 Token 发给 Nuxt，Nuxt 再原样转发给后端。</li>\n<li><strong>方案B</strong>：Nuxt 服务器自己持有访问后端的凭证，替用户与后端通信。但这需要非常小心地管理权限。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"如何实现？\"><a href=\"#如何实现？\" class=\"headerlink\" title=\"如何实现？\"></a>如何实现？</h3><p>在 Nuxt 中，你通常使用 <strong>API 路由</strong> 或 <strong>服务器中间件</strong> 来实现，而不是普通的中间件，因为它们专门处理服务器逻辑。</p>\n<p><strong>示例：在 <strong><code>**server/api/proxy/[...].ts**</code></strong> 中创建一个捕获所有路由的 API</strong></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server/api/proxy/[...].ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineEventHandler</span>(<span class=\"title function_\">async</span> (event) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 获取请求路径和方法</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = <span class=\"title function_\">getRouterParam</span>(event, <span class=\"string\">&#x27;path&#x27;</span>) <span class=\"comment\">// 获取 ... 通配符参数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> method = <span class=\"title function_\">getMethod</span>(event)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> body = method === <span class=\"string\">&#x27;GET&#x27;</span> ? <span class=\"literal\">undefined</span> : <span class=\"keyword\">await</span> <span class=\"title function_\">readBody</span>(event)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 定义你的真实后端基础 URL（应从环境变量读取！）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> baseURL = <span class=\"string\">&#x27;https://your-real-backend.com/api&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> targetURL = <span class=\"string\">`<span class=\"subst\">$&#123;baseURL&#125;</span>/<span class=\"subst\">$&#123;path&#125;</span>`</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 可选：处理认证（例如，将前端传来的 token 转发给后端）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> headers = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> authHeader = <span class=\"title function_\">getHeader</span>(event, <span class=\"string\">&#x27;authorization&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (authHeader) &#123;</span><br><span class=\"line\">    headers[<span class=\"string\">&#x27;Authorization&#x27;</span>] = authHeader</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 4. 代理请求到真实后端</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> $fetch.<span class=\"title function_\">raw</span>(targetURL, &#123;</span><br><span class=\"line\">      method,</span><br><span class=\"line\">      body,</span><br><span class=\"line\">      headers,</span><br><span class=\"line\">      <span class=\"comment\">// 重要：转发查询参数 (?foo=bar)</span></span><br><span class=\"line\">      <span class=\"attr\">query</span>: <span class=\"title function_\">getQuery</span>(event),</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 5. 可选：根据需要设置响应头</span></span><br><span class=\"line\">    <span class=\"title function_\">setHeaders</span>(event, response.<span class=\"property\">headers</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 6. 返回后端响应的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.<span class=\"property\">_data</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 7. 错误处理，将后端错误返回给前端</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"title function_\">createError</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">statusCode</span>: error.<span class=\"property\">statusCode</span> || <span class=\"number\">500</span>,</span><br><span class=\"line\">      <span class=\"attr\">statusMessage</span>: error.<span class=\"property\">statusMessage</span> || <span class=\"string\">&#x27;Internal Server Error&#x27;</span>,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这样，前端所有发往 <code>/api/proxy/items</code>、<code>/api/proxy/user/profile</code> 的请求，都会被这个 handler 捕获，并转发到 <code>https://your-real-backend.com/api/items</code> 和 <code>https://your-real-backend.com/api/user/profile</code>。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p><strong>是的，你的想法是完全正确且高效的。通过让 Nuxt 服务器作为所有后端请求的代理，你可以一劳永逸地解决跨域问题，无需在开发或生产环境配置任何 CORS 或代理规则。</strong></p>\n<p>这不仅是解决跨域的手段，更是一种先进的<strong>架构设计选择</strong>（BFF）。它特别适用于：</p>\n<ul>\n<li>中大型前后端分离项目。</li>\n<li>需要集成多个后端微服务的复杂前端。</li>\n<li>希望简化前端开发流程，将复杂性集中到 BFF 层的团队。</li>\n</ul>\n<p>你只需要评估其带来的<strong>额外延迟</strong>和<strong>单点压力</strong>是否在你的应用可接受范围内即可。对于绝大多数应用来说，这个方案的利远大于弊。</p>\n","_processedHighlight":true},{"title":"微前端","date":"2024-01-14T16:00:00.000Z","_content":"\n参考链接：\n\n[可能是你见过最完善的微前端解决方案](https://zhuanlan.zhihu.com/p/78362028)\n\n[深入调研了微前端，还是iframe最香](https://juejin.cn/post/7244070072788287544?searchId=202508250257166071DDB47E623E0BA671)\n\n[qiankun官方文档](https://qiankun.umijs.org/zh/guide/getting-started)\n\n### 什么是微前端？\n微前端是一种软件架构，可以将前端应用拆解成一些更小的能够独立开发部署的微型应用，然后在将这些微型应用组合使其成为整体的架构模式。\n\n微前端类似于组件架构，但不同的是，组件不能够独立构建和发布，但是微前端中的应用是可以的。\n\n微前端架构与框架无关，每个微应用都可以使用不同的框架。\n\n![微前端](images/微前端.png)\n\n\n\n| **特性** | **单体前端** | **微前端** |\n| --- | --- | --- |\n| **代码库** | 单个大型代码库 | 多个独立代码库 |\n| **团队结构** | 集中式团队 | 分布式独立团队 |\n| **技术栈** | 统一技术栈 | 混合技术栈 |\n| **部署** | 整体部署 | 独立部署 |\n| **开发速度** | 后期变慢 | 持续快速 |\n| **复杂度** | 高度耦合 | 解耦独立 |\n\n\n### 微前端的价值\n微前端架构具备以下几个核心价值：\n\n+ 技术栈无关 主框架不限制接入应用的技术栈，子应用具备完全自主权\n+ 独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n+ 独立运行时 每个子应用之间状态隔离，运行时状态不共享\n\n微前端架构旨在解决[单体应用](https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLljZXkvZPlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.Sy3sQVozhhuQwuwmw8-zjyU0X_81Vve5linQ55OPo0k&zhida_source=entity)在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个[巨石应用](https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%B7%A8%E7%9F%B3%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLlt6jnn7PlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.3VWm6X4yZDpq2_EqJZDuDErH1ST1iWJUa0qPK8T5Abk&zhida_source=entity)([Frontend Monolith](https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DpU1gXA0rfwc))后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。\n\n应用架构如下：\n\n<img src=\"/images/微前端架构.png\" alt=\"微前端架构\" height=\"auto\" style=\"width:50%; display:block;\">\n\n> Stitching layer 作为主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用。因此主框架的定位则仅仅是：**导航路由 + 资源加载框架**\n>\n\n\n\nsingle-spa是什么\n\n好的，我们来详细解释一下 **single-spa** 是什么。\n\n### 核心定义\n**single-spa 是一个用于构建【微前端】架构的 JavaScript 框架。** 你可以把它理解为一个**顶层的路由器和应用程序加载器**。\n\n它的核心思想是：将一个大型的单页前端应用（SPA）拆分成多个小型、独立、可以并行开发交付的“微应用”。然后，single-spa 负责在运行时根据一定的规则（通常是当前的 URL）动态地加载、展示、卸载这些微应用。\n\n---\n\n### 一个简单的比喻\n想象一下你的浏览器是一个舞台：\n\n+ **传统单体应用：** 只有一个庞大的剧团表演一整部冗长的戏剧。要更换一个演员（修改一个功能），需要整个剧团停下来重新排练（整个应用重新构建部署）。\n+ **single-spa 微前端：** 舞台（浏览器）本身是空的。有一个**导演（single-spa）**。导演手里有一个节目单（根配置），上面写着什么节目（微应用）在什么时刻（例如，URL 是 `/settings` 时）上台表演。\n    - 当报幕员说“下一个节目是《用户设置》”时（用户访问了 `/settings`），导演就喊：“《用户设置》剧组，上台！”（加载并挂载 React 微应用）。\n    - 节目表演完了（用户离开了 `/settings`），导演就喊：“《用户设置》剧组，下台！”（卸载 React 微应用）。\n    - 下一个节目是《商品列表》，另一个完全不同的剧组（Vue 微应用）就上台表演。\n\n**single-spa 就是这个导演**，它自己不表演具体内容，但它负责协调所有剧组（微应用）的上场和下场时机。\n\n---\n\n### 为什么需要 single-spa？（解决的问题）\n1. **技术栈无关：** 各个微应用可以使用不同的技术栈（React, Vue, Angular, Svelte 等）。团队可以自由选择或升级其技术栈，而不会影响其他团队。\n2. **独立开发、独立部署：** 每个微应用都由独立的团队开发、测试和部署，大大提升了团队的自治度和发布效率。\n3. **增量升级：** 允许你逐步重写一个老旧的巨型前端应用，可以一部分一部分地用新的框架替换，而不是一次性重写全部。\n4. **代码隔离：** 应用之间实现了良好的代码和样式隔离（虽然需要一些额外规范），避免了全局污染和冲突。\n\n---\n\n### single-spa 的核心工作原理\nsingle-spa 通过定义一套**生命周期协议**来工作。每个微应用都必须对外暴露三个核心的函数：\n\n1. `bootstrap`： 应用首次加载时执行一次，用于初始化。\n2. `mount`： 当激活条件满足时（例如用户访问了该应用的路由），执行此函数。应用需要在这个函数里完成渲染，将组件挂载到 DOM 上。\n3. `unmount`： 当激活条件不再满足时（例如用户离开了该路由），执行此函数。应用需要在这个函数里完成清理工作，将自己从 DOM 上卸载。\n\nsingle-spa 的“根配置”会**注册**所有微应用，并为每个应用定义一个 `activity function`（激活函数）。这个函数通常根据 `window.location` 进行判断。\n\njavascript\n\n```javascript\n// single-spa 根配置示例 (root-config.js)\nimport { registerApplication, start } from 'single-spa';\n\n// 注册一个应用\nregisterApplication({\n  name: 'my-react-app', // 应用唯一名\n  app: () => System.import('my-react-app'), // 如何加载该应用的代码\n  activeWhen: (location) => location.pathname.startsWith('/react'), // 激活函数：当路径以 /react 开头时，加载这个应用\n});\n\n// 启动 single-spa\nstart();\n```\n\n**流程如下：**\n\n1. 用户访问 `https://example.com/react`。\n2. single-spa 检查所有注册的应用，发现 `my-react-app` 的 `activeWhen` 函数返回 `true`。\n3. single-spa 动态加载 `my-react-app` 的代码包。\n4. 依次执行该应用的 `bootstrap` 和 `mount` 生命周期函数，应用被渲染到页面上。\n5. 用户导航到 `/vue`，`my-react-app` 的 `activeWhen` 返回 `false`。\n6. single-spa 执行它的 `unmount` 函数，将其卸载。\n\n---\n\n### 主要优缺点\n**优点：**\n\n+ **强大的解耦和能力：** 真正实现了前端应用的拆分和团队自治。\n+ **框架无关：** 是整合不同技术栈应用的理想选择。\n+ **懒加载：** 提升首次加载速度，按需加载应用。\n\n**缺点：**\n\n+ **复杂度高：** 引入了分布式系统的复杂性，需要解决依赖共享、样式隔离、通信机制等问题。\n+ **开发体验：** 调试和配置比单体应用更复杂。通常需要类似 `single-spa` 官方的 `create-single-spa` 工具链来简化流程。\n+ **依赖管理：** 需要谨慎处理共享库（如 `react`, `vue`）以避免重复打包。\n\n---\n\n### 与 Module Federation 的区别\nWebpack 5 的 **Module Federation（模块联邦）** 是另一种实现微前端的热门技术。它们不是互斥的，甚至可以结合使用：\n\n+ **single-spa** 主要解决的是**路由和应用生命周期管理**的问题（“什么时候加载哪个应用”）。\n+ **Module Federation** 主要解决的是**应用之间代码共享和依赖处理**的问题（“如何共享一个 React 实例，避免重复加载”）。\n\n一个常见的模式是：使用 **single-spa 作为路由器**，使用 **Module Federation 来加载微应用和共享依赖**。\n\n### 总结\n**single-spa 是一个成熟、强大的微前端解决方案，它通过一套生命周期协议，将多个独立开发、独立部署的微应用组合成一个完整的单体体验。它非常适合大型企业级应用、需要整合不同技术栈或进行增量迁移的项目。**虽然它引入了一定的复杂性，但它为解决前端单体膨胀问题提供了非常系统化的思路和工具。\n\nhtml entry和js entry的概念是什么\n\n好的，这是一个非常核心的微前端概念。`**js-entry**` 和 `**html-entry**` 是微前端中两种不同的应用打包和加载方式，它们代表了两种不同的设计哲学和实现技术。\n\n---\n\n### 核心概念对比\n| **特性** | **js-entry (JavaScript 入口)** | **html-entry (HTML 入口)** |\n| --- | --- | --- |\n| **入口文件** | 一个 JavaScript 文件 (e.g., `app.js`<br/>) | 一个 HTML 文件 (e.g., `index.html`<br/>) |\n| **内容** | 主要包含 **JavaScript 逻辑和组件** | 包含 **HTML、**`**<script>**`<br/>**、**`**<link>**`<br/>**、**`**<style>**` |\n| **加载方式** | 框架（如 single-spa）加载并执行 JS 文件 | 框架通过 **fetch** 获取 HTML，解析出其中的 JS/CSS 并执行 |\n| **样式处理** | **需要手动管理**。通常需要约定（如 CSS Modules, CSS-in-JS）或工具来避免冲突。 | **自动处理**。HTML 中的 `<link>`<br/> 和 `<style>`<br/> 标签会被自动插入到 `<head>`<br/> 中。 |\n| **沙箱隔离** | 通常需要额外的库（如 `qiankun`<br/> 的沙箱）来实现 JS 和 CSS 的运行时隔离。 | 天然更易于实现**HTML级别的沙箱**（例如，创建一个 Shadow DOM 来包裹整个微应用的内容）。 |\n| **代表性方案** | 原始的 **single-spa** 方案 | **qiankun**（基于 single-spa）、**Module Federation**（某种程度上） |\n\n\n---\n\n### 深入理解\n#### 1. js-entry (JavaScript 入口)\n这是 **single-spa 早期和官方推荐**的方式。它的理念是：一个微应用**本质上是一个 JavaScript 模块**，这个模块导出了 `bootstrap`, `mount`, `unmount` 等生命周期函数。\n\n**如何工作？**\n\n1. 主应用（容器）根据路由规则，判断需要加载微应用 A。\n2. 主应用通过 `System.import()` 或 `import()` 动态加载微应用 A 的 **入口 JS 文件**（例如 `https://a.com/app.js`）。\n3. 这个 JS 文件被执行，并返回一个包含生命周期函数的对象。\n4. 主应用依次调用微应用的 `bootstrap` 和 `mount` 函数。\n5. 在 `mount` 函数中，微应用**用自己的逻辑**将组件渲染到主应用提供的 DOM 容器中。\n\n**示例代码 (single-spa 配置)：**\n\njavascript\n\n```javascript\nregisterApplication({\n  name: 'my-app',\n  // 这里是一个 js-entry，指向一个 JS 文件\n  app: () => System.import('https://a.com/js/app.js'),\n  activeWhen: '/app'\n});\n```\n\n**优点：**\n\n+ 概念清晰，符合“应用即模块”的理念。\n+ 打包输出干净，通常是一个或多个 JS 包。\n\n**缺点：**\n\n+ **样式处理麻烦**：你需要自己在微应用的 JS 代码里引入 CSS（如 `import './app.css'`），并小心全局样式冲突。\n+ **需要额外配置**：为了实现资源加载和隔离，需要复杂的 Webpack 配置和额外的库。\n\n#### 2. html-entry (HTML 入口)\n这种方式的理念是：一个微应用是**一个完整的、可以独立运行的“页面”**。主应用只需要加载这个页面的 HTML 文件，剩下的资源（JS, CSS）都由这个 HTML 文件自己声明。\n\n**如何工作？**\n\n1. 主应用根据路由规则，判断需要加载微应用 B。\n2. 主应用通过 **fetch** 请求微应用 B 的**入口 HTML 文件**（例如 `https://b.com/index.html`）。\n3. 主应用**解析**这个 HTML 文件，提取出其中的 `**<script>**`** ****和**** **`**<link>**`** ****标签**。\n4. 主应用手动创建这些 `<script>` 和 `<link>` 元素，并将它们插入到主文档的 `<head>` 中，从而加载并执行微应用的 JS 和 CSS。\n5. 同时，主应用通常会提供一个**隔离的沙箱环境**（如 Shadow DOM），将微应用的整个 DOM 结构渲染在其中。\n\n**示例概念（qiankun 的做法）：**\n\njavascript\n\n```javascript\nimport { registerMicroApps, start } from 'qiankun';\n\nregisterMicroApps([\n  {\n    name: 'vue-app',\n    // 这里是一个 html-entry，指向一个 HTML 文件\n    entry: '//localhost:7101', // 会默认加载这个地址下的 index.html\n    container: '#container',\n    activeRule: '/vue',\n  },\n]);\nstart();\n```\n\n**优点：**\n\n+ **对旧项目更友好**：很多老项目（如 jQuery、Backbone 项目）本身就是以 HTML 为中心开发的，改造为 html-entry 更容易。\n+ **资源加载自动化**：无需在 JS 中手动引入资源，HTML 中声明的所有资源都会被自动加载。\n+ **更强大的隔离能力**：更容易与 Shadow DOM 结合，实现真正的样式和作用域隔离。\n\n**缺点：**\n\n+ **需要解析 HTML**：主应用需要具备解析 HTML 并提取资源的能力，实现起来比直接 `import` 一个 JS 文件更复杂。\n+ **可能加载多余资源**：如果 HTML 中声明了多个入口，需要更精细的解析策略来避免加载未使用的资源。\n\n---\n\n### 总结与类比\n| **概念** | **类比** |\n| --- | --- |\n| `**js-entry**` | 就像 **“组装电脑”**。主应用（你）买来各个零件（JS 逻辑、手动引入的 CSS），自己动手组装成一台完整的电脑（微应用）。控制力强，但过程繁琐。 |\n| `**html-entry**` | 就像 **“购买品牌整机”**。主应用（你）直接买来一台戴尔电脑（HTML 文件），插上电（插入 DOM）就能用。开箱即用，非常方便，但内部细节被封装了。 |\n\n\n**现代趋势：**\n\n+ 纯粹的 `js-entry` 由于其配置的复杂性，在直接使用时体验并不友好。\n+ **qiankun** 这类框架通过实现 `html-entry` 模式，极大地改善了开发者体验，降低了微前端的上手门槛。\n+ **Webpack Module Federation** 提供了另一种更现代化的 `js-entry`，它通过复杂的依赖共享机制，解决了 `js-entry` 的许多痛点（如共享库重复加载），可以看作是 `js-entry` 的终极进化形态。\n\n因此，选择哪种方式取决于你的技术栈和框架：\n\n+ 使用 **原始的 single-spa**，你通常需要处理 `js-entry`。\n+ 使用 **qiankun**，你享受的是 `html-entry` 带来的便利。\n+ 使用 **Module Federation**，你体验的是高级的、基于依赖共享的 `js-entry`。\n\n## 路由分发可以实现微前端架构吗\n当然可以。**路由分发是实现微前端架构最主要、最常用也是最经典的方式**。它被认为是微前端架构的“第一种模式”，并且非常有效。\n\n### 核心思想\n**通过路由（URL）的变化，来决定在页面容器中加载、展示和卸载哪个微前端应用。** 主应用（通常称为“容器应用”或“根应用”）充当一个**路由器**和**编排者**的角色，而各个微应用则是独立开发、部署的功能模块。\n\n---\n\n### 它是如何工作的？\n1. **一个路由规则集**：主应用中维护一个配置表，将特定的 URL 路径模式（如 `/app1/*`, `/settings`, `/dashboard`）映射到对应的微应用。\n2. **监听路由变化**：主应用监听 `popstate`、`hashchange` 等浏览器路由事件。\n3. **匹配与决策**：当路由发生变化时（用户点击链接或手动输入 URL），主应用根据配置表判断当前应该激活哪个微应用。\n4. **加载与挂载**：主应用动态获取该微应用的资源（JS, CSS），并将其挂载到页面中指定的 DOM 容器（如 `<div id=\"micro-app-container\">`）中。\n5. **卸载与清理**：当用户离开当前路由时，主应用会卸载之前的微应用，并进行必要的清理工作（如清除事件监听器、内存释放等），然后加载新的微应用。\n\n## webpack5的Module Federation可以详细说说嘛\n好的，我们来深入、详细地探讨 Webpack 5 的 **Module Federation（模块联邦）**。它不仅仅是微前端的一种实现方式，更是一种革命性的架构思想。\n\n### 一、核心概念：它是什么？\n**Module Federation (MF)** 的核心目标是：**允许一个 JavaScript 应用在运行时动态地从另一个应用加载代码并共享依赖**。\n\n你可以把它想象成在浏览器端实现了类似 Node.js 的 `require` 或 `import` 机制，但不是在本地文件系统，而是在**网络上的不同独立应用之间**。\n\n它打破了传统的应用隔离边界，允许应用彼此成为“模块提供者”和“模块消费者”。\n\n---\n\n### 二、为什么要用 Module Federation？(解决的核心痛点)\n1. **彻底解决依赖重复打包**\n    - **传统微前端**：如果主应用和微应用都使用了 React、Vue 等相同的库，这些库的代码会被分别打包到各自的 bundle 中。用户浏览器会多次下载和执行相同的库代码，导致体积膨胀和性能下降。\n    - **MF**：可以**指定共享依赖**。React 等库只加载一次，所有应用都使用同一份实例。这解决了最重要的“依赖地狱”问题。\n2. **更彻底的应用拆分与团队自治**\n    - 它允许将应用拆分成更细粒度的“模块”或“组件”，而不仅仅是“页面”或“应用”。\n    - 团队可以独立开发、部署**一个按钮、一个表单、一个页面**，并让其他团队直接消费。\n3. **运行时动态集成**\n    - 代码集成发生在运行时（Runtime），而非构建时（Build-time）。这意味着：\n        * 你可以进行 **A/B 测试**，动态切换不同版本的组件。\n        * 可以**独立部署**某个模块，而无需重新部署整个应用。\n        * 主应用甚至不需要提前知道所有可能被加载的微应用。\n\n---\n\n### 三、核心角色与配置\nMF 中有两个关键角色：\n\n1. **Remote (远程模块/消费者)**\n    - 它是一个**使用方**应用，在运行时从其他地方（`Host`）导入并执行代码。\n    - 它的配置使用 `remotes` 属性。\n2. **Host (宿主模块/提供者)**\n    - 它是一个**提供方**应用，将其内部的某些模块暴露给外部使用。\n    - 它的配置使用 `exposes` 属性。\n\n**一个应用可以同时是**** **`**Host**`** ****和**** **`**Remote**`。\n\n#### 配置详解 (`webpack.config.js`)\njavascript\n\n```javascript\n// Host 应用的配置 (提供模块的应用，端口3001)\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  // ...其他配置\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app1', // 必填，这个应用的唯一名称，是消费者调用时的标识\n      filename: 'remoteEntry.js', // 必填，对外暴露的入口文件清单名\n      exposes: { // 暴露哪些模块给外部使用\n        './Button': './src/components/Button', // 键：供外部使用的别名；值：本地模块路径\n        './App': './src/App',\n      },\n      shared: { // 共享的依赖库\n        react: { \n          singleton: true, // 确保只使用一个单例版本\n          requiredVersion: '^18.2.0' // 需要的版本\n        },\n        'react-dom': {\n          singleton: true,\n          requiredVersion: '^18.2.0'\n        },\n      },\n    }),\n  ],\n};\n```\n\njavascript\n\n```javascript\n// Remote 应用的配置 (消费模块的应用，端口3002)\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  // ...其他配置\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app2',\n      remotes: { // 声明要消费哪些远程应用\n        // 格式: \"name@url/remoteEntry.js\"\n        app1: 'app1@http://localhost:3001/remoteEntry.js',\n      },\n      shared: { // 共享依赖的配置必须与Host一致，才能成功共享\n        react: { \n          singleton: true,\n          requiredVersion: '^18.2.0'\n        },\n        'react-dom': {\n          singleton: true,\n          requiredVersion: '^18.2.0'\n        },\n      },\n    }),\n  ],\n};\n```\n\n---\n\n### 四、如何使用？\n在 `app2` (Remote) 的代码中，你可以像导入本地模块一样**动态导入** `app1` (Host) 暴露的模块：\n\njavascript\n\n```javascript\n// 在 app2 的 React 组件中\nimport React, { Suspense } from 'react';\n\n// 使用动态导入语法。`app1` 是配置中remotes的key，`./Button` 是app1暴露的模块名\nconst RemoteButton = React.lazy(() => import('app1/Button'));\n\nfunction App() {\n  return (\n    <div>\n    <h1>我是 App2</h1>\n    <Suspense fallback={<div>Loading Button...</div>}>\n  {/* 这个Button组件来自另一个独立应用 app1！ */}\n  <RemoteButton />\n    </Suspense>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n---\n\n### 五、工作流程（魔法是如何发生的？）\n1. **构建阶段**：\n    - `Host` (`app1`) 构建时，会生成一个 `remoteEntry.js` 文件。这个文件是一个**清单(Manifest)**，记录了 `exposes` 了哪些模块以及如何获取它们。\n    - `Remote` (`app2`) 构建时，会意识到 `import('app1/Button')` 是一个远程模块，不会将其打包到自己的 bundle 中。\n2. **运行时阶段**：\n    - 浏览器加载 `app2`。\n    - 当执行到 `import('app1/Button')` 时，Webpack 运行时就会去检查配置。\n    - 它发现 `app1` 对应 `http://localhost:3001/remoteEntry.js`，于是**动态加载**这个 `remoteEntry.js` 文件。\n    - `remoteEntry.js` 告诉 `app2` 如何从 `app1` 的服务器上获取 `Button` 组件的代码块。\n    - Webpack 加载这个代码块，并**与**** **`**app2**`** ****共享的**** **`**react**`** ****和**** **`**react-dom**`** ****实例一起执行它**。\n    - 组件渲染成功。\n\n---\n\n### 六、与 single-spa 等方案的对比\n| **特性** | **Module Federation** | **single-spa (传统方式)** |\n| --- | --- | --- |\n| **核心能力** | **模块共享与依赖管理** | **应用生命周期管理与路由** |\n| **集成方式** | **运行时动态导入** | 运行时加载（但依赖需各自处理） |\n| **依赖处理** | **卓越**。自动共享库，避免重复。 | **困难**。需要额外手动配置或工具解决。 |\n| **打包输出** | 生成 `remoteEntry.js`<br/> 清单文件 | 生成应用的入口 JS 文件 |\n| **粒度** | **非常细**。可以共享单个组件、函数、工具库。 | **较粗**。通常以整个“应用”或“页面”为单元。 |\n| **关系** | **互补**。可以**结合使用**：用 single-spa 做路由和生命周期管理，用 MF 来加载组件和共享依赖。 |  |\n\n\n### 总结\n**Webpack 5 的 Module Federation 是一项颠覆性的技术**。它不再是简单地将应用机械地拼凑在一起，而是真正实现了应用间代码的“无缝融合”与“依赖共享”。\n\n它最适合的场景包括：\n\n+ **大型平台型产品**：需要多个团队独立开发不同功能模块。\n+ **微前端架构**：是目前实现微前端最先进、最优雅的方案之一。\n+ **跨应用组件/工具库共享**：避免维护多个版本的通用组件。\n\n它代表了前端架构从“单体”到“分布式”演进的重要方向，是每一位前端架构师都应该深入理解的技术。\n\nweb component\n\n## 好的，我们来全面、深入地探讨 Web Components。\n### 一、核心概念：它是什么？\n**Web Components** 是一套**浏览器原生支持**的技术集合，允许你创建可重用的、封装的自定义 HTML 元素（类似于 `<div>`、`<button>`，但是是你自己定义的），并在任何现代浏览器中使用它们，无需任何外部框架（如 React、Vue、Angular）。\n\n它的核心目标是为 Web 开发提供**真正的组件化模型**，并解决代码重用和封装的问题。\n\n---\n\n### 二、为什么需要 Web Components？（解决的问题）\n1. **框架无关性 (Framework-Agnostic)**\n    - 你用 Web Components 编写的组件可以在任何 HTML 页面中使用，无论这个页面用的是 React、Vue、Angular、jQuery 还是纯 JavaScript。它提供了**最大程度的可移植性**。\n2. **原生封装 (Native Encapsulation)**\n    - **Shadow DOM** 提供了强大的样式和行为封装。组件内部的样式不会泄漏到外部，外部的样式也不会渗透到组件内部（除非特意允许）。这彻底解决了 CSS 全局污染的问题。\n3. **长期稳定性 (Longevity)**\n    - 作为**Web 平台标准**，它由浏览器厂商直接实现和维护，不像前端框架那样有生命周期（例如，AngularJS 到 Angular 的断代升级）。你写的组件在未来很多年内都能继续工作。\n4. **生态系统互操作性 (Interoperability)**\n    - 它可以在任何框架中被当作普通的 HTML 元素使用，成为了连接不同技术栈应用的“桥梁”。\n\n---\n\n### 三、技术构成（四大核心技术）\nWeb Components 主要由四项技术标准组成，它们可以单独使用，但组合在一起威力最大。\n\n#### 1. Custom Elements（自定义元素）\n一套 JavaScript API，允许你**定义自定义元素及其行为**。\n\n+ **如何定义**：通过继承 `HTMLElement` 类来创建一个新的元素类。\n+ **生命周期回调**：\n    - `connectedCallback`: 当元素首次被插入到 DOM 时调用。\n    - `disconnectedCallback`: 当元素从 DOM 中移除时调用。\n    - `adoptedCallback`: 当元素被移动到新的文档时调用。\n    - `attributeChangedCallback`: 当元素的被观察属性（在 `observedAttributes` 中定义）发生变化时调用。\n\n**示例：定义一个简单的自定义元素**\n\njavascript\n\n```javascript\nclass MyButton extends HTMLElement {\n  constructor() {\n    super();\n    // 初始化逻辑\n  }\n\n  connectedCallback() {\n    this.innerHTML = `<button>Click Me!</button>`;\n    this.addEventListener('click', () => {\n      alert('Button clicked!');\n    });\n  }\n\n  // 定义需要监听的属性\n  static get observedAttributes() {\n    return ['disabled'];\n  }\n\n  // 当disabled属性变化时触发\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === 'disabled') {\n      console.log(`disabled changed from ${oldValue} to ${newValue}`);\n    }\n  }\n}\n\n// 向浏览器注册这个新元素，标签名必须包含连字符 `-`\ncustomElements.define('my-button', MyButton);\n```\n\n**在 HTML 中使用**：\n\nhtml\n\n<my-button disabled></my-button>\n\n#### 2. Shadow DOM（影子 DOM）\n一套用于将**封装的、“影子”的 DOM 树附加到元素**的 API。这是实现样式和行为封装的关键。\n\n+ **Shadow Root**：Shadow DOM 的根节点。\n+ **模式**：\n    - `open`: 可以通过 JavaScript 从外部访问（例如 `element.shadowRoot`）。\n    - `closed`: 外部无法访问，封装性更强。\n+ **作用域**：在 Shadow DOM 内部定义的样式和脚本只在这个范围内有效，与外部隔离。\n\n**示例：为自定义元素添加 Shadow DOM**\n\njavascript\n\n```javascript\nclass MyCard extends HTMLElement {\n  constructor() {\n    super();\n    // 附加一个打开的 Shadow Root\n    const shadow = this.attachShadow({ mode: 'open' });\n\n    // 创建模板\n    const template = document.createElement('template');\n    template.innerHTML = `\n      <style>\n        /* 这些样式只在这个卡片内有效，不会影响外部 */\n        .card {\n          border: 1px solid #ccc;\n          padding: 16px;\n          border-radius: 8px;\n          font-family: sans-serif;\n        }\n        h2 { color: blue; margin-top: 0; }\n      </style>\n      <div class=\"card\">\n        <h2><slot name=\"title\">Default Title</slot></h2>\n        <p><slot name=\"content\">Default content...</slot></p>\n      </div>\n    `;\n\n    // 克隆模板内容并添加到 Shadow Root\n    shadow.appendChild(template.content.cloneNode(true));\n  }\n}\ncustomElements.define('my-card', MyCard);\n```\n\n**在 HTML 中使用**：\n\nhtml\n\n```plain\n<my-card>\n  <!-- 使用 slot 将外部内容投影到 Shadow DOM 中的指定位置 -->\n  <span slot=\"title\">My Awesome Title</span>\n  <span slot=\"content\">This is some fantastic content.</span>\n</my-card>\n```\n\n#### 3. HTML Templates（HTML 模板）\n`<template>` 和 `<slot>` 元素允许你编写**在页面加载时不会立即渲染的标记模板**。这些模板可以被后续的 JavaScript 激活和使用。\n\n+ `<template>`：内容不会被浏览器解析、渲染或执行，直到被 JavaScript 提取并使用。\n+ `<slot>`：在 Web Component 内部充当占位符，允许用户在使用组件时传入自己的自定义内容（如上例所示）。\n\n#### 4. ES Modules（ES 模块）\n现代 JavaScript 的模块标准，为在 Web 上包含和重用 JS 代码提供了官方机制。它使得导入和导出 Web Components 变得简单。\n\nhtml\n\n```html\n<!-- 在 HTML 中导入并使用一个定义好的 Web Component -->\n<script type=\"module\" src=\"./my-component.js\"></script>\n<my-component></my-component>\n```\n\n---\n\n### 四、Web Components 的优点与缺点\n#### 优点：\n1. **浏览器原生**：无需编译，无需复杂的构建工具。\n2. **高度封装**：Shadow DOM 解决了 CSS 和 DOM 的隔离问题。\n3. **框架无关**：极高的互操作性和可移植性。\n4. **永久可用**：作为 Web 标准，具有极长的生命周期和向后兼容性。\n\n#### 缺点：\n1. **生态相对年轻**：虽然基础功能强大，但缺少像 React/Vue 那样庞大的生态系统（状态管理、路由、测试工具等）。\n2. **数据流管理较弱**：原生不支持类似 React 的 Props 向下传递、事件向上冒泡的父子组件通信范式，需要自己实现（通常用 Custom Events）。\n3. **SSR (服务器端渲染) 支持差**：自定义元素可以在服务器上渲染，但其动态行为和客户端激活（Hydration）非常复杂，远不如 Next.js/Nuxt.js 成熟。\n4. **开发体验 (DX)**：原始的开发方式比较繁琐，需要写很多样板代码。但社区有诸如 **Lit**、**Stencil** 等库来极大地改善体验。\n\n---\n\n### 五、Web Components 与微前端和框架\n+ **在微前端中**：Web Components 是实现**技术栈无关**微前端的理想载体。每个团队可以用自己熟悉的技术（React, Vue）**开发**组件，但最终**发布**为一个封装好的 Web Component（例如，将一个 React 组件包装成 `<team-product-card>`），由主应用统一调度。\n+ **与框架的关系**：\n    - **不是替代关系**，而是**互补关系**。\n    - **框架 (React/Vue) 擅长解决：** 复杂的 UI 状态管理、数据流、高效的 DOM 差分更新。它们提供了**优秀的开发体验**和**完整的解决方案**。\n    - **Web Components 擅长解决：** 跨框架重用、底层 UI 组件库、集成遗留应用、长期稳定的基础组件。它们提供了**浏览器级别的互操作性**。\n\n**总结来说，Web Components 是 Web 平台的底层基础，为构建可长期存在、高度封装、框架无关的组件提供了强大的原生能力。** 虽然它在开发复杂应用时不如现代框架那么方便，但其独特优势使其在特定场景（如微前端、跨技术栈组件库、大型企业级应用）中是不可替代的选择。\n\nqiankun实现样式和js隔离的原理\n\n好的，我们来深入剖析 **qiankun** 实现样式和 JavaScript 隔离的原理。这是 qiankun 的核心能力之一，也是它相比原始 single-spa 更易用、更强大的关键。\n\n### 总体思想\nqiankun 的隔离策略可以概括为：**“重样式隔离，轻 JS 沙箱”**。它通过在应用加载和卸载时动态地操作样式和 JavaScript 执行环境来模拟一个隔离的沙箱环境。\n\n---\n\n### 一、样式隔离 (CSS Isolation)\nqiankun 提供了三种主要的样式隔离方案，根据场景不同自动或手动启用。\n\n#### 1. 严格样式隔离 (Scoped CSS)\n**原理：** 为每个微应用包裹一个 **Shadow DOM**。\n\n+ **如何工作：**\n    1. 当 qiankun 挂载一个微应用时，它会创建一个 Shadow Root，并将其作为该应用的容器。\n    2. 微应用的所有 DOM 结构都被渲染在这个 Shadow DOM 内部。\n    3. **Shadow DOM 的特性天然实现了样式的封装**：内部的样式不会影响外部，外部的样式也不会影响内部（除非使用 `::part` 或 `:host` 等特定语法）。\n+ **优点：** 隔离性最强，是浏览器原生的完美隔离方案。\n+ **缺点：**\n    - 某些第三方库（特别是弹窗类）可能会因为无法正确定位到 Shadow DOM 外部而出现问题。\n    - 微应用内的样式完全无法影响主应用，反之亦然，有时这可能不符合设计需求。\n+ **启用方式：** 在 `start` 函数中配置 `{ strictStyleIsolation: true }`。\n\njavascript\n\n```javascript\nimport { start } from 'qiankun';\nstart({\n  strictStyleIsolation: true, // 启用严格样式隔离\n});\n```\n\n#### 2. 实验性样式隔离 (CSS Scoped)\n**原理：** 一种更宽松的隔离方式，使用 **运行时动态样式表重写**。\n\n+ **如何工作：**\n    1. qiankun 会劫持微应用运行时**动态添加样式标签（**`**<style>**`**,**** **`**<link>**`**）** 的行为。\n    2. 当微应用插入一个新的样式标签时，qiankun 会将其内容抓取过来。\n    3. 使用 **CSS 规则重写器**（例如 `postcss` 插件）为所有 CSS 选择器**添加一个特殊的前缀**。这个前缀通常基于微应用的名称或一个特定属性。\n    4. 将重写后的 CSS 内容插入到 `document.head` 中。\n    5. 同时，qiankun 会为微应用的**容器元素**添加上一步中使用的**相同属性**。\n\n**示例：**\n\n    - 微应用有一个样式规则：`.button { color: red; }`\n    - qiankun 将其重写为：`[data-qiankun=\"my-app\"] .button { color: red; }`\n    - 同时，微应用的容器 `<div>` 会获得属性：`<div data-qiankun=\"my-app\">...</div>`\n    - 这样，样式规则就只会在这个容器内生效。\n+ **优点：** 比 Shadow DOM 兼容性更好，允许微应用样式影响其容器内的任何元素（包括动态 append 到 body 的弹窗）。\n+ **缺点：** 是运行时重写，有一定性能开销，且是实验性功能。\n+ **启用方式：** 在 `start` 函数中配置 `{ experimentalStyleIsolation: true }`。\n\njavascript\n\n```javascript\nstart({\n  experimentalStyleIsolation: true, // 启用实验性样式隔离\n});\n```\n\n#### 3. 动态样式表加载/卸载 (最常见的默认行为)\n如果不开启上述两种隔离，qiankun 默认采用一种更简单但有效的策略。\n\n+ **原理：**\n    1. **加载时：** qiankun 通过 `fetch` 获取微应用的 HTML 入口，解析出所有的 `<style>` 和 `<link>` 标签。\n    2. 将这些样式标签**直接插入到**** **`**document.head**` 中。\n    3. **卸载时：** qiankun 会**记录**所有由该微应用添加的样式标签，并在卸载微应用时**直接将这些标签从 DOM 中移除**。\n+ **优点：** 实现简单，性能好。\n+ **缺点：** **不是真正的隔离**。如果多个微应用有相同选择器的样式规则，后加载的会覆盖先加载的（因为后加载的样式表在更后面，优先级更高）。这依赖于开发者的约定。\n+ **这是 qiankun 的默认行为**，对于很多应用来说已经足够。\n\n---\n\n### 二、JavaScript 隔离 (JS Sandbox)\nqiankun 的 JS 沙箱的核心目标是：**防止微应用在全局环境（**`**window**`**）上留下永久的污染，并在应用切换时恢复和清理环境**。它主要模拟了三个环境的隔离：\n\n#### 1. 快照沙箱 (SnapshotSandbox) - 用于单实例场景\n**原理：** 在应用加载前后对全局 `window` 对象进行“拍照”和“diff”，适用于同一时间只能有一个微应用活跃的浏览器环境。\n\n+ **工作流程：**\n    1. **激活沙箱 (mount)：** 将当前 `window` 的所有属性拍一个**快照**（`windowSnapshot`），存起来。\n    2. **微应用运行：** 微应用可以任意修改 `window`。\n    3. **失活沙箱 (unmount)：**\n        * 将当前的 `window` 和之前存的 `windowSnapshot` 进行对比，得到修改的差异（`modifyPropsMap`）。\n        * **还原现场：** 遍历差异，将 `window` 上的属性**恢复**到拍快照时的状态。\n        * **记录污染：** 将微应用修改的差异保存起来。\n    4. **再次激活：** 将之前保存的差异（`modifyPropsMap`）**重新应用到**** **`**window**`** ****上**，让微应用感觉自己的修改一直都在。\n+ **优点：** 兼容性极好，支持所有浏览器。\n+ **缺点：** 无法支持多个微应用同时运行（多实例），因为共用一个全局 `window`。\n\n#### 2. 代理沙箱 (ProxySandbox) - 用于多实例场景（主流）\n**原理：** 使用 ES6 的 `Proxy` 为每个微应用创建一个假的、隔离的 `window` 对象。\n\n+ **工作流程：**\n    1. qiankun 为每个微应用创建一个空的 `fakeWindow` 对象。\n    2. 用 `Proxy` 代理这个 `fakeWindow`。\n    3. 当微应用操作 `window` 时：\n        * **读操作**：优先从 `fakeWindow` 里读，如果读不到，则 fallback 到真正的全局 `window`（这样可以共享 `document`, `location` 等全局对象）。\n        * **写操作**：所有对属性的新增和修改都只作用于 `fakeWindow` 上，**完全不会污染真正的全局**** **`**window**`。\n    4. 微应用的所有代码都在这个代理的上下文中执行（通过 `with` 语句或 `eval` 改写）。\n+ **示例：**\n\njavascript\n\n```javascript\n// 微应用代码\nwindow.myGlobalVar = 123; // 写入的是沙箱的 fakeWindow，真 window 不受影响\nconsole.log(document.title); // 读取的是真 window 的属性\n```\n\n+ **优点：**\n    - 真正的隔离，多个微应用可以同时运行，每个都有自己独立的 `window` 空间。\n    - 对微应用无感知，无需修改代码。\n+ **缺点：** 依赖 ES6 `Proxy`，无法在低版本浏览器（如 IE）中使用。\n\n#### 3. 遗留沙箱 (LegacySandbox) - 已逐渐被代理沙箱取代\n原理类似于快照沙箱，但性能优化更好。它只记录微应用修改过的属性，在卸载时还原这些属性。同样不支持多实例。\n\n---\n\n### 总结：qiankun 的隔离策略\n| **隔离类型** | **技术方案** | **优点** | **缺点** | **适用场景** |\n| --- | --- | --- | --- | --- |\n| **样式隔离** | **Shadow DOM** | 原生，隔离最彻底 | 兼容性问题，弹窗等组件可能异常 | 需要最强隔离的新应用 |\n|  | **动态样式表重写 (实验性)** | 兼容性好，支持弹窗 | 运行时开销，实验性功能 | 需要兼容弹窗的复杂应用 |\n|  | **动态加载/卸载 (默认)** | 简单，性能好 | 非真正隔离，依赖约定 | 大多数简单应用，样式冲突风险低 |\n| **JS 隔离** | **快照沙箱 (SnapshotSandbox)** | 兼容所有浏览器 | 不支持多实例 | 单实例模式，需兼容 IE 等老浏览器 |\n|  | **代理沙箱 (ProxySandbox)** | 真正隔离，支持多实例，对应用无感知 | 依赖 `Proxy`<br/>，不兼容 IE | **现代浏览器下的主流选择** |\n\n\n**qiankun 会自动选择最佳策略**：在支持 `Proxy` 的浏览器中默认使用**代理沙箱 (多实例)** 和**动态样式加载/卸载**。如果不支持 `Proxy`，则降级到**快照沙箱 (单实例)**。\n\n通过这种组合策略，qiankun 在绝大多数场景下为微前端应用提供了**足够安全、稳定且高性能的隔离环境**，极大地简化了微前端的落地复杂度。\n\nqiankun是如何实现父子应用通信的呢\n\n好的，**qiankun 的通信机制**是其核心功能之一，它设计得非常灵活，提供了多种方式来实现主应用（父应用）和微应用（子应用）之间的通信。\n\nqiankun 并没有强制使用某一种通信方式，而是提供了一个轻量的 **API（**`**initGlobalState**`**）** 作为推荐方案，同时也完全支持任何其他流行的状态管理库（如 Redux, Mobx, Vuex）或浏览器原生 API。\n\n---\n\n### 一、官方推荐方案：使用 `initGlobalState` (Actions 通信)\n这是 qiankun 官方提供的通信方式，适用于大多数场景。它的核心思想是一个**简单的发布-订阅模式**。\n\n#### 1. 在主应用中初始化状态并下发通信方法\n主应用是整个状态的管理中心。\n\njavascript\n\n```javascript\n// main-app/src/actions.js\nimport { initGlobalState } from 'qiankun';\n\n// 1. 初始化全局状态\nconst initialState = {\n  user: {\n    name: '张三',\n    token: 'abc123'\n  },\n  theme: 'light'\n};\n\n// 2. 创建 Actions 实例\nconst actions = initGlobalState(initialState);\n\n// 3. 监听状态变化（可选，主应用自己也可以监听）\nactions.onGlobalStateChange((state, prevState) => {\n  // state: 变更后的新状态\n  // prevState: 变更前的旧状态\n  console.log('主应用监听到状态变化: ', state, prevState);\n});\n\n// 4. 定义一个更新状态的方法\nexport const setGlobalState = (newState) => {\n  // 按层级合并状态\n  actions.setGlobalState(newState);\n};\n\n// 5. 将 actions 暴露出去，供微应用使用\nexport default actions;\n```\n\n#### 2. 在微应用中获取并操作状态\n微应用需要从生命周期函数中获取到 `props`，其中就包含了通信方法。\n\njavascript\n\n```javascript\n// micro-app/src/main.js (入口文件)\nlet microAppActions; // 用来保存通信方法\n\n// 导出 qiankun 生命周期函数\nexport async function mount(props) {\n  console.log('微应用挂载了', props);\n  // 1. 从 props 中获取主应用下发的 actions\n  microAppActions = props;\n\n  // 2. 监听全局状态变化\n  props.onGlobalStateChange((state, prevState) => {\n    console.log('微应用监听到状态变化: ', state, prevState);\n    // 状态变化后，更新微应用自己的视图\n    renderApp(state);\n  });\n\n  // 3. 首次挂载，获取当前全局状态并渲染应用\n  renderApp(props.getGlobalState());\n}\n\nexport async function unmount() {\n  // 卸载时取消监听（qiankun 内部会自动清理，但显式取消是好习惯）\n  microAppActions.offGlobalStateChange();\n}\n\n// React/Vue 应用的渲染函数\nfunction renderApp(state) {\n  ReactDOM.render(<App globalState={state} actions={microAppActions} />, document.getElementById('app'));\n}\n```\n\n#### 3. 在微应用组件中具体使用\njavascript\n\n```javascript\n// micro-app/src/App.jsx\nimport React from 'react';\n\nfunction App({ globalState, actions }) {\n  const { user, theme } = globalState;\n\n  const handleChangeTheme = () => {\n    // 更新全局状态\n    actions.setGlobalState({\n      theme: theme === 'light' ? 'dark' : 'light'\n    });\n  };\n\n  return (\n    <div className={`app ${theme}`}>\n  <h1>微应用页面</h1>\n  <p>用户名: {user.name}</p>\n  <button onClick={handleChangeTheme}>切换主题</button>\n  </div>\n);\n}\n\nexport default App;\n```\n\n#### `initGlobalState` API 说明：\n+ `setGlobalState(state: object)`: 设置新的全局状态，会自动与旧状态进行**浅合并**。\n+ `onGlobalStateChange(callback: function)`: 注册监听器，状态变化时触发。\n+ `offGlobalStateChange()`: 取消监听。\n+ `getGlobalState()`: 获取当前全局状态。\n\n---\n\n### 二、其他通信方案\nqiankun 是框架无关的，因此你也可以选择任何你熟悉的通信方式。\n\n#### 1. 使用 CustomEvent (浏览器原生事件)\n**原理：** 利用浏览器原生的 `window.dispatchEvent` 和 `window.addEventListener` 进行通信。\n\njavascript\n\n```javascript\n// 主应用 - 发送事件\nwindow.dispatchEvent(new CustomEvent('main-app-event', {\n  detail: { // 通过 detail 传递数据\n    type: 'CHANGE_THEME',\n    payload: 'dark'\n  }\n}));\n\n// 微应用 - 接收事件\nwindow.addEventListener('main-app-event', (event) => {\n  const { type, payload } = event.detail;\n  // 处理事件...\n});\n\n// 微应用 - 发送事件（同理）\nwindow.dispatchEvent(new CustomEvent('micro-app-event', {\n  detail: { message: 'Hello from micro app' }\n}));\n```\n\n**优点：** 原生支持，非常简单。  \n**缺点：** 数据传递能力较弱（只能同步），缺乏状态管理能力，事件需要全局唯一命名以免冲突。\n\n#### 2. 使用 Redux/Mobx/Vuex 等状态库\n**原理：** 主应用和微应用**共享同一个状态库实例**。\n\n+ **步骤：**\n    1. 主应用创建一个 Redux Store 或其他状态库实例。\n    2. 将这个 Store 通过 `window` 对象或者微应用的 `props` 暴露给微应用。\n    3. 微应用连接到这个全局的 Store，进行状态的读取和分发 Action。\n\njavascript\n\n```javascript\n// 主应用 - 创建并暴露 store\nimport { createStore } from 'redux';\nconst globalStore = createStore(/* ... */);\nwindow.__MAIN_APP_STORE__ = globalStore; // 挂到全局\n\n// 微应用 - 获取并使用 store\nconst store = window.__MAIN_APP_STORE__;\nstore.dispatch({ type: 'AN_ACTION' });\nconst state = store.getState();\n```\n\n**优点：** 功能强大，可以处理复杂的业务逻辑和状态流。  \n**缺点：** 紧密耦合，主应用和微应用必须使用同一种状态库，且版本需要兼容。\n\n#### 3. 通过 URL 或 Query Parameters 通信\n**原理：** 通过改变 URL 的查询参数来传递简单信息。\n\njavascript\n\n```javascript\n// 主应用改变URL\nconst newUrl = `${window.location.pathname}?theme=dark&userId=123`;\nhistory.pushState(null, '', newUrl);\n\n// 微应用监听URL变化\nwindow.addEventListener('popstate', () => {\n  const urlParams = new URLSearchParams(window.location.search);\n  const theme = urlParams.get('theme');\n  // ...使用参数\n});\n```\n\n**优点：** 非常简单，状态可被收藏和分享。  \n**缺点：** 只适合传递少量简单数据。\n\n---\n\n### 总结与选择建议\n| **方案** | **优点** | **缺点** | **适用场景** |\n| --- | --- | --- | --- |\n| **官方**** **`**initGlobalState**` | **官方推荐**，简单轻量，满足大部分通信需求 | 功能相对简单，不适合极其复杂的场景 | **绝大多数微前端通信场景的首选** |\n| **CustomEvent** | 浏览器原生，非常简单 | 功能弱，只能传简单数据，易产生事件名冲突 | 简单的父子通知、触发动作 |\n| **Redux/Vuex 等** | 功能强大，适合复杂状态管理 | 耦合度高，主子和微应用必须使用同一种状态库 | 大型复杂应用，且技术栈统一 |\n| **URL Parameters** | 实现简单，状态可分享 | 传递数据量有限，类型受限 | 过滤条件、简单配置等 |\n\n\n**最佳实践建议：**\n\n1. **优先使用官方的**** **`**initGlobalState**`，它能覆盖 90% 的微前端通信需求。\n2. 对于简单的、一次性的动作触发（如“刷新列表”、“显示通知”），可以辅以 **CustomEvent**。\n3. 只有在主应用和所有微应用技术栈统一且非常复杂时，才考虑使用**共享状态库**。\n4. 通信的设计应遵循**最小化原则**，尽量减少主应用和微应用之间的耦合，让微应用保持最大的独立性。\n\n\n\n","source":"_posts/微前端.md","raw":"---\ntitle: 微前端\ndate: 2024-01-15\ntags: [微前端, qiankun, single-spa, Module Federation]\ncategories: 微前端\n---\n\n参考链接：\n\n[可能是你见过最完善的微前端解决方案](https://zhuanlan.zhihu.com/p/78362028)\n\n[深入调研了微前端，还是iframe最香](https://juejin.cn/post/7244070072788287544?searchId=202508250257166071DDB47E623E0BA671)\n\n[qiankun官方文档](https://qiankun.umijs.org/zh/guide/getting-started)\n\n### 什么是微前端？\n微前端是一种软件架构，可以将前端应用拆解成一些更小的能够独立开发部署的微型应用，然后在将这些微型应用组合使其成为整体的架构模式。\n\n微前端类似于组件架构，但不同的是，组件不能够独立构建和发布，但是微前端中的应用是可以的。\n\n微前端架构与框架无关，每个微应用都可以使用不同的框架。\n\n![微前端](images/微前端.png)\n\n\n\n| **特性** | **单体前端** | **微前端** |\n| --- | --- | --- |\n| **代码库** | 单个大型代码库 | 多个独立代码库 |\n| **团队结构** | 集中式团队 | 分布式独立团队 |\n| **技术栈** | 统一技术栈 | 混合技术栈 |\n| **部署** | 整体部署 | 独立部署 |\n| **开发速度** | 后期变慢 | 持续快速 |\n| **复杂度** | 高度耦合 | 解耦独立 |\n\n\n### 微前端的价值\n微前端架构具备以下几个核心价值：\n\n+ 技术栈无关 主框架不限制接入应用的技术栈，子应用具备完全自主权\n+ 独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n+ 独立运行时 每个子应用之间状态隔离，运行时状态不共享\n\n微前端架构旨在解决[单体应用](https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLljZXkvZPlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.Sy3sQVozhhuQwuwmw8-zjyU0X_81Vve5linQ55OPo0k&zhida_source=entity)在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个[巨石应用](https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%B7%A8%E7%9F%B3%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLlt6jnn7PlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.3VWm6X4yZDpq2_EqJZDuDErH1ST1iWJUa0qPK8T5Abk&zhida_source=entity)([Frontend Monolith](https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DpU1gXA0rfwc))后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。\n\n应用架构如下：\n\n<img src=\"/images/微前端架构.png\" alt=\"微前端架构\" height=\"auto\" style=\"width:50%; display:block;\">\n\n> Stitching layer 作为主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用。因此主框架的定位则仅仅是：**导航路由 + 资源加载框架**\n>\n\n\n\nsingle-spa是什么\n\n好的，我们来详细解释一下 **single-spa** 是什么。\n\n### 核心定义\n**single-spa 是一个用于构建【微前端】架构的 JavaScript 框架。** 你可以把它理解为一个**顶层的路由器和应用程序加载器**。\n\n它的核心思想是：将一个大型的单页前端应用（SPA）拆分成多个小型、独立、可以并行开发交付的“微应用”。然后，single-spa 负责在运行时根据一定的规则（通常是当前的 URL）动态地加载、展示、卸载这些微应用。\n\n---\n\n### 一个简单的比喻\n想象一下你的浏览器是一个舞台：\n\n+ **传统单体应用：** 只有一个庞大的剧团表演一整部冗长的戏剧。要更换一个演员（修改一个功能），需要整个剧团停下来重新排练（整个应用重新构建部署）。\n+ **single-spa 微前端：** 舞台（浏览器）本身是空的。有一个**导演（single-spa）**。导演手里有一个节目单（根配置），上面写着什么节目（微应用）在什么时刻（例如，URL 是 `/settings` 时）上台表演。\n    - 当报幕员说“下一个节目是《用户设置》”时（用户访问了 `/settings`），导演就喊：“《用户设置》剧组，上台！”（加载并挂载 React 微应用）。\n    - 节目表演完了（用户离开了 `/settings`），导演就喊：“《用户设置》剧组，下台！”（卸载 React 微应用）。\n    - 下一个节目是《商品列表》，另一个完全不同的剧组（Vue 微应用）就上台表演。\n\n**single-spa 就是这个导演**，它自己不表演具体内容，但它负责协调所有剧组（微应用）的上场和下场时机。\n\n---\n\n### 为什么需要 single-spa？（解决的问题）\n1. **技术栈无关：** 各个微应用可以使用不同的技术栈（React, Vue, Angular, Svelte 等）。团队可以自由选择或升级其技术栈，而不会影响其他团队。\n2. **独立开发、独立部署：** 每个微应用都由独立的团队开发、测试和部署，大大提升了团队的自治度和发布效率。\n3. **增量升级：** 允许你逐步重写一个老旧的巨型前端应用，可以一部分一部分地用新的框架替换，而不是一次性重写全部。\n4. **代码隔离：** 应用之间实现了良好的代码和样式隔离（虽然需要一些额外规范），避免了全局污染和冲突。\n\n---\n\n### single-spa 的核心工作原理\nsingle-spa 通过定义一套**生命周期协议**来工作。每个微应用都必须对外暴露三个核心的函数：\n\n1. `bootstrap`： 应用首次加载时执行一次，用于初始化。\n2. `mount`： 当激活条件满足时（例如用户访问了该应用的路由），执行此函数。应用需要在这个函数里完成渲染，将组件挂载到 DOM 上。\n3. `unmount`： 当激活条件不再满足时（例如用户离开了该路由），执行此函数。应用需要在这个函数里完成清理工作，将自己从 DOM 上卸载。\n\nsingle-spa 的“根配置”会**注册**所有微应用，并为每个应用定义一个 `activity function`（激活函数）。这个函数通常根据 `window.location` 进行判断。\n\njavascript\n\n```javascript\n// single-spa 根配置示例 (root-config.js)\nimport { registerApplication, start } from 'single-spa';\n\n// 注册一个应用\nregisterApplication({\n  name: 'my-react-app', // 应用唯一名\n  app: () => System.import('my-react-app'), // 如何加载该应用的代码\n  activeWhen: (location) => location.pathname.startsWith('/react'), // 激活函数：当路径以 /react 开头时，加载这个应用\n});\n\n// 启动 single-spa\nstart();\n```\n\n**流程如下：**\n\n1. 用户访问 `https://example.com/react`。\n2. single-spa 检查所有注册的应用，发现 `my-react-app` 的 `activeWhen` 函数返回 `true`。\n3. single-spa 动态加载 `my-react-app` 的代码包。\n4. 依次执行该应用的 `bootstrap` 和 `mount` 生命周期函数，应用被渲染到页面上。\n5. 用户导航到 `/vue`，`my-react-app` 的 `activeWhen` 返回 `false`。\n6. single-spa 执行它的 `unmount` 函数，将其卸载。\n\n---\n\n### 主要优缺点\n**优点：**\n\n+ **强大的解耦和能力：** 真正实现了前端应用的拆分和团队自治。\n+ **框架无关：** 是整合不同技术栈应用的理想选择。\n+ **懒加载：** 提升首次加载速度，按需加载应用。\n\n**缺点：**\n\n+ **复杂度高：** 引入了分布式系统的复杂性，需要解决依赖共享、样式隔离、通信机制等问题。\n+ **开发体验：** 调试和配置比单体应用更复杂。通常需要类似 `single-spa` 官方的 `create-single-spa` 工具链来简化流程。\n+ **依赖管理：** 需要谨慎处理共享库（如 `react`, `vue`）以避免重复打包。\n\n---\n\n### 与 Module Federation 的区别\nWebpack 5 的 **Module Federation（模块联邦）** 是另一种实现微前端的热门技术。它们不是互斥的，甚至可以结合使用：\n\n+ **single-spa** 主要解决的是**路由和应用生命周期管理**的问题（“什么时候加载哪个应用”）。\n+ **Module Federation** 主要解决的是**应用之间代码共享和依赖处理**的问题（“如何共享一个 React 实例，避免重复加载”）。\n\n一个常见的模式是：使用 **single-spa 作为路由器**，使用 **Module Federation 来加载微应用和共享依赖**。\n\n### 总结\n**single-spa 是一个成熟、强大的微前端解决方案，它通过一套生命周期协议，将多个独立开发、独立部署的微应用组合成一个完整的单体体验。它非常适合大型企业级应用、需要整合不同技术栈或进行增量迁移的项目。**虽然它引入了一定的复杂性，但它为解决前端单体膨胀问题提供了非常系统化的思路和工具。\n\nhtml entry和js entry的概念是什么\n\n好的，这是一个非常核心的微前端概念。`**js-entry**` 和 `**html-entry**` 是微前端中两种不同的应用打包和加载方式，它们代表了两种不同的设计哲学和实现技术。\n\n---\n\n### 核心概念对比\n| **特性** | **js-entry (JavaScript 入口)** | **html-entry (HTML 入口)** |\n| --- | --- | --- |\n| **入口文件** | 一个 JavaScript 文件 (e.g., `app.js`<br/>) | 一个 HTML 文件 (e.g., `index.html`<br/>) |\n| **内容** | 主要包含 **JavaScript 逻辑和组件** | 包含 **HTML、**`**<script>**`<br/>**、**`**<link>**`<br/>**、**`**<style>**` |\n| **加载方式** | 框架（如 single-spa）加载并执行 JS 文件 | 框架通过 **fetch** 获取 HTML，解析出其中的 JS/CSS 并执行 |\n| **样式处理** | **需要手动管理**。通常需要约定（如 CSS Modules, CSS-in-JS）或工具来避免冲突。 | **自动处理**。HTML 中的 `<link>`<br/> 和 `<style>`<br/> 标签会被自动插入到 `<head>`<br/> 中。 |\n| **沙箱隔离** | 通常需要额外的库（如 `qiankun`<br/> 的沙箱）来实现 JS 和 CSS 的运行时隔离。 | 天然更易于实现**HTML级别的沙箱**（例如，创建一个 Shadow DOM 来包裹整个微应用的内容）。 |\n| **代表性方案** | 原始的 **single-spa** 方案 | **qiankun**（基于 single-spa）、**Module Federation**（某种程度上） |\n\n\n---\n\n### 深入理解\n#### 1. js-entry (JavaScript 入口)\n这是 **single-spa 早期和官方推荐**的方式。它的理念是：一个微应用**本质上是一个 JavaScript 模块**，这个模块导出了 `bootstrap`, `mount`, `unmount` 等生命周期函数。\n\n**如何工作？**\n\n1. 主应用（容器）根据路由规则，判断需要加载微应用 A。\n2. 主应用通过 `System.import()` 或 `import()` 动态加载微应用 A 的 **入口 JS 文件**（例如 `https://a.com/app.js`）。\n3. 这个 JS 文件被执行，并返回一个包含生命周期函数的对象。\n4. 主应用依次调用微应用的 `bootstrap` 和 `mount` 函数。\n5. 在 `mount` 函数中，微应用**用自己的逻辑**将组件渲染到主应用提供的 DOM 容器中。\n\n**示例代码 (single-spa 配置)：**\n\njavascript\n\n```javascript\nregisterApplication({\n  name: 'my-app',\n  // 这里是一个 js-entry，指向一个 JS 文件\n  app: () => System.import('https://a.com/js/app.js'),\n  activeWhen: '/app'\n});\n```\n\n**优点：**\n\n+ 概念清晰，符合“应用即模块”的理念。\n+ 打包输出干净，通常是一个或多个 JS 包。\n\n**缺点：**\n\n+ **样式处理麻烦**：你需要自己在微应用的 JS 代码里引入 CSS（如 `import './app.css'`），并小心全局样式冲突。\n+ **需要额外配置**：为了实现资源加载和隔离，需要复杂的 Webpack 配置和额外的库。\n\n#### 2. html-entry (HTML 入口)\n这种方式的理念是：一个微应用是**一个完整的、可以独立运行的“页面”**。主应用只需要加载这个页面的 HTML 文件，剩下的资源（JS, CSS）都由这个 HTML 文件自己声明。\n\n**如何工作？**\n\n1. 主应用根据路由规则，判断需要加载微应用 B。\n2. 主应用通过 **fetch** 请求微应用 B 的**入口 HTML 文件**（例如 `https://b.com/index.html`）。\n3. 主应用**解析**这个 HTML 文件，提取出其中的 `**<script>**`** ****和**** **`**<link>**`** ****标签**。\n4. 主应用手动创建这些 `<script>` 和 `<link>` 元素，并将它们插入到主文档的 `<head>` 中，从而加载并执行微应用的 JS 和 CSS。\n5. 同时，主应用通常会提供一个**隔离的沙箱环境**（如 Shadow DOM），将微应用的整个 DOM 结构渲染在其中。\n\n**示例概念（qiankun 的做法）：**\n\njavascript\n\n```javascript\nimport { registerMicroApps, start } from 'qiankun';\n\nregisterMicroApps([\n  {\n    name: 'vue-app',\n    // 这里是一个 html-entry，指向一个 HTML 文件\n    entry: '//localhost:7101', // 会默认加载这个地址下的 index.html\n    container: '#container',\n    activeRule: '/vue',\n  },\n]);\nstart();\n```\n\n**优点：**\n\n+ **对旧项目更友好**：很多老项目（如 jQuery、Backbone 项目）本身就是以 HTML 为中心开发的，改造为 html-entry 更容易。\n+ **资源加载自动化**：无需在 JS 中手动引入资源，HTML 中声明的所有资源都会被自动加载。\n+ **更强大的隔离能力**：更容易与 Shadow DOM 结合，实现真正的样式和作用域隔离。\n\n**缺点：**\n\n+ **需要解析 HTML**：主应用需要具备解析 HTML 并提取资源的能力，实现起来比直接 `import` 一个 JS 文件更复杂。\n+ **可能加载多余资源**：如果 HTML 中声明了多个入口，需要更精细的解析策略来避免加载未使用的资源。\n\n---\n\n### 总结与类比\n| **概念** | **类比** |\n| --- | --- |\n| `**js-entry**` | 就像 **“组装电脑”**。主应用（你）买来各个零件（JS 逻辑、手动引入的 CSS），自己动手组装成一台完整的电脑（微应用）。控制力强，但过程繁琐。 |\n| `**html-entry**` | 就像 **“购买品牌整机”**。主应用（你）直接买来一台戴尔电脑（HTML 文件），插上电（插入 DOM）就能用。开箱即用，非常方便，但内部细节被封装了。 |\n\n\n**现代趋势：**\n\n+ 纯粹的 `js-entry` 由于其配置的复杂性，在直接使用时体验并不友好。\n+ **qiankun** 这类框架通过实现 `html-entry` 模式，极大地改善了开发者体验，降低了微前端的上手门槛。\n+ **Webpack Module Federation** 提供了另一种更现代化的 `js-entry`，它通过复杂的依赖共享机制，解决了 `js-entry` 的许多痛点（如共享库重复加载），可以看作是 `js-entry` 的终极进化形态。\n\n因此，选择哪种方式取决于你的技术栈和框架：\n\n+ 使用 **原始的 single-spa**，你通常需要处理 `js-entry`。\n+ 使用 **qiankun**，你享受的是 `html-entry` 带来的便利。\n+ 使用 **Module Federation**，你体验的是高级的、基于依赖共享的 `js-entry`。\n\n## 路由分发可以实现微前端架构吗\n当然可以。**路由分发是实现微前端架构最主要、最常用也是最经典的方式**。它被认为是微前端架构的“第一种模式”，并且非常有效。\n\n### 核心思想\n**通过路由（URL）的变化，来决定在页面容器中加载、展示和卸载哪个微前端应用。** 主应用（通常称为“容器应用”或“根应用”）充当一个**路由器**和**编排者**的角色，而各个微应用则是独立开发、部署的功能模块。\n\n---\n\n### 它是如何工作的？\n1. **一个路由规则集**：主应用中维护一个配置表，将特定的 URL 路径模式（如 `/app1/*`, `/settings`, `/dashboard`）映射到对应的微应用。\n2. **监听路由变化**：主应用监听 `popstate`、`hashchange` 等浏览器路由事件。\n3. **匹配与决策**：当路由发生变化时（用户点击链接或手动输入 URL），主应用根据配置表判断当前应该激活哪个微应用。\n4. **加载与挂载**：主应用动态获取该微应用的资源（JS, CSS），并将其挂载到页面中指定的 DOM 容器（如 `<div id=\"micro-app-container\">`）中。\n5. **卸载与清理**：当用户离开当前路由时，主应用会卸载之前的微应用，并进行必要的清理工作（如清除事件监听器、内存释放等），然后加载新的微应用。\n\n## webpack5的Module Federation可以详细说说嘛\n好的，我们来深入、详细地探讨 Webpack 5 的 **Module Federation（模块联邦）**。它不仅仅是微前端的一种实现方式，更是一种革命性的架构思想。\n\n### 一、核心概念：它是什么？\n**Module Federation (MF)** 的核心目标是：**允许一个 JavaScript 应用在运行时动态地从另一个应用加载代码并共享依赖**。\n\n你可以把它想象成在浏览器端实现了类似 Node.js 的 `require` 或 `import` 机制，但不是在本地文件系统，而是在**网络上的不同独立应用之间**。\n\n它打破了传统的应用隔离边界，允许应用彼此成为“模块提供者”和“模块消费者”。\n\n---\n\n### 二、为什么要用 Module Federation？(解决的核心痛点)\n1. **彻底解决依赖重复打包**\n    - **传统微前端**：如果主应用和微应用都使用了 React、Vue 等相同的库，这些库的代码会被分别打包到各自的 bundle 中。用户浏览器会多次下载和执行相同的库代码，导致体积膨胀和性能下降。\n    - **MF**：可以**指定共享依赖**。React 等库只加载一次，所有应用都使用同一份实例。这解决了最重要的“依赖地狱”问题。\n2. **更彻底的应用拆分与团队自治**\n    - 它允许将应用拆分成更细粒度的“模块”或“组件”，而不仅仅是“页面”或“应用”。\n    - 团队可以独立开发、部署**一个按钮、一个表单、一个页面**，并让其他团队直接消费。\n3. **运行时动态集成**\n    - 代码集成发生在运行时（Runtime），而非构建时（Build-time）。这意味着：\n        * 你可以进行 **A/B 测试**，动态切换不同版本的组件。\n        * 可以**独立部署**某个模块，而无需重新部署整个应用。\n        * 主应用甚至不需要提前知道所有可能被加载的微应用。\n\n---\n\n### 三、核心角色与配置\nMF 中有两个关键角色：\n\n1. **Remote (远程模块/消费者)**\n    - 它是一个**使用方**应用，在运行时从其他地方（`Host`）导入并执行代码。\n    - 它的配置使用 `remotes` 属性。\n2. **Host (宿主模块/提供者)**\n    - 它是一个**提供方**应用，将其内部的某些模块暴露给外部使用。\n    - 它的配置使用 `exposes` 属性。\n\n**一个应用可以同时是**** **`**Host**`** ****和**** **`**Remote**`。\n\n#### 配置详解 (`webpack.config.js`)\njavascript\n\n```javascript\n// Host 应用的配置 (提供模块的应用，端口3001)\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  // ...其他配置\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app1', // 必填，这个应用的唯一名称，是消费者调用时的标识\n      filename: 'remoteEntry.js', // 必填，对外暴露的入口文件清单名\n      exposes: { // 暴露哪些模块给外部使用\n        './Button': './src/components/Button', // 键：供外部使用的别名；值：本地模块路径\n        './App': './src/App',\n      },\n      shared: { // 共享的依赖库\n        react: { \n          singleton: true, // 确保只使用一个单例版本\n          requiredVersion: '^18.2.0' // 需要的版本\n        },\n        'react-dom': {\n          singleton: true,\n          requiredVersion: '^18.2.0'\n        },\n      },\n    }),\n  ],\n};\n```\n\njavascript\n\n```javascript\n// Remote 应用的配置 (消费模块的应用，端口3002)\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  // ...其他配置\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app2',\n      remotes: { // 声明要消费哪些远程应用\n        // 格式: \"name@url/remoteEntry.js\"\n        app1: 'app1@http://localhost:3001/remoteEntry.js',\n      },\n      shared: { // 共享依赖的配置必须与Host一致，才能成功共享\n        react: { \n          singleton: true,\n          requiredVersion: '^18.2.0'\n        },\n        'react-dom': {\n          singleton: true,\n          requiredVersion: '^18.2.0'\n        },\n      },\n    }),\n  ],\n};\n```\n\n---\n\n### 四、如何使用？\n在 `app2` (Remote) 的代码中，你可以像导入本地模块一样**动态导入** `app1` (Host) 暴露的模块：\n\njavascript\n\n```javascript\n// 在 app2 的 React 组件中\nimport React, { Suspense } from 'react';\n\n// 使用动态导入语法。`app1` 是配置中remotes的key，`./Button` 是app1暴露的模块名\nconst RemoteButton = React.lazy(() => import('app1/Button'));\n\nfunction App() {\n  return (\n    <div>\n    <h1>我是 App2</h1>\n    <Suspense fallback={<div>Loading Button...</div>}>\n  {/* 这个Button组件来自另一个独立应用 app1！ */}\n  <RemoteButton />\n    </Suspense>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n---\n\n### 五、工作流程（魔法是如何发生的？）\n1. **构建阶段**：\n    - `Host` (`app1`) 构建时，会生成一个 `remoteEntry.js` 文件。这个文件是一个**清单(Manifest)**，记录了 `exposes` 了哪些模块以及如何获取它们。\n    - `Remote` (`app2`) 构建时，会意识到 `import('app1/Button')` 是一个远程模块，不会将其打包到自己的 bundle 中。\n2. **运行时阶段**：\n    - 浏览器加载 `app2`。\n    - 当执行到 `import('app1/Button')` 时，Webpack 运行时就会去检查配置。\n    - 它发现 `app1` 对应 `http://localhost:3001/remoteEntry.js`，于是**动态加载**这个 `remoteEntry.js` 文件。\n    - `remoteEntry.js` 告诉 `app2` 如何从 `app1` 的服务器上获取 `Button` 组件的代码块。\n    - Webpack 加载这个代码块，并**与**** **`**app2**`** ****共享的**** **`**react**`** ****和**** **`**react-dom**`** ****实例一起执行它**。\n    - 组件渲染成功。\n\n---\n\n### 六、与 single-spa 等方案的对比\n| **特性** | **Module Federation** | **single-spa (传统方式)** |\n| --- | --- | --- |\n| **核心能力** | **模块共享与依赖管理** | **应用生命周期管理与路由** |\n| **集成方式** | **运行时动态导入** | 运行时加载（但依赖需各自处理） |\n| **依赖处理** | **卓越**。自动共享库，避免重复。 | **困难**。需要额外手动配置或工具解决。 |\n| **打包输出** | 生成 `remoteEntry.js`<br/> 清单文件 | 生成应用的入口 JS 文件 |\n| **粒度** | **非常细**。可以共享单个组件、函数、工具库。 | **较粗**。通常以整个“应用”或“页面”为单元。 |\n| **关系** | **互补**。可以**结合使用**：用 single-spa 做路由和生命周期管理，用 MF 来加载组件和共享依赖。 |  |\n\n\n### 总结\n**Webpack 5 的 Module Federation 是一项颠覆性的技术**。它不再是简单地将应用机械地拼凑在一起，而是真正实现了应用间代码的“无缝融合”与“依赖共享”。\n\n它最适合的场景包括：\n\n+ **大型平台型产品**：需要多个团队独立开发不同功能模块。\n+ **微前端架构**：是目前实现微前端最先进、最优雅的方案之一。\n+ **跨应用组件/工具库共享**：避免维护多个版本的通用组件。\n\n它代表了前端架构从“单体”到“分布式”演进的重要方向，是每一位前端架构师都应该深入理解的技术。\n\nweb component\n\n## 好的，我们来全面、深入地探讨 Web Components。\n### 一、核心概念：它是什么？\n**Web Components** 是一套**浏览器原生支持**的技术集合，允许你创建可重用的、封装的自定义 HTML 元素（类似于 `<div>`、`<button>`，但是是你自己定义的），并在任何现代浏览器中使用它们，无需任何外部框架（如 React、Vue、Angular）。\n\n它的核心目标是为 Web 开发提供**真正的组件化模型**，并解决代码重用和封装的问题。\n\n---\n\n### 二、为什么需要 Web Components？（解决的问题）\n1. **框架无关性 (Framework-Agnostic)**\n    - 你用 Web Components 编写的组件可以在任何 HTML 页面中使用，无论这个页面用的是 React、Vue、Angular、jQuery 还是纯 JavaScript。它提供了**最大程度的可移植性**。\n2. **原生封装 (Native Encapsulation)**\n    - **Shadow DOM** 提供了强大的样式和行为封装。组件内部的样式不会泄漏到外部，外部的样式也不会渗透到组件内部（除非特意允许）。这彻底解决了 CSS 全局污染的问题。\n3. **长期稳定性 (Longevity)**\n    - 作为**Web 平台标准**，它由浏览器厂商直接实现和维护，不像前端框架那样有生命周期（例如，AngularJS 到 Angular 的断代升级）。你写的组件在未来很多年内都能继续工作。\n4. **生态系统互操作性 (Interoperability)**\n    - 它可以在任何框架中被当作普通的 HTML 元素使用，成为了连接不同技术栈应用的“桥梁”。\n\n---\n\n### 三、技术构成（四大核心技术）\nWeb Components 主要由四项技术标准组成，它们可以单独使用，但组合在一起威力最大。\n\n#### 1. Custom Elements（自定义元素）\n一套 JavaScript API，允许你**定义自定义元素及其行为**。\n\n+ **如何定义**：通过继承 `HTMLElement` 类来创建一个新的元素类。\n+ **生命周期回调**：\n    - `connectedCallback`: 当元素首次被插入到 DOM 时调用。\n    - `disconnectedCallback`: 当元素从 DOM 中移除时调用。\n    - `adoptedCallback`: 当元素被移动到新的文档时调用。\n    - `attributeChangedCallback`: 当元素的被观察属性（在 `observedAttributes` 中定义）发生变化时调用。\n\n**示例：定义一个简单的自定义元素**\n\njavascript\n\n```javascript\nclass MyButton extends HTMLElement {\n  constructor() {\n    super();\n    // 初始化逻辑\n  }\n\n  connectedCallback() {\n    this.innerHTML = `<button>Click Me!</button>`;\n    this.addEventListener('click', () => {\n      alert('Button clicked!');\n    });\n  }\n\n  // 定义需要监听的属性\n  static get observedAttributes() {\n    return ['disabled'];\n  }\n\n  // 当disabled属性变化时触发\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === 'disabled') {\n      console.log(`disabled changed from ${oldValue} to ${newValue}`);\n    }\n  }\n}\n\n// 向浏览器注册这个新元素，标签名必须包含连字符 `-`\ncustomElements.define('my-button', MyButton);\n```\n\n**在 HTML 中使用**：\n\nhtml\n\n<my-button disabled></my-button>\n\n#### 2. Shadow DOM（影子 DOM）\n一套用于将**封装的、“影子”的 DOM 树附加到元素**的 API。这是实现样式和行为封装的关键。\n\n+ **Shadow Root**：Shadow DOM 的根节点。\n+ **模式**：\n    - `open`: 可以通过 JavaScript 从外部访问（例如 `element.shadowRoot`）。\n    - `closed`: 外部无法访问，封装性更强。\n+ **作用域**：在 Shadow DOM 内部定义的样式和脚本只在这个范围内有效，与外部隔离。\n\n**示例：为自定义元素添加 Shadow DOM**\n\njavascript\n\n```javascript\nclass MyCard extends HTMLElement {\n  constructor() {\n    super();\n    // 附加一个打开的 Shadow Root\n    const shadow = this.attachShadow({ mode: 'open' });\n\n    // 创建模板\n    const template = document.createElement('template');\n    template.innerHTML = `\n      <style>\n        /* 这些样式只在这个卡片内有效，不会影响外部 */\n        .card {\n          border: 1px solid #ccc;\n          padding: 16px;\n          border-radius: 8px;\n          font-family: sans-serif;\n        }\n        h2 { color: blue; margin-top: 0; }\n      </style>\n      <div class=\"card\">\n        <h2><slot name=\"title\">Default Title</slot></h2>\n        <p><slot name=\"content\">Default content...</slot></p>\n      </div>\n    `;\n\n    // 克隆模板内容并添加到 Shadow Root\n    shadow.appendChild(template.content.cloneNode(true));\n  }\n}\ncustomElements.define('my-card', MyCard);\n```\n\n**在 HTML 中使用**：\n\nhtml\n\n```plain\n<my-card>\n  <!-- 使用 slot 将外部内容投影到 Shadow DOM 中的指定位置 -->\n  <span slot=\"title\">My Awesome Title</span>\n  <span slot=\"content\">This is some fantastic content.</span>\n</my-card>\n```\n\n#### 3. HTML Templates（HTML 模板）\n`<template>` 和 `<slot>` 元素允许你编写**在页面加载时不会立即渲染的标记模板**。这些模板可以被后续的 JavaScript 激活和使用。\n\n+ `<template>`：内容不会被浏览器解析、渲染或执行，直到被 JavaScript 提取并使用。\n+ `<slot>`：在 Web Component 内部充当占位符，允许用户在使用组件时传入自己的自定义内容（如上例所示）。\n\n#### 4. ES Modules（ES 模块）\n现代 JavaScript 的模块标准，为在 Web 上包含和重用 JS 代码提供了官方机制。它使得导入和导出 Web Components 变得简单。\n\nhtml\n\n```html\n<!-- 在 HTML 中导入并使用一个定义好的 Web Component -->\n<script type=\"module\" src=\"./my-component.js\"></script>\n<my-component></my-component>\n```\n\n---\n\n### 四、Web Components 的优点与缺点\n#### 优点：\n1. **浏览器原生**：无需编译，无需复杂的构建工具。\n2. **高度封装**：Shadow DOM 解决了 CSS 和 DOM 的隔离问题。\n3. **框架无关**：极高的互操作性和可移植性。\n4. **永久可用**：作为 Web 标准，具有极长的生命周期和向后兼容性。\n\n#### 缺点：\n1. **生态相对年轻**：虽然基础功能强大，但缺少像 React/Vue 那样庞大的生态系统（状态管理、路由、测试工具等）。\n2. **数据流管理较弱**：原生不支持类似 React 的 Props 向下传递、事件向上冒泡的父子组件通信范式，需要自己实现（通常用 Custom Events）。\n3. **SSR (服务器端渲染) 支持差**：自定义元素可以在服务器上渲染，但其动态行为和客户端激活（Hydration）非常复杂，远不如 Next.js/Nuxt.js 成熟。\n4. **开发体验 (DX)**：原始的开发方式比较繁琐，需要写很多样板代码。但社区有诸如 **Lit**、**Stencil** 等库来极大地改善体验。\n\n---\n\n### 五、Web Components 与微前端和框架\n+ **在微前端中**：Web Components 是实现**技术栈无关**微前端的理想载体。每个团队可以用自己熟悉的技术（React, Vue）**开发**组件，但最终**发布**为一个封装好的 Web Component（例如，将一个 React 组件包装成 `<team-product-card>`），由主应用统一调度。\n+ **与框架的关系**：\n    - **不是替代关系**，而是**互补关系**。\n    - **框架 (React/Vue) 擅长解决：** 复杂的 UI 状态管理、数据流、高效的 DOM 差分更新。它们提供了**优秀的开发体验**和**完整的解决方案**。\n    - **Web Components 擅长解决：** 跨框架重用、底层 UI 组件库、集成遗留应用、长期稳定的基础组件。它们提供了**浏览器级别的互操作性**。\n\n**总结来说，Web Components 是 Web 平台的底层基础，为构建可长期存在、高度封装、框架无关的组件提供了强大的原生能力。** 虽然它在开发复杂应用时不如现代框架那么方便，但其独特优势使其在特定场景（如微前端、跨技术栈组件库、大型企业级应用）中是不可替代的选择。\n\nqiankun实现样式和js隔离的原理\n\n好的，我们来深入剖析 **qiankun** 实现样式和 JavaScript 隔离的原理。这是 qiankun 的核心能力之一，也是它相比原始 single-spa 更易用、更强大的关键。\n\n### 总体思想\nqiankun 的隔离策略可以概括为：**“重样式隔离，轻 JS 沙箱”**。它通过在应用加载和卸载时动态地操作样式和 JavaScript 执行环境来模拟一个隔离的沙箱环境。\n\n---\n\n### 一、样式隔离 (CSS Isolation)\nqiankun 提供了三种主要的样式隔离方案，根据场景不同自动或手动启用。\n\n#### 1. 严格样式隔离 (Scoped CSS)\n**原理：** 为每个微应用包裹一个 **Shadow DOM**。\n\n+ **如何工作：**\n    1. 当 qiankun 挂载一个微应用时，它会创建一个 Shadow Root，并将其作为该应用的容器。\n    2. 微应用的所有 DOM 结构都被渲染在这个 Shadow DOM 内部。\n    3. **Shadow DOM 的特性天然实现了样式的封装**：内部的样式不会影响外部，外部的样式也不会影响内部（除非使用 `::part` 或 `:host` 等特定语法）。\n+ **优点：** 隔离性最强，是浏览器原生的完美隔离方案。\n+ **缺点：**\n    - 某些第三方库（特别是弹窗类）可能会因为无法正确定位到 Shadow DOM 外部而出现问题。\n    - 微应用内的样式完全无法影响主应用，反之亦然，有时这可能不符合设计需求。\n+ **启用方式：** 在 `start` 函数中配置 `{ strictStyleIsolation: true }`。\n\njavascript\n\n```javascript\nimport { start } from 'qiankun';\nstart({\n  strictStyleIsolation: true, // 启用严格样式隔离\n});\n```\n\n#### 2. 实验性样式隔离 (CSS Scoped)\n**原理：** 一种更宽松的隔离方式，使用 **运行时动态样式表重写**。\n\n+ **如何工作：**\n    1. qiankun 会劫持微应用运行时**动态添加样式标签（**`**<style>**`**,**** **`**<link>**`**）** 的行为。\n    2. 当微应用插入一个新的样式标签时，qiankun 会将其内容抓取过来。\n    3. 使用 **CSS 规则重写器**（例如 `postcss` 插件）为所有 CSS 选择器**添加一个特殊的前缀**。这个前缀通常基于微应用的名称或一个特定属性。\n    4. 将重写后的 CSS 内容插入到 `document.head` 中。\n    5. 同时，qiankun 会为微应用的**容器元素**添加上一步中使用的**相同属性**。\n\n**示例：**\n\n    - 微应用有一个样式规则：`.button { color: red; }`\n    - qiankun 将其重写为：`[data-qiankun=\"my-app\"] .button { color: red; }`\n    - 同时，微应用的容器 `<div>` 会获得属性：`<div data-qiankun=\"my-app\">...</div>`\n    - 这样，样式规则就只会在这个容器内生效。\n+ **优点：** 比 Shadow DOM 兼容性更好，允许微应用样式影响其容器内的任何元素（包括动态 append 到 body 的弹窗）。\n+ **缺点：** 是运行时重写，有一定性能开销，且是实验性功能。\n+ **启用方式：** 在 `start` 函数中配置 `{ experimentalStyleIsolation: true }`。\n\njavascript\n\n```javascript\nstart({\n  experimentalStyleIsolation: true, // 启用实验性样式隔离\n});\n```\n\n#### 3. 动态样式表加载/卸载 (最常见的默认行为)\n如果不开启上述两种隔离，qiankun 默认采用一种更简单但有效的策略。\n\n+ **原理：**\n    1. **加载时：** qiankun 通过 `fetch` 获取微应用的 HTML 入口，解析出所有的 `<style>` 和 `<link>` 标签。\n    2. 将这些样式标签**直接插入到**** **`**document.head**` 中。\n    3. **卸载时：** qiankun 会**记录**所有由该微应用添加的样式标签，并在卸载微应用时**直接将这些标签从 DOM 中移除**。\n+ **优点：** 实现简单，性能好。\n+ **缺点：** **不是真正的隔离**。如果多个微应用有相同选择器的样式规则，后加载的会覆盖先加载的（因为后加载的样式表在更后面，优先级更高）。这依赖于开发者的约定。\n+ **这是 qiankun 的默认行为**，对于很多应用来说已经足够。\n\n---\n\n### 二、JavaScript 隔离 (JS Sandbox)\nqiankun 的 JS 沙箱的核心目标是：**防止微应用在全局环境（**`**window**`**）上留下永久的污染，并在应用切换时恢复和清理环境**。它主要模拟了三个环境的隔离：\n\n#### 1. 快照沙箱 (SnapshotSandbox) - 用于单实例场景\n**原理：** 在应用加载前后对全局 `window` 对象进行“拍照”和“diff”，适用于同一时间只能有一个微应用活跃的浏览器环境。\n\n+ **工作流程：**\n    1. **激活沙箱 (mount)：** 将当前 `window` 的所有属性拍一个**快照**（`windowSnapshot`），存起来。\n    2. **微应用运行：** 微应用可以任意修改 `window`。\n    3. **失活沙箱 (unmount)：**\n        * 将当前的 `window` 和之前存的 `windowSnapshot` 进行对比，得到修改的差异（`modifyPropsMap`）。\n        * **还原现场：** 遍历差异，将 `window` 上的属性**恢复**到拍快照时的状态。\n        * **记录污染：** 将微应用修改的差异保存起来。\n    4. **再次激活：** 将之前保存的差异（`modifyPropsMap`）**重新应用到**** **`**window**`** ****上**，让微应用感觉自己的修改一直都在。\n+ **优点：** 兼容性极好，支持所有浏览器。\n+ **缺点：** 无法支持多个微应用同时运行（多实例），因为共用一个全局 `window`。\n\n#### 2. 代理沙箱 (ProxySandbox) - 用于多实例场景（主流）\n**原理：** 使用 ES6 的 `Proxy` 为每个微应用创建一个假的、隔离的 `window` 对象。\n\n+ **工作流程：**\n    1. qiankun 为每个微应用创建一个空的 `fakeWindow` 对象。\n    2. 用 `Proxy` 代理这个 `fakeWindow`。\n    3. 当微应用操作 `window` 时：\n        * **读操作**：优先从 `fakeWindow` 里读，如果读不到，则 fallback 到真正的全局 `window`（这样可以共享 `document`, `location` 等全局对象）。\n        * **写操作**：所有对属性的新增和修改都只作用于 `fakeWindow` 上，**完全不会污染真正的全局**** **`**window**`。\n    4. 微应用的所有代码都在这个代理的上下文中执行（通过 `with` 语句或 `eval` 改写）。\n+ **示例：**\n\njavascript\n\n```javascript\n// 微应用代码\nwindow.myGlobalVar = 123; // 写入的是沙箱的 fakeWindow，真 window 不受影响\nconsole.log(document.title); // 读取的是真 window 的属性\n```\n\n+ **优点：**\n    - 真正的隔离，多个微应用可以同时运行，每个都有自己独立的 `window` 空间。\n    - 对微应用无感知，无需修改代码。\n+ **缺点：** 依赖 ES6 `Proxy`，无法在低版本浏览器（如 IE）中使用。\n\n#### 3. 遗留沙箱 (LegacySandbox) - 已逐渐被代理沙箱取代\n原理类似于快照沙箱，但性能优化更好。它只记录微应用修改过的属性，在卸载时还原这些属性。同样不支持多实例。\n\n---\n\n### 总结：qiankun 的隔离策略\n| **隔离类型** | **技术方案** | **优点** | **缺点** | **适用场景** |\n| --- | --- | --- | --- | --- |\n| **样式隔离** | **Shadow DOM** | 原生，隔离最彻底 | 兼容性问题，弹窗等组件可能异常 | 需要最强隔离的新应用 |\n|  | **动态样式表重写 (实验性)** | 兼容性好，支持弹窗 | 运行时开销，实验性功能 | 需要兼容弹窗的复杂应用 |\n|  | **动态加载/卸载 (默认)** | 简单，性能好 | 非真正隔离，依赖约定 | 大多数简单应用，样式冲突风险低 |\n| **JS 隔离** | **快照沙箱 (SnapshotSandbox)** | 兼容所有浏览器 | 不支持多实例 | 单实例模式，需兼容 IE 等老浏览器 |\n|  | **代理沙箱 (ProxySandbox)** | 真正隔离，支持多实例，对应用无感知 | 依赖 `Proxy`<br/>，不兼容 IE | **现代浏览器下的主流选择** |\n\n\n**qiankun 会自动选择最佳策略**：在支持 `Proxy` 的浏览器中默认使用**代理沙箱 (多实例)** 和**动态样式加载/卸载**。如果不支持 `Proxy`，则降级到**快照沙箱 (单实例)**。\n\n通过这种组合策略，qiankun 在绝大多数场景下为微前端应用提供了**足够安全、稳定且高性能的隔离环境**，极大地简化了微前端的落地复杂度。\n\nqiankun是如何实现父子应用通信的呢\n\n好的，**qiankun 的通信机制**是其核心功能之一，它设计得非常灵活，提供了多种方式来实现主应用（父应用）和微应用（子应用）之间的通信。\n\nqiankun 并没有强制使用某一种通信方式，而是提供了一个轻量的 **API（**`**initGlobalState**`**）** 作为推荐方案，同时也完全支持任何其他流行的状态管理库（如 Redux, Mobx, Vuex）或浏览器原生 API。\n\n---\n\n### 一、官方推荐方案：使用 `initGlobalState` (Actions 通信)\n这是 qiankun 官方提供的通信方式，适用于大多数场景。它的核心思想是一个**简单的发布-订阅模式**。\n\n#### 1. 在主应用中初始化状态并下发通信方法\n主应用是整个状态的管理中心。\n\njavascript\n\n```javascript\n// main-app/src/actions.js\nimport { initGlobalState } from 'qiankun';\n\n// 1. 初始化全局状态\nconst initialState = {\n  user: {\n    name: '张三',\n    token: 'abc123'\n  },\n  theme: 'light'\n};\n\n// 2. 创建 Actions 实例\nconst actions = initGlobalState(initialState);\n\n// 3. 监听状态变化（可选，主应用自己也可以监听）\nactions.onGlobalStateChange((state, prevState) => {\n  // state: 变更后的新状态\n  // prevState: 变更前的旧状态\n  console.log('主应用监听到状态变化: ', state, prevState);\n});\n\n// 4. 定义一个更新状态的方法\nexport const setGlobalState = (newState) => {\n  // 按层级合并状态\n  actions.setGlobalState(newState);\n};\n\n// 5. 将 actions 暴露出去，供微应用使用\nexport default actions;\n```\n\n#### 2. 在微应用中获取并操作状态\n微应用需要从生命周期函数中获取到 `props`，其中就包含了通信方法。\n\njavascript\n\n```javascript\n// micro-app/src/main.js (入口文件)\nlet microAppActions; // 用来保存通信方法\n\n// 导出 qiankun 生命周期函数\nexport async function mount(props) {\n  console.log('微应用挂载了', props);\n  // 1. 从 props 中获取主应用下发的 actions\n  microAppActions = props;\n\n  // 2. 监听全局状态变化\n  props.onGlobalStateChange((state, prevState) => {\n    console.log('微应用监听到状态变化: ', state, prevState);\n    // 状态变化后，更新微应用自己的视图\n    renderApp(state);\n  });\n\n  // 3. 首次挂载，获取当前全局状态并渲染应用\n  renderApp(props.getGlobalState());\n}\n\nexport async function unmount() {\n  // 卸载时取消监听（qiankun 内部会自动清理，但显式取消是好习惯）\n  microAppActions.offGlobalStateChange();\n}\n\n// React/Vue 应用的渲染函数\nfunction renderApp(state) {\n  ReactDOM.render(<App globalState={state} actions={microAppActions} />, document.getElementById('app'));\n}\n```\n\n#### 3. 在微应用组件中具体使用\njavascript\n\n```javascript\n// micro-app/src/App.jsx\nimport React from 'react';\n\nfunction App({ globalState, actions }) {\n  const { user, theme } = globalState;\n\n  const handleChangeTheme = () => {\n    // 更新全局状态\n    actions.setGlobalState({\n      theme: theme === 'light' ? 'dark' : 'light'\n    });\n  };\n\n  return (\n    <div className={`app ${theme}`}>\n  <h1>微应用页面</h1>\n  <p>用户名: {user.name}</p>\n  <button onClick={handleChangeTheme}>切换主题</button>\n  </div>\n);\n}\n\nexport default App;\n```\n\n#### `initGlobalState` API 说明：\n+ `setGlobalState(state: object)`: 设置新的全局状态，会自动与旧状态进行**浅合并**。\n+ `onGlobalStateChange(callback: function)`: 注册监听器，状态变化时触发。\n+ `offGlobalStateChange()`: 取消监听。\n+ `getGlobalState()`: 获取当前全局状态。\n\n---\n\n### 二、其他通信方案\nqiankun 是框架无关的，因此你也可以选择任何你熟悉的通信方式。\n\n#### 1. 使用 CustomEvent (浏览器原生事件)\n**原理：** 利用浏览器原生的 `window.dispatchEvent` 和 `window.addEventListener` 进行通信。\n\njavascript\n\n```javascript\n// 主应用 - 发送事件\nwindow.dispatchEvent(new CustomEvent('main-app-event', {\n  detail: { // 通过 detail 传递数据\n    type: 'CHANGE_THEME',\n    payload: 'dark'\n  }\n}));\n\n// 微应用 - 接收事件\nwindow.addEventListener('main-app-event', (event) => {\n  const { type, payload } = event.detail;\n  // 处理事件...\n});\n\n// 微应用 - 发送事件（同理）\nwindow.dispatchEvent(new CustomEvent('micro-app-event', {\n  detail: { message: 'Hello from micro app' }\n}));\n```\n\n**优点：** 原生支持，非常简单。  \n**缺点：** 数据传递能力较弱（只能同步），缺乏状态管理能力，事件需要全局唯一命名以免冲突。\n\n#### 2. 使用 Redux/Mobx/Vuex 等状态库\n**原理：** 主应用和微应用**共享同一个状态库实例**。\n\n+ **步骤：**\n    1. 主应用创建一个 Redux Store 或其他状态库实例。\n    2. 将这个 Store 通过 `window` 对象或者微应用的 `props` 暴露给微应用。\n    3. 微应用连接到这个全局的 Store，进行状态的读取和分发 Action。\n\njavascript\n\n```javascript\n// 主应用 - 创建并暴露 store\nimport { createStore } from 'redux';\nconst globalStore = createStore(/* ... */);\nwindow.__MAIN_APP_STORE__ = globalStore; // 挂到全局\n\n// 微应用 - 获取并使用 store\nconst store = window.__MAIN_APP_STORE__;\nstore.dispatch({ type: 'AN_ACTION' });\nconst state = store.getState();\n```\n\n**优点：** 功能强大，可以处理复杂的业务逻辑和状态流。  \n**缺点：** 紧密耦合，主应用和微应用必须使用同一种状态库，且版本需要兼容。\n\n#### 3. 通过 URL 或 Query Parameters 通信\n**原理：** 通过改变 URL 的查询参数来传递简单信息。\n\njavascript\n\n```javascript\n// 主应用改变URL\nconst newUrl = `${window.location.pathname}?theme=dark&userId=123`;\nhistory.pushState(null, '', newUrl);\n\n// 微应用监听URL变化\nwindow.addEventListener('popstate', () => {\n  const urlParams = new URLSearchParams(window.location.search);\n  const theme = urlParams.get('theme');\n  // ...使用参数\n});\n```\n\n**优点：** 非常简单，状态可被收藏和分享。  \n**缺点：** 只适合传递少量简单数据。\n\n---\n\n### 总结与选择建议\n| **方案** | **优点** | **缺点** | **适用场景** |\n| --- | --- | --- | --- |\n| **官方**** **`**initGlobalState**` | **官方推荐**，简单轻量，满足大部分通信需求 | 功能相对简单，不适合极其复杂的场景 | **绝大多数微前端通信场景的首选** |\n| **CustomEvent** | 浏览器原生，非常简单 | 功能弱，只能传简单数据，易产生事件名冲突 | 简单的父子通知、触发动作 |\n| **Redux/Vuex 等** | 功能强大，适合复杂状态管理 | 耦合度高，主子和微应用必须使用同一种状态库 | 大型复杂应用，且技术栈统一 |\n| **URL Parameters** | 实现简单，状态可分享 | 传递数据量有限，类型受限 | 过滤条件、简单配置等 |\n\n\n**最佳实践建议：**\n\n1. **优先使用官方的**** **`**initGlobalState**`，它能覆盖 90% 的微前端通信需求。\n2. 对于简单的、一次性的动作触发（如“刷新列表”、“显示通知”），可以辅以 **CustomEvent**。\n3. 只有在主应用和所有微应用技术栈统一且非常复杂时，才考虑使用**共享状态库**。\n4. 通信的设计应遵循**最小化原则**，尽量减少主应用和微应用之间的耦合，让微应用保持最大的独立性。\n\n\n\n","slug":"微前端","published":1,"updated":"2025-09-14T13:50:19.615Z","_id":"cmfjkpz9g0000ma5wfkkshevh","comments":1,"layout":"post","photos":[],"content":"<p>参考链接：</p>\n<p><a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/78362028\" >可能是你见过最完善的微前端解决方案<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p><a class=\"link\"   href=\"https://juejin.cn/post/7244070072788287544?searchId=202508250257166071DDB47E623E0BA671\" >深入调研了微前端，还是iframe最香<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p><a class=\"link\"   href=\"https://qiankun.umijs.org/zh/guide/getting-started\" >qiankun官方文档<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<h3 id=\"什么是微前端？\"><a href=\"#什么是微前端？\" class=\"headerlink\" title=\"什么是微前端？\"></a>什么是微前端？</h3><p>微前端是一种软件架构，可以将前端应用拆解成一些更小的能够独立开发部署的微型应用，然后在将这些微型应用组合使其成为整体的架构模式。</p>\n<p>微前端类似于组件架构，但不同的是，组件不能够独立构建和发布，但是微前端中的应用是可以的。</p>\n<p>微前端架构与框架无关，每个微应用都可以使用不同的框架。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/%E5%BE%AE%E5%89%8D%E7%AB%AF.png\"\n                      alt=\"微前端\"\n                ></p>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>单体前端</strong></th>\n<th><strong>微前端</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>代码库</strong></td>\n<td>单个大型代码库</td>\n<td>多个独立代码库</td>\n</tr>\n<tr>\n<td><strong>团队结构</strong></td>\n<td>集中式团队</td>\n<td>分布式独立团队</td>\n</tr>\n<tr>\n<td><strong>技术栈</strong></td>\n<td>统一技术栈</td>\n<td>混合技术栈</td>\n</tr>\n<tr>\n<td><strong>部署</strong></td>\n<td>整体部署</td>\n<td>独立部署</td>\n</tr>\n<tr>\n<td><strong>开发速度</strong></td>\n<td>后期变慢</td>\n<td>持续快速</td>\n</tr>\n<tr>\n<td><strong>复杂度</strong></td>\n<td>高度耦合</td>\n<td>解耦独立</td>\n</tr>\n</tbody></table>\n<h3 id=\"微前端的价值\"><a href=\"#微前端的价值\" class=\"headerlink\" title=\"微前端的价值\"></a>微前端的价值</h3><p>微前端架构具备以下几个核心价值：</p>\n<ul>\n<li>技术栈无关 主框架不限制接入应用的技术栈，子应用具备完全自主权</li>\n<li>独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</li>\n<li>独立运行时 每个子应用之间状态隔离，运行时状态不共享</li>\n</ul>\n<p>微前端架构旨在解决<a class=\"link\"   href=\"https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLljZXkvZPlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.Sy3sQVozhhuQwuwmw8-zjyU0X_81Vve5linQ55OPo0k&zhida_source=entity\" >单体应用<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个<a class=\"link\"   href=\"https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%B7%A8%E7%9F%B3%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLlt6jnn7PlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.3VWm6X4yZDpq2_EqJZDuDErH1ST1iWJUa0qPK8T5Abk&zhida_source=entity\" >巨石应用<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>(<a class=\"link\"   href=\"https://link.zhihu.com/?target=https://www.youtube.com/watch?v=pU1gXA0rfwc\" >Frontend Monolith<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。</p>\n<p>应用架构如下：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/微前端架构.png\"\n                      alt=\"微前端架构\" height=\"auto\" style=\"width:50%; display:block;\"\n                >\n\n<blockquote>\n<p>Stitching layer 作为主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用。因此主框架的定位则仅仅是：<strong>导航路由 + 资源加载框架</strong></p>\n</blockquote>\n<p>single-spa是什么</p>\n<p>好的，我们来详细解释一下 <strong>single-spa</strong> 是什么。</p>\n<h3 id=\"核心定义\"><a href=\"#核心定义\" class=\"headerlink\" title=\"核心定义\"></a>核心定义</h3><p><strong>single-spa 是一个用于构建【微前端】架构的 JavaScript 框架。</strong> 你可以把它理解为一个<strong>顶层的路由器和应用程序加载器</strong>。</p>\n<p>它的核心思想是：将一个大型的单页前端应用（SPA）拆分成多个小型、独立、可以并行开发交付的“微应用”。然后，single-spa 负责在运行时根据一定的规则（通常是当前的 URL）动态地加载、展示、卸载这些微应用。</p>\n<hr>\n<h3 id=\"一个简单的比喻\"><a href=\"#一个简单的比喻\" class=\"headerlink\" title=\"一个简单的比喻\"></a>一个简单的比喻</h3><p>想象一下你的浏览器是一个舞台：</p>\n<ul>\n<li><strong>传统单体应用：</strong> 只有一个庞大的剧团表演一整部冗长的戏剧。要更换一个演员（修改一个功能），需要整个剧团停下来重新排练（整个应用重新构建部署）。</li>\n<li><strong>single-spa 微前端：</strong> 舞台（浏览器）本身是空的。有一个<strong>导演（single-spa）</strong>。导演手里有一个节目单（根配置），上面写着什么节目（微应用）在什么时刻（例如，URL 是 <code>/settings</code> 时）上台表演。<ul>\n<li>当报幕员说“下一个节目是《用户设置》”时（用户访问了 <code>/settings</code>），导演就喊：“《用户设置》剧组，上台！”（加载并挂载 React 微应用）。</li>\n<li>节目表演完了（用户离开了 <code>/settings</code>），导演就喊：“《用户设置》剧组，下台！”（卸载 React 微应用）。</li>\n<li>下一个节目是《商品列表》，另一个完全不同的剧组（Vue 微应用）就上台表演。</li>\n</ul>\n</li>\n</ul>\n<p><strong>single-spa 就是这个导演</strong>，它自己不表演具体内容，但它负责协调所有剧组（微应用）的上场和下场时机。</p>\n<hr>\n<h3 id=\"为什么需要-single-spa？（解决的问题）\"><a href=\"#为什么需要-single-spa？（解决的问题）\" class=\"headerlink\" title=\"为什么需要 single-spa？（解决的问题）\"></a>为什么需要 single-spa？（解决的问题）</h3><ol>\n<li><strong>技术栈无关：</strong> 各个微应用可以使用不同的技术栈（React, Vue, Angular, Svelte 等）。团队可以自由选择或升级其技术栈，而不会影响其他团队。</li>\n<li><strong>独立开发、独立部署：</strong> 每个微应用都由独立的团队开发、测试和部署，大大提升了团队的自治度和发布效率。</li>\n<li><strong>增量升级：</strong> 允许你逐步重写一个老旧的巨型前端应用，可以一部分一部分地用新的框架替换，而不是一次性重写全部。</li>\n<li><strong>代码隔离：</strong> 应用之间实现了良好的代码和样式隔离（虽然需要一些额外规范），避免了全局污染和冲突。</li>\n</ol>\n<hr>\n<h3 id=\"single-spa-的核心工作原理\"><a href=\"#single-spa-的核心工作原理\" class=\"headerlink\" title=\"single-spa 的核心工作原理\"></a>single-spa 的核心工作原理</h3><p>single-spa 通过定义一套<strong>生命周期协议</strong>来工作。每个微应用都必须对外暴露三个核心的函数：</p>\n<ol>\n<li><code>bootstrap</code>： 应用首次加载时执行一次，用于初始化。</li>\n<li><code>mount</code>： 当激活条件满足时（例如用户访问了该应用的路由），执行此函数。应用需要在这个函数里完成渲染，将组件挂载到 DOM 上。</li>\n<li><code>unmount</code>： 当激活条件不再满足时（例如用户离开了该路由），执行此函数。应用需要在这个函数里完成清理工作，将自己从 DOM 上卸载。</li>\n</ol>\n<p>single-spa 的“根配置”会<strong>注册</strong>所有微应用，并为每个应用定义一个 <code>activity function</code>（激活函数）。这个函数通常根据 <code>window.location</code> 进行判断。</p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// single-spa 根配置示例 (root-config.js)</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; registerApplication, start &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;single-spa&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册一个应用</span></span><br><span class=\"line\"><span class=\"title function_\">registerApplication</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;my-react-app&#x27;</span>, <span class=\"comment\">// 应用唯一名</span></span><br><span class=\"line\">  <span class=\"attr\">app</span>: <span class=\"function\">() =&gt;</span> <span class=\"title class_\">System</span>.<span class=\"keyword\">import</span>(<span class=\"string\">&#x27;my-react-app&#x27;</span>), <span class=\"comment\">// 如何加载该应用的代码</span></span><br><span class=\"line\">  <span class=\"attr\">activeWhen</span>: <span class=\"function\">(<span class=\"params\">location</span>) =&gt;</span> location.<span class=\"property\">pathname</span>.<span class=\"title function_\">startsWith</span>(<span class=\"string\">&#x27;/react&#x27;</span>), <span class=\"comment\">// 激活函数：当路径以 /react 开头时，加载这个应用</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动 single-spa</span></span><br><span class=\"line\"><span class=\"title function_\">start</span>();</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>流程如下：</strong></p>\n<ol>\n<li>用户访问 <code>https://example.com/react</code>。</li>\n<li>single-spa 检查所有注册的应用，发现 <code>my-react-app</code> 的 <code>activeWhen</code> 函数返回 <code>true</code>。</li>\n<li>single-spa 动态加载 <code>my-react-app</code> 的代码包。</li>\n<li>依次执行该应用的 <code>bootstrap</code> 和 <code>mount</code> 生命周期函数，应用被渲染到页面上。</li>\n<li>用户导航到 <code>/vue</code>，<code>my-react-app</code> 的 <code>activeWhen</code> 返回 <code>false</code>。</li>\n<li>single-spa 执行它的 <code>unmount</code> 函数，将其卸载。</li>\n</ol>\n<hr>\n<h3 id=\"主要优缺点\"><a href=\"#主要优缺点\" class=\"headerlink\" title=\"主要优缺点\"></a>主要优缺点</h3><p><strong>优点：</strong></p>\n<ul>\n<li><strong>强大的解耦和能力：</strong> 真正实现了前端应用的拆分和团队自治。</li>\n<li><strong>框架无关：</strong> 是整合不同技术栈应用的理想选择。</li>\n<li><strong>懒加载：</strong> 提升首次加载速度，按需加载应用。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>复杂度高：</strong> 引入了分布式系统的复杂性，需要解决依赖共享、样式隔离、通信机制等问题。</li>\n<li><strong>开发体验：</strong> 调试和配置比单体应用更复杂。通常需要类似 <code>single-spa</code> 官方的 <code>create-single-spa</code> 工具链来简化流程。</li>\n<li><strong>依赖管理：</strong> 需要谨慎处理共享库（如 <code>react</code>, <code>vue</code>）以避免重复打包。</li>\n</ul>\n<hr>\n<h3 id=\"与-Module-Federation-的区别\"><a href=\"#与-Module-Federation-的区别\" class=\"headerlink\" title=\"与 Module Federation 的区别\"></a>与 Module Federation 的区别</h3><p>Webpack 5 的 <strong>Module Federation（模块联邦）</strong> 是另一种实现微前端的热门技术。它们不是互斥的，甚至可以结合使用：</p>\n<ul>\n<li><strong>single-spa</strong> 主要解决的是<strong>路由和应用生命周期管理</strong>的问题（“什么时候加载哪个应用”）。</li>\n<li><strong>Module Federation</strong> 主要解决的是<strong>应用之间代码共享和依赖处理</strong>的问题（“如何共享一个 React 实例，避免重复加载”）。</li>\n</ul>\n<p>一个常见的模式是：使用 <strong>single-spa 作为路由器</strong>，使用 <strong>Module Federation 来加载微应用和共享依赖</strong>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>**single-spa 是一个成熟、强大的微前端解决方案，它通过一套生命周期协议，将多个独立开发、独立部署的微应用组合成一个完整的单体体验。它非常适合大型企业级应用、需要整合不同技术栈或进行增量迁移的项目。**虽然它引入了一定的复杂性，但它为解决前端单体膨胀问题提供了非常系统化的思路和工具。</p>\n<p>html entry和js entry的概念是什么</p>\n<p>好的，这是一个非常核心的微前端概念。<code>**js-entry**</code> 和 <code>**html-entry**</code> 是微前端中两种不同的应用打包和加载方式，它们代表了两种不同的设计哲学和实现技术。</p>\n<hr>\n<h3 id=\"核心概念对比\"><a href=\"#核心概念对比\" class=\"headerlink\" title=\"核心概念对比\"></a>核心概念对比</h3><table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>js-entry (JavaScript 入口)</strong></th>\n<th><strong>html-entry (HTML 入口)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>入口文件</strong></td>\n<td>一个 JavaScript 文件 (e.g., <code>app.js</code><br/>)</td>\n<td>一个 HTML 文件 (e.g., <code>index.html</code><br/>)</td>\n</tr>\n<tr>\n<td><strong>内容</strong></td>\n<td>主要包含 <strong>JavaScript 逻辑和组件</strong></td>\n<td>包含 <strong>HTML、</strong><code>**&lt;script&gt;**</code><br/><strong>、</strong><code>**&lt;link&gt;**</code><br/><strong>、</strong><code>**&lt;style&gt;**</code></td>\n</tr>\n<tr>\n<td><strong>加载方式</strong></td>\n<td>框架（如 single-spa）加载并执行 JS 文件</td>\n<td>框架通过 <strong>fetch</strong> 获取 HTML，解析出其中的 JS&#x2F;CSS 并执行</td>\n</tr>\n<tr>\n<td><strong>样式处理</strong></td>\n<td><strong>需要手动管理</strong>。通常需要约定（如 CSS Modules, CSS-in-JS）或工具来避免冲突。</td>\n<td><strong>自动处理</strong>。HTML 中的 <code>&lt;link&gt;</code><br/> 和 <code>&lt;style&gt;</code><br/> 标签会被自动插入到 <code>&lt;head&gt;</code><br/> 中。</td>\n</tr>\n<tr>\n<td><strong>沙箱隔离</strong></td>\n<td>通常需要额外的库（如 <code>qiankun</code><br/> 的沙箱）来实现 JS 和 CSS 的运行时隔离。</td>\n<td>天然更易于实现<strong>HTML级别的沙箱</strong>（例如，创建一个 Shadow DOM 来包裹整个微应用的内容）。</td>\n</tr>\n<tr>\n<td><strong>代表性方案</strong></td>\n<td>原始的 <strong>single-spa</strong> 方案</td>\n<td><strong>qiankun</strong>（基于 single-spa）、<strong>Module Federation</strong>（某种程度上）</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"深入理解\"><a href=\"#深入理解\" class=\"headerlink\" title=\"深入理解\"></a>深入理解</h3><h4 id=\"1-js-entry-JavaScript-入口\"><a href=\"#1-js-entry-JavaScript-入口\" class=\"headerlink\" title=\"1. js-entry (JavaScript 入口)\"></a>1. js-entry (JavaScript 入口)</h4><p>这是 <strong>single-spa 早期和官方推荐</strong>的方式。它的理念是：一个微应用<strong>本质上是一个 JavaScript 模块</strong>，这个模块导出了 <code>bootstrap</code>, <code>mount</code>, <code>unmount</code> 等生命周期函数。</p>\n<p><strong>如何工作？</strong></p>\n<ol>\n<li>主应用（容器）根据路由规则，判断需要加载微应用 A。</li>\n<li>主应用通过 <code>System.import()</code> 或 <code>import()</code> 动态加载微应用 A 的 <strong>入口 JS 文件</strong>（例如 <code>https://a.com/app.js</code>）。</li>\n<li>这个 JS 文件被执行，并返回一个包含生命周期函数的对象。</li>\n<li>主应用依次调用微应用的 <code>bootstrap</code> 和 <code>mount</code> 函数。</li>\n<li>在 <code>mount</code> 函数中，微应用<strong>用自己的逻辑</strong>将组件渲染到主应用提供的 DOM 容器中。</li>\n</ol>\n<p><strong>示例代码 (single-spa 配置)：</strong></p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">registerApplication</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;my-app&#x27;</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 这里是一个 js-entry，指向一个 JS 文件</span></span><br><span class=\"line\">  <span class=\"attr\">app</span>: <span class=\"function\">() =&gt;</span> <span class=\"title class_\">System</span>.<span class=\"keyword\">import</span>(<span class=\"string\">&#x27;https://a.com/js/app.js&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">activeWhen</span>: <span class=\"string\">&#x27;/app&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>概念清晰，符合“应用即模块”的理念。</li>\n<li>打包输出干净，通常是一个或多个 JS 包。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>样式处理麻烦</strong>：你需要自己在微应用的 JS 代码里引入 CSS（如 <code>import &#39;./app.css&#39;</code>），并小心全局样式冲突。</li>\n<li><strong>需要额外配置</strong>：为了实现资源加载和隔离，需要复杂的 Webpack 配置和额外的库。</li>\n</ul>\n<h4 id=\"2-html-entry-HTML-入口\"><a href=\"#2-html-entry-HTML-入口\" class=\"headerlink\" title=\"2. html-entry (HTML 入口)\"></a>2. html-entry (HTML 入口)</h4><p>这种方式的理念是：一个微应用是<strong>一个完整的、可以独立运行的“页面”</strong>。主应用只需要加载这个页面的 HTML 文件，剩下的资源（JS, CSS）都由这个 HTML 文件自己声明。</p>\n<p><strong>如何工作？</strong></p>\n<ol>\n<li>主应用根据路由规则，判断需要加载微应用 B。</li>\n<li>主应用通过 <strong>fetch</strong> 请求微应用 B 的<strong>入口 HTML 文件</strong>（例如 <code>https://b.com/index.html</code>）。</li>\n<li>主应用<strong>解析</strong>这个 HTML 文件，提取出其中的 <code>**&lt;script&gt;**</code>** <strong><strong>和</strong></strong> <strong><code>**&lt;link&gt;**</code></strong> **<strong>标签</strong>。</li>\n<li>主应用手动创建这些 <code>&lt;script&gt;</code> 和 <code>&lt;link&gt;</code> 元素，并将它们插入到主文档的 <code>&lt;head&gt;</code> 中，从而加载并执行微应用的 JS 和 CSS。</li>\n<li>同时，主应用通常会提供一个<strong>隔离的沙箱环境</strong>（如 Shadow DOM），将微应用的整个 DOM 结构渲染在其中。</li>\n</ol>\n<p><strong>示例概念（qiankun 的做法）：</strong></p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; registerMicroApps, start &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;qiankun&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">registerMicroApps</span>([</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;vue-app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 这里是一个 html-entry，指向一个 HTML 文件</span></span><br><span class=\"line\">    <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;//localhost:7101&#x27;</span>, <span class=\"comment\">// 会默认加载这个地址下的 index.html</span></span><br><span class=\"line\">    <span class=\"attr\">container</span>: <span class=\"string\">&#x27;#container&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">activeRule</span>: <span class=\"string\">&#x27;/vue&#x27;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]);</span><br><span class=\"line\"><span class=\"title function_\">start</span>();</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li><strong>对旧项目更友好</strong>：很多老项目（如 jQuery、Backbone 项目）本身就是以 HTML 为中心开发的，改造为 html-entry 更容易。</li>\n<li><strong>资源加载自动化</strong>：无需在 JS 中手动引入资源，HTML 中声明的所有资源都会被自动加载。</li>\n<li><strong>更强大的隔离能力</strong>：更容易与 Shadow DOM 结合，实现真正的样式和作用域隔离。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>需要解析 HTML</strong>：主应用需要具备解析 HTML 并提取资源的能力，实现起来比直接 <code>import</code> 一个 JS 文件更复杂。</li>\n<li><strong>可能加载多余资源</strong>：如果 HTML 中声明了多个入口，需要更精细的解析策略来避免加载未使用的资源。</li>\n</ul>\n<hr>\n<h3 id=\"总结与类比\"><a href=\"#总结与类比\" class=\"headerlink\" title=\"总结与类比\"></a>总结与类比</h3><table>\n<thead>\n<tr>\n<th><strong>概念</strong></th>\n<th><strong>类比</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>**js-entry**</code></td>\n<td>就像 <strong>“组装电脑”</strong>。主应用（你）买来各个零件（JS 逻辑、手动引入的 CSS），自己动手组装成一台完整的电脑（微应用）。控制力强，但过程繁琐。</td>\n</tr>\n<tr>\n<td><code>**html-entry**</code></td>\n<td>就像 <strong>“购买品牌整机”</strong>。主应用（你）直接买来一台戴尔电脑（HTML 文件），插上电（插入 DOM）就能用。开箱即用，非常方便，但内部细节被封装了。</td>\n</tr>\n</tbody></table>\n<p><strong>现代趋势：</strong></p>\n<ul>\n<li>纯粹的 <code>js-entry</code> 由于其配置的复杂性，在直接使用时体验并不友好。</li>\n<li><strong>qiankun</strong> 这类框架通过实现 <code>html-entry</code> 模式，极大地改善了开发者体验，降低了微前端的上手门槛。</li>\n<li><strong>Webpack Module Federation</strong> 提供了另一种更现代化的 <code>js-entry</code>，它通过复杂的依赖共享机制，解决了 <code>js-entry</code> 的许多痛点（如共享库重复加载），可以看作是 <code>js-entry</code> 的终极进化形态。</li>\n</ul>\n<p>因此，选择哪种方式取决于你的技术栈和框架：</p>\n<ul>\n<li>使用 <strong>原始的 single-spa</strong>，你通常需要处理 <code>js-entry</code>。</li>\n<li>使用 <strong>qiankun</strong>，你享受的是 <code>html-entry</code> 带来的便利。</li>\n<li>使用 <strong>Module Federation</strong>，你体验的是高级的、基于依赖共享的 <code>js-entry</code>。</li>\n</ul>\n<h2 id=\"路由分发可以实现微前端架构吗\"><a href=\"#路由分发可以实现微前端架构吗\" class=\"headerlink\" title=\"路由分发可以实现微前端架构吗\"></a>路由分发可以实现微前端架构吗</h2><p>当然可以。<strong>路由分发是实现微前端架构最主要、最常用也是最经典的方式</strong>。它被认为是微前端架构的“第一种模式”，并且非常有效。</p>\n<h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p><strong>通过路由（URL）的变化，来决定在页面容器中加载、展示和卸载哪个微前端应用。</strong> 主应用（通常称为“容器应用”或“根应用”）充当一个<strong>路由器</strong>和<strong>编排者</strong>的角色，而各个微应用则是独立开发、部署的功能模块。</p>\n<hr>\n<h3 id=\"它是如何工作的？\"><a href=\"#它是如何工作的？\" class=\"headerlink\" title=\"它是如何工作的？\"></a>它是如何工作的？</h3><ol>\n<li><strong>一个路由规则集</strong>：主应用中维护一个配置表，将特定的 URL 路径模式（如 <code>/app1/*</code>, <code>/settings</code>, <code>/dashboard</code>）映射到对应的微应用。</li>\n<li><strong>监听路由变化</strong>：主应用监听 <code>popstate</code>、<code>hashchange</code> 等浏览器路由事件。</li>\n<li><strong>匹配与决策</strong>：当路由发生变化时（用户点击链接或手动输入 URL），主应用根据配置表判断当前应该激活哪个微应用。</li>\n<li><strong>加载与挂载</strong>：主应用动态获取该微应用的资源（JS, CSS），并将其挂载到页面中指定的 DOM 容器（如 <code>&lt;div id=&quot;micro-app-container&quot;&gt;</code>）中。</li>\n<li><strong>卸载与清理</strong>：当用户离开当前路由时，主应用会卸载之前的微应用，并进行必要的清理工作（如清除事件监听器、内存释放等），然后加载新的微应用。</li>\n</ol>\n<h2 id=\"webpack5的Module-Federation可以详细说说嘛\"><a href=\"#webpack5的Module-Federation可以详细说说嘛\" class=\"headerlink\" title=\"webpack5的Module Federation可以详细说说嘛\"></a>webpack5的Module Federation可以详细说说嘛</h2><p>好的，我们来深入、详细地探讨 Webpack 5 的 <strong>Module Federation（模块联邦）</strong>。它不仅仅是微前端的一种实现方式，更是一种革命性的架构思想。</p>\n<h3 id=\"一、核心概念：它是什么？\"><a href=\"#一、核心概念：它是什么？\" class=\"headerlink\" title=\"一、核心概念：它是什么？\"></a>一、核心概念：它是什么？</h3><p><strong>Module Federation (MF)</strong> 的核心目标是：<strong>允许一个 JavaScript 应用在运行时动态地从另一个应用加载代码并共享依赖</strong>。</p>\n<p>你可以把它想象成在浏览器端实现了类似 Node.js 的 <code>require</code> 或 <code>import</code> 机制，但不是在本地文件系统，而是在<strong>网络上的不同独立应用之间</strong>。</p>\n<p>它打破了传统的应用隔离边界，允许应用彼此成为“模块提供者”和“模块消费者”。</p>\n<hr>\n<h3 id=\"二、为什么要用-Module-Federation？-解决的核心痛点\"><a href=\"#二、为什么要用-Module-Federation？-解决的核心痛点\" class=\"headerlink\" title=\"二、为什么要用 Module Federation？(解决的核心痛点)\"></a>二、为什么要用 Module Federation？(解决的核心痛点)</h3><ol>\n<li><strong>彻底解决依赖重复打包</strong><ul>\n<li><strong>传统微前端</strong>：如果主应用和微应用都使用了 React、Vue 等相同的库，这些库的代码会被分别打包到各自的 bundle 中。用户浏览器会多次下载和执行相同的库代码，导致体积膨胀和性能下降。</li>\n<li><strong>MF</strong>：可以<strong>指定共享依赖</strong>。React 等库只加载一次，所有应用都使用同一份实例。这解决了最重要的“依赖地狱”问题。</li>\n</ul>\n</li>\n<li><strong>更彻底的应用拆分与团队自治</strong><ul>\n<li>它允许将应用拆分成更细粒度的“模块”或“组件”，而不仅仅是“页面”或“应用”。</li>\n<li>团队可以独立开发、部署<strong>一个按钮、一个表单、一个页面</strong>，并让其他团队直接消费。</li>\n</ul>\n</li>\n<li><strong>运行时动态集成</strong><ul>\n<li>代码集成发生在运行时（Runtime），而非构建时（Build-time）。这意味着：<ul>\n<li>你可以进行 <strong>A&#x2F;B 测试</strong>，动态切换不同版本的组件。</li>\n<li>可以<strong>独立部署</strong>某个模块，而无需重新部署整个应用。</li>\n<li>主应用甚至不需要提前知道所有可能被加载的微应用。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"三、核心角色与配置\"><a href=\"#三、核心角色与配置\" class=\"headerlink\" title=\"三、核心角色与配置\"></a>三、核心角色与配置</h3><p>MF 中有两个关键角色：</p>\n<ol>\n<li><strong>Remote (远程模块&#x2F;消费者)</strong><ul>\n<li>它是一个<strong>使用方</strong>应用，在运行时从其他地方（<code>Host</code>）导入并执行代码。</li>\n<li>它的配置使用 <code>remotes</code> 属性。</li>\n</ul>\n</li>\n<li><strong>Host (宿主模块&#x2F;提供者)</strong><ul>\n<li>它是一个<strong>提供方</strong>应用，将其内部的某些模块暴露给外部使用。</li>\n<li>它的配置使用 <code>exposes</code> 属性。</li>\n</ul>\n</li>\n</ol>\n<p><strong>一个应用可以同时是</strong>** <strong><code>**Host**</code></strong> <strong><strong>和</strong></strong> **<code>**Remote**</code>。</p>\n<h4 id=\"配置详解-webpack-config-js\"><a href=\"#配置详解-webpack-config-js\" class=\"headerlink\" title=\"配置详解 (webpack.config.js)\"></a>配置详解 (<code>webpack.config.js</code>)</h4><p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Host 应用的配置 (提供模块的应用，端口3001)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ModuleFederationPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack/lib/container/ModuleFederationPlugin&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...其他配置</span></span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">ModuleFederationPlugin</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;app1&#x27;</span>, <span class=\"comment\">// 必填，这个应用的唯一名称，是消费者调用时的标识</span></span><br><span class=\"line\">      <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;remoteEntry.js&#x27;</span>, <span class=\"comment\">// 必填，对外暴露的入口文件清单名</span></span><br><span class=\"line\">      <span class=\"attr\">exposes</span>: &#123; <span class=\"comment\">// 暴露哪些模块给外部使用</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;./Button&#x27;</span>: <span class=\"string\">&#x27;./src/components/Button&#x27;</span>, <span class=\"comment\">// 键：供外部使用的别名；值：本地模块路径</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;./App&#x27;</span>: <span class=\"string\">&#x27;./src/App&#x27;</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">shared</span>: &#123; <span class=\"comment\">// 共享的依赖库</span></span><br><span class=\"line\">        <span class=\"attr\">react</span>: &#123; </span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 确保只使用一个单例版本</span></span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span> <span class=\"comment\">// 需要的版本</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&#x27;react-dom&#x27;</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Remote 应用的配置 (消费模块的应用，端口3002)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ModuleFederationPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack/lib/container/ModuleFederationPlugin&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...其他配置</span></span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">ModuleFederationPlugin</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;app2&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">remotes</span>: &#123; <span class=\"comment\">// 声明要消费哪些远程应用</span></span><br><span class=\"line\">        <span class=\"comment\">// 格式: &quot;name@url/remoteEntry.js&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">app1</span>: <span class=\"string\">&#x27;app1@http://localhost:3001/remoteEntry.js&#x27;</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">shared</span>: &#123; <span class=\"comment\">// 共享依赖的配置必须与Host一致，才能成功共享</span></span><br><span class=\"line\">        <span class=\"attr\">react</span>: &#123; </span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&#x27;react-dom&#x27;</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h3 id=\"四、如何使用？\"><a href=\"#四、如何使用？\" class=\"headerlink\" title=\"四、如何使用？\"></a>四、如何使用？</h3><p>在 <code>app2</code> (Remote) 的代码中，你可以像导入本地模块一样<strong>动态导入</strong> <code>app1</code> (Host) 暴露的模块：</p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 app2 的 React 组件中</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; <span class=\"title class_\">Suspense</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用动态导入语法。`app1` 是配置中remotes的key，`./Button` 是app1暴露的模块名</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">RemoteButton</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">lazy</span>(<span class=\"function\">() =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;app1/Button&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>我是 App2<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">Suspense</span> <span class=\"attr\">fallback</span>=<span class=\"string\">&#123;</span>&lt;<span class=\"attr\">div</span>&gt;</span>Loading Button...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">  &#123;/* 这个Button组件来自另一个独立应用 app1！ */&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">RemoteButton</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Suspense</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span>;</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h3 id=\"五、工作流程（魔法是如何发生的？）\"><a href=\"#五、工作流程（魔法是如何发生的？）\" class=\"headerlink\" title=\"五、工作流程（魔法是如何发生的？）\"></a>五、工作流程（魔法是如何发生的？）</h3><ol>\n<li><strong>构建阶段</strong>：<ul>\n<li><code>Host</code> (<code>app1</code>) 构建时，会生成一个 <code>remoteEntry.js</code> 文件。这个文件是一个<strong>清单(Manifest)</strong>，记录了 <code>exposes</code> 了哪些模块以及如何获取它们。</li>\n<li><code>Remote</code> (<code>app2</code>) 构建时，会意识到 <code>import(&#39;app1/Button&#39;)</code> 是一个远程模块，不会将其打包到自己的 bundle 中。</li>\n</ul>\n</li>\n<li><strong>运行时阶段</strong>：<ul>\n<li>浏览器加载 <code>app2</code>。</li>\n<li>当执行到 <code>import(&#39;app1/Button&#39;)</code> 时，Webpack 运行时就会去检查配置。</li>\n<li>它发现 <code>app1</code> 对应 <code>http://localhost:3001/remoteEntry.js</code>，于是<strong>动态加载</strong>这个 <code>remoteEntry.js</code> 文件。</li>\n<li><code>remoteEntry.js</code> 告诉 <code>app2</code> 如何从 <code>app1</code> 的服务器上获取 <code>Button</code> 组件的代码块。</li>\n<li>Webpack 加载这个代码块，并<strong>与</strong>** <strong><code>**app2**</code></strong> <strong><strong>共享的</strong></strong> <strong><code>**react**</code></strong> <strong><strong>和</strong></strong> <strong><code>**react-dom**</code></strong> **<strong>实例一起执行它</strong>。</li>\n<li>组件渲染成功。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"六、与-single-spa-等方案的对比\"><a href=\"#六、与-single-spa-等方案的对比\" class=\"headerlink\" title=\"六、与 single-spa 等方案的对比\"></a>六、与 single-spa 等方案的对比</h3><table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>Module Federation</strong></th>\n<th><strong>single-spa (传统方式)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>核心能力</strong></td>\n<td><strong>模块共享与依赖管理</strong></td>\n<td><strong>应用生命周期管理与路由</strong></td>\n</tr>\n<tr>\n<td><strong>集成方式</strong></td>\n<td><strong>运行时动态导入</strong></td>\n<td>运行时加载（但依赖需各自处理）</td>\n</tr>\n<tr>\n<td><strong>依赖处理</strong></td>\n<td><strong>卓越</strong>。自动共享库，避免重复。</td>\n<td><strong>困难</strong>。需要额外手动配置或工具解决。</td>\n</tr>\n<tr>\n<td><strong>打包输出</strong></td>\n<td>生成 <code>remoteEntry.js</code><br/> 清单文件</td>\n<td>生成应用的入口 JS 文件</td>\n</tr>\n<tr>\n<td><strong>粒度</strong></td>\n<td><strong>非常细</strong>。可以共享单个组件、函数、工具库。</td>\n<td><strong>较粗</strong>。通常以整个“应用”或“页面”为单元。</td>\n</tr>\n<tr>\n<td><strong>关系</strong></td>\n<td><strong>互补</strong>。可以<strong>结合使用</strong>：用 single-spa 做路由和生命周期管理，用 MF 来加载组件和共享依赖。</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>Webpack 5 的 Module Federation 是一项颠覆性的技术</strong>。它不再是简单地将应用机械地拼凑在一起，而是真正实现了应用间代码的“无缝融合”与“依赖共享”。</p>\n<p>它最适合的场景包括：</p>\n<ul>\n<li><strong>大型平台型产品</strong>：需要多个团队独立开发不同功能模块。</li>\n<li><strong>微前端架构</strong>：是目前实现微前端最先进、最优雅的方案之一。</li>\n<li><strong>跨应用组件&#x2F;工具库共享</strong>：避免维护多个版本的通用组件。</li>\n</ul>\n<p>它代表了前端架构从“单体”到“分布式”演进的重要方向，是每一位前端架构师都应该深入理解的技术。</p>\n<p>web component</p>\n<h2 id=\"好的，我们来全面、深入地探讨-Web-Components。\"><a href=\"#好的，我们来全面、深入地探讨-Web-Components。\" class=\"headerlink\" title=\"好的，我们来全面、深入地探讨 Web Components。\"></a>好的，我们来全面、深入地探讨 Web Components。</h2><h3 id=\"一、核心概念：它是什么？-1\"><a href=\"#一、核心概念：它是什么？-1\" class=\"headerlink\" title=\"一、核心概念：它是什么？\"></a>一、核心概念：它是什么？</h3><p><strong>Web Components</strong> 是一套<strong>浏览器原生支持</strong>的技术集合，允许你创建可重用的、封装的自定义 HTML 元素（类似于 <code>&lt;div&gt;</code>、<code>&lt;button&gt;</code>，但是是你自己定义的），并在任何现代浏览器中使用它们，无需任何外部框架（如 React、Vue、Angular）。</p>\n<p>它的核心目标是为 Web 开发提供<strong>真正的组件化模型</strong>，并解决代码重用和封装的问题。</p>\n<hr>\n<h3 id=\"二、为什么需要-Web-Components？（解决的问题）\"><a href=\"#二、为什么需要-Web-Components？（解决的问题）\" class=\"headerlink\" title=\"二、为什么需要 Web Components？（解决的问题）\"></a>二、为什么需要 Web Components？（解决的问题）</h3><ol>\n<li><strong>框架无关性 (Framework-Agnostic)</strong><ul>\n<li>你用 Web Components 编写的组件可以在任何 HTML 页面中使用，无论这个页面用的是 React、Vue、Angular、jQuery 还是纯 JavaScript。它提供了<strong>最大程度的可移植性</strong>。</li>\n</ul>\n</li>\n<li><strong>原生封装 (Native Encapsulation)</strong><ul>\n<li><strong>Shadow DOM</strong> 提供了强大的样式和行为封装。组件内部的样式不会泄漏到外部，外部的样式也不会渗透到组件内部（除非特意允许）。这彻底解决了 CSS 全局污染的问题。</li>\n</ul>\n</li>\n<li><strong>长期稳定性 (Longevity)</strong><ul>\n<li>作为<strong>Web 平台标准</strong>，它由浏览器厂商直接实现和维护，不像前端框架那样有生命周期（例如，AngularJS 到 Angular 的断代升级）。你写的组件在未来很多年内都能继续工作。</li>\n</ul>\n</li>\n<li><strong>生态系统互操作性 (Interoperability)</strong><ul>\n<li>它可以在任何框架中被当作普通的 HTML 元素使用，成为了连接不同技术栈应用的“桥梁”。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"三、技术构成（四大核心技术）\"><a href=\"#三、技术构成（四大核心技术）\" class=\"headerlink\" title=\"三、技术构成（四大核心技术）\"></a>三、技术构成（四大核心技术）</h3><p>Web Components 主要由四项技术标准组成，它们可以单独使用，但组合在一起威力最大。</p>\n<h4 id=\"1-Custom-Elements（自定义元素）\"><a href=\"#1-Custom-Elements（自定义元素）\" class=\"headerlink\" title=\"1. Custom Elements（自定义元素）\"></a>1. Custom Elements（自定义元素）</h4><p>一套 JavaScript API，允许你<strong>定义自定义元素及其行为</strong>。</p>\n<ul>\n<li><strong>如何定义</strong>：通过继承 <code>HTMLElement</code> 类来创建一个新的元素类。</li>\n<li><strong>生命周期回调</strong>：<ul>\n<li><code>connectedCallback</code>: 当元素首次被插入到 DOM 时调用。</li>\n<li><code>disconnectedCallback</code>: 当元素从 DOM 中移除时调用。</li>\n<li><code>adoptedCallback</code>: 当元素被移动到新的文档时调用。</li>\n<li><code>attributeChangedCallback</code>: 当元素的被观察属性（在 <code>observedAttributes</code> 中定义）发生变化时调用。</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例：定义一个简单的自定义元素</strong></p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyButton</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">HTMLElement</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 初始化逻辑</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">connectedCallback</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">innerHTML</span> = <span class=\"string\">`&lt;button&gt;Click Me!&lt;/button&gt;`</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;Button clicked!&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义需要监听的属性</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> <span class=\"title function_\">observedAttributes</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">&#x27;disabled&#x27;</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 当disabled属性变化时触发</span></span><br><span class=\"line\">  <span class=\"title function_\">attributeChangedCallback</span>(<span class=\"params\">name, oldValue, newValue</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"string\">&#x27;disabled&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`disabled changed from <span class=\"subst\">$&#123;oldValue&#125;</span> to <span class=\"subst\">$&#123;newValue&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向浏览器注册这个新元素，标签名必须包含连字符 `-`</span></span><br><span class=\"line\">customElements.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;my-button&#x27;</span>, <span class=\"title class_\">MyButton</span>);</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>在 HTML 中使用</strong>：</p>\n<p>html</p>\n<p><my-button disabled></my-button></p>\n<h4 id=\"2-Shadow-DOM（影子-DOM）\"><a href=\"#2-Shadow-DOM（影子-DOM）\" class=\"headerlink\" title=\"2. Shadow DOM（影子 DOM）\"></a>2. Shadow DOM（影子 DOM）</h4><p>一套用于将<strong>封装的、“影子”的 DOM 树附加到元素</strong>的 API。这是实现样式和行为封装的关键。</p>\n<ul>\n<li><strong>Shadow Root</strong>：Shadow DOM 的根节点。</li>\n<li><strong>模式</strong>：<ul>\n<li><code>open</code>: 可以通过 JavaScript 从外部访问（例如 <code>element.shadowRoot</code>）。</li>\n<li><code>closed</code>: 外部无法访问，封装性更强。</li>\n</ul>\n</li>\n<li><strong>作用域</strong>：在 Shadow DOM 内部定义的样式和脚本只在这个范围内有效，与外部隔离。</li>\n</ul>\n<p><strong>示例：为自定义元素添加 Shadow DOM</strong></p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyCard</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">HTMLElement</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 附加一个打开的 Shadow Root</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> shadow = <span class=\"variable language_\">this</span>.<span class=\"title function_\">attachShadow</span>(&#123; <span class=\"attr\">mode</span>: <span class=\"string\">&#x27;open&#x27;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建模板</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> template = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;template&#x27;</span>);</span><br><span class=\"line\">    template.<span class=\"property\">innerHTML</span> = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      &lt;style&gt;</span></span><br><span class=\"line\"><span class=\"string\">        /* 这些样式只在这个卡片内有效，不会影响外部 */</span></span><br><span class=\"line\"><span class=\"string\">        .card &#123;</span></span><br><span class=\"line\"><span class=\"string\">          border: 1px solid #ccc;</span></span><br><span class=\"line\"><span class=\"string\">          padding: 16px;</span></span><br><span class=\"line\"><span class=\"string\">          border-radius: 8px;</span></span><br><span class=\"line\"><span class=\"string\">          font-family: sans-serif;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        h2 &#123; color: blue; margin-top: 0; &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/style&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;div class=&quot;card&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;h2&gt;&lt;slot name=&quot;title&quot;&gt;Default Title&lt;/slot&gt;&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;&lt;slot name=&quot;content&quot;&gt;Default content...&lt;/slot&gt;&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 克隆模板内容并添加到 Shadow Root</span></span><br><span class=\"line\">    shadow.<span class=\"title function_\">appendChild</span>(template.<span class=\"property\">content</span>.<span class=\"title function_\">cloneNode</span>(<span class=\"literal\">true</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">customElements.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;my-card&#x27;</span>, <span class=\"title class_\">MyCard</span>);</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>在 HTML 中使用</strong>：</p>\n<p>html</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-card&gt;</span><br><span class=\"line\">  &lt;!-- 使用 slot 将外部内容投影到 Shadow DOM 中的指定位置 --&gt;</span><br><span class=\"line\">  &lt;span slot=&quot;title&quot;&gt;My Awesome Title&lt;/span&gt;</span><br><span class=\"line\">  &lt;span slot=&quot;content&quot;&gt;This is some fantastic content.&lt;/span&gt;</span><br><span class=\"line\">&lt;/my-card&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"3-HTML-Templates（HTML-模板）\"><a href=\"#3-HTML-Templates（HTML-模板）\" class=\"headerlink\" title=\"3. HTML Templates（HTML 模板）\"></a>3. HTML Templates（HTML 模板）</h4><p><code>&lt;template&gt;</code> 和 <code>&lt;slot&gt;</code> 元素允许你编写<strong>在页面加载时不会立即渲染的标记模板</strong>。这些模板可以被后续的 JavaScript 激活和使用。</p>\n<ul>\n<li><code>&lt;template&gt;</code>：内容不会被浏览器解析、渲染或执行，直到被 JavaScript 提取并使用。</li>\n<li><code>&lt;slot&gt;</code>：在 Web Component 内部充当占位符，允许用户在使用组件时传入自己的自定义内容（如上例所示）。</li>\n</ul>\n<h4 id=\"4-ES-Modules（ES-模块）\"><a href=\"#4-ES-Modules（ES-模块）\" class=\"headerlink\" title=\"4. ES Modules（ES 模块）\"></a>4. ES Modules（ES 模块）</h4><p>现代 JavaScript 的模块标准，为在 Web 上包含和重用 JS 代码提供了官方机制。它使得导入和导出 Web Components 变得简单。</p>\n<p>html</p>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 在 HTML 中导入并使用一个定义好的 Web Component --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;module&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./my-component.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h3 id=\"四、Web-Components-的优点与缺点\"><a href=\"#四、Web-Components-的优点与缺点\" class=\"headerlink\" title=\"四、Web Components 的优点与缺点\"></a>四、Web Components 的优点与缺点</h3><h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ol>\n<li><strong>浏览器原生</strong>：无需编译，无需复杂的构建工具。</li>\n<li><strong>高度封装</strong>：Shadow DOM 解决了 CSS 和 DOM 的隔离问题。</li>\n<li><strong>框架无关</strong>：极高的互操作性和可移植性。</li>\n<li><strong>永久可用</strong>：作为 Web 标准，具有极长的生命周期和向后兼容性。</li>\n</ol>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ol>\n<li><strong>生态相对年轻</strong>：虽然基础功能强大，但缺少像 React&#x2F;Vue 那样庞大的生态系统（状态管理、路由、测试工具等）。</li>\n<li><strong>数据流管理较弱</strong>：原生不支持类似 React 的 Props 向下传递、事件向上冒泡的父子组件通信范式，需要自己实现（通常用 Custom Events）。</li>\n<li><strong>SSR (服务器端渲染) 支持差</strong>：自定义元素可以在服务器上渲染，但其动态行为和客户端激活（Hydration）非常复杂，远不如 Next.js&#x2F;Nuxt.js 成熟。</li>\n<li><strong>开发体验 (DX)</strong>：原始的开发方式比较繁琐，需要写很多样板代码。但社区有诸如 <strong>Lit</strong>、<strong>Stencil</strong> 等库来极大地改善体验。</li>\n</ol>\n<hr>\n<h3 id=\"五、Web-Components-与微前端和框架\"><a href=\"#五、Web-Components-与微前端和框架\" class=\"headerlink\" title=\"五、Web Components 与微前端和框架\"></a>五、Web Components 与微前端和框架</h3><ul>\n<li><strong>在微前端中</strong>：Web Components 是实现<strong>技术栈无关</strong>微前端的理想载体。每个团队可以用自己熟悉的技术（React, Vue）<strong>开发</strong>组件，但最终<strong>发布</strong>为一个封装好的 Web Component（例如，将一个 React 组件包装成 <code>&lt;team-product-card&gt;</code>），由主应用统一调度。</li>\n<li><strong>与框架的关系</strong>：<ul>\n<li><strong>不是替代关系</strong>，而是<strong>互补关系</strong>。</li>\n<li><strong>框架 (React&#x2F;Vue) 擅长解决：</strong> 复杂的 UI 状态管理、数据流、高效的 DOM 差分更新。它们提供了<strong>优秀的开发体验</strong>和<strong>完整的解决方案</strong>。</li>\n<li><strong>Web Components 擅长解决：</strong> 跨框架重用、底层 UI 组件库、集成遗留应用、长期稳定的基础组件。它们提供了<strong>浏览器级别的互操作性</strong>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>总结来说，Web Components 是 Web 平台的底层基础，为构建可长期存在、高度封装、框架无关的组件提供了强大的原生能力。</strong> 虽然它在开发复杂应用时不如现代框架那么方便，但其独特优势使其在特定场景（如微前端、跨技术栈组件库、大型企业级应用）中是不可替代的选择。</p>\n<p>qiankun实现样式和js隔离的原理</p>\n<p>好的，我们来深入剖析 <strong>qiankun</strong> 实现样式和 JavaScript 隔离的原理。这是 qiankun 的核心能力之一，也是它相比原始 single-spa 更易用、更强大的关键。</p>\n<h3 id=\"总体思想\"><a href=\"#总体思想\" class=\"headerlink\" title=\"总体思想\"></a>总体思想</h3><p>qiankun 的隔离策略可以概括为：<strong>“重样式隔离，轻 JS 沙箱”</strong>。它通过在应用加载和卸载时动态地操作样式和 JavaScript 执行环境来模拟一个隔离的沙箱环境。</p>\n<hr>\n<h3 id=\"一、样式隔离-CSS-Isolation\"><a href=\"#一、样式隔离-CSS-Isolation\" class=\"headerlink\" title=\"一、样式隔离 (CSS Isolation)\"></a>一、样式隔离 (CSS Isolation)</h3><p>qiankun 提供了三种主要的样式隔离方案，根据场景不同自动或手动启用。</p>\n<h4 id=\"1-严格样式隔离-Scoped-CSS\"><a href=\"#1-严格样式隔离-Scoped-CSS\" class=\"headerlink\" title=\"1. 严格样式隔离 (Scoped CSS)\"></a>1. 严格样式隔离 (Scoped CSS)</h4><p><strong>原理：</strong> 为每个微应用包裹一个 <strong>Shadow DOM</strong>。</p>\n<ul>\n<li><strong>如何工作：</strong><ol>\n<li>当 qiankun 挂载一个微应用时，它会创建一个 Shadow Root，并将其作为该应用的容器。</li>\n<li>微应用的所有 DOM 结构都被渲染在这个 Shadow DOM 内部。</li>\n<li><strong>Shadow DOM 的特性天然实现了样式的封装</strong>：内部的样式不会影响外部，外部的样式也不会影响内部（除非使用 <code>::part</code> 或 <code>:host</code> 等特定语法）。</li>\n</ol>\n</li>\n<li><strong>优点：</strong> 隔离性最强，是浏览器原生的完美隔离方案。</li>\n<li><strong>缺点：</strong><ul>\n<li>某些第三方库（特别是弹窗类）可能会因为无法正确定位到 Shadow DOM 外部而出现问题。</li>\n<li>微应用内的样式完全无法影响主应用，反之亦然，有时这可能不符合设计需求。</li>\n</ul>\n</li>\n<li><strong>启用方式：</strong> 在 <code>start</code> 函数中配置 <code>&#123; strictStyleIsolation: true &#125;</code>。</li>\n</ul>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; start &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;qiankun&#x27;</span>;</span><br><span class=\"line\"><span class=\"title function_\">start</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">strictStyleIsolation</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 启用严格样式隔离</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"2-实验性样式隔离-CSS-Scoped\"><a href=\"#2-实验性样式隔离-CSS-Scoped\" class=\"headerlink\" title=\"2. 实验性样式隔离 (CSS Scoped)\"></a>2. 实验性样式隔离 (CSS Scoped)</h4><p><strong>原理：</strong> 一种更宽松的隔离方式，使用 <strong>运行时动态样式表重写</strong>。</p>\n<ul>\n<li><strong>如何工作：</strong><ol>\n<li>qiankun 会劫持微应用运行时<strong>动态添加样式标签（</strong><code>**&lt;style&gt;**</code><strong>,</strong>** <strong><code>**&lt;link&gt;**</code></strong>）** 的行为。</li>\n<li>当微应用插入一个新的样式标签时，qiankun 会将其内容抓取过来。</li>\n<li>使用 <strong>CSS 规则重写器</strong>（例如 <code>postcss</code> 插件）为所有 CSS 选择器<strong>添加一个特殊的前缀</strong>。这个前缀通常基于微应用的名称或一个特定属性。</li>\n<li>将重写后的 CSS 内容插入到 <code>document.head</code> 中。</li>\n<li>同时，qiankun 会为微应用的<strong>容器元素</strong>添加上一步中使用的<strong>相同属性</strong>。</li>\n</ol>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code>- 微应用有一个样式规则：`.button &#123; color: red; &#125;`\n- qiankun 将其重写为：`[data-qiankun=&quot;my-app&quot;] .button &#123; color: red; &#125;`\n- 同时，微应用的容器 `&lt;div&gt;` 会获得属性：`&lt;div data-qiankun=&quot;my-app&quot;&gt;...&lt;/div&gt;`\n- 这样，样式规则就只会在这个容器内生效。\n</code></pre>\n<ul>\n<li><strong>优点：</strong> 比 Shadow DOM 兼容性更好，允许微应用样式影响其容器内的任何元素（包括动态 append 到 body 的弹窗）。</li>\n<li><strong>缺点：</strong> 是运行时重写，有一定性能开销，且是实验性功能。</li>\n<li><strong>启用方式：</strong> 在 <code>start</code> 函数中配置 <code>&#123; experimentalStyleIsolation: true &#125;</code>。</li>\n</ul>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">start</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">experimentalStyleIsolation</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 启用实验性样式隔离</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"3-动态样式表加载-卸载-最常见的默认行为\"><a href=\"#3-动态样式表加载-卸载-最常见的默认行为\" class=\"headerlink\" title=\"3. 动态样式表加载&#x2F;卸载 (最常见的默认行为)\"></a>3. 动态样式表加载&#x2F;卸载 (最常见的默认行为)</h4><p>如果不开启上述两种隔离，qiankun 默认采用一种更简单但有效的策略。</p>\n<ul>\n<li><strong>原理：</strong><ol>\n<li><strong>加载时：</strong> qiankun 通过 <code>fetch</code> 获取微应用的 HTML 入口，解析出所有的 <code>&lt;style&gt;</code> 和 <code>&lt;link&gt;</code> 标签。</li>\n<li>将这些样式标签<strong>直接插入到</strong>** **<code>**document.head**</code> 中。</li>\n<li><strong>卸载时：</strong> qiankun 会<strong>记录</strong>所有由该微应用添加的样式标签，并在卸载微应用时<strong>直接将这些标签从 DOM 中移除</strong>。</li>\n</ol>\n</li>\n<li><strong>优点：</strong> 实现简单，性能好。</li>\n<li><strong>缺点：</strong> <strong>不是真正的隔离</strong>。如果多个微应用有相同选择器的样式规则，后加载的会覆盖先加载的（因为后加载的样式表在更后面，优先级更高）。这依赖于开发者的约定。</li>\n<li><strong>这是 qiankun 的默认行为</strong>，对于很多应用来说已经足够。</li>\n</ul>\n<hr>\n<h3 id=\"二、JavaScript-隔离-JS-Sandbox\"><a href=\"#二、JavaScript-隔离-JS-Sandbox\" class=\"headerlink\" title=\"二、JavaScript 隔离 (JS Sandbox)\"></a>二、JavaScript 隔离 (JS Sandbox)</h3><p>qiankun 的 JS 沙箱的核心目标是：<strong>防止微应用在全局环境（</strong><code>**window**</code><strong>）上留下永久的污染，并在应用切换时恢复和清理环境</strong>。它主要模拟了三个环境的隔离：</p>\n<h4 id=\"1-快照沙箱-SnapshotSandbox-用于单实例场景\"><a href=\"#1-快照沙箱-SnapshotSandbox-用于单实例场景\" class=\"headerlink\" title=\"1. 快照沙箱 (SnapshotSandbox) - 用于单实例场景\"></a>1. 快照沙箱 (SnapshotSandbox) - 用于单实例场景</h4><p><strong>原理：</strong> 在应用加载前后对全局 <code>window</code> 对象进行“拍照”和“diff”，适用于同一时间只能有一个微应用活跃的浏览器环境。</p>\n<ul>\n<li><strong>工作流程：</strong><ol>\n<li><strong>激活沙箱 (mount)：</strong> 将当前 <code>window</code> 的所有属性拍一个<strong>快照</strong>（<code>windowSnapshot</code>），存起来。</li>\n<li><strong>微应用运行：</strong> 微应用可以任意修改 <code>window</code>。</li>\n<li><strong>失活沙箱 (unmount)：</strong><ul>\n<li>将当前的 <code>window</code> 和之前存的 <code>windowSnapshot</code> 进行对比，得到修改的差异（<code>modifyPropsMap</code>）。</li>\n<li><strong>还原现场：</strong> 遍历差异，将 <code>window</code> 上的属性<strong>恢复</strong>到拍快照时的状态。</li>\n<li><strong>记录污染：</strong> 将微应用修改的差异保存起来。</li>\n</ul>\n</li>\n<li><strong>再次激活：</strong> 将之前保存的差异（<code>modifyPropsMap</code>）<strong>重新应用到</strong>** <strong><code>**window**</code></strong> **<strong>上</strong>，让微应用感觉自己的修改一直都在。</li>\n</ol>\n</li>\n<li><strong>优点：</strong> 兼容性极好，支持所有浏览器。</li>\n<li><strong>缺点：</strong> 无法支持多个微应用同时运行（多实例），因为共用一个全局 <code>window</code>。</li>\n</ul>\n<h4 id=\"2-代理沙箱-ProxySandbox-用于多实例场景（主流）\"><a href=\"#2-代理沙箱-ProxySandbox-用于多实例场景（主流）\" class=\"headerlink\" title=\"2. 代理沙箱 (ProxySandbox) - 用于多实例场景（主流）\"></a>2. 代理沙箱 (ProxySandbox) - 用于多实例场景（主流）</h4><p><strong>原理：</strong> 使用 ES6 的 <code>Proxy</code> 为每个微应用创建一个假的、隔离的 <code>window</code> 对象。</p>\n<ul>\n<li><strong>工作流程：</strong><ol>\n<li>qiankun 为每个微应用创建一个空的 <code>fakeWindow</code> 对象。</li>\n<li>用 <code>Proxy</code> 代理这个 <code>fakeWindow</code>。</li>\n<li>当微应用操作 <code>window</code> 时：<ul>\n<li><strong>读操作</strong>：优先从 <code>fakeWindow</code> 里读，如果读不到，则 fallback 到真正的全局 <code>window</code>（这样可以共享 <code>document</code>, <code>location</code> 等全局对象）。</li>\n<li><strong>写操作</strong>：所有对属性的新增和修改都只作用于 <code>fakeWindow</code> 上，<strong>完全不会污染真正的全局</strong>** **<code>**window**</code>。</li>\n</ul>\n</li>\n<li>微应用的所有代码都在这个代理的上下文中执行（通过 <code>with</code> 语句或 <code>eval</code> 改写）。</li>\n</ol>\n</li>\n<li><strong>示例：</strong></li>\n</ul>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 微应用代码</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">myGlobalVar</span> = <span class=\"number\">123</span>; <span class=\"comment\">// 写入的是沙箱的 fakeWindow，真 window 不受影响</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">document</span>.<span class=\"property\">title</span>); <span class=\"comment\">// 读取的是真 window 的属性</span></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><strong>优点：</strong><ul>\n<li>真正的隔离，多个微应用可以同时运行，每个都有自己独立的 <code>window</code> 空间。</li>\n<li>对微应用无感知，无需修改代码。</li>\n</ul>\n</li>\n<li><strong>缺点：</strong> 依赖 ES6 <code>Proxy</code>，无法在低版本浏览器（如 IE）中使用。</li>\n</ul>\n<h4 id=\"3-遗留沙箱-LegacySandbox-已逐渐被代理沙箱取代\"><a href=\"#3-遗留沙箱-LegacySandbox-已逐渐被代理沙箱取代\" class=\"headerlink\" title=\"3. 遗留沙箱 (LegacySandbox) - 已逐渐被代理沙箱取代\"></a>3. 遗留沙箱 (LegacySandbox) - 已逐渐被代理沙箱取代</h4><p>原理类似于快照沙箱，但性能优化更好。它只记录微应用修改过的属性，在卸载时还原这些属性。同样不支持多实例。</p>\n<hr>\n<h3 id=\"总结：qiankun-的隔离策略\"><a href=\"#总结：qiankun-的隔离策略\" class=\"headerlink\" title=\"总结：qiankun 的隔离策略\"></a>总结：qiankun 的隔离策略</h3><table>\n<thead>\n<tr>\n<th><strong>隔离类型</strong></th>\n<th><strong>技术方案</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>样式隔离</strong></td>\n<td><strong>Shadow DOM</strong></td>\n<td>原生，隔离最彻底</td>\n<td>兼容性问题，弹窗等组件可能异常</td>\n<td>需要最强隔离的新应用</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>动态样式表重写 (实验性)</strong></td>\n<td>兼容性好，支持弹窗</td>\n<td>运行时开销，实验性功能</td>\n<td>需要兼容弹窗的复杂应用</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>动态加载&#x2F;卸载 (默认)</strong></td>\n<td>简单，性能好</td>\n<td>非真正隔离，依赖约定</td>\n<td>大多数简单应用，样式冲突风险低</td>\n</tr>\n<tr>\n<td><strong>JS 隔离</strong></td>\n<td><strong>快照沙箱 (SnapshotSandbox)</strong></td>\n<td>兼容所有浏览器</td>\n<td>不支持多实例</td>\n<td>单实例模式，需兼容 IE 等老浏览器</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>代理沙箱 (ProxySandbox)</strong></td>\n<td>真正隔离，支持多实例，对应用无感知</td>\n<td>依赖 <code>Proxy</code><br/>，不兼容 IE</td>\n<td><strong>现代浏览器下的主流选择</strong></td>\n</tr>\n</tbody></table>\n<p><strong>qiankun 会自动选择最佳策略</strong>：在支持 <code>Proxy</code> 的浏览器中默认使用<strong>代理沙箱 (多实例)</strong> 和<strong>动态样式加载&#x2F;卸载</strong>。如果不支持 <code>Proxy</code>，则降级到<strong>快照沙箱 (单实例)</strong>。</p>\n<p>通过这种组合策略，qiankun 在绝大多数场景下为微前端应用提供了<strong>足够安全、稳定且高性能的隔离环境</strong>，极大地简化了微前端的落地复杂度。</p>\n<p>qiankun是如何实现父子应用通信的呢</p>\n<p>好的，<strong>qiankun 的通信机制</strong>是其核心功能之一，它设计得非常灵活，提供了多种方式来实现主应用（父应用）和微应用（子应用）之间的通信。</p>\n<p>qiankun 并没有强制使用某一种通信方式，而是提供了一个轻量的 <strong>API（</strong><code>**initGlobalState**</code><strong>）</strong> 作为推荐方案，同时也完全支持任何其他流行的状态管理库（如 Redux, Mobx, Vuex）或浏览器原生 API。</p>\n<hr>\n<h3 id=\"一、官方推荐方案：使用-initGlobalState-Actions-通信\"><a href=\"#一、官方推荐方案：使用-initGlobalState-Actions-通信\" class=\"headerlink\" title=\"一、官方推荐方案：使用 initGlobalState (Actions 通信)\"></a>一、官方推荐方案：使用 <code>initGlobalState</code> (Actions 通信)</h3><p>这是 qiankun 官方提供的通信方式，适用于大多数场景。它的核心思想是一个<strong>简单的发布-订阅模式</strong>。</p>\n<h4 id=\"1-在主应用中初始化状态并下发通信方法\"><a href=\"#1-在主应用中初始化状态并下发通信方法\" class=\"headerlink\" title=\"1. 在主应用中初始化状态并下发通信方法\"></a>1. 在主应用中初始化状态并下发通信方法</h4><p>主应用是整个状态的管理中心。</p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main-app/src/actions.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; initGlobalState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;qiankun&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 初始化全局状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\">  <span class=\"attr\">user</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;张三&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">token</span>: <span class=\"string\">&#x27;abc123&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">theme</span>: <span class=\"string\">&#x27;light&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 创建 Actions 实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> actions = <span class=\"title function_\">initGlobalState</span>(initialState);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 监听状态变化（可选，主应用自己也可以监听）</span></span><br><span class=\"line\">actions.<span class=\"title function_\">onGlobalStateChange</span>(<span class=\"function\">(<span class=\"params\">state, prevState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// state: 变更后的新状态</span></span><br><span class=\"line\">  <span class=\"comment\">// prevState: 变更前的旧状态</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;主应用监听到状态变化: &#x27;</span>, state, prevState);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 定义一个更新状态的方法</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">setGlobalState</span> = (<span class=\"params\">newState</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 按层级合并状态</span></span><br><span class=\"line\">  actions.<span class=\"title function_\">setGlobalState</span>(newState);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 将 actions 暴露出去，供微应用使用</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> actions;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"2-在微应用中获取并操作状态\"><a href=\"#2-在微应用中获取并操作状态\" class=\"headerlink\" title=\"2. 在微应用中获取并操作状态\"></a>2. 在微应用中获取并操作状态</h4><p>微应用需要从生命周期函数中获取到 <code>props</code>，其中就包含了通信方法。</p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// micro-app/src/main.js (入口文件)</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> microAppActions; <span class=\"comment\">// 用来保存通信方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导出 qiankun 生命周期函数</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">mount</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;微应用挂载了&#x27;</span>, props);</span><br><span class=\"line\">  <span class=\"comment\">// 1. 从 props 中获取主应用下发的 actions</span></span><br><span class=\"line\">  microAppActions = props;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 监听全局状态变化</span></span><br><span class=\"line\">  props.<span class=\"title function_\">onGlobalStateChange</span>(<span class=\"function\">(<span class=\"params\">state, prevState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;微应用监听到状态变化: &#x27;</span>, state, prevState);</span><br><span class=\"line\">    <span class=\"comment\">// 状态变化后，更新微应用自己的视图</span></span><br><span class=\"line\">    <span class=\"title function_\">renderApp</span>(state);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 首次挂载，获取当前全局状态并渲染应用</span></span><br><span class=\"line\">  <span class=\"title function_\">renderApp</span>(props.<span class=\"title function_\">getGlobalState</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">unmount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 卸载时取消监听（qiankun 内部会自动清理，但显式取消是好习惯）</span></span><br><span class=\"line\">  microAppActions.<span class=\"title function_\">offGlobalStateChange</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// React/Vue 应用的渲染函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">renderApp</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">globalState</span>=<span class=\"string\">&#123;state&#125;</span> <span class=\"attr\">actions</span>=<span class=\"string\">&#123;microAppActions&#125;</span> /&gt;</span></span>, <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"3-在微应用组件中具体使用\"><a href=\"#3-在微应用组件中具体使用\" class=\"headerlink\" title=\"3. 在微应用组件中具体使用\"></a>3. 在微应用组件中具体使用</h4><p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// micro-app/src/App.jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\">&#123; globalState, actions &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; user, theme &#125; = globalState;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleChangeTheme</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新全局状态</span></span><br><span class=\"line\">    actions.<span class=\"title function_\">setGlobalState</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">theme</span>: theme === <span class=\"string\">&#x27;light&#x27;</span> ? <span class=\"string\">&#x27;dark&#x27;</span> : <span class=\"string\">&#x27;light&#x27;</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;</span>`<span class=\"attr\">app</span> $&#123;<span class=\"attr\">theme</span>&#125;`&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>微应用页面<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>用户名: &#123;user.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleChangeTheme&#125;</span>&gt;</span>切换主题<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span>;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"initGlobalState-API-说明：\"><a href=\"#initGlobalState-API-说明：\" class=\"headerlink\" title=\"initGlobalState API 说明：\"></a><code>initGlobalState</code> API 说明：</h4><ul>\n<li><code>setGlobalState(state: object)</code>: 设置新的全局状态，会自动与旧状态进行<strong>浅合并</strong>。</li>\n<li><code>onGlobalStateChange(callback: function)</code>: 注册监听器，状态变化时触发。</li>\n<li><code>offGlobalStateChange()</code>: 取消监听。</li>\n<li><code>getGlobalState()</code>: 获取当前全局状态。</li>\n</ul>\n<hr>\n<h3 id=\"二、其他通信方案\"><a href=\"#二、其他通信方案\" class=\"headerlink\" title=\"二、其他通信方案\"></a>二、其他通信方案</h3><p>qiankun 是框架无关的，因此你也可以选择任何你熟悉的通信方式。</p>\n<h4 id=\"1-使用-CustomEvent-浏览器原生事件\"><a href=\"#1-使用-CustomEvent-浏览器原生事件\" class=\"headerlink\" title=\"1. 使用 CustomEvent (浏览器原生事件)\"></a>1. 使用 CustomEvent (浏览器原生事件)</h4><p><strong>原理：</strong> 利用浏览器原生的 <code>window.dispatchEvent</code> 和 <code>window.addEventListener</code> 进行通信。</p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主应用 - 发送事件</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;main-app-event&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">detail</span>: &#123; <span class=\"comment\">// 通过 detail 传递数据</span></span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;CHANGE_THEME&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">payload</span>: <span class=\"string\">&#x27;dark&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用 - 接收事件</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;main-app-event&#x27;</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; type, payload &#125; = event.<span class=\"property\">detail</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 处理事件...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用 - 发送事件（同理）</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;micro-app-event&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">detail</span>: &#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Hello from micro app&#x27;</span> &#125;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>优点：</strong> 原生支持，非常简单。<br><strong>缺点：</strong> 数据传递能力较弱（只能同步），缺乏状态管理能力，事件需要全局唯一命名以免冲突。</p>\n<h4 id=\"2-使用-Redux-Mobx-Vuex-等状态库\"><a href=\"#2-使用-Redux-Mobx-Vuex-等状态库\" class=\"headerlink\" title=\"2. 使用 Redux&#x2F;Mobx&#x2F;Vuex 等状态库\"></a>2. 使用 Redux&#x2F;Mobx&#x2F;Vuex 等状态库</h4><p><strong>原理：</strong> 主应用和微应用<strong>共享同一个状态库实例</strong>。</p>\n<ul>\n<li><strong>步骤：</strong><ol>\n<li>主应用创建一个 Redux Store 或其他状态库实例。</li>\n<li>将这个 Store 通过 <code>window</code> 对象或者微应用的 <code>props</code> 暴露给微应用。</li>\n<li>微应用连接到这个全局的 Store，进行状态的读取和分发 Action。</li>\n</ol>\n</li>\n</ul>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主应用 - 创建并暴露 store</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;redux&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> globalStore = <span class=\"title function_\">createStore</span>(<span class=\"comment\">/* ... */</span>);</span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">__MAIN_APP_STORE__</span> = globalStore; <span class=\"comment\">// 挂到全局</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用 - 获取并使用 store</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"variable language_\">window</span>.<span class=\"property\">__MAIN_APP_STORE__</span>;</span><br><span class=\"line\">store.<span class=\"title function_\">dispatch</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;AN_ACTION&#x27;</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> state = store.<span class=\"title function_\">getState</span>();</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>优点：</strong> 功能强大，可以处理复杂的业务逻辑和状态流。<br><strong>缺点：</strong> 紧密耦合，主应用和微应用必须使用同一种状态库，且版本需要兼容。</p>\n<h4 id=\"3-通过-URL-或-Query-Parameters-通信\"><a href=\"#3-通过-URL-或-Query-Parameters-通信\" class=\"headerlink\" title=\"3. 通过 URL 或 Query Parameters 通信\"></a>3. 通过 URL 或 Query Parameters 通信</h4><p><strong>原理：</strong> 通过改变 URL 的查询参数来传递简单信息。</p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主应用改变URL</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newUrl = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"variable language_\">window</span>.location.pathname&#125;</span>?theme=dark&amp;userId=123`</span>;</span><br><span class=\"line\">history.<span class=\"title function_\">pushState</span>(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;&#x27;</span>, newUrl);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用监听URL变化</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;popstate&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> urlParams = <span class=\"keyword\">new</span> <span class=\"title class_\">URLSearchParams</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">location</span>.<span class=\"property\">search</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> theme = urlParams.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;theme&#x27;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ...使用参数</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>优点：</strong> 非常简单，状态可被收藏和分享。<br><strong>缺点：</strong> 只适合传递少量简单数据。</p>\n<hr>\n<h3 id=\"总结与选择建议\"><a href=\"#总结与选择建议\" class=\"headerlink\" title=\"总结与选择建议\"></a>总结与选择建议</h3><table>\n<thead>\n<tr>\n<th><strong>方案</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>官方</strong>** **<code>**initGlobalState**</code></td>\n<td><strong>官方推荐</strong>，简单轻量，满足大部分通信需求</td>\n<td>功能相对简单，不适合极其复杂的场景</td>\n<td><strong>绝大多数微前端通信场景的首选</strong></td>\n</tr>\n<tr>\n<td><strong>CustomEvent</strong></td>\n<td>浏览器原生，非常简单</td>\n<td>功能弱，只能传简单数据，易产生事件名冲突</td>\n<td>简单的父子通知、触发动作</td>\n</tr>\n<tr>\n<td><strong>Redux&#x2F;Vuex 等</strong></td>\n<td>功能强大，适合复杂状态管理</td>\n<td>耦合度高，主子和微应用必须使用同一种状态库</td>\n<td>大型复杂应用，且技术栈统一</td>\n</tr>\n<tr>\n<td><strong>URL Parameters</strong></td>\n<td>实现简单，状态可分享</td>\n<td>传递数据量有限，类型受限</td>\n<td>过滤条件、简单配置等</td>\n</tr>\n</tbody></table>\n<p><strong>最佳实践建议：</strong></p>\n<ol>\n<li><strong>优先使用官方的</strong>** **<code>**initGlobalState**</code>，它能覆盖 90% 的微前端通信需求。</li>\n<li>对于简单的、一次性的动作触发（如“刷新列表”、“显示通知”），可以辅以 <strong>CustomEvent</strong>。</li>\n<li>只有在主应用和所有微应用技术栈统一且非常复杂时，才考虑使用<strong>共享状态库</strong>。</li>\n<li>通信的设计应遵循<strong>最小化原则</strong>，尽量减少主应用和微应用之间的耦合，让微应用保持最大的独立性。</li>\n</ol>\n","excerpt":"","more":"<p>参考链接：</p>\n<p><a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/78362028\" >可能是你见过最完善的微前端解决方案<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p><a class=\"link\"   href=\"https://juejin.cn/post/7244070072788287544?searchId=202508250257166071DDB47E623E0BA671\" >深入调研了微前端，还是iframe最香<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p><a class=\"link\"   href=\"https://qiankun.umijs.org/zh/guide/getting-started\" >qiankun官方文档<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<h3 id=\"什么是微前端？\"><a href=\"#什么是微前端？\" class=\"headerlink\" title=\"什么是微前端？\"></a>什么是微前端？</h3><p>微前端是一种软件架构，可以将前端应用拆解成一些更小的能够独立开发部署的微型应用，然后在将这些微型应用组合使其成为整体的架构模式。</p>\n<p>微前端类似于组件架构，但不同的是，组件不能够独立构建和发布，但是微前端中的应用是可以的。</p>\n<p>微前端架构与框架无关，每个微应用都可以使用不同的框架。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/%E5%BE%AE%E5%89%8D%E7%AB%AF.png\"\n                      alt=\"微前端\"\n                ></p>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>单体前端</strong></th>\n<th><strong>微前端</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>代码库</strong></td>\n<td>单个大型代码库</td>\n<td>多个独立代码库</td>\n</tr>\n<tr>\n<td><strong>团队结构</strong></td>\n<td>集中式团队</td>\n<td>分布式独立团队</td>\n</tr>\n<tr>\n<td><strong>技术栈</strong></td>\n<td>统一技术栈</td>\n<td>混合技术栈</td>\n</tr>\n<tr>\n<td><strong>部署</strong></td>\n<td>整体部署</td>\n<td>独立部署</td>\n</tr>\n<tr>\n<td><strong>开发速度</strong></td>\n<td>后期变慢</td>\n<td>持续快速</td>\n</tr>\n<tr>\n<td><strong>复杂度</strong></td>\n<td>高度耦合</td>\n<td>解耦独立</td>\n</tr>\n</tbody></table>\n<h3 id=\"微前端的价值\"><a href=\"#微前端的价值\" class=\"headerlink\" title=\"微前端的价值\"></a>微前端的价值</h3><p>微前端架构具备以下几个核心价值：</p>\n<ul>\n<li>技术栈无关 主框架不限制接入应用的技术栈，子应用具备完全自主权</li>\n<li>独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</li>\n<li>独立运行时 每个子应用之间状态隔离，运行时状态不共享</li>\n</ul>\n<p>微前端架构旨在解决<a class=\"link\"   href=\"https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLljZXkvZPlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.Sy3sQVozhhuQwuwmw8-zjyU0X_81Vve5linQ55OPo0k&zhida_source=entity\" >单体应用<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个<a class=\"link\"   href=\"https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%B7%A8%E7%9F%B3%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLlt6jnn7PlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.3VWm6X4yZDpq2_EqJZDuDErH1ST1iWJUa0qPK8T5Abk&zhida_source=entity\" >巨石应用<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>(<a class=\"link\"   href=\"https://link.zhihu.com/?target=https://www.youtube.com/watch?v=pU1gXA0rfwc\" >Frontend Monolith<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。</p>\n<p>应用架构如下：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/微前端架构.png\"\n                      alt=\"微前端架构\" height=\"auto\" style=\"width:50%; display:block;\"\n                >\n\n<blockquote>\n<p>Stitching layer 作为主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用。因此主框架的定位则仅仅是：<strong>导航路由 + 资源加载框架</strong></p>\n</blockquote>\n<p>single-spa是什么</p>\n<p>好的，我们来详细解释一下 <strong>single-spa</strong> 是什么。</p>\n<h3 id=\"核心定义\"><a href=\"#核心定义\" class=\"headerlink\" title=\"核心定义\"></a>核心定义</h3><p><strong>single-spa 是一个用于构建【微前端】架构的 JavaScript 框架。</strong> 你可以把它理解为一个<strong>顶层的路由器和应用程序加载器</strong>。</p>\n<p>它的核心思想是：将一个大型的单页前端应用（SPA）拆分成多个小型、独立、可以并行开发交付的“微应用”。然后，single-spa 负责在运行时根据一定的规则（通常是当前的 URL）动态地加载、展示、卸载这些微应用。</p>\n<hr>\n<h3 id=\"一个简单的比喻\"><a href=\"#一个简单的比喻\" class=\"headerlink\" title=\"一个简单的比喻\"></a>一个简单的比喻</h3><p>想象一下你的浏览器是一个舞台：</p>\n<ul>\n<li><strong>传统单体应用：</strong> 只有一个庞大的剧团表演一整部冗长的戏剧。要更换一个演员（修改一个功能），需要整个剧团停下来重新排练（整个应用重新构建部署）。</li>\n<li><strong>single-spa 微前端：</strong> 舞台（浏览器）本身是空的。有一个<strong>导演（single-spa）</strong>。导演手里有一个节目单（根配置），上面写着什么节目（微应用）在什么时刻（例如，URL 是 <code>/settings</code> 时）上台表演。<ul>\n<li>当报幕员说“下一个节目是《用户设置》”时（用户访问了 <code>/settings</code>），导演就喊：“《用户设置》剧组，上台！”（加载并挂载 React 微应用）。</li>\n<li>节目表演完了（用户离开了 <code>/settings</code>），导演就喊：“《用户设置》剧组，下台！”（卸载 React 微应用）。</li>\n<li>下一个节目是《商品列表》，另一个完全不同的剧组（Vue 微应用）就上台表演。</li>\n</ul>\n</li>\n</ul>\n<p><strong>single-spa 就是这个导演</strong>，它自己不表演具体内容，但它负责协调所有剧组（微应用）的上场和下场时机。</p>\n<hr>\n<h3 id=\"为什么需要-single-spa？（解决的问题）\"><a href=\"#为什么需要-single-spa？（解决的问题）\" class=\"headerlink\" title=\"为什么需要 single-spa？（解决的问题）\"></a>为什么需要 single-spa？（解决的问题）</h3><ol>\n<li><strong>技术栈无关：</strong> 各个微应用可以使用不同的技术栈（React, Vue, Angular, Svelte 等）。团队可以自由选择或升级其技术栈，而不会影响其他团队。</li>\n<li><strong>独立开发、独立部署：</strong> 每个微应用都由独立的团队开发、测试和部署，大大提升了团队的自治度和发布效率。</li>\n<li><strong>增量升级：</strong> 允许你逐步重写一个老旧的巨型前端应用，可以一部分一部分地用新的框架替换，而不是一次性重写全部。</li>\n<li><strong>代码隔离：</strong> 应用之间实现了良好的代码和样式隔离（虽然需要一些额外规范），避免了全局污染和冲突。</li>\n</ol>\n<hr>\n<h3 id=\"single-spa-的核心工作原理\"><a href=\"#single-spa-的核心工作原理\" class=\"headerlink\" title=\"single-spa 的核心工作原理\"></a>single-spa 的核心工作原理</h3><p>single-spa 通过定义一套<strong>生命周期协议</strong>来工作。每个微应用都必须对外暴露三个核心的函数：</p>\n<ol>\n<li><code>bootstrap</code>： 应用首次加载时执行一次，用于初始化。</li>\n<li><code>mount</code>： 当激活条件满足时（例如用户访问了该应用的路由），执行此函数。应用需要在这个函数里完成渲染，将组件挂载到 DOM 上。</li>\n<li><code>unmount</code>： 当激活条件不再满足时（例如用户离开了该路由），执行此函数。应用需要在这个函数里完成清理工作，将自己从 DOM 上卸载。</li>\n</ol>\n<p>single-spa 的“根配置”会<strong>注册</strong>所有微应用，并为每个应用定义一个 <code>activity function</code>（激活函数）。这个函数通常根据 <code>window.location</code> 进行判断。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// single-spa 根配置示例 (root-config.js)</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; registerApplication, start &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;single-spa&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册一个应用</span></span><br><span class=\"line\"><span class=\"title function_\">registerApplication</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;my-react-app&#x27;</span>, <span class=\"comment\">// 应用唯一名</span></span><br><span class=\"line\">  <span class=\"attr\">app</span>: <span class=\"function\">() =&gt;</span> <span class=\"title class_\">System</span>.<span class=\"keyword\">import</span>(<span class=\"string\">&#x27;my-react-app&#x27;</span>), <span class=\"comment\">// 如何加载该应用的代码</span></span><br><span class=\"line\">  <span class=\"attr\">activeWhen</span>: <span class=\"function\">(<span class=\"params\">location</span>) =&gt;</span> location.<span class=\"property\">pathname</span>.<span class=\"title function_\">startsWith</span>(<span class=\"string\">&#x27;/react&#x27;</span>), <span class=\"comment\">// 激活函数：当路径以 /react 开头时，加载这个应用</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动 single-spa</span></span><br><span class=\"line\"><span class=\"title function_\">start</span>();</span><br></pre></td></tr></table></figure>\n\n<p><strong>流程如下：</strong></p>\n<ol>\n<li>用户访问 <code>https://example.com/react</code>。</li>\n<li>single-spa 检查所有注册的应用，发现 <code>my-react-app</code> 的 <code>activeWhen</code> 函数返回 <code>true</code>。</li>\n<li>single-spa 动态加载 <code>my-react-app</code> 的代码包。</li>\n<li>依次执行该应用的 <code>bootstrap</code> 和 <code>mount</code> 生命周期函数，应用被渲染到页面上。</li>\n<li>用户导航到 <code>/vue</code>，<code>my-react-app</code> 的 <code>activeWhen</code> 返回 <code>false</code>。</li>\n<li>single-spa 执行它的 <code>unmount</code> 函数，将其卸载。</li>\n</ol>\n<hr>\n<h3 id=\"主要优缺点\"><a href=\"#主要优缺点\" class=\"headerlink\" title=\"主要优缺点\"></a>主要优缺点</h3><p><strong>优点：</strong></p>\n<ul>\n<li><strong>强大的解耦和能力：</strong> 真正实现了前端应用的拆分和团队自治。</li>\n<li><strong>框架无关：</strong> 是整合不同技术栈应用的理想选择。</li>\n<li><strong>懒加载：</strong> 提升首次加载速度，按需加载应用。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>复杂度高：</strong> 引入了分布式系统的复杂性，需要解决依赖共享、样式隔离、通信机制等问题。</li>\n<li><strong>开发体验：</strong> 调试和配置比单体应用更复杂。通常需要类似 <code>single-spa</code> 官方的 <code>create-single-spa</code> 工具链来简化流程。</li>\n<li><strong>依赖管理：</strong> 需要谨慎处理共享库（如 <code>react</code>, <code>vue</code>）以避免重复打包。</li>\n</ul>\n<hr>\n<h3 id=\"与-Module-Federation-的区别\"><a href=\"#与-Module-Federation-的区别\" class=\"headerlink\" title=\"与 Module Federation 的区别\"></a>与 Module Federation 的区别</h3><p>Webpack 5 的 <strong>Module Federation（模块联邦）</strong> 是另一种实现微前端的热门技术。它们不是互斥的，甚至可以结合使用：</p>\n<ul>\n<li><strong>single-spa</strong> 主要解决的是<strong>路由和应用生命周期管理</strong>的问题（“什么时候加载哪个应用”）。</li>\n<li><strong>Module Federation</strong> 主要解决的是<strong>应用之间代码共享和依赖处理</strong>的问题（“如何共享一个 React 实例，避免重复加载”）。</li>\n</ul>\n<p>一个常见的模式是：使用 <strong>single-spa 作为路由器</strong>，使用 <strong>Module Federation 来加载微应用和共享依赖</strong>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>**single-spa 是一个成熟、强大的微前端解决方案，它通过一套生命周期协议，将多个独立开发、独立部署的微应用组合成一个完整的单体体验。它非常适合大型企业级应用、需要整合不同技术栈或进行增量迁移的项目。**虽然它引入了一定的复杂性，但它为解决前端单体膨胀问题提供了非常系统化的思路和工具。</p>\n<p>html entry和js entry的概念是什么</p>\n<p>好的，这是一个非常核心的微前端概念。<code>**js-entry**</code> 和 <code>**html-entry**</code> 是微前端中两种不同的应用打包和加载方式，它们代表了两种不同的设计哲学和实现技术。</p>\n<hr>\n<h3 id=\"核心概念对比\"><a href=\"#核心概念对比\" class=\"headerlink\" title=\"核心概念对比\"></a>核心概念对比</h3><table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>js-entry (JavaScript 入口)</strong></th>\n<th><strong>html-entry (HTML 入口)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>入口文件</strong></td>\n<td>一个 JavaScript 文件 (e.g., <code>app.js</code><br/>)</td>\n<td>一个 HTML 文件 (e.g., <code>index.html</code><br/>)</td>\n</tr>\n<tr>\n<td><strong>内容</strong></td>\n<td>主要包含 <strong>JavaScript 逻辑和组件</strong></td>\n<td>包含 <strong>HTML、</strong><code>**&lt;script&gt;**</code><br/><strong>、</strong><code>**&lt;link&gt;**</code><br/><strong>、</strong><code>**&lt;style&gt;**</code></td>\n</tr>\n<tr>\n<td><strong>加载方式</strong></td>\n<td>框架（如 single-spa）加载并执行 JS 文件</td>\n<td>框架通过 <strong>fetch</strong> 获取 HTML，解析出其中的 JS&#x2F;CSS 并执行</td>\n</tr>\n<tr>\n<td><strong>样式处理</strong></td>\n<td><strong>需要手动管理</strong>。通常需要约定（如 CSS Modules, CSS-in-JS）或工具来避免冲突。</td>\n<td><strong>自动处理</strong>。HTML 中的 <code>&lt;link&gt;</code><br/> 和 <code>&lt;style&gt;</code><br/> 标签会被自动插入到 <code>&lt;head&gt;</code><br/> 中。</td>\n</tr>\n<tr>\n<td><strong>沙箱隔离</strong></td>\n<td>通常需要额外的库（如 <code>qiankun</code><br/> 的沙箱）来实现 JS 和 CSS 的运行时隔离。</td>\n<td>天然更易于实现<strong>HTML级别的沙箱</strong>（例如，创建一个 Shadow DOM 来包裹整个微应用的内容）。</td>\n</tr>\n<tr>\n<td><strong>代表性方案</strong></td>\n<td>原始的 <strong>single-spa</strong> 方案</td>\n<td><strong>qiankun</strong>（基于 single-spa）、<strong>Module Federation</strong>（某种程度上）</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"深入理解\"><a href=\"#深入理解\" class=\"headerlink\" title=\"深入理解\"></a>深入理解</h3><h4 id=\"1-js-entry-JavaScript-入口\"><a href=\"#1-js-entry-JavaScript-入口\" class=\"headerlink\" title=\"1. js-entry (JavaScript 入口)\"></a>1. js-entry (JavaScript 入口)</h4><p>这是 <strong>single-spa 早期和官方推荐</strong>的方式。它的理念是：一个微应用<strong>本质上是一个 JavaScript 模块</strong>，这个模块导出了 <code>bootstrap</code>, <code>mount</code>, <code>unmount</code> 等生命周期函数。</p>\n<p><strong>如何工作？</strong></p>\n<ol>\n<li>主应用（容器）根据路由规则，判断需要加载微应用 A。</li>\n<li>主应用通过 <code>System.import()</code> 或 <code>import()</code> 动态加载微应用 A 的 <strong>入口 JS 文件</strong>（例如 <code>https://a.com/app.js</code>）。</li>\n<li>这个 JS 文件被执行，并返回一个包含生命周期函数的对象。</li>\n<li>主应用依次调用微应用的 <code>bootstrap</code> 和 <code>mount</code> 函数。</li>\n<li>在 <code>mount</code> 函数中，微应用<strong>用自己的逻辑</strong>将组件渲染到主应用提供的 DOM 容器中。</li>\n</ol>\n<p><strong>示例代码 (single-spa 配置)：</strong></p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">registerApplication</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;my-app&#x27;</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 这里是一个 js-entry，指向一个 JS 文件</span></span><br><span class=\"line\">  <span class=\"attr\">app</span>: <span class=\"function\">() =&gt;</span> <span class=\"title class_\">System</span>.<span class=\"keyword\">import</span>(<span class=\"string\">&#x27;https://a.com/js/app.js&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">activeWhen</span>: <span class=\"string\">&#x27;/app&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>概念清晰，符合“应用即模块”的理念。</li>\n<li>打包输出干净，通常是一个或多个 JS 包。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>样式处理麻烦</strong>：你需要自己在微应用的 JS 代码里引入 CSS（如 <code>import &#39;./app.css&#39;</code>），并小心全局样式冲突。</li>\n<li><strong>需要额外配置</strong>：为了实现资源加载和隔离，需要复杂的 Webpack 配置和额外的库。</li>\n</ul>\n<h4 id=\"2-html-entry-HTML-入口\"><a href=\"#2-html-entry-HTML-入口\" class=\"headerlink\" title=\"2. html-entry (HTML 入口)\"></a>2. html-entry (HTML 入口)</h4><p>这种方式的理念是：一个微应用是<strong>一个完整的、可以独立运行的“页面”</strong>。主应用只需要加载这个页面的 HTML 文件，剩下的资源（JS, CSS）都由这个 HTML 文件自己声明。</p>\n<p><strong>如何工作？</strong></p>\n<ol>\n<li>主应用根据路由规则，判断需要加载微应用 B。</li>\n<li>主应用通过 <strong>fetch</strong> 请求微应用 B 的<strong>入口 HTML 文件</strong>（例如 <code>https://b.com/index.html</code>）。</li>\n<li>主应用<strong>解析</strong>这个 HTML 文件，提取出其中的 <code>**&lt;script&gt;**</code>** <strong><strong>和</strong></strong> <strong><code>**&lt;link&gt;**</code></strong> **<strong>标签</strong>。</li>\n<li>主应用手动创建这些 <code>&lt;script&gt;</code> 和 <code>&lt;link&gt;</code> 元素，并将它们插入到主文档的 <code>&lt;head&gt;</code> 中，从而加载并执行微应用的 JS 和 CSS。</li>\n<li>同时，主应用通常会提供一个<strong>隔离的沙箱环境</strong>（如 Shadow DOM），将微应用的整个 DOM 结构渲染在其中。</li>\n</ol>\n<p><strong>示例概念（qiankun 的做法）：</strong></p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; registerMicroApps, start &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;qiankun&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">registerMicroApps</span>([</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;vue-app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 这里是一个 html-entry，指向一个 HTML 文件</span></span><br><span class=\"line\">    <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;//localhost:7101&#x27;</span>, <span class=\"comment\">// 会默认加载这个地址下的 index.html</span></span><br><span class=\"line\">    <span class=\"attr\">container</span>: <span class=\"string\">&#x27;#container&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">activeRule</span>: <span class=\"string\">&#x27;/vue&#x27;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]);</span><br><span class=\"line\"><span class=\"title function_\">start</span>();</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li><strong>对旧项目更友好</strong>：很多老项目（如 jQuery、Backbone 项目）本身就是以 HTML 为中心开发的，改造为 html-entry 更容易。</li>\n<li><strong>资源加载自动化</strong>：无需在 JS 中手动引入资源，HTML 中声明的所有资源都会被自动加载。</li>\n<li><strong>更强大的隔离能力</strong>：更容易与 Shadow DOM 结合，实现真正的样式和作用域隔离。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>需要解析 HTML</strong>：主应用需要具备解析 HTML 并提取资源的能力，实现起来比直接 <code>import</code> 一个 JS 文件更复杂。</li>\n<li><strong>可能加载多余资源</strong>：如果 HTML 中声明了多个入口，需要更精细的解析策略来避免加载未使用的资源。</li>\n</ul>\n<hr>\n<h3 id=\"总结与类比\"><a href=\"#总结与类比\" class=\"headerlink\" title=\"总结与类比\"></a>总结与类比</h3><table>\n<thead>\n<tr>\n<th><strong>概念</strong></th>\n<th><strong>类比</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>**js-entry**</code></td>\n<td>就像 <strong>“组装电脑”</strong>。主应用（你）买来各个零件（JS 逻辑、手动引入的 CSS），自己动手组装成一台完整的电脑（微应用）。控制力强，但过程繁琐。</td>\n</tr>\n<tr>\n<td><code>**html-entry**</code></td>\n<td>就像 <strong>“购买品牌整机”</strong>。主应用（你）直接买来一台戴尔电脑（HTML 文件），插上电（插入 DOM）就能用。开箱即用，非常方便，但内部细节被封装了。</td>\n</tr>\n</tbody></table>\n<p><strong>现代趋势：</strong></p>\n<ul>\n<li>纯粹的 <code>js-entry</code> 由于其配置的复杂性，在直接使用时体验并不友好。</li>\n<li><strong>qiankun</strong> 这类框架通过实现 <code>html-entry</code> 模式，极大地改善了开发者体验，降低了微前端的上手门槛。</li>\n<li><strong>Webpack Module Federation</strong> 提供了另一种更现代化的 <code>js-entry</code>，它通过复杂的依赖共享机制，解决了 <code>js-entry</code> 的许多痛点（如共享库重复加载），可以看作是 <code>js-entry</code> 的终极进化形态。</li>\n</ul>\n<p>因此，选择哪种方式取决于你的技术栈和框架：</p>\n<ul>\n<li>使用 <strong>原始的 single-spa</strong>，你通常需要处理 <code>js-entry</code>。</li>\n<li>使用 <strong>qiankun</strong>，你享受的是 <code>html-entry</code> 带来的便利。</li>\n<li>使用 <strong>Module Federation</strong>，你体验的是高级的、基于依赖共享的 <code>js-entry</code>。</li>\n</ul>\n<h2 id=\"路由分发可以实现微前端架构吗\"><a href=\"#路由分发可以实现微前端架构吗\" class=\"headerlink\" title=\"路由分发可以实现微前端架构吗\"></a>路由分发可以实现微前端架构吗</h2><p>当然可以。<strong>路由分发是实现微前端架构最主要、最常用也是最经典的方式</strong>。它被认为是微前端架构的“第一种模式”，并且非常有效。</p>\n<h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p><strong>通过路由（URL）的变化，来决定在页面容器中加载、展示和卸载哪个微前端应用。</strong> 主应用（通常称为“容器应用”或“根应用”）充当一个<strong>路由器</strong>和<strong>编排者</strong>的角色，而各个微应用则是独立开发、部署的功能模块。</p>\n<hr>\n<h3 id=\"它是如何工作的？\"><a href=\"#它是如何工作的？\" class=\"headerlink\" title=\"它是如何工作的？\"></a>它是如何工作的？</h3><ol>\n<li><strong>一个路由规则集</strong>：主应用中维护一个配置表，将特定的 URL 路径模式（如 <code>/app1/*</code>, <code>/settings</code>, <code>/dashboard</code>）映射到对应的微应用。</li>\n<li><strong>监听路由变化</strong>：主应用监听 <code>popstate</code>、<code>hashchange</code> 等浏览器路由事件。</li>\n<li><strong>匹配与决策</strong>：当路由发生变化时（用户点击链接或手动输入 URL），主应用根据配置表判断当前应该激活哪个微应用。</li>\n<li><strong>加载与挂载</strong>：主应用动态获取该微应用的资源（JS, CSS），并将其挂载到页面中指定的 DOM 容器（如 <code>&lt;div id=&quot;micro-app-container&quot;&gt;</code>）中。</li>\n<li><strong>卸载与清理</strong>：当用户离开当前路由时，主应用会卸载之前的微应用，并进行必要的清理工作（如清除事件监听器、内存释放等），然后加载新的微应用。</li>\n</ol>\n<h2 id=\"webpack5的Module-Federation可以详细说说嘛\"><a href=\"#webpack5的Module-Federation可以详细说说嘛\" class=\"headerlink\" title=\"webpack5的Module Federation可以详细说说嘛\"></a>webpack5的Module Federation可以详细说说嘛</h2><p>好的，我们来深入、详细地探讨 Webpack 5 的 <strong>Module Federation（模块联邦）</strong>。它不仅仅是微前端的一种实现方式，更是一种革命性的架构思想。</p>\n<h3 id=\"一、核心概念：它是什么？\"><a href=\"#一、核心概念：它是什么？\" class=\"headerlink\" title=\"一、核心概念：它是什么？\"></a>一、核心概念：它是什么？</h3><p><strong>Module Federation (MF)</strong> 的核心目标是：<strong>允许一个 JavaScript 应用在运行时动态地从另一个应用加载代码并共享依赖</strong>。</p>\n<p>你可以把它想象成在浏览器端实现了类似 Node.js 的 <code>require</code> 或 <code>import</code> 机制，但不是在本地文件系统，而是在<strong>网络上的不同独立应用之间</strong>。</p>\n<p>它打破了传统的应用隔离边界，允许应用彼此成为“模块提供者”和“模块消费者”。</p>\n<hr>\n<h3 id=\"二、为什么要用-Module-Federation？-解决的核心痛点\"><a href=\"#二、为什么要用-Module-Federation？-解决的核心痛点\" class=\"headerlink\" title=\"二、为什么要用 Module Federation？(解决的核心痛点)\"></a>二、为什么要用 Module Federation？(解决的核心痛点)</h3><ol>\n<li><strong>彻底解决依赖重复打包</strong><ul>\n<li><strong>传统微前端</strong>：如果主应用和微应用都使用了 React、Vue 等相同的库，这些库的代码会被分别打包到各自的 bundle 中。用户浏览器会多次下载和执行相同的库代码，导致体积膨胀和性能下降。</li>\n<li><strong>MF</strong>：可以<strong>指定共享依赖</strong>。React 等库只加载一次，所有应用都使用同一份实例。这解决了最重要的“依赖地狱”问题。</li>\n</ul>\n</li>\n<li><strong>更彻底的应用拆分与团队自治</strong><ul>\n<li>它允许将应用拆分成更细粒度的“模块”或“组件”，而不仅仅是“页面”或“应用”。</li>\n<li>团队可以独立开发、部署<strong>一个按钮、一个表单、一个页面</strong>，并让其他团队直接消费。</li>\n</ul>\n</li>\n<li><strong>运行时动态集成</strong><ul>\n<li>代码集成发生在运行时（Runtime），而非构建时（Build-time）。这意味着：<ul>\n<li>你可以进行 <strong>A&#x2F;B 测试</strong>，动态切换不同版本的组件。</li>\n<li>可以<strong>独立部署</strong>某个模块，而无需重新部署整个应用。</li>\n<li>主应用甚至不需要提前知道所有可能被加载的微应用。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"三、核心角色与配置\"><a href=\"#三、核心角色与配置\" class=\"headerlink\" title=\"三、核心角色与配置\"></a>三、核心角色与配置</h3><p>MF 中有两个关键角色：</p>\n<ol>\n<li><strong>Remote (远程模块&#x2F;消费者)</strong><ul>\n<li>它是一个<strong>使用方</strong>应用，在运行时从其他地方（<code>Host</code>）导入并执行代码。</li>\n<li>它的配置使用 <code>remotes</code> 属性。</li>\n</ul>\n</li>\n<li><strong>Host (宿主模块&#x2F;提供者)</strong><ul>\n<li>它是一个<strong>提供方</strong>应用，将其内部的某些模块暴露给外部使用。</li>\n<li>它的配置使用 <code>exposes</code> 属性。</li>\n</ul>\n</li>\n</ol>\n<p><strong>一个应用可以同时是</strong>** <strong><code>**Host**</code></strong> <strong><strong>和</strong></strong> **<code>**Remote**</code>。</p>\n<h4 id=\"配置详解-webpack-config-js\"><a href=\"#配置详解-webpack-config-js\" class=\"headerlink\" title=\"配置详解 (webpack.config.js)\"></a>配置详解 (<code>webpack.config.js</code>)</h4><p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Host 应用的配置 (提供模块的应用，端口3001)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ModuleFederationPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack/lib/container/ModuleFederationPlugin&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...其他配置</span></span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">ModuleFederationPlugin</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;app1&#x27;</span>, <span class=\"comment\">// 必填，这个应用的唯一名称，是消费者调用时的标识</span></span><br><span class=\"line\">      <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;remoteEntry.js&#x27;</span>, <span class=\"comment\">// 必填，对外暴露的入口文件清单名</span></span><br><span class=\"line\">      <span class=\"attr\">exposes</span>: &#123; <span class=\"comment\">// 暴露哪些模块给外部使用</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;./Button&#x27;</span>: <span class=\"string\">&#x27;./src/components/Button&#x27;</span>, <span class=\"comment\">// 键：供外部使用的别名；值：本地模块路径</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;./App&#x27;</span>: <span class=\"string\">&#x27;./src/App&#x27;</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">shared</span>: &#123; <span class=\"comment\">// 共享的依赖库</span></span><br><span class=\"line\">        <span class=\"attr\">react</span>: &#123; </span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 确保只使用一个单例版本</span></span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span> <span class=\"comment\">// 需要的版本</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&#x27;react-dom&#x27;</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Remote 应用的配置 (消费模块的应用，端口3002)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ModuleFederationPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack/lib/container/ModuleFederationPlugin&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...其他配置</span></span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">ModuleFederationPlugin</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;app2&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">remotes</span>: &#123; <span class=\"comment\">// 声明要消费哪些远程应用</span></span><br><span class=\"line\">        <span class=\"comment\">// 格式: &quot;name@url/remoteEntry.js&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">app1</span>: <span class=\"string\">&#x27;app1@http://localhost:3001/remoteEntry.js&#x27;</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">shared</span>: &#123; <span class=\"comment\">// 共享依赖的配置必须与Host一致，才能成功共享</span></span><br><span class=\"line\">        <span class=\"attr\">react</span>: &#123; </span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&#x27;react-dom&#x27;</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"四、如何使用？\"><a href=\"#四、如何使用？\" class=\"headerlink\" title=\"四、如何使用？\"></a>四、如何使用？</h3><p>在 <code>app2</code> (Remote) 的代码中，你可以像导入本地模块一样<strong>动态导入</strong> <code>app1</code> (Host) 暴露的模块：</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 app2 的 React 组件中</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; <span class=\"title class_\">Suspense</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用动态导入语法。`app1` 是配置中remotes的key，`./Button` 是app1暴露的模块名</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">RemoteButton</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">lazy</span>(<span class=\"function\">() =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;app1/Button&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>我是 App2<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">Suspense</span> <span class=\"attr\">fallback</span>=<span class=\"string\">&#123;</span>&lt;<span class=\"attr\">div</span>&gt;</span>Loading Button...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">  &#123;/* 这个Button组件来自另一个独立应用 app1！ */&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">RemoteButton</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Suspense</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"五、工作流程（魔法是如何发生的？）\"><a href=\"#五、工作流程（魔法是如何发生的？）\" class=\"headerlink\" title=\"五、工作流程（魔法是如何发生的？）\"></a>五、工作流程（魔法是如何发生的？）</h3><ol>\n<li><strong>构建阶段</strong>：<ul>\n<li><code>Host</code> (<code>app1</code>) 构建时，会生成一个 <code>remoteEntry.js</code> 文件。这个文件是一个<strong>清单(Manifest)</strong>，记录了 <code>exposes</code> 了哪些模块以及如何获取它们。</li>\n<li><code>Remote</code> (<code>app2</code>) 构建时，会意识到 <code>import(&#39;app1/Button&#39;)</code> 是一个远程模块，不会将其打包到自己的 bundle 中。</li>\n</ul>\n</li>\n<li><strong>运行时阶段</strong>：<ul>\n<li>浏览器加载 <code>app2</code>。</li>\n<li>当执行到 <code>import(&#39;app1/Button&#39;)</code> 时，Webpack 运行时就会去检查配置。</li>\n<li>它发现 <code>app1</code> 对应 <code>http://localhost:3001/remoteEntry.js</code>，于是<strong>动态加载</strong>这个 <code>remoteEntry.js</code> 文件。</li>\n<li><code>remoteEntry.js</code> 告诉 <code>app2</code> 如何从 <code>app1</code> 的服务器上获取 <code>Button</code> 组件的代码块。</li>\n<li>Webpack 加载这个代码块，并<strong>与</strong>** <strong><code>**app2**</code></strong> <strong><strong>共享的</strong></strong> <strong><code>**react**</code></strong> <strong><strong>和</strong></strong> <strong><code>**react-dom**</code></strong> **<strong>实例一起执行它</strong>。</li>\n<li>组件渲染成功。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"六、与-single-spa-等方案的对比\"><a href=\"#六、与-single-spa-等方案的对比\" class=\"headerlink\" title=\"六、与 single-spa 等方案的对比\"></a>六、与 single-spa 等方案的对比</h3><table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>Module Federation</strong></th>\n<th><strong>single-spa (传统方式)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>核心能力</strong></td>\n<td><strong>模块共享与依赖管理</strong></td>\n<td><strong>应用生命周期管理与路由</strong></td>\n</tr>\n<tr>\n<td><strong>集成方式</strong></td>\n<td><strong>运行时动态导入</strong></td>\n<td>运行时加载（但依赖需各自处理）</td>\n</tr>\n<tr>\n<td><strong>依赖处理</strong></td>\n<td><strong>卓越</strong>。自动共享库，避免重复。</td>\n<td><strong>困难</strong>。需要额外手动配置或工具解决。</td>\n</tr>\n<tr>\n<td><strong>打包输出</strong></td>\n<td>生成 <code>remoteEntry.js</code><br/> 清单文件</td>\n<td>生成应用的入口 JS 文件</td>\n</tr>\n<tr>\n<td><strong>粒度</strong></td>\n<td><strong>非常细</strong>。可以共享单个组件、函数、工具库。</td>\n<td><strong>较粗</strong>。通常以整个“应用”或“页面”为单元。</td>\n</tr>\n<tr>\n<td><strong>关系</strong></td>\n<td><strong>互补</strong>。可以<strong>结合使用</strong>：用 single-spa 做路由和生命周期管理，用 MF 来加载组件和共享依赖。</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>Webpack 5 的 Module Federation 是一项颠覆性的技术</strong>。它不再是简单地将应用机械地拼凑在一起，而是真正实现了应用间代码的“无缝融合”与“依赖共享”。</p>\n<p>它最适合的场景包括：</p>\n<ul>\n<li><strong>大型平台型产品</strong>：需要多个团队独立开发不同功能模块。</li>\n<li><strong>微前端架构</strong>：是目前实现微前端最先进、最优雅的方案之一。</li>\n<li><strong>跨应用组件&#x2F;工具库共享</strong>：避免维护多个版本的通用组件。</li>\n</ul>\n<p>它代表了前端架构从“单体”到“分布式”演进的重要方向，是每一位前端架构师都应该深入理解的技术。</p>\n<p>web component</p>\n<h2 id=\"好的，我们来全面、深入地探讨-Web-Components。\"><a href=\"#好的，我们来全面、深入地探讨-Web-Components。\" class=\"headerlink\" title=\"好的，我们来全面、深入地探讨 Web Components。\"></a>好的，我们来全面、深入地探讨 Web Components。</h2><h3 id=\"一、核心概念：它是什么？-1\"><a href=\"#一、核心概念：它是什么？-1\" class=\"headerlink\" title=\"一、核心概念：它是什么？\"></a>一、核心概念：它是什么？</h3><p><strong>Web Components</strong> 是一套<strong>浏览器原生支持</strong>的技术集合，允许你创建可重用的、封装的自定义 HTML 元素（类似于 <code>&lt;div&gt;</code>、<code>&lt;button&gt;</code>，但是是你自己定义的），并在任何现代浏览器中使用它们，无需任何外部框架（如 React、Vue、Angular）。</p>\n<p>它的核心目标是为 Web 开发提供<strong>真正的组件化模型</strong>，并解决代码重用和封装的问题。</p>\n<hr>\n<h3 id=\"二、为什么需要-Web-Components？（解决的问题）\"><a href=\"#二、为什么需要-Web-Components？（解决的问题）\" class=\"headerlink\" title=\"二、为什么需要 Web Components？（解决的问题）\"></a>二、为什么需要 Web Components？（解决的问题）</h3><ol>\n<li><strong>框架无关性 (Framework-Agnostic)</strong><ul>\n<li>你用 Web Components 编写的组件可以在任何 HTML 页面中使用，无论这个页面用的是 React、Vue、Angular、jQuery 还是纯 JavaScript。它提供了<strong>最大程度的可移植性</strong>。</li>\n</ul>\n</li>\n<li><strong>原生封装 (Native Encapsulation)</strong><ul>\n<li><strong>Shadow DOM</strong> 提供了强大的样式和行为封装。组件内部的样式不会泄漏到外部，外部的样式也不会渗透到组件内部（除非特意允许）。这彻底解决了 CSS 全局污染的问题。</li>\n</ul>\n</li>\n<li><strong>长期稳定性 (Longevity)</strong><ul>\n<li>作为<strong>Web 平台标准</strong>，它由浏览器厂商直接实现和维护，不像前端框架那样有生命周期（例如，AngularJS 到 Angular 的断代升级）。你写的组件在未来很多年内都能继续工作。</li>\n</ul>\n</li>\n<li><strong>生态系统互操作性 (Interoperability)</strong><ul>\n<li>它可以在任何框架中被当作普通的 HTML 元素使用，成为了连接不同技术栈应用的“桥梁”。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"三、技术构成（四大核心技术）\"><a href=\"#三、技术构成（四大核心技术）\" class=\"headerlink\" title=\"三、技术构成（四大核心技术）\"></a>三、技术构成（四大核心技术）</h3><p>Web Components 主要由四项技术标准组成，它们可以单独使用，但组合在一起威力最大。</p>\n<h4 id=\"1-Custom-Elements（自定义元素）\"><a href=\"#1-Custom-Elements（自定义元素）\" class=\"headerlink\" title=\"1. Custom Elements（自定义元素）\"></a>1. Custom Elements（自定义元素）</h4><p>一套 JavaScript API，允许你<strong>定义自定义元素及其行为</strong>。</p>\n<ul>\n<li><strong>如何定义</strong>：通过继承 <code>HTMLElement</code> 类来创建一个新的元素类。</li>\n<li><strong>生命周期回调</strong>：<ul>\n<li><code>connectedCallback</code>: 当元素首次被插入到 DOM 时调用。</li>\n<li><code>disconnectedCallback</code>: 当元素从 DOM 中移除时调用。</li>\n<li><code>adoptedCallback</code>: 当元素被移动到新的文档时调用。</li>\n<li><code>attributeChangedCallback</code>: 当元素的被观察属性（在 <code>observedAttributes</code> 中定义）发生变化时调用。</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例：定义一个简单的自定义元素</strong></p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyButton</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">HTMLElement</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 初始化逻辑</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">connectedCallback</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">innerHTML</span> = <span class=\"string\">`&lt;button&gt;Click Me!&lt;/button&gt;`</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;Button clicked!&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义需要监听的属性</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> <span class=\"title function_\">observedAttributes</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">&#x27;disabled&#x27;</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 当disabled属性变化时触发</span></span><br><span class=\"line\">  <span class=\"title function_\">attributeChangedCallback</span>(<span class=\"params\">name, oldValue, newValue</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"string\">&#x27;disabled&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`disabled changed from <span class=\"subst\">$&#123;oldValue&#125;</span> to <span class=\"subst\">$&#123;newValue&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向浏览器注册这个新元素，标签名必须包含连字符 `-`</span></span><br><span class=\"line\">customElements.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;my-button&#x27;</span>, <span class=\"title class_\">MyButton</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>在 HTML 中使用</strong>：</p>\n<p>html</p>\n<p><my-button disabled></my-button></p>\n<h4 id=\"2-Shadow-DOM（影子-DOM）\"><a href=\"#2-Shadow-DOM（影子-DOM）\" class=\"headerlink\" title=\"2. Shadow DOM（影子 DOM）\"></a>2. Shadow DOM（影子 DOM）</h4><p>一套用于将<strong>封装的、“影子”的 DOM 树附加到元素</strong>的 API。这是实现样式和行为封装的关键。</p>\n<ul>\n<li><strong>Shadow Root</strong>：Shadow DOM 的根节点。</li>\n<li><strong>模式</strong>：<ul>\n<li><code>open</code>: 可以通过 JavaScript 从外部访问（例如 <code>element.shadowRoot</code>）。</li>\n<li><code>closed</code>: 外部无法访问，封装性更强。</li>\n</ul>\n</li>\n<li><strong>作用域</strong>：在 Shadow DOM 内部定义的样式和脚本只在这个范围内有效，与外部隔离。</li>\n</ul>\n<p><strong>示例：为自定义元素添加 Shadow DOM</strong></p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyCard</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">HTMLElement</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 附加一个打开的 Shadow Root</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> shadow = <span class=\"variable language_\">this</span>.<span class=\"title function_\">attachShadow</span>(&#123; <span class=\"attr\">mode</span>: <span class=\"string\">&#x27;open&#x27;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建模板</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> template = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;template&#x27;</span>);</span><br><span class=\"line\">    template.<span class=\"property\">innerHTML</span> = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      &lt;style&gt;</span></span><br><span class=\"line\"><span class=\"string\">        /* 这些样式只在这个卡片内有效，不会影响外部 */</span></span><br><span class=\"line\"><span class=\"string\">        .card &#123;</span></span><br><span class=\"line\"><span class=\"string\">          border: 1px solid #ccc;</span></span><br><span class=\"line\"><span class=\"string\">          padding: 16px;</span></span><br><span class=\"line\"><span class=\"string\">          border-radius: 8px;</span></span><br><span class=\"line\"><span class=\"string\">          font-family: sans-serif;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        h2 &#123; color: blue; margin-top: 0; &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/style&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;div class=&quot;card&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;h2&gt;&lt;slot name=&quot;title&quot;&gt;Default Title&lt;/slot&gt;&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;&lt;slot name=&quot;content&quot;&gt;Default content...&lt;/slot&gt;&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 克隆模板内容并添加到 Shadow Root</span></span><br><span class=\"line\">    shadow.<span class=\"title function_\">appendChild</span>(template.<span class=\"property\">content</span>.<span class=\"title function_\">cloneNode</span>(<span class=\"literal\">true</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">customElements.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;my-card&#x27;</span>, <span class=\"title class_\">MyCard</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>在 HTML 中使用</strong>：</p>\n<p>html</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-card&gt;</span><br><span class=\"line\">  &lt;!-- 使用 slot 将外部内容投影到 Shadow DOM 中的指定位置 --&gt;</span><br><span class=\"line\">  &lt;span slot=&quot;title&quot;&gt;My Awesome Title&lt;/span&gt;</span><br><span class=\"line\">  &lt;span slot=&quot;content&quot;&gt;This is some fantastic content.&lt;/span&gt;</span><br><span class=\"line\">&lt;/my-card&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-HTML-Templates（HTML-模板）\"><a href=\"#3-HTML-Templates（HTML-模板）\" class=\"headerlink\" title=\"3. HTML Templates（HTML 模板）\"></a>3. HTML Templates（HTML 模板）</h4><p><code>&lt;template&gt;</code> 和 <code>&lt;slot&gt;</code> 元素允许你编写<strong>在页面加载时不会立即渲染的标记模板</strong>。这些模板可以被后续的 JavaScript 激活和使用。</p>\n<ul>\n<li><code>&lt;template&gt;</code>：内容不会被浏览器解析、渲染或执行，直到被 JavaScript 提取并使用。</li>\n<li><code>&lt;slot&gt;</code>：在 Web Component 内部充当占位符，允许用户在使用组件时传入自己的自定义内容（如上例所示）。</li>\n</ul>\n<h4 id=\"4-ES-Modules（ES-模块）\"><a href=\"#4-ES-Modules（ES-模块）\" class=\"headerlink\" title=\"4. ES Modules（ES 模块）\"></a>4. ES Modules（ES 模块）</h4><p>现代 JavaScript 的模块标准，为在 Web 上包含和重用 JS 代码提供了官方机制。它使得导入和导出 Web Components 变得简单。</p>\n<p>html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 在 HTML 中导入并使用一个定义好的 Web Component --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;module&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./my-component.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"四、Web-Components-的优点与缺点\"><a href=\"#四、Web-Components-的优点与缺点\" class=\"headerlink\" title=\"四、Web Components 的优点与缺点\"></a>四、Web Components 的优点与缺点</h3><h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ol>\n<li><strong>浏览器原生</strong>：无需编译，无需复杂的构建工具。</li>\n<li><strong>高度封装</strong>：Shadow DOM 解决了 CSS 和 DOM 的隔离问题。</li>\n<li><strong>框架无关</strong>：极高的互操作性和可移植性。</li>\n<li><strong>永久可用</strong>：作为 Web 标准，具有极长的生命周期和向后兼容性。</li>\n</ol>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ol>\n<li><strong>生态相对年轻</strong>：虽然基础功能强大，但缺少像 React&#x2F;Vue 那样庞大的生态系统（状态管理、路由、测试工具等）。</li>\n<li><strong>数据流管理较弱</strong>：原生不支持类似 React 的 Props 向下传递、事件向上冒泡的父子组件通信范式，需要自己实现（通常用 Custom Events）。</li>\n<li><strong>SSR (服务器端渲染) 支持差</strong>：自定义元素可以在服务器上渲染，但其动态行为和客户端激活（Hydration）非常复杂，远不如 Next.js&#x2F;Nuxt.js 成熟。</li>\n<li><strong>开发体验 (DX)</strong>：原始的开发方式比较繁琐，需要写很多样板代码。但社区有诸如 <strong>Lit</strong>、<strong>Stencil</strong> 等库来极大地改善体验。</li>\n</ol>\n<hr>\n<h3 id=\"五、Web-Components-与微前端和框架\"><a href=\"#五、Web-Components-与微前端和框架\" class=\"headerlink\" title=\"五、Web Components 与微前端和框架\"></a>五、Web Components 与微前端和框架</h3><ul>\n<li><strong>在微前端中</strong>：Web Components 是实现<strong>技术栈无关</strong>微前端的理想载体。每个团队可以用自己熟悉的技术（React, Vue）<strong>开发</strong>组件，但最终<strong>发布</strong>为一个封装好的 Web Component（例如，将一个 React 组件包装成 <code>&lt;team-product-card&gt;</code>），由主应用统一调度。</li>\n<li><strong>与框架的关系</strong>：<ul>\n<li><strong>不是替代关系</strong>，而是<strong>互补关系</strong>。</li>\n<li><strong>框架 (React&#x2F;Vue) 擅长解决：</strong> 复杂的 UI 状态管理、数据流、高效的 DOM 差分更新。它们提供了<strong>优秀的开发体验</strong>和<strong>完整的解决方案</strong>。</li>\n<li><strong>Web Components 擅长解决：</strong> 跨框架重用、底层 UI 组件库、集成遗留应用、长期稳定的基础组件。它们提供了<strong>浏览器级别的互操作性</strong>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>总结来说，Web Components 是 Web 平台的底层基础，为构建可长期存在、高度封装、框架无关的组件提供了强大的原生能力。</strong> 虽然它在开发复杂应用时不如现代框架那么方便，但其独特优势使其在特定场景（如微前端、跨技术栈组件库、大型企业级应用）中是不可替代的选择。</p>\n<p>qiankun实现样式和js隔离的原理</p>\n<p>好的，我们来深入剖析 <strong>qiankun</strong> 实现样式和 JavaScript 隔离的原理。这是 qiankun 的核心能力之一，也是它相比原始 single-spa 更易用、更强大的关键。</p>\n<h3 id=\"总体思想\"><a href=\"#总体思想\" class=\"headerlink\" title=\"总体思想\"></a>总体思想</h3><p>qiankun 的隔离策略可以概括为：<strong>“重样式隔离，轻 JS 沙箱”</strong>。它通过在应用加载和卸载时动态地操作样式和 JavaScript 执行环境来模拟一个隔离的沙箱环境。</p>\n<hr>\n<h3 id=\"一、样式隔离-CSS-Isolation\"><a href=\"#一、样式隔离-CSS-Isolation\" class=\"headerlink\" title=\"一、样式隔离 (CSS Isolation)\"></a>一、样式隔离 (CSS Isolation)</h3><p>qiankun 提供了三种主要的样式隔离方案，根据场景不同自动或手动启用。</p>\n<h4 id=\"1-严格样式隔离-Scoped-CSS\"><a href=\"#1-严格样式隔离-Scoped-CSS\" class=\"headerlink\" title=\"1. 严格样式隔离 (Scoped CSS)\"></a>1. 严格样式隔离 (Scoped CSS)</h4><p><strong>原理：</strong> 为每个微应用包裹一个 <strong>Shadow DOM</strong>。</p>\n<ul>\n<li><strong>如何工作：</strong><ol>\n<li>当 qiankun 挂载一个微应用时，它会创建一个 Shadow Root，并将其作为该应用的容器。</li>\n<li>微应用的所有 DOM 结构都被渲染在这个 Shadow DOM 内部。</li>\n<li><strong>Shadow DOM 的特性天然实现了样式的封装</strong>：内部的样式不会影响外部，外部的样式也不会影响内部（除非使用 <code>::part</code> 或 <code>:host</code> 等特定语法）。</li>\n</ol>\n</li>\n<li><strong>优点：</strong> 隔离性最强，是浏览器原生的完美隔离方案。</li>\n<li><strong>缺点：</strong><ul>\n<li>某些第三方库（特别是弹窗类）可能会因为无法正确定位到 Shadow DOM 外部而出现问题。</li>\n<li>微应用内的样式完全无法影响主应用，反之亦然，有时这可能不符合设计需求。</li>\n</ul>\n</li>\n<li><strong>启用方式：</strong> 在 <code>start</code> 函数中配置 <code>&#123; strictStyleIsolation: true &#125;</code>。</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; start &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;qiankun&#x27;</span>;</span><br><span class=\"line\"><span class=\"title function_\">start</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">strictStyleIsolation</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 启用严格样式隔离</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-实验性样式隔离-CSS-Scoped\"><a href=\"#2-实验性样式隔离-CSS-Scoped\" class=\"headerlink\" title=\"2. 实验性样式隔离 (CSS Scoped)\"></a>2. 实验性样式隔离 (CSS Scoped)</h4><p><strong>原理：</strong> 一种更宽松的隔离方式，使用 <strong>运行时动态样式表重写</strong>。</p>\n<ul>\n<li><strong>如何工作：</strong><ol>\n<li>qiankun 会劫持微应用运行时<strong>动态添加样式标签（</strong><code>**&lt;style&gt;**</code><strong>,</strong>** <strong><code>**&lt;link&gt;**</code></strong>）** 的行为。</li>\n<li>当微应用插入一个新的样式标签时，qiankun 会将其内容抓取过来。</li>\n<li>使用 <strong>CSS 规则重写器</strong>（例如 <code>postcss</code> 插件）为所有 CSS 选择器<strong>添加一个特殊的前缀</strong>。这个前缀通常基于微应用的名称或一个特定属性。</li>\n<li>将重写后的 CSS 内容插入到 <code>document.head</code> 中。</li>\n<li>同时，qiankun 会为微应用的<strong>容器元素</strong>添加上一步中使用的<strong>相同属性</strong>。</li>\n</ol>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code>- 微应用有一个样式规则：`.button &#123; color: red; &#125;`\n- qiankun 将其重写为：`[data-qiankun=&quot;my-app&quot;] .button &#123; color: red; &#125;`\n- 同时，微应用的容器 `&lt;div&gt;` 会获得属性：`&lt;div data-qiankun=&quot;my-app&quot;&gt;...&lt;/div&gt;`\n- 这样，样式规则就只会在这个容器内生效。\n</code></pre>\n<ul>\n<li><strong>优点：</strong> 比 Shadow DOM 兼容性更好，允许微应用样式影响其容器内的任何元素（包括动态 append 到 body 的弹窗）。</li>\n<li><strong>缺点：</strong> 是运行时重写，有一定性能开销，且是实验性功能。</li>\n<li><strong>启用方式：</strong> 在 <code>start</code> 函数中配置 <code>&#123; experimentalStyleIsolation: true &#125;</code>。</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">start</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">experimentalStyleIsolation</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 启用实验性样式隔离</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-动态样式表加载-卸载-最常见的默认行为\"><a href=\"#3-动态样式表加载-卸载-最常见的默认行为\" class=\"headerlink\" title=\"3. 动态样式表加载&#x2F;卸载 (最常见的默认行为)\"></a>3. 动态样式表加载&#x2F;卸载 (最常见的默认行为)</h4><p>如果不开启上述两种隔离，qiankun 默认采用一种更简单但有效的策略。</p>\n<ul>\n<li><strong>原理：</strong><ol>\n<li><strong>加载时：</strong> qiankun 通过 <code>fetch</code> 获取微应用的 HTML 入口，解析出所有的 <code>&lt;style&gt;</code> 和 <code>&lt;link&gt;</code> 标签。</li>\n<li>将这些样式标签<strong>直接插入到</strong>** **<code>**document.head**</code> 中。</li>\n<li><strong>卸载时：</strong> qiankun 会<strong>记录</strong>所有由该微应用添加的样式标签，并在卸载微应用时<strong>直接将这些标签从 DOM 中移除</strong>。</li>\n</ol>\n</li>\n<li><strong>优点：</strong> 实现简单，性能好。</li>\n<li><strong>缺点：</strong> <strong>不是真正的隔离</strong>。如果多个微应用有相同选择器的样式规则，后加载的会覆盖先加载的（因为后加载的样式表在更后面，优先级更高）。这依赖于开发者的约定。</li>\n<li><strong>这是 qiankun 的默认行为</strong>，对于很多应用来说已经足够。</li>\n</ul>\n<hr>\n<h3 id=\"二、JavaScript-隔离-JS-Sandbox\"><a href=\"#二、JavaScript-隔离-JS-Sandbox\" class=\"headerlink\" title=\"二、JavaScript 隔离 (JS Sandbox)\"></a>二、JavaScript 隔离 (JS Sandbox)</h3><p>qiankun 的 JS 沙箱的核心目标是：<strong>防止微应用在全局环境（</strong><code>**window**</code><strong>）上留下永久的污染，并在应用切换时恢复和清理环境</strong>。它主要模拟了三个环境的隔离：</p>\n<h4 id=\"1-快照沙箱-SnapshotSandbox-用于单实例场景\"><a href=\"#1-快照沙箱-SnapshotSandbox-用于单实例场景\" class=\"headerlink\" title=\"1. 快照沙箱 (SnapshotSandbox) - 用于单实例场景\"></a>1. 快照沙箱 (SnapshotSandbox) - 用于单实例场景</h4><p><strong>原理：</strong> 在应用加载前后对全局 <code>window</code> 对象进行“拍照”和“diff”，适用于同一时间只能有一个微应用活跃的浏览器环境。</p>\n<ul>\n<li><strong>工作流程：</strong><ol>\n<li><strong>激活沙箱 (mount)：</strong> 将当前 <code>window</code> 的所有属性拍一个<strong>快照</strong>（<code>windowSnapshot</code>），存起来。</li>\n<li><strong>微应用运行：</strong> 微应用可以任意修改 <code>window</code>。</li>\n<li><strong>失活沙箱 (unmount)：</strong><ul>\n<li>将当前的 <code>window</code> 和之前存的 <code>windowSnapshot</code> 进行对比，得到修改的差异（<code>modifyPropsMap</code>）。</li>\n<li><strong>还原现场：</strong> 遍历差异，将 <code>window</code> 上的属性<strong>恢复</strong>到拍快照时的状态。</li>\n<li><strong>记录污染：</strong> 将微应用修改的差异保存起来。</li>\n</ul>\n</li>\n<li><strong>再次激活：</strong> 将之前保存的差异（<code>modifyPropsMap</code>）<strong>重新应用到</strong>** <strong><code>**window**</code></strong> **<strong>上</strong>，让微应用感觉自己的修改一直都在。</li>\n</ol>\n</li>\n<li><strong>优点：</strong> 兼容性极好，支持所有浏览器。</li>\n<li><strong>缺点：</strong> 无法支持多个微应用同时运行（多实例），因为共用一个全局 <code>window</code>。</li>\n</ul>\n<h4 id=\"2-代理沙箱-ProxySandbox-用于多实例场景（主流）\"><a href=\"#2-代理沙箱-ProxySandbox-用于多实例场景（主流）\" class=\"headerlink\" title=\"2. 代理沙箱 (ProxySandbox) - 用于多实例场景（主流）\"></a>2. 代理沙箱 (ProxySandbox) - 用于多实例场景（主流）</h4><p><strong>原理：</strong> 使用 ES6 的 <code>Proxy</code> 为每个微应用创建一个假的、隔离的 <code>window</code> 对象。</p>\n<ul>\n<li><strong>工作流程：</strong><ol>\n<li>qiankun 为每个微应用创建一个空的 <code>fakeWindow</code> 对象。</li>\n<li>用 <code>Proxy</code> 代理这个 <code>fakeWindow</code>。</li>\n<li>当微应用操作 <code>window</code> 时：<ul>\n<li><strong>读操作</strong>：优先从 <code>fakeWindow</code> 里读，如果读不到，则 fallback 到真正的全局 <code>window</code>（这样可以共享 <code>document</code>, <code>location</code> 等全局对象）。</li>\n<li><strong>写操作</strong>：所有对属性的新增和修改都只作用于 <code>fakeWindow</code> 上，<strong>完全不会污染真正的全局</strong>** **<code>**window**</code>。</li>\n</ul>\n</li>\n<li>微应用的所有代码都在这个代理的上下文中执行（通过 <code>with</code> 语句或 <code>eval</code> 改写）。</li>\n</ol>\n</li>\n<li><strong>示例：</strong></li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 微应用代码</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">myGlobalVar</span> = <span class=\"number\">123</span>; <span class=\"comment\">// 写入的是沙箱的 fakeWindow，真 window 不受影响</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">document</span>.<span class=\"property\">title</span>); <span class=\"comment\">// 读取的是真 window 的属性</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>优点：</strong><ul>\n<li>真正的隔离，多个微应用可以同时运行，每个都有自己独立的 <code>window</code> 空间。</li>\n<li>对微应用无感知，无需修改代码。</li>\n</ul>\n</li>\n<li><strong>缺点：</strong> 依赖 ES6 <code>Proxy</code>，无法在低版本浏览器（如 IE）中使用。</li>\n</ul>\n<h4 id=\"3-遗留沙箱-LegacySandbox-已逐渐被代理沙箱取代\"><a href=\"#3-遗留沙箱-LegacySandbox-已逐渐被代理沙箱取代\" class=\"headerlink\" title=\"3. 遗留沙箱 (LegacySandbox) - 已逐渐被代理沙箱取代\"></a>3. 遗留沙箱 (LegacySandbox) - 已逐渐被代理沙箱取代</h4><p>原理类似于快照沙箱，但性能优化更好。它只记录微应用修改过的属性，在卸载时还原这些属性。同样不支持多实例。</p>\n<hr>\n<h3 id=\"总结：qiankun-的隔离策略\"><a href=\"#总结：qiankun-的隔离策略\" class=\"headerlink\" title=\"总结：qiankun 的隔离策略\"></a>总结：qiankun 的隔离策略</h3><table>\n<thead>\n<tr>\n<th><strong>隔离类型</strong></th>\n<th><strong>技术方案</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>样式隔离</strong></td>\n<td><strong>Shadow DOM</strong></td>\n<td>原生，隔离最彻底</td>\n<td>兼容性问题，弹窗等组件可能异常</td>\n<td>需要最强隔离的新应用</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>动态样式表重写 (实验性)</strong></td>\n<td>兼容性好，支持弹窗</td>\n<td>运行时开销，实验性功能</td>\n<td>需要兼容弹窗的复杂应用</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>动态加载&#x2F;卸载 (默认)</strong></td>\n<td>简单，性能好</td>\n<td>非真正隔离，依赖约定</td>\n<td>大多数简单应用，样式冲突风险低</td>\n</tr>\n<tr>\n<td><strong>JS 隔离</strong></td>\n<td><strong>快照沙箱 (SnapshotSandbox)</strong></td>\n<td>兼容所有浏览器</td>\n<td>不支持多实例</td>\n<td>单实例模式，需兼容 IE 等老浏览器</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>代理沙箱 (ProxySandbox)</strong></td>\n<td>真正隔离，支持多实例，对应用无感知</td>\n<td>依赖 <code>Proxy</code><br/>，不兼容 IE</td>\n<td><strong>现代浏览器下的主流选择</strong></td>\n</tr>\n</tbody></table>\n<p><strong>qiankun 会自动选择最佳策略</strong>：在支持 <code>Proxy</code> 的浏览器中默认使用<strong>代理沙箱 (多实例)</strong> 和<strong>动态样式加载&#x2F;卸载</strong>。如果不支持 <code>Proxy</code>，则降级到<strong>快照沙箱 (单实例)</strong>。</p>\n<p>通过这种组合策略，qiankun 在绝大多数场景下为微前端应用提供了<strong>足够安全、稳定且高性能的隔离环境</strong>，极大地简化了微前端的落地复杂度。</p>\n<p>qiankun是如何实现父子应用通信的呢</p>\n<p>好的，<strong>qiankun 的通信机制</strong>是其核心功能之一，它设计得非常灵活，提供了多种方式来实现主应用（父应用）和微应用（子应用）之间的通信。</p>\n<p>qiankun 并没有强制使用某一种通信方式，而是提供了一个轻量的 <strong>API（</strong><code>**initGlobalState**</code><strong>）</strong> 作为推荐方案，同时也完全支持任何其他流行的状态管理库（如 Redux, Mobx, Vuex）或浏览器原生 API。</p>\n<hr>\n<h3 id=\"一、官方推荐方案：使用-initGlobalState-Actions-通信\"><a href=\"#一、官方推荐方案：使用-initGlobalState-Actions-通信\" class=\"headerlink\" title=\"一、官方推荐方案：使用 initGlobalState (Actions 通信)\"></a>一、官方推荐方案：使用 <code>initGlobalState</code> (Actions 通信)</h3><p>这是 qiankun 官方提供的通信方式，适用于大多数场景。它的核心思想是一个<strong>简单的发布-订阅模式</strong>。</p>\n<h4 id=\"1-在主应用中初始化状态并下发通信方法\"><a href=\"#1-在主应用中初始化状态并下发通信方法\" class=\"headerlink\" title=\"1. 在主应用中初始化状态并下发通信方法\"></a>1. 在主应用中初始化状态并下发通信方法</h4><p>主应用是整个状态的管理中心。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main-app/src/actions.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; initGlobalState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;qiankun&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 初始化全局状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\">  <span class=\"attr\">user</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;张三&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">token</span>: <span class=\"string\">&#x27;abc123&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">theme</span>: <span class=\"string\">&#x27;light&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 创建 Actions 实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> actions = <span class=\"title function_\">initGlobalState</span>(initialState);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 监听状态变化（可选，主应用自己也可以监听）</span></span><br><span class=\"line\">actions.<span class=\"title function_\">onGlobalStateChange</span>(<span class=\"function\">(<span class=\"params\">state, prevState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// state: 变更后的新状态</span></span><br><span class=\"line\">  <span class=\"comment\">// prevState: 变更前的旧状态</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;主应用监听到状态变化: &#x27;</span>, state, prevState);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 定义一个更新状态的方法</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">setGlobalState</span> = (<span class=\"params\">newState</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 按层级合并状态</span></span><br><span class=\"line\">  actions.<span class=\"title function_\">setGlobalState</span>(newState);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 将 actions 暴露出去，供微应用使用</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> actions;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-在微应用中获取并操作状态\"><a href=\"#2-在微应用中获取并操作状态\" class=\"headerlink\" title=\"2. 在微应用中获取并操作状态\"></a>2. 在微应用中获取并操作状态</h4><p>微应用需要从生命周期函数中获取到 <code>props</code>，其中就包含了通信方法。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// micro-app/src/main.js (入口文件)</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> microAppActions; <span class=\"comment\">// 用来保存通信方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导出 qiankun 生命周期函数</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">mount</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;微应用挂载了&#x27;</span>, props);</span><br><span class=\"line\">  <span class=\"comment\">// 1. 从 props 中获取主应用下发的 actions</span></span><br><span class=\"line\">  microAppActions = props;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 监听全局状态变化</span></span><br><span class=\"line\">  props.<span class=\"title function_\">onGlobalStateChange</span>(<span class=\"function\">(<span class=\"params\">state, prevState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;微应用监听到状态变化: &#x27;</span>, state, prevState);</span><br><span class=\"line\">    <span class=\"comment\">// 状态变化后，更新微应用自己的视图</span></span><br><span class=\"line\">    <span class=\"title function_\">renderApp</span>(state);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 首次挂载，获取当前全局状态并渲染应用</span></span><br><span class=\"line\">  <span class=\"title function_\">renderApp</span>(props.<span class=\"title function_\">getGlobalState</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">unmount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 卸载时取消监听（qiankun 内部会自动清理，但显式取消是好习惯）</span></span><br><span class=\"line\">  microAppActions.<span class=\"title function_\">offGlobalStateChange</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// React/Vue 应用的渲染函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">renderApp</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">globalState</span>=<span class=\"string\">&#123;state&#125;</span> <span class=\"attr\">actions</span>=<span class=\"string\">&#123;microAppActions&#125;</span> /&gt;</span></span>, <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-在微应用组件中具体使用\"><a href=\"#3-在微应用组件中具体使用\" class=\"headerlink\" title=\"3. 在微应用组件中具体使用\"></a>3. 在微应用组件中具体使用</h4><p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// micro-app/src/App.jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\">&#123; globalState, actions &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; user, theme &#125; = globalState;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleChangeTheme</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新全局状态</span></span><br><span class=\"line\">    actions.<span class=\"title function_\">setGlobalState</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">theme</span>: theme === <span class=\"string\">&#x27;light&#x27;</span> ? <span class=\"string\">&#x27;dark&#x27;</span> : <span class=\"string\">&#x27;light&#x27;</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;</span>`<span class=\"attr\">app</span> $&#123;<span class=\"attr\">theme</span>&#125;`&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>微应用页面<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>用户名: &#123;user.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleChangeTheme&#125;</span>&gt;</span>切换主题<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"initGlobalState-API-说明：\"><a href=\"#initGlobalState-API-说明：\" class=\"headerlink\" title=\"initGlobalState API 说明：\"></a><code>initGlobalState</code> API 说明：</h4><ul>\n<li><code>setGlobalState(state: object)</code>: 设置新的全局状态，会自动与旧状态进行<strong>浅合并</strong>。</li>\n<li><code>onGlobalStateChange(callback: function)</code>: 注册监听器，状态变化时触发。</li>\n<li><code>offGlobalStateChange()</code>: 取消监听。</li>\n<li><code>getGlobalState()</code>: 获取当前全局状态。</li>\n</ul>\n<hr>\n<h3 id=\"二、其他通信方案\"><a href=\"#二、其他通信方案\" class=\"headerlink\" title=\"二、其他通信方案\"></a>二、其他通信方案</h3><p>qiankun 是框架无关的，因此你也可以选择任何你熟悉的通信方式。</p>\n<h4 id=\"1-使用-CustomEvent-浏览器原生事件\"><a href=\"#1-使用-CustomEvent-浏览器原生事件\" class=\"headerlink\" title=\"1. 使用 CustomEvent (浏览器原生事件)\"></a>1. 使用 CustomEvent (浏览器原生事件)</h4><p><strong>原理：</strong> 利用浏览器原生的 <code>window.dispatchEvent</code> 和 <code>window.addEventListener</code> 进行通信。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主应用 - 发送事件</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;main-app-event&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">detail</span>: &#123; <span class=\"comment\">// 通过 detail 传递数据</span></span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;CHANGE_THEME&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">payload</span>: <span class=\"string\">&#x27;dark&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用 - 接收事件</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;main-app-event&#x27;</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; type, payload &#125; = event.<span class=\"property\">detail</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 处理事件...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用 - 发送事件（同理）</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;micro-app-event&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">detail</span>: &#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Hello from micro app&#x27;</span> &#125;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong> 原生支持，非常简单。<br><strong>缺点：</strong> 数据传递能力较弱（只能同步），缺乏状态管理能力，事件需要全局唯一命名以免冲突。</p>\n<h4 id=\"2-使用-Redux-Mobx-Vuex-等状态库\"><a href=\"#2-使用-Redux-Mobx-Vuex-等状态库\" class=\"headerlink\" title=\"2. 使用 Redux&#x2F;Mobx&#x2F;Vuex 等状态库\"></a>2. 使用 Redux&#x2F;Mobx&#x2F;Vuex 等状态库</h4><p><strong>原理：</strong> 主应用和微应用<strong>共享同一个状态库实例</strong>。</p>\n<ul>\n<li><strong>步骤：</strong><ol>\n<li>主应用创建一个 Redux Store 或其他状态库实例。</li>\n<li>将这个 Store 通过 <code>window</code> 对象或者微应用的 <code>props</code> 暴露给微应用。</li>\n<li>微应用连接到这个全局的 Store，进行状态的读取和分发 Action。</li>\n</ol>\n</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主应用 - 创建并暴露 store</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;redux&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> globalStore = <span class=\"title function_\">createStore</span>(<span class=\"comment\">/* ... */</span>);</span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">__MAIN_APP_STORE__</span> = globalStore; <span class=\"comment\">// 挂到全局</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用 - 获取并使用 store</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"variable language_\">window</span>.<span class=\"property\">__MAIN_APP_STORE__</span>;</span><br><span class=\"line\">store.<span class=\"title function_\">dispatch</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;AN_ACTION&#x27;</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> state = store.<span class=\"title function_\">getState</span>();</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong> 功能强大，可以处理复杂的业务逻辑和状态流。<br><strong>缺点：</strong> 紧密耦合，主应用和微应用必须使用同一种状态库，且版本需要兼容。</p>\n<h4 id=\"3-通过-URL-或-Query-Parameters-通信\"><a href=\"#3-通过-URL-或-Query-Parameters-通信\" class=\"headerlink\" title=\"3. 通过 URL 或 Query Parameters 通信\"></a>3. 通过 URL 或 Query Parameters 通信</h4><p><strong>原理：</strong> 通过改变 URL 的查询参数来传递简单信息。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主应用改变URL</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newUrl = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"variable language_\">window</span>.location.pathname&#125;</span>?theme=dark&amp;userId=123`</span>;</span><br><span class=\"line\">history.<span class=\"title function_\">pushState</span>(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;&#x27;</span>, newUrl);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用监听URL变化</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;popstate&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> urlParams = <span class=\"keyword\">new</span> <span class=\"title class_\">URLSearchParams</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">location</span>.<span class=\"property\">search</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> theme = urlParams.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;theme&#x27;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ...使用参数</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong> 非常简单，状态可被收藏和分享。<br><strong>缺点：</strong> 只适合传递少量简单数据。</p>\n<hr>\n<h3 id=\"总结与选择建议\"><a href=\"#总结与选择建议\" class=\"headerlink\" title=\"总结与选择建议\"></a>总结与选择建议</h3><table>\n<thead>\n<tr>\n<th><strong>方案</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>官方</strong>** **<code>**initGlobalState**</code></td>\n<td><strong>官方推荐</strong>，简单轻量，满足大部分通信需求</td>\n<td>功能相对简单，不适合极其复杂的场景</td>\n<td><strong>绝大多数微前端通信场景的首选</strong></td>\n</tr>\n<tr>\n<td><strong>CustomEvent</strong></td>\n<td>浏览器原生，非常简单</td>\n<td>功能弱，只能传简单数据，易产生事件名冲突</td>\n<td>简单的父子通知、触发动作</td>\n</tr>\n<tr>\n<td><strong>Redux&#x2F;Vuex 等</strong></td>\n<td>功能强大，适合复杂状态管理</td>\n<td>耦合度高，主子和微应用必须使用同一种状态库</td>\n<td>大型复杂应用，且技术栈统一</td>\n</tr>\n<tr>\n<td><strong>URL Parameters</strong></td>\n<td>实现简单，状态可分享</td>\n<td>传递数据量有限，类型受限</td>\n<td>过滤条件、简单配置等</td>\n</tr>\n</tbody></table>\n<p><strong>最佳实践建议：</strong></p>\n<ol>\n<li><strong>优先使用官方的</strong>** **<code>**initGlobalState**</code>，它能覆盖 90% 的微前端通信需求。</li>\n<li>对于简单的、一次性的动作触发（如“刷新列表”、“显示通知”），可以辅以 <strong>CustomEvent</strong>。</li>\n<li>只有在主应用和所有微应用技术栈统一且非常复杂时，才考虑使用<strong>共享状态库</strong>。</li>\n<li>通信的设计应遵循<strong>最小化原则</strong>，尽量减少主应用和微应用之间的耦合，让微应用保持最大的独立性。</li>\n</ol>\n","_processedHighlight":true},{"title":"前端部署详解","date":"2025-03-25T16:00:00.000Z","_content":"\n# CI/CD\n## 🧠 核心概念：CI/CD是什么？\nCI/CD 是现代软件工程中的一套最佳实践和方法论，旨在自动化软件的集成、测试和部署流程。它由两个部分组成：\n\nCI - 持续集成 (Continuous Integration)\n\nCD - 持续交付/持续部署 (Continuous Delivery / Continuous Deployment)\n\n可以把 CI/CD 想象成一个全自动的软件装配流水线。开发者提交代码（如同送上原料），流水线会自动进行一系列质量检测、打包和发布，最终将合格的产品交付给用户。\n\n## 🔧 详解两个部分\n### 1. CI - 持续集成\n**核心思想：** 开发者频繁地将代码更改合并到共享的主干分支（如每天多次）。每次合并都会自动触发一系列构建和测试，以便快速发现和修复错误。\n\n<img src=\"/images/CI流程.svg\" alt=\"CI流程\" width=\"300\" height=\"auto\" style=\"display:block;\">\n\n\n\n**好处：**\n\n+ ✅ **快速发现错误**：问题在引入后几分钟内就能被发现。\n+ ✅ **减少集成冲突**：频繁合并小批量代码，避免在发布前一次性合并大量代码带来的巨大冲突。\n+ ✅ 提高代码质量**：自动化测试保障了代码标准。\n\n### 2. CD - 持续交付 / 持续部署\n**CD 有两种细微差别的含义：**\n\n#### a) 持续交付 (Continuous Delivery)\n**核心思想：** CI流程结束后，代码总是处于**可随时、一键手动部署**到生产环境的状态。\n\n**流程：** `代码 -> CI -> 生成制品 -> 等待手动点击部署`\n\n#### b) 持续部署 (Continuous Deployment)\n**核心思想：** 这是持续交付的更高阶段。只要代码通过所有测试流程，就**自动地、无需人工干预地**部署到生产环境。\n\n**流程：** `代码 -> CI -> 生成制品 -> 自动部署到生产环境`\n\n可以这样理解：\n\n+ **持续交付** = \"软件已经打包好放在门口了，你随时可以签收（手动部署）。\"\n+ **持续部署** = \"软件通过质检后，快递机器人自动送货上门（自动部署）。\"\n\n## 🛠️ CI/CD 工具链\n整个流程依赖于一系列自动化工具，常见的工具有：\n\n| **阶段** | **流行工具** |\n| --- | --- |\n| **源代码管理****** | Git (GitLab, GitHub, Gitee) |\n| **CI/CD 流水线引擎** | **Jenkins**, GitLab CI/CD, GitHub Actions, Drone |\n| **构建工具** | Maven, Gradle (Java), npm, Webpack (JS), Make |\n| **测试工具** | JUnit, Selenium, Jest, Cypress |\n| **部署工具** | Ansible, Kubernetes, Docker, Terraform |\n| **监控工具** | Prometheus, Grafana, ELK Stack |\n\n\n## 💡 为什么需要 CI/CD？它的价值是什么？\n1. **加速开发流程**\n    - 自动化代替手动操作，释放开发者的生产力。\n    - 快速反馈，开发者能立即知道这次提交是否破坏了系统。\n2. **提高软件质量**\n    - 通过自动化测试在早期发现缺陷，修复成本远低于生产环境才发现。\n    - 代码规范、安全漏洞扫描等流程被标准化。\n3. **降低发布风险**\n    - 小批量、频繁的发布使得每次变更的内容很少。如果出现问题，可以快速定位和回滚。\n    - 传统的\"半年发布一次，一次改动500个功能\"的方式风险极高。\n4. **增强项目可见性**\n    - 每个人都能清晰地看到代码从提交到部署的整个状态，构建是否成功、测试是否通过。\n\n## ✅ 总结\n**CI/CD** 是一套通过**自动化**来**优化软件开发生命周期**的实践，其核心目标是：\n\n+ **更快的发布速度**\n+ **更高质量的软件**\n+ **更低的发布风险**\n\n它不是某个特定的工具，而是一种文化和流程的变革，是现代DevOps理念的核心支柱，已经成为中大型软件开发团队的标配。\n\n# OpenVpn与跳板机/堡垒机\n## 🔧 什么是 OpenVPN 客户端？\n**OpenVPN 客户端**是一个安装在您本地设备（如电脑、手机）上的**软件程序**。\n\n它的核心功能是：**根据配置文件（.ovpn 文件），与远端的 OpenVPN 服务器建立一条加密的、安全的隧道连接。**\n\n+ **它是什么？** 一个软件（例如：OpenVPN Connect、Tunnelblick等）。\n+ **它在哪里运行？** 在你的个人设备上（Windows PC, Mac, Linux, 手机）。\n+ **它的作用？** 创建加密通道，让你的所有或指定网络流量都通过这个通道流向VPN服务器。\n\n**就像一个专门的电话（客户端），用于拨打一个安全的号码（服务器）。**\n\n---\n\n## 🖥️ 什么是跳板机？\n**跳板机**（Jump Server / Bastion Host）是一台位于某个特定网络区域（如公司内网）的**服务器**。\n\n它的核心功能是：**作为一个唯一的、受严格控制的访问入口，所有外部人员必须先连接到这台服务器，才能进一步访问目标网络内部的其他设备。**\n\n+ **它是什么？** 一台物理或虚拟的服务器/计算机。\n+ **它在哪里运行？** 在目标网络的入口处（例如公司机房或公有云上）。\n+ **它的作用？** 提供访问桥梁和安全审计。所有操作都通过它进行，便于监控和记录日志。\n\n**就像是大楼的门卫室（跳板机），所有访客（用户）必须先在门卫室登记、核实身份，由门卫带领才能进入大楼内部（内网）。**\n\n---\n\n## 🔄 它们如何协同工作？（两者的关系）\nOpenVPN 客户端和跳板机通常**配合使用**，但它们扮演完全不同的角色。\n\n### 工作流程分解：\n#### 阶段一：建立安全隧道（认证与连接）\n1. **配置加载**：用户在自己的电脑上启动OpenVPN客户端软件，并加载管理员提供的 `.ovpn`配置文件。这个文件包含了连接所需的所有信息：\n    - **跳板机的公网IP/域名**\n    - 加密算法和协议类型\n    - **CA根证书**（用于验证服务器身份）\n    - **客户端证书和私钥**（用于向服务器证明自身身份）\n    - 其他参数（如使用的端口、是否使用密码等）\n2. **发起连接**：客户端根据配置，向跳板机的公网IP和指定端口发起TCP/UDP连接请求。\n3. **TLS双向认证**（最关键的安全步骤）：\n    - **服务器认证**：跳板机上的OpenVPN服务端将自己的证书发给客户端。客户端用CA根证书验证服务器证书的有效性，**确保连接的是真正的公司跳板机，而不是钓鱼服务器**。\n    - **客户端认证**：客户端将自己的证书和私钥签名发给服务器。服务器用CA根证书验证客户端证书，**确保连接的是授权员工，而不是外人**。\n    - 这个过程通常还辅以用户名/密码认证。\n4. **隧道建立**：认证通过后，双方利用协商好的密钥，建立一条**加密隧道**。跳板机为客户端分配一个内网IP地址（如 `10.8.0.100`）。此时，用户的电脑在逻辑上已经“接入”了公司内网。\n\n#### 阶段二：访问内部资源（路由与转发）\n1. **发起访问请求**：用户需要访问内网的一台Web服务器（`192.168.1.100`）。他在本地使用SSH命令：`ssh developer@192.168.1.100`。\n2. **流量封装与路由**：\n    - 客户端的操作系统会根据路由表规则，将所有发往 `192.168.1.0/24` 网段的流量，都指向OpenVPN创建的虚拟网卡。\n    - OpenVPN客户端将原始的SSH数据包（TCP协议）**整个加密并包裹（封装）** 在一个新的数据包内，这个新数据包的目的地是跳板机的公网IP。\n    - 这个加密后的数据包通过互联网发送到跳板机。\n3. **跳板机处理**（流量枢纽）：\n    - 跳板机上的OpenVPN服务端**解密**收到的数据包，**解出**原始的SSH请求数据包。\n    - 跳板机的**操作系统内核**根据其自身的路由表，发现这个目标是 `192.168.1.100` 的数据包需要从其内部网卡（如 `eth0`）发出。\n    - **防火墙和访问控制**：在转发前，跳板机上的防火墙规则（如 `iptables`）会进行检查，判断源IP（`10.8.0.100`）是否有权限访问目标IP（`192.168.1.100`）的22端口。通过后，才将数据包转发给目标Web服务器。\n4. **响应返回**：\n    - Web服务器处理SSH请求后，将响应包发回给跳板机（因为请求的来源IP是跳板机）。\n    - 跳板机收到响应后，再将其加密，通过隧道发回给远端的用户客户端。\n    - 客户端解密后，得到原始的SSH响应，完成一次完整的交互。\n\n#### 🛡️ 核心价值与优势\n这种架构的优势在于提供了**双重安全性和极佳的可管理性**：\n\n1. **强身份认证**：通过证书方式，同时验证了服务器和客户端的身份，避免了密码泄露和中间人攻击。\n2. **通信加密**：所有数据在公网上传输时都是加密的，保证机密性。\n3. **访问隔离**：跳板机成为唯一的入口，外部无法直接访问任何其他内网机器，攻击面最小化。\n4. **集中审计与管控**：所有对内网的访问都必须经过跳板机，便于**记录完整的操作日志**、**监控会话**和**统一设置访问权限策略**。管理员只需要在跳板机上修改规则，就可以控制所有用户的权限。\n\n### 结论：\n+ **OpenVPN客户端**是您用来**连接**的**软件**。\n+ **跳板机**是您**连接上去**的那台**服务器**。\n+ OpenVPN是**实现安全连接的方式之一**，而跳板机是**一种网络访问策略和架构**。\n\n您可以**不使用OpenVPN**而用其他方式（如SSH）登录跳板机；也可以**使用OpenVPN**连接到一台**不是跳板机**的服务器（例如只是为了加密咖啡店的公共Wi-Fi流量）。\n\n但当它们结合时，就构成了一个非常经典和强大的安全远程访问方案。\n\n## 🧠 什么是堡垒机？\n如果说「跳板机」是一个基础概念，那么「堡垒机」就是它的**完全体、企业级、工业化**的形态。\n\n**堡垒机**（Bastion Host）是一种位于内部网络和外部网络之间的**高性能、高安全性的专用服务器**，其核心设计理念是 **“网络要塞”** 。所有内部设备的远程访问（如 SSH, RDP, SFTP）都必须通过它进行，它作为唯一的入口点，集中进行**身份认证、授权、审计和监控**。\n\n您可以把它想象成一个**极其严格的银行金库门卫**：\n\n1. **唯一入口**：所有人都必须从这个门进出。\n2. **严格安检**：需要多重身份验证（工牌、指纹、密码）。\n3. **权限分明**：你只能进入你有权限进入的区域（金库、柜台、办公室）。\n4. **全程监控**：你进去后的一举一动都被全程录像，说了什么话（执行的命令）、拿了什么东西（传输的文件）都有记录。\n\n---\n\n### 🆚 堡垒机 vs. 简单跳板机：有何不同？\n很多人会混用这两个词，但它们有本质上的区别：\n\n| **特性** | **简单跳板机 (Jump Server)** | **堡垒机 (Bastion Host)** |\n| --- | --- | --- |\n| **核心功能** | **网络转发**、基础连接 | **4A管理**：认证、授权、账号、审计 |\n| **安全性** | 相对较低，依赖系统自身安全 | **极高**，有专门的安全加固和防护 |\n| **用户体验** | 命令行，原始 | **Web图形化界面**，易于操作 |\n| **权限控制** | 粗粒度（能/不能登录某台机器） | **细粒度**（能登录，且只能执行某些命令） |\n| **审计能力** | 基础日志（谁什么时候登录了） | **强大审计****：****   ****-**** ****会话录像**（全程录屏）   - **命令记录**（精确到每一条命令）   - **文件传输记录** |\n| **账号管理** | 分散在各台服务器上 | **统一账号管理**，单点登录（SSO） |\n| **本质** | **一台功能单一的服务器** | **一套完整的安全运维管控系统** |\n\n\n**简单说：跳板机主要解决“**怎么进去**”的问题，而堡垒机在此基础上，更解决了“**谁能进**”、“**能干什么**”和“**干了什么**”的问题。**\n\n---\n\n### 🛡️ 堡垒机的核心功能（4A管理）\n#### 1. 认证 (Authentication)：“你是谁？”\n+ **多种认证方式**：支持密码、SSH密钥、动态令牌（如Google Authenticator）、LDAP/AD域集成、生物识别等。\n+ **多因子认证 (MFA)**：强制要求使用两种及以上方式验证身份，极大提升安全性。\n\n#### 2. 授权 (Authorization)：“你能干什么？”\n+ **精细化的权限控制**：\n    - **主机权限**：允许用户访问哪些服务器（如：只能访问Web服务器，不能访问数据库服务器）。\n    - **操作权限**：允许用户执行哪些命令（如：可以执行 `systemctl restart nginx`，但不能执行 `rm -rf /`）。\n    - **时间权限**：允许用户在什么时间段内访问（如：只能在工作时间访问）。\n+ **临时权限申请与审批**：如果需要临时获得更高权限，可以通过工单系统申请，由管理员审批后自动授权，过期自动回收。\n\n#### 3. 账号 (Account)：“你的身份是什么？”\n+ **统一账号管理**：在堡垒机上创建账号，即可映射到后端的多台服务器，无需在每个服务器上单独创建账号。实现了“一个堡垒机账号，访问所有授权资产”。\n+ **托管服务器账号**：服务器账号和密码可以由堡垒机托管，用户无需知道目标服务器的真实密码。\n\n#### 4. 审计 (Audit)：“你干了什么？”（这是堡垒机的灵魂）\n+ ****会话录像 (Session Recording)**：** 像录屏一样，完整记录用户在目标服务器上的**所有操作过程**，包括敲打的命令、返回的结果。无法抵赖。\n+ **命令记录**：详细记录执行过的每一条命令及其时间、来源IP。\n+ **文件传输审计**：记录所有通过SFTP/SCP/RDP上传和下载的文件日志。\n+ **行为分析**：对异常操作、危险命令（如 `rm`、`chmod`）进行实时告警。\n\n---\n\n### 🏗️ 堡垒机的工作流程\n下图以一个运维人员需要通过堡垒机修复网站为例，展示了其核心工作流程与4A功能：\n\n<img src=\"/images/堡垒机工作流程.svg\" alt=\"堡垒机工作流程\" width=\"240\" height=\"auto\" style=\"display:block;\">\n\n\n\n---\n\n### 🚀 常见的堡垒机方案\n1. **开源方案**：\n    - **Jumpserver**：国内最流行的开源堡垒机，功能全面，对中文支持好，社区活跃。\n    - **Teleport**：现代、轻量级，对云原生和Kubernetes环境支持良好。\n    - **Apache Guacamole**：无客户端堡垒机，通过浏览器即可实现RDP、SSH、VNC等连接。\n2. **商业方案**：\n    - **齐治堡垒机**：国内老牌商业产品，市场份额大。\n    - ** Cisco Secure Access (前Duo)**、**CyberArk**：国际知名的商业解决方案，功能强大，价格昂贵。\n\n---\n\n### ✅ 总结：为什么需要堡垒机？\n1. **安全第一**：极大缩小了网络攻击面，保护了内部资产。\n2. **合规要求**：满足等保2.0、ISO27001、GDPR等法规对运维审计的强制性要求。\n3. **权限清晰**：实现最小权限原则，避免权限滥用。\n4. **责任界定**：出现问题时，可以通过录像和日志快速定位责任人、还原事故现场。\n5. **运维效率**：统一入口，简化了账号管理和访问流程。\n\n简而言之，堡垒机是企业IT基础设施中**不可或缺的安全与审计基石**，尤其对于金融、政府、互联网等对安全性和合规性要求极高的行业来说，是标配产品。\n\n# OpenVpn+跳板机/堡垒机实现前端部署\n这是一个非常经典的DevOps场景：OpenVpn+跳板机/堡垒机与前端工程部署结合起来，可以构建一个既安全又高效的部署流程。\n\n这种架构的核心思想是：通过 OpenVPN 建立安全通道，通过跳板机/堡垒机作为统一、受控的入口，来执行部署操作。\n\n## 🧩 核心架构与角色分工\n在这种架构下，各个组件的职责非常清晰：\n\n1. **OpenVPN Server**：**负责建“路”**。建立一条从开发者本地到部署环境的加密隧道，确保传输安全。\n2. **跳板机/堡垒机 (Bastion Host)**：**负责管“门”和看“人”**。它是唯一的部署操作入口，负责身份验证、权限控制和操作审计。\n3. **部署目标服务器**：**负责住“应用”**。这是最终运行前端项目（Nginx, Node.js 等）的服务器。\n4. **CI/CD 工具 (可选但推荐)**：**负责自动“开车”**。例如 Jenkins、GitLab Runner 等，它们可以自动从仓库拉取代码、构建，并通过跳板机执行部署脚本。\n\n整个从前端代码到部署上线的安全部署流程，如图所述：\n\n<img src=\"/images/OpenVpn+堡垒机结合前端部署.svg\" alt=\"OpenVpn+堡垒机结合前端部署\" width=\"400\" height=\"auto\" style=\"display:block;\">\n\n\n\n\n## 🛠️ 两种常见的部署模式\n### 模式一：手动部署（适合小团队或初期）\n**流程：** 开发者本地构建，然后通过跳板机手动上传文件。\n\n**本地构建**：\n\n```bash\nnpm run build\n```\n\n这会在项目根目录生成 `dist` 或 `build` 文件夹，里面是静态文件（HTML, CSS, JS）。\n\n1. **连接VPN**：确保 OpenVPN 客户端已连接，获得访问内网的权限。\n2. **通过跳板机上传文件**：\n\n```bash\n# 使用 scp 命令，通过跳板机转发到目标服务器\n# 注意：跳板机需要配置SSH代理转发或用户有直接权限\nscp -r -o 'ProxyJump user@jumpbox-ip' ./dist/* user@target-server-ip:/path/to/nginx/html/\n\n# 或者使用更现代的 rsync\nrsync -avz -e \"ssh -J user@jumpbox-ip\" ./dist/ user@target-server-ip:/path/to/nginx/html/\n```\n\n3. **通过跳板机执行远程命令**（如果需要）：\n\n```bash\n# 登录跳板机，再从跳板机SSH到目标服务器\nssh user@jumpbox-ip\n# 然后，在跳板机上执行\nssh user@target-server-ip \"sudo nginx -s reload\"\n```\n\n### 模式二：自动化部署（推荐，适合成熟团队）\n**流程：** CI/CD 工具（如 Jenkins、GitLab CI）在检测到 Git 标签或特定分支更新后，自动完成所有步骤。\n\n这是一个在 GitLab 中实现的自动化部署流程示例：\n\n```yaml\n# .gitlab-ci.yml\n\nstages:\n  - build\n  - deploy\n\nbuild_production:\n  stage: build\n  image: node:16\n  rules:\n    - if: $CI_COMMIT_TAG # 通常在打标签时触发生产环境部署\n  script:\n    - npm install\n    - npm run build\n  artifacts:\n    paths:\n      - dist/ # 将构建产物传递给下一个阶段\n\ndeploy_to_production:\n  stage: deploy\n  image: alpine\n  rules:\n    - if: $CI_COMMIT_TAG\n  script:\n    - apk add --no-cache openssh-client rsync\n    # 使用 SSH 通过跳板机部署 (-o ProxyJump)\n    - rsync -avz --delete -e \"ssh -o StrictHostKeyChecking=no -J $JUMPBOX_USER@$JUMPBOX_IP\" dist/ $TARGET_SERVER_USER@$TARGET_SERVER_IP:/app/frontend/\n    # 通过跳板机执行远程命令，重启服务\n    - ssh -J $JUMPBOX_USER@$JUMPBOX_IP $TARGET_SERVER_USER@$TARGET_SERVER_IP \"sudo systemctl reload nginx\"\n```\n\n**关键点：**\n\n+ `$JUMPBOX_IP`, `$TARGET_SERVER_IP` 等变量在 GitLab 的 **CI/CD 设置**中配置，避免写在代码里。\n+ `-J` 参数是 SSH 的 **代理跳跃**，让 SSH 连接自动通过跳板机。\n+ 堡垒机上需要存放 CI/CD 工具的 **SSH 私钥**，并且该密钥对目标服务器有访问权限。\n\n---\n\n## ⚙️ 部署前的重要准备工作\n1. **网络与权限配置**：\n    - 确保 OpenVPN 服务器配置的路由规则，能让客户端访问到跳板机和目标服务器。\n    - 在跳板机上为每个开发者或CI/CD服务创建账号，并配置严格的 SSH 密钥认证。\n    - 配置跳板机的权限控制，确保用户只能访问特定的目标服务器。\n2. **堡垒机审计**：\n    - 开启堡垒机的会话录制功能，记录所有通过它执行的部署命令和文件传输操作。一旦出问题，可以快速回放定位。\n3. **目标服务器配置**：\n    - **Nginx 配置示例**：\n\n```nginx\nserver {\n  listen 80;\n  server_name your-app.com;\n  root /app/frontend; # 前端文件部署的目录\n  index index.html;\n\n  # 处理 SPA 路由（如 Vue Router 的 history 模式）\n  location / {\n    try_files $uri $uri/ /index.html;\n  }\n\n  # 启用 gzip 压缩\n  gzip on;\n  gzip_types text/css application/javascript;\n}\n```\n\n---\n\n## ✅ 这种架构的优势\n1. **极致安全**：\n    - 内部服务器**完全不用暴露到公网**，攻击者无法直接扫描到。\n    - 所有部署操作都经过**加密隧道**和**严格审计**。\n2. **权限清晰**：\n    - 开发者可能根本不知道目标服务器的密码，而是通过堡垒机的授权来访问，实现了权限最小化原则。\n3. **流程标准化**：\n    - 无论是谁部署，都必须走同一个通道，执行相同的流程，减少了人为出错的可能。\n4. **可追溯性**：\n    - 结合堡垒机的录像功能，可以清晰看到**谁**、在**什么时间**、**部署了什么**、**执行了什么命令**，便于故障排查和审计。\n\n## ⚠️ 注意事项\n+ **复杂度**：初始设置比直接部署到公网服务器要复杂，但长期来看收益巨大。\n+ **性能**：如果 CI/CD 服务器在海外，而跳板机和目标服务器在国内，传输大量文件可能会慢，可以考虑在目标服务器上直接构建。\n+ **成本**：需要维护额外的跳板机/堡垒机组件。\n\n**总结：** **OpenVPN + 跳板机/堡垒机的部署模式，是企业级前端工程部署的最佳实践之一。** 它通过牺牲一点点部署的便利性，换来了极高的安全性和规范性，非常适合对安全有要求的中大型项目。\n\n# SaaS使用的部署方式到底叫什么呢？\n描述：没有使用jenkins，开发者通过堡垒机连入目标网络中通过git拉取代码并执行打包命令后生成dist或build文件夹，执行shell脚本将打包后的静态资源放到对应的目标服务器的路径下。\n\n**手动或半自动的基于堡垒机的 Git 拉取部署。**\n\n更具体地说，它属于 **\"Git-Based Deployment\"** 的一种演变形式，核心特点是**通过安全堡垒机作为跳板，直接在目标环境或邻近网络中执行构建和部署**。\n\n## 🧩 这种部署模式的详细流程拆解\n\n<img src=\"/images/yjt中SaaS的前端部署方式.svg\" alt=\"yjt中SaaS的前端部署方式\" width=\"220\" height=\"auto\" style=\"display:block;\">\n\n\n它与纯CI/CD自动化部署的**核心区别**在于，流程图中**黄色框线**的部分（从 `git push` 到 `重启服务`）完全由**开发者手动触发和执行**，而非由CI/CD工具（如Jenkins、GitLab CI）自动触发。\n\n---\n\n## ⚙️ 这种模式的特点\n### 优点：\n1. **环境高度一致**：在**目标网络内**进行构建，可以有效避免“在我本地是好的”这类问题。构建环境与生产环境一致（操作系统、Node版本等）。\n2. **安全性高**：所有操作都通过受审计的堡垒机进行，目标服务器无需暴露到公网，也无需在本地和服务器之间开放额外的端口。\n3. **简单直接，无需复杂配置**：不需要搭建和维护一整套CI/CD系统（如Jenkins），对于小团队或项目初期来说，成本更低，更轻量。\n4. **依赖少**：只需要目标服务器上有Git和Node.js环境即可，不需要安装CI/CD的Agent。\n\n### 缺点：\n1. **自动化程度低**：严重依赖人工操作。开发者需要手动登录、执行一系列命令。容易因操作失误（比如忘了拉最新代码、在错误目录执行）导致部署失败。\n2. **无法实现真正的持续交付**：部署过程不是自动触发的，通常需要人工干预，无法做到代码一提交就自动测试和部署。\n3. **可追溯性较差**：虽然堡垒机会记录执行了哪些命令，但**“谁在什么时候部署了哪个版本的代码”** 这一信息没有与代码提交（Git Tag/Commit ID）强关联地记录下来。出问题时，需要回溯堡垒机日志。\n4. **效率较低**：每次部署都需要在服务器上重新执行完整的构建过程，占用服务器资源，如果服务器性能不佳，构建时间会很长。\n\n---\n\n## 🚀 如何优化这种模式？\n即使不引入Jenkins，也可以让这个流程变得更高效、更可靠：\n\n### 1. 编写自动化部署脚本\n将一系列手动命令写成一个Shell脚本，例如 `deploy.sh`，放在代码库根目录。\n\n**（这就是SaaS的做法）**\n\n```bash\n#!/bin/bash\n# deploy.sh\n\nset -e # 遇到错误就退出\n\necho \"1. Pulling latest code...\"\ngit pull origin main\n\necho \"2. Installing dependencies...\"\nnpm install\n\necho \"3. Building project...\"\nnpm run build\n\necho \"4. Backing up old version...\"\ntar -czf /app/backup/frontend-$(date +%Y%m%d-%H%M%S).tar.gz /usr/share/nginx/html/\n\necho \"5. Deploying new version...\"\nrsync -av --delete ./dist/ /usr/share/nginx/html/\n\necho \"6. Reloading Nginx...\"\nsudo systemctl reload nginx\n\necho \"Deployment completed successfully!\"\n```\n\n**使用方式：** 开发者登录后，只需要执行一条命令：\n\n```bash\nbash deploy.sh\n```\n\n### 2. 使用 Git Hooks（简单CI）\n在**代码服务器的Git仓库**上配置 `post-receive` Hook（例如使用Gitea），当收到`push`时，自动通知目标服务器执行拉取和部署脚本。这实现了简单的自动触发。\n\n### 3. 使用 SSH 直接执行远程命令\n开发者可以在本地电脑上通过一条命令完成部署，无需手动登录。\n\n```bash\nssh -J user@jumpbox-ip user@target-server-ip \"cd /path/to/project && bash deploy.sh\"\n```\n\n### 4. 引入版本标记\n在脚本中加入步骤，在部署成功后，给当前的提交打上一个Tag。\n\n```bash\ngit tag deploy-$(date +%Y%m%d-%H%M%S)\ngit push origin --tags\n```\n\n这样就能清晰地知道生产环境对应的是哪个代码版本。\n\n---\n\n## ✅ 总结\n这是一种 **“基于堡垒机的半自动 Git 拉取部署”**。\n\n+ **它不是什么？** 它不是全自动的CI/CD（如Jenkins Pipeline），也不是传统的FTP上传部署。\n+ **它是什么？** 它是一种在**安全约束条件下**、**介于手动部署和全自动部署之间**的实用型方案。\n\n**适用场景：**\n\n+ 内部系统、管理后台等对发布频率要求不高的项目。\n+ 团队规模较小，尚未引入完整CI/CD工具链的初期阶段。\n+ 对安全性要求极高，所有内部网络访问必须通过堡垒机的环境。\n\n对于很多项目来说，这是一个非常好的起点。随着项目发展，当您觉得每次手动运行脚本也很麻烦时，就是考虑引入 **GitLab CI/CD、Github Actions** 等真正自动化工具的时候了。\n\n# <font style=\"color:#FFFFFF;background-color:#ED740C;\"> 待完善内容 </font>\n- [ ] CI/CD工具：jekins\n- [ ] Docker\n\n","source":"_posts/前端部署详解.md","raw":"---\ntitle: 前端部署详解\ndate: 2025-03-26\ntags: [部署, 前端, CI/CD]\ncategories: 前端\n---\n\n# CI/CD\n## 🧠 核心概念：CI/CD是什么？\nCI/CD 是现代软件工程中的一套最佳实践和方法论，旨在自动化软件的集成、测试和部署流程。它由两个部分组成：\n\nCI - 持续集成 (Continuous Integration)\n\nCD - 持续交付/持续部署 (Continuous Delivery / Continuous Deployment)\n\n可以把 CI/CD 想象成一个全自动的软件装配流水线。开发者提交代码（如同送上原料），流水线会自动进行一系列质量检测、打包和发布，最终将合格的产品交付给用户。\n\n## 🔧 详解两个部分\n### 1. CI - 持续集成\n**核心思想：** 开发者频繁地将代码更改合并到共享的主干分支（如每天多次）。每次合并都会自动触发一系列构建和测试，以便快速发现和修复错误。\n\n<img src=\"/images/CI流程.svg\" alt=\"CI流程\" width=\"300\" height=\"auto\" style=\"display:block;\">\n\n\n\n**好处：**\n\n+ ✅ **快速发现错误**：问题在引入后几分钟内就能被发现。\n+ ✅ **减少集成冲突**：频繁合并小批量代码，避免在发布前一次性合并大量代码带来的巨大冲突。\n+ ✅ 提高代码质量**：自动化测试保障了代码标准。\n\n### 2. CD - 持续交付 / 持续部署\n**CD 有两种细微差别的含义：**\n\n#### a) 持续交付 (Continuous Delivery)\n**核心思想：** CI流程结束后，代码总是处于**可随时、一键手动部署**到生产环境的状态。\n\n**流程：** `代码 -> CI -> 生成制品 -> 等待手动点击部署`\n\n#### b) 持续部署 (Continuous Deployment)\n**核心思想：** 这是持续交付的更高阶段。只要代码通过所有测试流程，就**自动地、无需人工干预地**部署到生产环境。\n\n**流程：** `代码 -> CI -> 生成制品 -> 自动部署到生产环境`\n\n可以这样理解：\n\n+ **持续交付** = \"软件已经打包好放在门口了，你随时可以签收（手动部署）。\"\n+ **持续部署** = \"软件通过质检后，快递机器人自动送货上门（自动部署）。\"\n\n## 🛠️ CI/CD 工具链\n整个流程依赖于一系列自动化工具，常见的工具有：\n\n| **阶段** | **流行工具** |\n| --- | --- |\n| **源代码管理****** | Git (GitLab, GitHub, Gitee) |\n| **CI/CD 流水线引擎** | **Jenkins**, GitLab CI/CD, GitHub Actions, Drone |\n| **构建工具** | Maven, Gradle (Java), npm, Webpack (JS), Make |\n| **测试工具** | JUnit, Selenium, Jest, Cypress |\n| **部署工具** | Ansible, Kubernetes, Docker, Terraform |\n| **监控工具** | Prometheus, Grafana, ELK Stack |\n\n\n## 💡 为什么需要 CI/CD？它的价值是什么？\n1. **加速开发流程**\n    - 自动化代替手动操作，释放开发者的生产力。\n    - 快速反馈，开发者能立即知道这次提交是否破坏了系统。\n2. **提高软件质量**\n    - 通过自动化测试在早期发现缺陷，修复成本远低于生产环境才发现。\n    - 代码规范、安全漏洞扫描等流程被标准化。\n3. **降低发布风险**\n    - 小批量、频繁的发布使得每次变更的内容很少。如果出现问题，可以快速定位和回滚。\n    - 传统的\"半年发布一次，一次改动500个功能\"的方式风险极高。\n4. **增强项目可见性**\n    - 每个人都能清晰地看到代码从提交到部署的整个状态，构建是否成功、测试是否通过。\n\n## ✅ 总结\n**CI/CD** 是一套通过**自动化**来**优化软件开发生命周期**的实践，其核心目标是：\n\n+ **更快的发布速度**\n+ **更高质量的软件**\n+ **更低的发布风险**\n\n它不是某个特定的工具，而是一种文化和流程的变革，是现代DevOps理念的核心支柱，已经成为中大型软件开发团队的标配。\n\n# OpenVpn与跳板机/堡垒机\n## 🔧 什么是 OpenVPN 客户端？\n**OpenVPN 客户端**是一个安装在您本地设备（如电脑、手机）上的**软件程序**。\n\n它的核心功能是：**根据配置文件（.ovpn 文件），与远端的 OpenVPN 服务器建立一条加密的、安全的隧道连接。**\n\n+ **它是什么？** 一个软件（例如：OpenVPN Connect、Tunnelblick等）。\n+ **它在哪里运行？** 在你的个人设备上（Windows PC, Mac, Linux, 手机）。\n+ **它的作用？** 创建加密通道，让你的所有或指定网络流量都通过这个通道流向VPN服务器。\n\n**就像一个专门的电话（客户端），用于拨打一个安全的号码（服务器）。**\n\n---\n\n## 🖥️ 什么是跳板机？\n**跳板机**（Jump Server / Bastion Host）是一台位于某个特定网络区域（如公司内网）的**服务器**。\n\n它的核心功能是：**作为一个唯一的、受严格控制的访问入口，所有外部人员必须先连接到这台服务器，才能进一步访问目标网络内部的其他设备。**\n\n+ **它是什么？** 一台物理或虚拟的服务器/计算机。\n+ **它在哪里运行？** 在目标网络的入口处（例如公司机房或公有云上）。\n+ **它的作用？** 提供访问桥梁和安全审计。所有操作都通过它进行，便于监控和记录日志。\n\n**就像是大楼的门卫室（跳板机），所有访客（用户）必须先在门卫室登记、核实身份，由门卫带领才能进入大楼内部（内网）。**\n\n---\n\n## 🔄 它们如何协同工作？（两者的关系）\nOpenVPN 客户端和跳板机通常**配合使用**，但它们扮演完全不同的角色。\n\n### 工作流程分解：\n#### 阶段一：建立安全隧道（认证与连接）\n1. **配置加载**：用户在自己的电脑上启动OpenVPN客户端软件，并加载管理员提供的 `.ovpn`配置文件。这个文件包含了连接所需的所有信息：\n    - **跳板机的公网IP/域名**\n    - 加密算法和协议类型\n    - **CA根证书**（用于验证服务器身份）\n    - **客户端证书和私钥**（用于向服务器证明自身身份）\n    - 其他参数（如使用的端口、是否使用密码等）\n2. **发起连接**：客户端根据配置，向跳板机的公网IP和指定端口发起TCP/UDP连接请求。\n3. **TLS双向认证**（最关键的安全步骤）：\n    - **服务器认证**：跳板机上的OpenVPN服务端将自己的证书发给客户端。客户端用CA根证书验证服务器证书的有效性，**确保连接的是真正的公司跳板机，而不是钓鱼服务器**。\n    - **客户端认证**：客户端将自己的证书和私钥签名发给服务器。服务器用CA根证书验证客户端证书，**确保连接的是授权员工，而不是外人**。\n    - 这个过程通常还辅以用户名/密码认证。\n4. **隧道建立**：认证通过后，双方利用协商好的密钥，建立一条**加密隧道**。跳板机为客户端分配一个内网IP地址（如 `10.8.0.100`）。此时，用户的电脑在逻辑上已经“接入”了公司内网。\n\n#### 阶段二：访问内部资源（路由与转发）\n1. **发起访问请求**：用户需要访问内网的一台Web服务器（`192.168.1.100`）。他在本地使用SSH命令：`ssh developer@192.168.1.100`。\n2. **流量封装与路由**：\n    - 客户端的操作系统会根据路由表规则，将所有发往 `192.168.1.0/24` 网段的流量，都指向OpenVPN创建的虚拟网卡。\n    - OpenVPN客户端将原始的SSH数据包（TCP协议）**整个加密并包裹（封装）** 在一个新的数据包内，这个新数据包的目的地是跳板机的公网IP。\n    - 这个加密后的数据包通过互联网发送到跳板机。\n3. **跳板机处理**（流量枢纽）：\n    - 跳板机上的OpenVPN服务端**解密**收到的数据包，**解出**原始的SSH请求数据包。\n    - 跳板机的**操作系统内核**根据其自身的路由表，发现这个目标是 `192.168.1.100` 的数据包需要从其内部网卡（如 `eth0`）发出。\n    - **防火墙和访问控制**：在转发前，跳板机上的防火墙规则（如 `iptables`）会进行检查，判断源IP（`10.8.0.100`）是否有权限访问目标IP（`192.168.1.100`）的22端口。通过后，才将数据包转发给目标Web服务器。\n4. **响应返回**：\n    - Web服务器处理SSH请求后，将响应包发回给跳板机（因为请求的来源IP是跳板机）。\n    - 跳板机收到响应后，再将其加密，通过隧道发回给远端的用户客户端。\n    - 客户端解密后，得到原始的SSH响应，完成一次完整的交互。\n\n#### 🛡️ 核心价值与优势\n这种架构的优势在于提供了**双重安全性和极佳的可管理性**：\n\n1. **强身份认证**：通过证书方式，同时验证了服务器和客户端的身份，避免了密码泄露和中间人攻击。\n2. **通信加密**：所有数据在公网上传输时都是加密的，保证机密性。\n3. **访问隔离**：跳板机成为唯一的入口，外部无法直接访问任何其他内网机器，攻击面最小化。\n4. **集中审计与管控**：所有对内网的访问都必须经过跳板机，便于**记录完整的操作日志**、**监控会话**和**统一设置访问权限策略**。管理员只需要在跳板机上修改规则，就可以控制所有用户的权限。\n\n### 结论：\n+ **OpenVPN客户端**是您用来**连接**的**软件**。\n+ **跳板机**是您**连接上去**的那台**服务器**。\n+ OpenVPN是**实现安全连接的方式之一**，而跳板机是**一种网络访问策略和架构**。\n\n您可以**不使用OpenVPN**而用其他方式（如SSH）登录跳板机；也可以**使用OpenVPN**连接到一台**不是跳板机**的服务器（例如只是为了加密咖啡店的公共Wi-Fi流量）。\n\n但当它们结合时，就构成了一个非常经典和强大的安全远程访问方案。\n\n## 🧠 什么是堡垒机？\n如果说「跳板机」是一个基础概念，那么「堡垒机」就是它的**完全体、企业级、工业化**的形态。\n\n**堡垒机**（Bastion Host）是一种位于内部网络和外部网络之间的**高性能、高安全性的专用服务器**，其核心设计理念是 **“网络要塞”** 。所有内部设备的远程访问（如 SSH, RDP, SFTP）都必须通过它进行，它作为唯一的入口点，集中进行**身份认证、授权、审计和监控**。\n\n您可以把它想象成一个**极其严格的银行金库门卫**：\n\n1. **唯一入口**：所有人都必须从这个门进出。\n2. **严格安检**：需要多重身份验证（工牌、指纹、密码）。\n3. **权限分明**：你只能进入你有权限进入的区域（金库、柜台、办公室）。\n4. **全程监控**：你进去后的一举一动都被全程录像，说了什么话（执行的命令）、拿了什么东西（传输的文件）都有记录。\n\n---\n\n### 🆚 堡垒机 vs. 简单跳板机：有何不同？\n很多人会混用这两个词，但它们有本质上的区别：\n\n| **特性** | **简单跳板机 (Jump Server)** | **堡垒机 (Bastion Host)** |\n| --- | --- | --- |\n| **核心功能** | **网络转发**、基础连接 | **4A管理**：认证、授权、账号、审计 |\n| **安全性** | 相对较低，依赖系统自身安全 | **极高**，有专门的安全加固和防护 |\n| **用户体验** | 命令行，原始 | **Web图形化界面**，易于操作 |\n| **权限控制** | 粗粒度（能/不能登录某台机器） | **细粒度**（能登录，且只能执行某些命令） |\n| **审计能力** | 基础日志（谁什么时候登录了） | **强大审计****：****   ****-**** ****会话录像**（全程录屏）   - **命令记录**（精确到每一条命令）   - **文件传输记录** |\n| **账号管理** | 分散在各台服务器上 | **统一账号管理**，单点登录（SSO） |\n| **本质** | **一台功能单一的服务器** | **一套完整的安全运维管控系统** |\n\n\n**简单说：跳板机主要解决“**怎么进去**”的问题，而堡垒机在此基础上，更解决了“**谁能进**”、“**能干什么**”和“**干了什么**”的问题。**\n\n---\n\n### 🛡️ 堡垒机的核心功能（4A管理）\n#### 1. 认证 (Authentication)：“你是谁？”\n+ **多种认证方式**：支持密码、SSH密钥、动态令牌（如Google Authenticator）、LDAP/AD域集成、生物识别等。\n+ **多因子认证 (MFA)**：强制要求使用两种及以上方式验证身份，极大提升安全性。\n\n#### 2. 授权 (Authorization)：“你能干什么？”\n+ **精细化的权限控制**：\n    - **主机权限**：允许用户访问哪些服务器（如：只能访问Web服务器，不能访问数据库服务器）。\n    - **操作权限**：允许用户执行哪些命令（如：可以执行 `systemctl restart nginx`，但不能执行 `rm -rf /`）。\n    - **时间权限**：允许用户在什么时间段内访问（如：只能在工作时间访问）。\n+ **临时权限申请与审批**：如果需要临时获得更高权限，可以通过工单系统申请，由管理员审批后自动授权，过期自动回收。\n\n#### 3. 账号 (Account)：“你的身份是什么？”\n+ **统一账号管理**：在堡垒机上创建账号，即可映射到后端的多台服务器，无需在每个服务器上单独创建账号。实现了“一个堡垒机账号，访问所有授权资产”。\n+ **托管服务器账号**：服务器账号和密码可以由堡垒机托管，用户无需知道目标服务器的真实密码。\n\n#### 4. 审计 (Audit)：“你干了什么？”（这是堡垒机的灵魂）\n+ ****会话录像 (Session Recording)**：** 像录屏一样，完整记录用户在目标服务器上的**所有操作过程**，包括敲打的命令、返回的结果。无法抵赖。\n+ **命令记录**：详细记录执行过的每一条命令及其时间、来源IP。\n+ **文件传输审计**：记录所有通过SFTP/SCP/RDP上传和下载的文件日志。\n+ **行为分析**：对异常操作、危险命令（如 `rm`、`chmod`）进行实时告警。\n\n---\n\n### 🏗️ 堡垒机的工作流程\n下图以一个运维人员需要通过堡垒机修复网站为例，展示了其核心工作流程与4A功能：\n\n<img src=\"/images/堡垒机工作流程.svg\" alt=\"堡垒机工作流程\" width=\"240\" height=\"auto\" style=\"display:block;\">\n\n\n\n---\n\n### 🚀 常见的堡垒机方案\n1. **开源方案**：\n    - **Jumpserver**：国内最流行的开源堡垒机，功能全面，对中文支持好，社区活跃。\n    - **Teleport**：现代、轻量级，对云原生和Kubernetes环境支持良好。\n    - **Apache Guacamole**：无客户端堡垒机，通过浏览器即可实现RDP、SSH、VNC等连接。\n2. **商业方案**：\n    - **齐治堡垒机**：国内老牌商业产品，市场份额大。\n    - ** Cisco Secure Access (前Duo)**、**CyberArk**：国际知名的商业解决方案，功能强大，价格昂贵。\n\n---\n\n### ✅ 总结：为什么需要堡垒机？\n1. **安全第一**：极大缩小了网络攻击面，保护了内部资产。\n2. **合规要求**：满足等保2.0、ISO27001、GDPR等法规对运维审计的强制性要求。\n3. **权限清晰**：实现最小权限原则，避免权限滥用。\n4. **责任界定**：出现问题时，可以通过录像和日志快速定位责任人、还原事故现场。\n5. **运维效率**：统一入口，简化了账号管理和访问流程。\n\n简而言之，堡垒机是企业IT基础设施中**不可或缺的安全与审计基石**，尤其对于金融、政府、互联网等对安全性和合规性要求极高的行业来说，是标配产品。\n\n# OpenVpn+跳板机/堡垒机实现前端部署\n这是一个非常经典的DevOps场景：OpenVpn+跳板机/堡垒机与前端工程部署结合起来，可以构建一个既安全又高效的部署流程。\n\n这种架构的核心思想是：通过 OpenVPN 建立安全通道，通过跳板机/堡垒机作为统一、受控的入口，来执行部署操作。\n\n## 🧩 核心架构与角色分工\n在这种架构下，各个组件的职责非常清晰：\n\n1. **OpenVPN Server**：**负责建“路”**。建立一条从开发者本地到部署环境的加密隧道，确保传输安全。\n2. **跳板机/堡垒机 (Bastion Host)**：**负责管“门”和看“人”**。它是唯一的部署操作入口，负责身份验证、权限控制和操作审计。\n3. **部署目标服务器**：**负责住“应用”**。这是最终运行前端项目（Nginx, Node.js 等）的服务器。\n4. **CI/CD 工具 (可选但推荐)**：**负责自动“开车”**。例如 Jenkins、GitLab Runner 等，它们可以自动从仓库拉取代码、构建，并通过跳板机执行部署脚本。\n\n整个从前端代码到部署上线的安全部署流程，如图所述：\n\n<img src=\"/images/OpenVpn+堡垒机结合前端部署.svg\" alt=\"OpenVpn+堡垒机结合前端部署\" width=\"400\" height=\"auto\" style=\"display:block;\">\n\n\n\n\n## 🛠️ 两种常见的部署模式\n### 模式一：手动部署（适合小团队或初期）\n**流程：** 开发者本地构建，然后通过跳板机手动上传文件。\n\n**本地构建**：\n\n```bash\nnpm run build\n```\n\n这会在项目根目录生成 `dist` 或 `build` 文件夹，里面是静态文件（HTML, CSS, JS）。\n\n1. **连接VPN**：确保 OpenVPN 客户端已连接，获得访问内网的权限。\n2. **通过跳板机上传文件**：\n\n```bash\n# 使用 scp 命令，通过跳板机转发到目标服务器\n# 注意：跳板机需要配置SSH代理转发或用户有直接权限\nscp -r -o 'ProxyJump user@jumpbox-ip' ./dist/* user@target-server-ip:/path/to/nginx/html/\n\n# 或者使用更现代的 rsync\nrsync -avz -e \"ssh -J user@jumpbox-ip\" ./dist/ user@target-server-ip:/path/to/nginx/html/\n```\n\n3. **通过跳板机执行远程命令**（如果需要）：\n\n```bash\n# 登录跳板机，再从跳板机SSH到目标服务器\nssh user@jumpbox-ip\n# 然后，在跳板机上执行\nssh user@target-server-ip \"sudo nginx -s reload\"\n```\n\n### 模式二：自动化部署（推荐，适合成熟团队）\n**流程：** CI/CD 工具（如 Jenkins、GitLab CI）在检测到 Git 标签或特定分支更新后，自动完成所有步骤。\n\n这是一个在 GitLab 中实现的自动化部署流程示例：\n\n```yaml\n# .gitlab-ci.yml\n\nstages:\n  - build\n  - deploy\n\nbuild_production:\n  stage: build\n  image: node:16\n  rules:\n    - if: $CI_COMMIT_TAG # 通常在打标签时触发生产环境部署\n  script:\n    - npm install\n    - npm run build\n  artifacts:\n    paths:\n      - dist/ # 将构建产物传递给下一个阶段\n\ndeploy_to_production:\n  stage: deploy\n  image: alpine\n  rules:\n    - if: $CI_COMMIT_TAG\n  script:\n    - apk add --no-cache openssh-client rsync\n    # 使用 SSH 通过跳板机部署 (-o ProxyJump)\n    - rsync -avz --delete -e \"ssh -o StrictHostKeyChecking=no -J $JUMPBOX_USER@$JUMPBOX_IP\" dist/ $TARGET_SERVER_USER@$TARGET_SERVER_IP:/app/frontend/\n    # 通过跳板机执行远程命令，重启服务\n    - ssh -J $JUMPBOX_USER@$JUMPBOX_IP $TARGET_SERVER_USER@$TARGET_SERVER_IP \"sudo systemctl reload nginx\"\n```\n\n**关键点：**\n\n+ `$JUMPBOX_IP`, `$TARGET_SERVER_IP` 等变量在 GitLab 的 **CI/CD 设置**中配置，避免写在代码里。\n+ `-J` 参数是 SSH 的 **代理跳跃**，让 SSH 连接自动通过跳板机。\n+ 堡垒机上需要存放 CI/CD 工具的 **SSH 私钥**，并且该密钥对目标服务器有访问权限。\n\n---\n\n## ⚙️ 部署前的重要准备工作\n1. **网络与权限配置**：\n    - 确保 OpenVPN 服务器配置的路由规则，能让客户端访问到跳板机和目标服务器。\n    - 在跳板机上为每个开发者或CI/CD服务创建账号，并配置严格的 SSH 密钥认证。\n    - 配置跳板机的权限控制，确保用户只能访问特定的目标服务器。\n2. **堡垒机审计**：\n    - 开启堡垒机的会话录制功能，记录所有通过它执行的部署命令和文件传输操作。一旦出问题，可以快速回放定位。\n3. **目标服务器配置**：\n    - **Nginx 配置示例**：\n\n```nginx\nserver {\n  listen 80;\n  server_name your-app.com;\n  root /app/frontend; # 前端文件部署的目录\n  index index.html;\n\n  # 处理 SPA 路由（如 Vue Router 的 history 模式）\n  location / {\n    try_files $uri $uri/ /index.html;\n  }\n\n  # 启用 gzip 压缩\n  gzip on;\n  gzip_types text/css application/javascript;\n}\n```\n\n---\n\n## ✅ 这种架构的优势\n1. **极致安全**：\n    - 内部服务器**完全不用暴露到公网**，攻击者无法直接扫描到。\n    - 所有部署操作都经过**加密隧道**和**严格审计**。\n2. **权限清晰**：\n    - 开发者可能根本不知道目标服务器的密码，而是通过堡垒机的授权来访问，实现了权限最小化原则。\n3. **流程标准化**：\n    - 无论是谁部署，都必须走同一个通道，执行相同的流程，减少了人为出错的可能。\n4. **可追溯性**：\n    - 结合堡垒机的录像功能，可以清晰看到**谁**、在**什么时间**、**部署了什么**、**执行了什么命令**，便于故障排查和审计。\n\n## ⚠️ 注意事项\n+ **复杂度**：初始设置比直接部署到公网服务器要复杂，但长期来看收益巨大。\n+ **性能**：如果 CI/CD 服务器在海外，而跳板机和目标服务器在国内，传输大量文件可能会慢，可以考虑在目标服务器上直接构建。\n+ **成本**：需要维护额外的跳板机/堡垒机组件。\n\n**总结：** **OpenVPN + 跳板机/堡垒机的部署模式，是企业级前端工程部署的最佳实践之一。** 它通过牺牲一点点部署的便利性，换来了极高的安全性和规范性，非常适合对安全有要求的中大型项目。\n\n# SaaS使用的部署方式到底叫什么呢？\n描述：没有使用jenkins，开发者通过堡垒机连入目标网络中通过git拉取代码并执行打包命令后生成dist或build文件夹，执行shell脚本将打包后的静态资源放到对应的目标服务器的路径下。\n\n**手动或半自动的基于堡垒机的 Git 拉取部署。**\n\n更具体地说，它属于 **\"Git-Based Deployment\"** 的一种演变形式，核心特点是**通过安全堡垒机作为跳板，直接在目标环境或邻近网络中执行构建和部署**。\n\n## 🧩 这种部署模式的详细流程拆解\n\n<img src=\"/images/yjt中SaaS的前端部署方式.svg\" alt=\"yjt中SaaS的前端部署方式\" width=\"220\" height=\"auto\" style=\"display:block;\">\n\n\n它与纯CI/CD自动化部署的**核心区别**在于，流程图中**黄色框线**的部分（从 `git push` 到 `重启服务`）完全由**开发者手动触发和执行**，而非由CI/CD工具（如Jenkins、GitLab CI）自动触发。\n\n---\n\n## ⚙️ 这种模式的特点\n### 优点：\n1. **环境高度一致**：在**目标网络内**进行构建，可以有效避免“在我本地是好的”这类问题。构建环境与生产环境一致（操作系统、Node版本等）。\n2. **安全性高**：所有操作都通过受审计的堡垒机进行，目标服务器无需暴露到公网，也无需在本地和服务器之间开放额外的端口。\n3. **简单直接，无需复杂配置**：不需要搭建和维护一整套CI/CD系统（如Jenkins），对于小团队或项目初期来说，成本更低，更轻量。\n4. **依赖少**：只需要目标服务器上有Git和Node.js环境即可，不需要安装CI/CD的Agent。\n\n### 缺点：\n1. **自动化程度低**：严重依赖人工操作。开发者需要手动登录、执行一系列命令。容易因操作失误（比如忘了拉最新代码、在错误目录执行）导致部署失败。\n2. **无法实现真正的持续交付**：部署过程不是自动触发的，通常需要人工干预，无法做到代码一提交就自动测试和部署。\n3. **可追溯性较差**：虽然堡垒机会记录执行了哪些命令，但**“谁在什么时候部署了哪个版本的代码”** 这一信息没有与代码提交（Git Tag/Commit ID）强关联地记录下来。出问题时，需要回溯堡垒机日志。\n4. **效率较低**：每次部署都需要在服务器上重新执行完整的构建过程，占用服务器资源，如果服务器性能不佳，构建时间会很长。\n\n---\n\n## 🚀 如何优化这种模式？\n即使不引入Jenkins，也可以让这个流程变得更高效、更可靠：\n\n### 1. 编写自动化部署脚本\n将一系列手动命令写成一个Shell脚本，例如 `deploy.sh`，放在代码库根目录。\n\n**（这就是SaaS的做法）**\n\n```bash\n#!/bin/bash\n# deploy.sh\n\nset -e # 遇到错误就退出\n\necho \"1. Pulling latest code...\"\ngit pull origin main\n\necho \"2. Installing dependencies...\"\nnpm install\n\necho \"3. Building project...\"\nnpm run build\n\necho \"4. Backing up old version...\"\ntar -czf /app/backup/frontend-$(date +%Y%m%d-%H%M%S).tar.gz /usr/share/nginx/html/\n\necho \"5. Deploying new version...\"\nrsync -av --delete ./dist/ /usr/share/nginx/html/\n\necho \"6. Reloading Nginx...\"\nsudo systemctl reload nginx\n\necho \"Deployment completed successfully!\"\n```\n\n**使用方式：** 开发者登录后，只需要执行一条命令：\n\n```bash\nbash deploy.sh\n```\n\n### 2. 使用 Git Hooks（简单CI）\n在**代码服务器的Git仓库**上配置 `post-receive` Hook（例如使用Gitea），当收到`push`时，自动通知目标服务器执行拉取和部署脚本。这实现了简单的自动触发。\n\n### 3. 使用 SSH 直接执行远程命令\n开发者可以在本地电脑上通过一条命令完成部署，无需手动登录。\n\n```bash\nssh -J user@jumpbox-ip user@target-server-ip \"cd /path/to/project && bash deploy.sh\"\n```\n\n### 4. 引入版本标记\n在脚本中加入步骤，在部署成功后，给当前的提交打上一个Tag。\n\n```bash\ngit tag deploy-$(date +%Y%m%d-%H%M%S)\ngit push origin --tags\n```\n\n这样就能清晰地知道生产环境对应的是哪个代码版本。\n\n---\n\n## ✅ 总结\n这是一种 **“基于堡垒机的半自动 Git 拉取部署”**。\n\n+ **它不是什么？** 它不是全自动的CI/CD（如Jenkins Pipeline），也不是传统的FTP上传部署。\n+ **它是什么？** 它是一种在**安全约束条件下**、**介于手动部署和全自动部署之间**的实用型方案。\n\n**适用场景：**\n\n+ 内部系统、管理后台等对发布频率要求不高的项目。\n+ 团队规模较小，尚未引入完整CI/CD工具链的初期阶段。\n+ 对安全性要求极高，所有内部网络访问必须通过堡垒机的环境。\n\n对于很多项目来说，这是一个非常好的起点。随着项目发展，当您觉得每次手动运行脚本也很麻烦时，就是考虑引入 **GitLab CI/CD、Github Actions** 等真正自动化工具的时候了。\n\n# <font style=\"color:#FFFFFF;background-color:#ED740C;\"> 待完善内容 </font>\n- [ ] CI/CD工具：jekins\n- [ ] Docker\n\n","slug":"前端部署详解","published":1,"updated":"2025-09-14T12:31:59.223Z","_id":"cmfjktvt00000tx5w8wom0bev","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"CI-CD\"><a href=\"#CI-CD\" class=\"headerlink\" title=\"CI&#x2F;CD\"></a>CI&#x2F;CD</h1><h2 id=\"🧠-核心概念：CI-CD是什么？\"><a href=\"#🧠-核心概念：CI-CD是什么？\" class=\"headerlink\" title=\"🧠 核心概念：CI&#x2F;CD是什么？\"></a>🧠 核心概念：CI&#x2F;CD是什么？</h2><p>CI&#x2F;CD 是现代软件工程中的一套最佳实践和方法论，旨在自动化软件的集成、测试和部署流程。它由两个部分组成：</p>\n<p>CI - 持续集成 (Continuous Integration)</p>\n<p>CD - 持续交付&#x2F;持续部署 (Continuous Delivery &#x2F; Continuous Deployment)</p>\n<p>可以把 CI&#x2F;CD 想象成一个全自动的软件装配流水线。开发者提交代码（如同送上原料），流水线会自动进行一系列质量检测、打包和发布，最终将合格的产品交付给用户。</p>\n<h2 id=\"🔧-详解两个部分\"><a href=\"#🔧-详解两个部分\" class=\"headerlink\" title=\"🔧 详解两个部分\"></a>🔧 详解两个部分</h2><h3 id=\"1-CI-持续集成\"><a href=\"#1-CI-持续集成\" class=\"headerlink\" title=\"1. CI - 持续集成\"></a>1. CI - 持续集成</h3><p><strong>核心思想：</strong> 开发者频繁地将代码更改合并到共享的主干分支（如每天多次）。每次合并都会自动触发一系列构建和测试，以便快速发现和修复错误。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/CI流程.svg\"\n                      alt=\"CI流程\" width=\"300\" height=\"auto\" style=\"display:block;\"\n                >\n\n\n\n<p><strong>好处：</strong></p>\n<ul>\n<li>✅ <strong>快速发现错误</strong>：问题在引入后几分钟内就能被发现。</li>\n<li>✅ <strong>减少集成冲突</strong>：频繁合并小批量代码，避免在发布前一次性合并大量代码带来的巨大冲突。</li>\n<li>✅ 提高代码质量**：自动化测试保障了代码标准。</li>\n</ul>\n<h3 id=\"2-CD-持续交付-持续部署\"><a href=\"#2-CD-持续交付-持续部署\" class=\"headerlink\" title=\"2. CD - 持续交付 &#x2F; 持续部署\"></a>2. CD - 持续交付 &#x2F; 持续部署</h3><p><strong>CD 有两种细微差别的含义：</strong></p>\n<h4 id=\"a-持续交付-Continuous-Delivery\"><a href=\"#a-持续交付-Continuous-Delivery\" class=\"headerlink\" title=\"a) 持续交付 (Continuous Delivery)\"></a>a) 持续交付 (Continuous Delivery)</h4><p><strong>核心思想：</strong> CI流程结束后，代码总是处于<strong>可随时、一键手动部署</strong>到生产环境的状态。</p>\n<p><strong>流程：</strong> <code>代码 -&gt; CI -&gt; 生成制品 -&gt; 等待手动点击部署</code></p>\n<h4 id=\"b-持续部署-Continuous-Deployment\"><a href=\"#b-持续部署-Continuous-Deployment\" class=\"headerlink\" title=\"b) 持续部署 (Continuous Deployment)\"></a>b) 持续部署 (Continuous Deployment)</h4><p><strong>核心思想：</strong> 这是持续交付的更高阶段。只要代码通过所有测试流程，就<strong>自动地、无需人工干预地</strong>部署到生产环境。</p>\n<p><strong>流程：</strong> <code>代码 -&gt; CI -&gt; 生成制品 -&gt; 自动部署到生产环境</code></p>\n<p>可以这样理解：</p>\n<ul>\n<li><strong>持续交付</strong> &#x3D; “软件已经打包好放在门口了，你随时可以签收（手动部署）。”</li>\n<li><strong>持续部署</strong> &#x3D; “软件通过质检后，快递机器人自动送货上门（自动部署）。”</li>\n</ul>\n<h2 id=\"🛠️-CI-CD-工具链\"><a href=\"#🛠️-CI-CD-工具链\" class=\"headerlink\" title=\"🛠️ CI&#x2F;CD 工具链\"></a>🛠️ CI&#x2F;CD 工具链</h2><p>整个流程依赖于一系列自动化工具，常见的工具有：</p>\n<table>\n<thead>\n<tr>\n<th><strong>阶段</strong></th>\n<th><strong>流行工具</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>源代码管理</strong>****</td>\n<td>Git (GitLab, GitHub, Gitee)</td>\n</tr>\n<tr>\n<td><strong>CI&#x2F;CD 流水线引擎</strong></td>\n<td><strong>Jenkins</strong>, GitLab CI&#x2F;CD, GitHub Actions, Drone</td>\n</tr>\n<tr>\n<td><strong>构建工具</strong></td>\n<td>Maven, Gradle (Java), npm, Webpack (JS), Make</td>\n</tr>\n<tr>\n<td><strong>测试工具</strong></td>\n<td>JUnit, Selenium, Jest, Cypress</td>\n</tr>\n<tr>\n<td><strong>部署工具</strong></td>\n<td>Ansible, Kubernetes, Docker, Terraform</td>\n</tr>\n<tr>\n<td><strong>监控工具</strong></td>\n<td>Prometheus, Grafana, ELK Stack</td>\n</tr>\n</tbody></table>\n<h2 id=\"💡-为什么需要-CI-CD？它的价值是什么？\"><a href=\"#💡-为什么需要-CI-CD？它的价值是什么？\" class=\"headerlink\" title=\"💡 为什么需要 CI&#x2F;CD？它的价值是什么？\"></a>💡 为什么需要 CI&#x2F;CD？它的价值是什么？</h2><ol>\n<li><strong>加速开发流程</strong><ul>\n<li>自动化代替手动操作，释放开发者的生产力。</li>\n<li>快速反馈，开发者能立即知道这次提交是否破坏了系统。</li>\n</ul>\n</li>\n<li><strong>提高软件质量</strong><ul>\n<li>通过自动化测试在早期发现缺陷，修复成本远低于生产环境才发现。</li>\n<li>代码规范、安全漏洞扫描等流程被标准化。</li>\n</ul>\n</li>\n<li><strong>降低发布风险</strong><ul>\n<li>小批量、频繁的发布使得每次变更的内容很少。如果出现问题，可以快速定位和回滚。</li>\n<li>传统的”半年发布一次，一次改动500个功能”的方式风险极高。</li>\n</ul>\n</li>\n<li><strong>增强项目可见性</strong><ul>\n<li>每个人都能清晰地看到代码从提交到部署的整个状态，构建是否成功、测试是否通过。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"✅-总结\"><a href=\"#✅-总结\" class=\"headerlink\" title=\"✅ 总结\"></a>✅ 总结</h2><p><strong>CI&#x2F;CD</strong> 是一套通过<strong>自动化</strong>来<strong>优化软件开发生命周期</strong>的实践，其核心目标是：</p>\n<ul>\n<li><strong>更快的发布速度</strong></li>\n<li><strong>更高质量的软件</strong></li>\n<li><strong>更低的发布风险</strong></li>\n</ul>\n<p>它不是某个特定的工具，而是一种文化和流程的变革，是现代DevOps理念的核心支柱，已经成为中大型软件开发团队的标配。</p>\n<h1 id=\"OpenVpn与跳板机-堡垒机\"><a href=\"#OpenVpn与跳板机-堡垒机\" class=\"headerlink\" title=\"OpenVpn与跳板机&#x2F;堡垒机\"></a>OpenVpn与跳板机&#x2F;堡垒机</h1><h2 id=\"🔧-什么是-OpenVPN-客户端？\"><a href=\"#🔧-什么是-OpenVPN-客户端？\" class=\"headerlink\" title=\"🔧 什么是 OpenVPN 客户端？\"></a>🔧 什么是 OpenVPN 客户端？</h2><p><strong>OpenVPN 客户端</strong>是一个安装在您本地设备（如电脑、手机）上的<strong>软件程序</strong>。</p>\n<p>它的核心功能是：<strong>根据配置文件（.ovpn 文件），与远端的 OpenVPN 服务器建立一条加密的、安全的隧道连接。</strong></p>\n<ul>\n<li><strong>它是什么？</strong> 一个软件（例如：OpenVPN Connect、Tunnelblick等）。</li>\n<li><strong>它在哪里运行？</strong> 在你的个人设备上（Windows PC, Mac, Linux, 手机）。</li>\n<li><strong>它的作用？</strong> 创建加密通道，让你的所有或指定网络流量都通过这个通道流向VPN服务器。</li>\n</ul>\n<p><strong>就像一个专门的电话（客户端），用于拨打一个安全的号码（服务器）。</strong></p>\n<hr>\n<h2 id=\"🖥️-什么是跳板机？\"><a href=\"#🖥️-什么是跳板机？\" class=\"headerlink\" title=\"🖥️ 什么是跳板机？\"></a>🖥️ 什么是跳板机？</h2><p><strong>跳板机</strong>（Jump Server &#x2F; Bastion Host）是一台位于某个特定网络区域（如公司内网）的<strong>服务器</strong>。</p>\n<p>它的核心功能是：<strong>作为一个唯一的、受严格控制的访问入口，所有外部人员必须先连接到这台服务器，才能进一步访问目标网络内部的其他设备。</strong></p>\n<ul>\n<li><strong>它是什么？</strong> 一台物理或虚拟的服务器&#x2F;计算机。</li>\n<li><strong>它在哪里运行？</strong> 在目标网络的入口处（例如公司机房或公有云上）。</li>\n<li><strong>它的作用？</strong> 提供访问桥梁和安全审计。所有操作都通过它进行，便于监控和记录日志。</li>\n</ul>\n<p><strong>就像是大楼的门卫室（跳板机），所有访客（用户）必须先在门卫室登记、核实身份，由门卫带领才能进入大楼内部（内网）。</strong></p>\n<hr>\n<h2 id=\"🔄-它们如何协同工作？（两者的关系）\"><a href=\"#🔄-它们如何协同工作？（两者的关系）\" class=\"headerlink\" title=\"🔄 它们如何协同工作？（两者的关系）\"></a>🔄 它们如何协同工作？（两者的关系）</h2><p>OpenVPN 客户端和跳板机通常<strong>配合使用</strong>，但它们扮演完全不同的角色。</p>\n<h3 id=\"工作流程分解：\"><a href=\"#工作流程分解：\" class=\"headerlink\" title=\"工作流程分解：\"></a>工作流程分解：</h3><h4 id=\"阶段一：建立安全隧道（认证与连接）\"><a href=\"#阶段一：建立安全隧道（认证与连接）\" class=\"headerlink\" title=\"阶段一：建立安全隧道（认证与连接）\"></a>阶段一：建立安全隧道（认证与连接）</h4><ol>\n<li><strong>配置加载</strong>：用户在自己的电脑上启动OpenVPN客户端软件，并加载管理员提供的 <code>.ovpn</code>配置文件。这个文件包含了连接所需的所有信息：<ul>\n<li><strong>跳板机的公网IP&#x2F;域名</strong></li>\n<li>加密算法和协议类型</li>\n<li><strong>CA根证书</strong>（用于验证服务器身份）</li>\n<li><strong>客户端证书和私钥</strong>（用于向服务器证明自身身份）</li>\n<li>其他参数（如使用的端口、是否使用密码等）</li>\n</ul>\n</li>\n<li><strong>发起连接</strong>：客户端根据配置，向跳板机的公网IP和指定端口发起TCP&#x2F;UDP连接请求。</li>\n<li><strong>TLS双向认证</strong>（最关键的安全步骤）：<ul>\n<li><strong>服务器认证</strong>：跳板机上的OpenVPN服务端将自己的证书发给客户端。客户端用CA根证书验证服务器证书的有效性，<strong>确保连接的是真正的公司跳板机，而不是钓鱼服务器</strong>。</li>\n<li><strong>客户端认证</strong>：客户端将自己的证书和私钥签名发给服务器。服务器用CA根证书验证客户端证书，<strong>确保连接的是授权员工，而不是外人</strong>。</li>\n<li>这个过程通常还辅以用户名&#x2F;密码认证。</li>\n</ul>\n</li>\n<li><strong>隧道建立</strong>：认证通过后，双方利用协商好的密钥，建立一条<strong>加密隧道</strong>。跳板机为客户端分配一个内网IP地址（如 <code>10.8.0.100</code>）。此时，用户的电脑在逻辑上已经“接入”了公司内网。</li>\n</ol>\n<h4 id=\"阶段二：访问内部资源（路由与转发）\"><a href=\"#阶段二：访问内部资源（路由与转发）\" class=\"headerlink\" title=\"阶段二：访问内部资源（路由与转发）\"></a>阶段二：访问内部资源（路由与转发）</h4><ol>\n<li><strong>发起访问请求</strong>：用户需要访问内网的一台Web服务器（<code>192.168.1.100</code>）。他在本地使用SSH命令：<code>ssh developer@192.168.1.100</code>。</li>\n<li><strong>流量封装与路由</strong>：<ul>\n<li>客户端的操作系统会根据路由表规则，将所有发往 <code>192.168.1.0/24</code> 网段的流量，都指向OpenVPN创建的虚拟网卡。</li>\n<li>OpenVPN客户端将原始的SSH数据包（TCP协议）<strong>整个加密并包裹（封装）</strong> 在一个新的数据包内，这个新数据包的目的地是跳板机的公网IP。</li>\n<li>这个加密后的数据包通过互联网发送到跳板机。</li>\n</ul>\n</li>\n<li><strong>跳板机处理</strong>（流量枢纽）：<ul>\n<li>跳板机上的OpenVPN服务端<strong>解密</strong>收到的数据包，<strong>解出</strong>原始的SSH请求数据包。</li>\n<li>跳板机的<strong>操作系统内核</strong>根据其自身的路由表，发现这个目标是 <code>192.168.1.100</code> 的数据包需要从其内部网卡（如 <code>eth0</code>）发出。</li>\n<li><strong>防火墙和访问控制</strong>：在转发前，跳板机上的防火墙规则（如 <code>iptables</code>）会进行检查，判断源IP（<code>10.8.0.100</code>）是否有权限访问目标IP（<code>192.168.1.100</code>）的22端口。通过后，才将数据包转发给目标Web服务器。</li>\n</ul>\n</li>\n<li><strong>响应返回</strong>：<ul>\n<li>Web服务器处理SSH请求后，将响应包发回给跳板机（因为请求的来源IP是跳板机）。</li>\n<li>跳板机收到响应后，再将其加密，通过隧道发回给远端的用户客户端。</li>\n<li>客户端解密后，得到原始的SSH响应，完成一次完整的交互。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"🛡️-核心价值与优势\"><a href=\"#🛡️-核心价值与优势\" class=\"headerlink\" title=\"🛡️ 核心价值与优势\"></a>🛡️ 核心价值与优势</h4><p>这种架构的优势在于提供了<strong>双重安全性和极佳的可管理性</strong>：</p>\n<ol>\n<li><strong>强身份认证</strong>：通过证书方式，同时验证了服务器和客户端的身份，避免了密码泄露和中间人攻击。</li>\n<li><strong>通信加密</strong>：所有数据在公网上传输时都是加密的，保证机密性。</li>\n<li><strong>访问隔离</strong>：跳板机成为唯一的入口，外部无法直接访问任何其他内网机器，攻击面最小化。</li>\n<li><strong>集中审计与管控</strong>：所有对内网的访问都必须经过跳板机，便于<strong>记录完整的操作日志</strong>、<strong>监控会话</strong>和<strong>统一设置访问权限策略</strong>。管理员只需要在跳板机上修改规则，就可以控制所有用户的权限。</li>\n</ol>\n<h3 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h3><ul>\n<li><strong>OpenVPN客户端</strong>是您用来<strong>连接</strong>的<strong>软件</strong>。</li>\n<li><strong>跳板机</strong>是您<strong>连接上去</strong>的那台<strong>服务器</strong>。</li>\n<li>OpenVPN是<strong>实现安全连接的方式之一</strong>，而跳板机是<strong>一种网络访问策略和架构</strong>。</li>\n</ul>\n<p>您可以<strong>不使用OpenVPN</strong>而用其他方式（如SSH）登录跳板机；也可以<strong>使用OpenVPN</strong>连接到一台<strong>不是跳板机</strong>的服务器（例如只是为了加密咖啡店的公共Wi-Fi流量）。</p>\n<p>但当它们结合时，就构成了一个非常经典和强大的安全远程访问方案。</p>\n<h2 id=\"🧠-什么是堡垒机？\"><a href=\"#🧠-什么是堡垒机？\" class=\"headerlink\" title=\"🧠 什么是堡垒机？\"></a>🧠 什么是堡垒机？</h2><p>如果说「跳板机」是一个基础概念，那么「堡垒机」就是它的<strong>完全体、企业级、工业化</strong>的形态。</p>\n<p><strong>堡垒机</strong>（Bastion Host）是一种位于内部网络和外部网络之间的<strong>高性能、高安全性的专用服务器</strong>，其核心设计理念是 <strong>“网络要塞”</strong> 。所有内部设备的远程访问（如 SSH, RDP, SFTP）都必须通过它进行，它作为唯一的入口点，集中进行<strong>身份认证、授权、审计和监控</strong>。</p>\n<p>您可以把它想象成一个<strong>极其严格的银行金库门卫</strong>：</p>\n<ol>\n<li><strong>唯一入口</strong>：所有人都必须从这个门进出。</li>\n<li><strong>严格安检</strong>：需要多重身份验证（工牌、指纹、密码）。</li>\n<li><strong>权限分明</strong>：你只能进入你有权限进入的区域（金库、柜台、办公室）。</li>\n<li><strong>全程监控</strong>：你进去后的一举一动都被全程录像，说了什么话（执行的命令）、拿了什么东西（传输的文件）都有记录。</li>\n</ol>\n<hr>\n<h3 id=\"🆚-堡垒机-vs-简单跳板机：有何不同？\"><a href=\"#🆚-堡垒机-vs-简单跳板机：有何不同？\" class=\"headerlink\" title=\"🆚 堡垒机 vs. 简单跳板机：有何不同？\"></a>🆚 堡垒机 vs. 简单跳板机：有何不同？</h3><p>很多人会混用这两个词，但它们有本质上的区别：</p>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>简单跳板机 (Jump Server)</strong></th>\n<th><strong>堡垒机 (Bastion Host)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>核心功能</strong></td>\n<td><strong>网络转发</strong>、基础连接</td>\n<td><strong>4A管理</strong>：认证、授权、账号、审计</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>相对较低，依赖系统自身安全</td>\n<td><strong>极高</strong>，有专门的安全加固和防护</td>\n</tr>\n<tr>\n<td><strong>用户体验</strong></td>\n<td>命令行，原始</td>\n<td><strong>Web图形化界面</strong>，易于操作</td>\n</tr>\n<tr>\n<td><strong>权限控制</strong></td>\n<td>粗粒度（能&#x2F;不能登录某台机器）</td>\n<td><strong>细粒度</strong>（能登录，且只能执行某些命令）</td>\n</tr>\n<tr>\n<td><strong>审计能力</strong></td>\n<td>基础日志（谁什么时候登录了）</td>\n<td><strong>强大审计</strong><strong>：</strong>**   <strong><strong>-</strong></strong> **<strong>会话录像</strong>（全程录屏）   - <strong>命令记录</strong>（精确到每一条命令）   - <strong>文件传输记录</strong></td>\n</tr>\n<tr>\n<td><strong>账号管理</strong></td>\n<td>分散在各台服务器上</td>\n<td><strong>统一账号管理</strong>，单点登录（SSO）</td>\n</tr>\n<tr>\n<td><strong>本质</strong></td>\n<td><strong>一台功能单一的服务器</strong></td>\n<td><strong>一套完整的安全运维管控系统</strong></td>\n</tr>\n</tbody></table>\n<p><strong>简单说：跳板机主要解决“<strong>怎么进去</strong>”的问题，而堡垒机在此基础上，更解决了“<strong>谁能进</strong>”、“<strong>能干什么</strong>”和“<strong>干了什么</strong>”的问题。</strong></p>\n<hr>\n<h3 id=\"🛡️-堡垒机的核心功能（4A管理）\"><a href=\"#🛡️-堡垒机的核心功能（4A管理）\" class=\"headerlink\" title=\"🛡️ 堡垒机的核心功能（4A管理）\"></a>🛡️ 堡垒机的核心功能（4A管理）</h3><h4 id=\"1-认证-Authentication-：“你是谁？”\"><a href=\"#1-认证-Authentication-：“你是谁？”\" class=\"headerlink\" title=\"1. 认证 (Authentication)：“你是谁？”\"></a>1. 认证 (Authentication)：“你是谁？”</h4><ul>\n<li><strong>多种认证方式</strong>：支持密码、SSH密钥、动态令牌（如Google Authenticator）、LDAP&#x2F;AD域集成、生物识别等。</li>\n<li><strong>多因子认证 (MFA)</strong>：强制要求使用两种及以上方式验证身份，极大提升安全性。</li>\n</ul>\n<h4 id=\"2-授权-Authorization-：“你能干什么？”\"><a href=\"#2-授权-Authorization-：“你能干什么？”\" class=\"headerlink\" title=\"2. 授权 (Authorization)：“你能干什么？”\"></a>2. 授权 (Authorization)：“你能干什么？”</h4><ul>\n<li><strong>精细化的权限控制</strong>：<ul>\n<li><strong>主机权限</strong>：允许用户访问哪些服务器（如：只能访问Web服务器，不能访问数据库服务器）。</li>\n<li><strong>操作权限</strong>：允许用户执行哪些命令（如：可以执行 <code>systemctl restart nginx</code>，但不能执行 <code>rm -rf /</code>）。</li>\n<li><strong>时间权限</strong>：允许用户在什么时间段内访问（如：只能在工作时间访问）。</li>\n</ul>\n</li>\n<li><strong>临时权限申请与审批</strong>：如果需要临时获得更高权限，可以通过工单系统申请，由管理员审批后自动授权，过期自动回收。</li>\n</ul>\n<h4 id=\"3-账号-Account-：“你的身份是什么？”\"><a href=\"#3-账号-Account-：“你的身份是什么？”\" class=\"headerlink\" title=\"3. 账号 (Account)：“你的身份是什么？”\"></a>3. 账号 (Account)：“你的身份是什么？”</h4><ul>\n<li><strong>统一账号管理</strong>：在堡垒机上创建账号，即可映射到后端的多台服务器，无需在每个服务器上单独创建账号。实现了“一个堡垒机账号，访问所有授权资产”。</li>\n<li><strong>托管服务器账号</strong>：服务器账号和密码可以由堡垒机托管，用户无需知道目标服务器的真实密码。</li>\n</ul>\n<h4 id=\"4-审计-Audit-：“你干了什么？”（这是堡垒机的灵魂）\"><a href=\"#4-审计-Audit-：“你干了什么？”（这是堡垒机的灵魂）\" class=\"headerlink\" title=\"4. 审计 (Audit)：“你干了什么？”（这是堡垒机的灵魂）\"></a>4. 审计 (Audit)：“你干了什么？”（这是堡垒机的灵魂）</h4><ul>\n<li><strong><strong>会话录像 (Session Recording)</strong>：** 像录屏一样，完整记录用户在目标服务器上的**所有操作过程</strong>，包括敲打的命令、返回的结果。无法抵赖。</li>\n<li><strong>命令记录</strong>：详细记录执行过的每一条命令及其时间、来源IP。</li>\n<li><strong>文件传输审计</strong>：记录所有通过SFTP&#x2F;SCP&#x2F;RDP上传和下载的文件日志。</li>\n<li><strong>行为分析</strong>：对异常操作、危险命令（如 <code>rm</code>、<code>chmod</code>）进行实时告警。</li>\n</ul>\n<hr>\n<h3 id=\"🏗️-堡垒机的工作流程\"><a href=\"#🏗️-堡垒机的工作流程\" class=\"headerlink\" title=\"🏗️ 堡垒机的工作流程\"></a>🏗️ 堡垒机的工作流程</h3><p>下图以一个运维人员需要通过堡垒机修复网站为例，展示了其核心工作流程与4A功能：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/堡垒机工作流程.svg\"\n                      alt=\"堡垒机工作流程\" width=\"240\" height=\"auto\" style=\"display:block;\"\n                >\n\n\n\n<hr>\n<h3 id=\"🚀-常见的堡垒机方案\"><a href=\"#🚀-常见的堡垒机方案\" class=\"headerlink\" title=\"🚀 常见的堡垒机方案\"></a>🚀 常见的堡垒机方案</h3><ol>\n<li><strong>开源方案</strong>：<ul>\n<li><strong>Jumpserver</strong>：国内最流行的开源堡垒机，功能全面，对中文支持好，社区活跃。</li>\n<li><strong>Teleport</strong>：现代、轻量级，对云原生和Kubernetes环境支持良好。</li>\n<li><strong>Apache Guacamole</strong>：无客户端堡垒机，通过浏览器即可实现RDP、SSH、VNC等连接。</li>\n</ul>\n</li>\n<li><strong>商业方案</strong>：<ul>\n<li><strong>齐治堡垒机</strong>：国内老牌商业产品，市场份额大。</li>\n<li>** Cisco Secure Access (前Duo)**、<strong>CyberArk</strong>：国际知名的商业解决方案，功能强大，价格昂贵。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"✅-总结：为什么需要堡垒机？\"><a href=\"#✅-总结：为什么需要堡垒机？\" class=\"headerlink\" title=\"✅ 总结：为什么需要堡垒机？\"></a>✅ 总结：为什么需要堡垒机？</h3><ol>\n<li><strong>安全第一</strong>：极大缩小了网络攻击面，保护了内部资产。</li>\n<li><strong>合规要求</strong>：满足等保2.0、ISO27001、GDPR等法规对运维审计的强制性要求。</li>\n<li><strong>权限清晰</strong>：实现最小权限原则，避免权限滥用。</li>\n<li><strong>责任界定</strong>：出现问题时，可以通过录像和日志快速定位责任人、还原事故现场。</li>\n<li><strong>运维效率</strong>：统一入口，简化了账号管理和访问流程。</li>\n</ol>\n<p>简而言之，堡垒机是企业IT基础设施中<strong>不可或缺的安全与审计基石</strong>，尤其对于金融、政府、互联网等对安全性和合规性要求极高的行业来说，是标配产品。</p>\n<h1 id=\"OpenVpn-跳板机-堡垒机实现前端部署\"><a href=\"#OpenVpn-跳板机-堡垒机实现前端部署\" class=\"headerlink\" title=\"OpenVpn+跳板机&#x2F;堡垒机实现前端部署\"></a>OpenVpn+跳板机&#x2F;堡垒机实现前端部署</h1><p>这是一个非常经典的DevOps场景：OpenVpn+跳板机&#x2F;堡垒机与前端工程部署结合起来，可以构建一个既安全又高效的部署流程。</p>\n<p>这种架构的核心思想是：通过 OpenVPN 建立安全通道，通过跳板机&#x2F;堡垒机作为统一、受控的入口，来执行部署操作。</p>\n<h2 id=\"🧩-核心架构与角色分工\"><a href=\"#🧩-核心架构与角色分工\" class=\"headerlink\" title=\"🧩 核心架构与角色分工\"></a>🧩 核心架构与角色分工</h2><p>在这种架构下，各个组件的职责非常清晰：</p>\n<ol>\n<li><strong>OpenVPN Server</strong>：<strong>负责建“路”</strong>。建立一条从开发者本地到部署环境的加密隧道，确保传输安全。</li>\n<li><strong>跳板机&#x2F;堡垒机 (Bastion Host)</strong>：<strong>负责管“门”和看“人”</strong>。它是唯一的部署操作入口，负责身份验证、权限控制和操作审计。</li>\n<li><strong>部署目标服务器</strong>：<strong>负责住“应用”</strong>。这是最终运行前端项目（Nginx, Node.js 等）的服务器。</li>\n<li><strong>CI&#x2F;CD 工具 (可选但推荐)</strong>：<strong>负责自动“开车”</strong>。例如 Jenkins、GitLab Runner 等，它们可以自动从仓库拉取代码、构建，并通过跳板机执行部署脚本。</li>\n</ol>\n<p>整个从前端代码到部署上线的安全部署流程，如图所述：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/OpenVpn+堡垒机结合前端部署.svg\"\n                      alt=\"OpenVpn+堡垒机结合前端部署\" width=\"400\" height=\"auto\" style=\"display:block;\"\n                >\n\n\n\n\n<h2 id=\"🛠️-两种常见的部署模式\"><a href=\"#🛠️-两种常见的部署模式\" class=\"headerlink\" title=\"🛠️ 两种常见的部署模式\"></a>🛠️ 两种常见的部署模式</h2><h3 id=\"模式一：手动部署（适合小团队或初期）\"><a href=\"#模式一：手动部署（适合小团队或初期）\" class=\"headerlink\" title=\"模式一：手动部署（适合小团队或初期）\"></a>模式一：手动部署（适合小团队或初期）</h3><p><strong>流程：</strong> 开发者本地构建，然后通过跳板机手动上传文件。</p>\n<p><strong>本地构建</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure></div>\n\n<p>这会在项目根目录生成 <code>dist</code> 或 <code>build</code> 文件夹，里面是静态文件（HTML, CSS, JS）。</p>\n<ol>\n<li><strong>连接VPN</strong>：确保 OpenVPN 客户端已连接，获得访问内网的权限。</li>\n<li><strong>通过跳板机上传文件</strong>：</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 scp 命令，通过跳板机转发到目标服务器</span></span><br><span class=\"line\"><span class=\"comment\"># 注意：跳板机需要配置SSH代理转发或用户有直接权限</span></span><br><span class=\"line\">scp -r -o <span class=\"string\">&#x27;ProxyJump user@jumpbox-ip&#x27;</span> ./dist/* user@target-server-ip:/path/to/nginx/html/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或者使用更现代的 rsync</span></span><br><span class=\"line\">rsync -avz -e <span class=\"string\">&quot;ssh -J user@jumpbox-ip&quot;</span> ./dist/ user@target-server-ip:/path/to/nginx/html/</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"3\">\n<li><strong>通过跳板机执行远程命令</strong>（如果需要）：</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 登录跳板机，再从跳板机SSH到目标服务器</span></span><br><span class=\"line\">ssh user@jumpbox-ip</span><br><span class=\"line\"><span class=\"comment\"># 然后，在跳板机上执行</span></span><br><span class=\"line\">ssh user@target-server-ip <span class=\"string\">&quot;sudo nginx -s reload&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"模式二：自动化部署（推荐，适合成熟团队）\"><a href=\"#模式二：自动化部署（推荐，适合成熟团队）\" class=\"headerlink\" title=\"模式二：自动化部署（推荐，适合成熟团队）\"></a>模式二：自动化部署（推荐，适合成熟团队）</h3><p><strong>流程：</strong> CI&#x2F;CD 工具（如 Jenkins、GitLab CI）在检测到 Git 标签或特定分支更新后，自动完成所有步骤。</p>\n<p>这是一个在 GitLab 中实现的自动化部署流程示例：</p>\n<div class=\"code-container\" data-rel=\"Yaml\"><figure class=\"iseeu highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># .gitlab-ci.yml</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">stages:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">deploy</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">build_production:</span></span><br><span class=\"line\">  <span class=\"attr\">stage:</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"attr\">image:</span> <span class=\"string\">node:16</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">if:</span> <span class=\"string\">$CI_COMMIT_TAG</span> <span class=\"comment\"># 通常在打标签时触发生产环境部署</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"attr\">artifacts:</span></span><br><span class=\"line\">    <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">dist/</span> <span class=\"comment\"># 将构建产物传递给下一个阶段</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">deploy_to_production:</span></span><br><span class=\"line\">  <span class=\"attr\">stage:</span> <span class=\"string\">deploy</span></span><br><span class=\"line\">  <span class=\"attr\">image:</span> <span class=\"string\">alpine</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">if:</span> <span class=\"string\">$CI_COMMIT_TAG</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">apk</span> <span class=\"string\">add</span> <span class=\"string\">--no-cache</span> <span class=\"string\">openssh-client</span> <span class=\"string\">rsync</span></span><br><span class=\"line\">    <span class=\"comment\"># 使用 SSH 通过跳板机部署 (-o ProxyJump)</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">rsync</span> <span class=\"string\">-avz</span> <span class=\"string\">--delete</span> <span class=\"string\">-e</span> <span class=\"string\">&quot;ssh -o StrictHostKeyChecking=no -J $JUMPBOX_USER@$JUMPBOX_IP&quot;</span> <span class=\"string\">dist/</span> <span class=\"string\">$TARGET_SERVER_USER@$TARGET_SERVER_IP:/app/frontend/</span></span><br><span class=\"line\">    <span class=\"comment\"># 通过跳板机执行远程命令，重启服务</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ssh</span> <span class=\"string\">-J</span> <span class=\"string\">$JUMPBOX_USER@$JUMPBOX_IP</span> <span class=\"string\">$TARGET_SERVER_USER@$TARGET_SERVER_IP</span> <span class=\"string\">&quot;sudo systemctl reload nginx&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>$JUMPBOX_IP</code>, <code>$TARGET_SERVER_IP</code> 等变量在 GitLab 的 <strong>CI&#x2F;CD 设置</strong>中配置，避免写在代码里。</li>\n<li><code>-J</code> 参数是 SSH 的 <strong>代理跳跃</strong>，让 SSH 连接自动通过跳板机。</li>\n<li>堡垒机上需要存放 CI&#x2F;CD 工具的 <strong>SSH 私钥</strong>，并且该密钥对目标服务器有访问权限。</li>\n</ul>\n<hr>\n<h2 id=\"⚙️-部署前的重要准备工作\"><a href=\"#⚙️-部署前的重要准备工作\" class=\"headerlink\" title=\"⚙️ 部署前的重要准备工作\"></a>⚙️ 部署前的重要准备工作</h2><ol>\n<li><strong>网络与权限配置</strong>：<ul>\n<li>确保 OpenVPN 服务器配置的路由规则，能让客户端访问到跳板机和目标服务器。</li>\n<li>在跳板机上为每个开发者或CI&#x2F;CD服务创建账号，并配置严格的 SSH 密钥认证。</li>\n<li>配置跳板机的权限控制，确保用户只能访问特定的目标服务器。</li>\n</ul>\n</li>\n<li><strong>堡垒机审计</strong>：<ul>\n<li>开启堡垒机的会话录制功能，记录所有通过它执行的部署命令和文件传输操作。一旦出问题，可以快速回放定位。</li>\n</ul>\n</li>\n<li><strong>目标服务器配置</strong>：<ul>\n<li><strong>Nginx 配置示例</strong>：</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Nginx\"><figure class=\"iseeu highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> your-app.com;</span><br><span class=\"line\">  <span class=\"attribute\">root</span> /app/frontend; <span class=\"comment\"># 前端文件部署的目录</span></span><br><span class=\"line\">  <span class=\"attribute\">index</span> index.html;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 处理 SPA 路由（如 Vue Router 的 history 模式）</span></span><br><span class=\"line\">  <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">    <span class=\"attribute\">try_files</span> <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.html;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 启用 gzip 压缩</span></span><br><span class=\"line\">  <span class=\"attribute\">gzip</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\">  <span class=\"attribute\">gzip_types</span> text/css application/javascript;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h2 id=\"✅-这种架构的优势\"><a href=\"#✅-这种架构的优势\" class=\"headerlink\" title=\"✅ 这种架构的优势\"></a>✅ 这种架构的优势</h2><ol>\n<li><strong>极致安全</strong>：<ul>\n<li>内部服务器<strong>完全不用暴露到公网</strong>，攻击者无法直接扫描到。</li>\n<li>所有部署操作都经过<strong>加密隧道</strong>和<strong>严格审计</strong>。</li>\n</ul>\n</li>\n<li><strong>权限清晰</strong>：<ul>\n<li>开发者可能根本不知道目标服务器的密码，而是通过堡垒机的授权来访问，实现了权限最小化原则。</li>\n</ul>\n</li>\n<li><strong>流程标准化</strong>：<ul>\n<li>无论是谁部署，都必须走同一个通道，执行相同的流程，减少了人为出错的可能。</li>\n</ul>\n</li>\n<li><strong>可追溯性</strong>：<ul>\n<li>结合堡垒机的录像功能，可以清晰看到<strong>谁</strong>、在<strong>什么时间</strong>、<strong>部署了什么</strong>、<strong>执行了什么命令</strong>，便于故障排查和审计。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"⚠️-注意事项\"><a href=\"#⚠️-注意事项\" class=\"headerlink\" title=\"⚠️ 注意事项\"></a>⚠️ 注意事项</h2><ul>\n<li><strong>复杂度</strong>：初始设置比直接部署到公网服务器要复杂，但长期来看收益巨大。</li>\n<li><strong>性能</strong>：如果 CI&#x2F;CD 服务器在海外，而跳板机和目标服务器在国内，传输大量文件可能会慢，可以考虑在目标服务器上直接构建。</li>\n<li><strong>成本</strong>：需要维护额外的跳板机&#x2F;堡垒机组件。</li>\n</ul>\n<p><strong>总结：</strong> <strong>OpenVPN + 跳板机&#x2F;堡垒机的部署模式，是企业级前端工程部署的最佳实践之一。</strong> 它通过牺牲一点点部署的便利性，换来了极高的安全性和规范性，非常适合对安全有要求的中大型项目。</p>\n<h1 id=\"SaaS使用的部署方式到底叫什么呢？\"><a href=\"#SaaS使用的部署方式到底叫什么呢？\" class=\"headerlink\" title=\"SaaS使用的部署方式到底叫什么呢？\"></a>SaaS使用的部署方式到底叫什么呢？</h1><p>描述：没有使用jenkins，开发者通过堡垒机连入目标网络中通过git拉取代码并执行打包命令后生成dist或build文件夹，执行shell脚本将打包后的静态资源放到对应的目标服务器的路径下。</p>\n<p><strong>手动或半自动的基于堡垒机的 Git 拉取部署。</strong></p>\n<p>更具体地说，它属于 <strong>“Git-Based Deployment”</strong> 的一种演变形式，核心特点是<strong>通过安全堡垒机作为跳板，直接在目标环境或邻近网络中执行构建和部署</strong>。</p>\n<h2 id=\"🧩-这种部署模式的详细流程拆解\"><a href=\"#🧩-这种部署模式的详细流程拆解\" class=\"headerlink\" title=\"🧩 这种部署模式的详细流程拆解\"></a>🧩 这种部署模式的详细流程拆解</h2><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/yjt中SaaS的前端部署方式.svg\"\n                      alt=\"yjt中SaaS的前端部署方式\" width=\"220\" height=\"auto\" style=\"display:block;\"\n                >\n\n\n<p>它与纯CI&#x2F;CD自动化部署的<strong>核心区别</strong>在于，流程图中<strong>黄色框线</strong>的部分（从 <code>git push</code> 到 <code>重启服务</code>）完全由<strong>开发者手动触发和执行</strong>，而非由CI&#x2F;CD工具（如Jenkins、GitLab CI）自动触发。</p>\n<hr>\n<h2 id=\"⚙️-这种模式的特点\"><a href=\"#⚙️-这种模式的特点\" class=\"headerlink\" title=\"⚙️ 这种模式的特点\"></a>⚙️ 这种模式的特点</h2><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li><strong>环境高度一致</strong>：在<strong>目标网络内</strong>进行构建，可以有效避免“在我本地是好的”这类问题。构建环境与生产环境一致（操作系统、Node版本等）。</li>\n<li><strong>安全性高</strong>：所有操作都通过受审计的堡垒机进行，目标服务器无需暴露到公网，也无需在本地和服务器之间开放额外的端口。</li>\n<li><strong>简单直接，无需复杂配置</strong>：不需要搭建和维护一整套CI&#x2F;CD系统（如Jenkins），对于小团队或项目初期来说，成本更低，更轻量。</li>\n<li><strong>依赖少</strong>：只需要目标服务器上有Git和Node.js环境即可，不需要安装CI&#x2F;CD的Agent。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li><strong>自动化程度低</strong>：严重依赖人工操作。开发者需要手动登录、执行一系列命令。容易因操作失误（比如忘了拉最新代码、在错误目录执行）导致部署失败。</li>\n<li><strong>无法实现真正的持续交付</strong>：部署过程不是自动触发的，通常需要人工干预，无法做到代码一提交就自动测试和部署。</li>\n<li><strong>可追溯性较差</strong>：虽然堡垒机会记录执行了哪些命令，但**“谁在什么时候部署了哪个版本的代码”** 这一信息没有与代码提交（Git Tag&#x2F;Commit ID）强关联地记录下来。出问题时，需要回溯堡垒机日志。</li>\n<li><strong>效率较低</strong>：每次部署都需要在服务器上重新执行完整的构建过程，占用服务器资源，如果服务器性能不佳，构建时间会很长。</li>\n</ol>\n<hr>\n<h2 id=\"🚀-如何优化这种模式？\"><a href=\"#🚀-如何优化这种模式？\" class=\"headerlink\" title=\"🚀 如何优化这种模式？\"></a>🚀 如何优化这种模式？</h2><p>即使不引入Jenkins，也可以让这个流程变得更高效、更可靠：</p>\n<h3 id=\"1-编写自动化部署脚本\"><a href=\"#1-编写自动化部署脚本\" class=\"headerlink\" title=\"1. 编写自动化部署脚本\"></a>1. 编写自动化部署脚本</h3><p>将一系列手动命令写成一个Shell脚本，例如 <code>deploy.sh</code>，放在代码库根目录。</p>\n<p><strong>（这就是SaaS的做法）</strong></p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># deploy.sh</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> -e <span class=\"comment\"># 遇到错误就退出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;1. Pulling latest code...&quot;</span></span><br><span class=\"line\">git pull origin main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;2. Installing dependencies...&quot;</span></span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;3. Building project...&quot;</span></span><br><span class=\"line\">npm run build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;4. Backing up old version...&quot;</span></span><br><span class=\"line\">tar -czf /app/backup/frontend-$(<span class=\"built_in\">date</span> +%Y%m%d-%H%M%S).tar.gz /usr/share/nginx/html/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;5. Deploying new version...&quot;</span></span><br><span class=\"line\">rsync -av --delete ./dist/ /usr/share/nginx/html/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;6. Reloading Nginx...&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl reload nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Deployment completed successfully!&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>使用方式：</strong> 开发者登录后，只需要执行一条命令：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash deploy.sh</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"2-使用-Git-Hooks（简单CI）\"><a href=\"#2-使用-Git-Hooks（简单CI）\" class=\"headerlink\" title=\"2. 使用 Git Hooks（简单CI）\"></a>2. 使用 Git Hooks（简单CI）</h3><p>在<strong>代码服务器的Git仓库</strong>上配置 <code>post-receive</code> Hook（例如使用Gitea），当收到<code>push</code>时，自动通知目标服务器执行拉取和部署脚本。这实现了简单的自动触发。</p>\n<h3 id=\"3-使用-SSH-直接执行远程命令\"><a href=\"#3-使用-SSH-直接执行远程命令\" class=\"headerlink\" title=\"3. 使用 SSH 直接执行远程命令\"></a>3. 使用 SSH 直接执行远程命令</h3><p>开发者可以在本地电脑上通过一条命令完成部署，无需手动登录。</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -J user@jumpbox-ip user@target-server-ip <span class=\"string\">&quot;cd /path/to/project &amp;&amp; bash deploy.sh&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"4-引入版本标记\"><a href=\"#4-引入版本标记\" class=\"headerlink\" title=\"4. 引入版本标记\"></a>4. 引入版本标记</h3><p>在脚本中加入步骤，在部署成功后，给当前的提交打上一个Tag。</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag deploy-$(<span class=\"built_in\">date</span> +%Y%m%d-%H%M%S)</span><br><span class=\"line\">git push origin --tags</span><br></pre></td></tr></table></figure></div>\n\n<p>这样就能清晰地知道生产环境对应的是哪个代码版本。</p>\n<hr>\n<h2 id=\"✅-总结-1\"><a href=\"#✅-总结-1\" class=\"headerlink\" title=\"✅ 总结\"></a>✅ 总结</h2><p>这是一种 <strong>“基于堡垒机的半自动 Git 拉取部署”</strong>。</p>\n<ul>\n<li><strong>它不是什么？</strong> 它不是全自动的CI&#x2F;CD（如Jenkins Pipeline），也不是传统的FTP上传部署。</li>\n<li><strong>它是什么？</strong> 它是一种在<strong>安全约束条件下</strong>、<strong>介于手动部署和全自动部署之间</strong>的实用型方案。</li>\n</ul>\n<p><strong>适用场景：</strong></p>\n<ul>\n<li>内部系统、管理后台等对发布频率要求不高的项目。</li>\n<li>团队规模较小，尚未引入完整CI&#x2F;CD工具链的初期阶段。</li>\n<li>对安全性要求极高，所有内部网络访问必须通过堡垒机的环境。</li>\n</ul>\n<p>对于很多项目来说，这是一个非常好的起点。随着项目发展，当您觉得每次手动运行脚本也很麻烦时，就是考虑引入 <strong>GitLab CI&#x2F;CD、Github Actions</strong> 等真正自动化工具的时候了。</p>\n<h1 id=\"待完善内容\"><a href=\"#待完善内容\" class=\"headerlink\" title=\" 待完善内容 \"></a><font style=\"color:#FFFFFF;background-color:#ED740C;\"> 待完善内容 </font></h1><ul>\n<li><input disabled=\"\" type=\"checkbox\"> CI&#x2F;CD工具：jekins</li>\n<li><input disabled=\"\" type=\"checkbox\"> Docker</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"CI-CD\"><a href=\"#CI-CD\" class=\"headerlink\" title=\"CI&#x2F;CD\"></a>CI&#x2F;CD</h1><h2 id=\"🧠-核心概念：CI-CD是什么？\"><a href=\"#🧠-核心概念：CI-CD是什么？\" class=\"headerlink\" title=\"🧠 核心概念：CI&#x2F;CD是什么？\"></a>🧠 核心概念：CI&#x2F;CD是什么？</h2><p>CI&#x2F;CD 是现代软件工程中的一套最佳实践和方法论，旨在自动化软件的集成、测试和部署流程。它由两个部分组成：</p>\n<p>CI - 持续集成 (Continuous Integration)</p>\n<p>CD - 持续交付&#x2F;持续部署 (Continuous Delivery &#x2F; Continuous Deployment)</p>\n<p>可以把 CI&#x2F;CD 想象成一个全自动的软件装配流水线。开发者提交代码（如同送上原料），流水线会自动进行一系列质量检测、打包和发布，最终将合格的产品交付给用户。</p>\n<h2 id=\"🔧-详解两个部分\"><a href=\"#🔧-详解两个部分\" class=\"headerlink\" title=\"🔧 详解两个部分\"></a>🔧 详解两个部分</h2><h3 id=\"1-CI-持续集成\"><a href=\"#1-CI-持续集成\" class=\"headerlink\" title=\"1. CI - 持续集成\"></a>1. CI - 持续集成</h3><p><strong>核心思想：</strong> 开发者频繁地将代码更改合并到共享的主干分支（如每天多次）。每次合并都会自动触发一系列构建和测试，以便快速发现和修复错误。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/CI流程.svg\"\n                      alt=\"CI流程\" width=\"300\" height=\"auto\" style=\"display:block;\"\n                >\n\n\n\n<p><strong>好处：</strong></p>\n<ul>\n<li>✅ <strong>快速发现错误</strong>：问题在引入后几分钟内就能被发现。</li>\n<li>✅ <strong>减少集成冲突</strong>：频繁合并小批量代码，避免在发布前一次性合并大量代码带来的巨大冲突。</li>\n<li>✅ 提高代码质量**：自动化测试保障了代码标准。</li>\n</ul>\n<h3 id=\"2-CD-持续交付-持续部署\"><a href=\"#2-CD-持续交付-持续部署\" class=\"headerlink\" title=\"2. CD - 持续交付 &#x2F; 持续部署\"></a>2. CD - 持续交付 &#x2F; 持续部署</h3><p><strong>CD 有两种细微差别的含义：</strong></p>\n<h4 id=\"a-持续交付-Continuous-Delivery\"><a href=\"#a-持续交付-Continuous-Delivery\" class=\"headerlink\" title=\"a) 持续交付 (Continuous Delivery)\"></a>a) 持续交付 (Continuous Delivery)</h4><p><strong>核心思想：</strong> CI流程结束后，代码总是处于<strong>可随时、一键手动部署</strong>到生产环境的状态。</p>\n<p><strong>流程：</strong> <code>代码 -&gt; CI -&gt; 生成制品 -&gt; 等待手动点击部署</code></p>\n<h4 id=\"b-持续部署-Continuous-Deployment\"><a href=\"#b-持续部署-Continuous-Deployment\" class=\"headerlink\" title=\"b) 持续部署 (Continuous Deployment)\"></a>b) 持续部署 (Continuous Deployment)</h4><p><strong>核心思想：</strong> 这是持续交付的更高阶段。只要代码通过所有测试流程，就<strong>自动地、无需人工干预地</strong>部署到生产环境。</p>\n<p><strong>流程：</strong> <code>代码 -&gt; CI -&gt; 生成制品 -&gt; 自动部署到生产环境</code></p>\n<p>可以这样理解：</p>\n<ul>\n<li><strong>持续交付</strong> &#x3D; “软件已经打包好放在门口了，你随时可以签收（手动部署）。”</li>\n<li><strong>持续部署</strong> &#x3D; “软件通过质检后，快递机器人自动送货上门（自动部署）。”</li>\n</ul>\n<h2 id=\"🛠️-CI-CD-工具链\"><a href=\"#🛠️-CI-CD-工具链\" class=\"headerlink\" title=\"🛠️ CI&#x2F;CD 工具链\"></a>🛠️ CI&#x2F;CD 工具链</h2><p>整个流程依赖于一系列自动化工具，常见的工具有：</p>\n<table>\n<thead>\n<tr>\n<th><strong>阶段</strong></th>\n<th><strong>流行工具</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>源代码管理</strong>****</td>\n<td>Git (GitLab, GitHub, Gitee)</td>\n</tr>\n<tr>\n<td><strong>CI&#x2F;CD 流水线引擎</strong></td>\n<td><strong>Jenkins</strong>, GitLab CI&#x2F;CD, GitHub Actions, Drone</td>\n</tr>\n<tr>\n<td><strong>构建工具</strong></td>\n<td>Maven, Gradle (Java), npm, Webpack (JS), Make</td>\n</tr>\n<tr>\n<td><strong>测试工具</strong></td>\n<td>JUnit, Selenium, Jest, Cypress</td>\n</tr>\n<tr>\n<td><strong>部署工具</strong></td>\n<td>Ansible, Kubernetes, Docker, Terraform</td>\n</tr>\n<tr>\n<td><strong>监控工具</strong></td>\n<td>Prometheus, Grafana, ELK Stack</td>\n</tr>\n</tbody></table>\n<h2 id=\"💡-为什么需要-CI-CD？它的价值是什么？\"><a href=\"#💡-为什么需要-CI-CD？它的价值是什么？\" class=\"headerlink\" title=\"💡 为什么需要 CI&#x2F;CD？它的价值是什么？\"></a>💡 为什么需要 CI&#x2F;CD？它的价值是什么？</h2><ol>\n<li><strong>加速开发流程</strong><ul>\n<li>自动化代替手动操作，释放开发者的生产力。</li>\n<li>快速反馈，开发者能立即知道这次提交是否破坏了系统。</li>\n</ul>\n</li>\n<li><strong>提高软件质量</strong><ul>\n<li>通过自动化测试在早期发现缺陷，修复成本远低于生产环境才发现。</li>\n<li>代码规范、安全漏洞扫描等流程被标准化。</li>\n</ul>\n</li>\n<li><strong>降低发布风险</strong><ul>\n<li>小批量、频繁的发布使得每次变更的内容很少。如果出现问题，可以快速定位和回滚。</li>\n<li>传统的”半年发布一次，一次改动500个功能”的方式风险极高。</li>\n</ul>\n</li>\n<li><strong>增强项目可见性</strong><ul>\n<li>每个人都能清晰地看到代码从提交到部署的整个状态，构建是否成功、测试是否通过。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"✅-总结\"><a href=\"#✅-总结\" class=\"headerlink\" title=\"✅ 总结\"></a>✅ 总结</h2><p><strong>CI&#x2F;CD</strong> 是一套通过<strong>自动化</strong>来<strong>优化软件开发生命周期</strong>的实践，其核心目标是：</p>\n<ul>\n<li><strong>更快的发布速度</strong></li>\n<li><strong>更高质量的软件</strong></li>\n<li><strong>更低的发布风险</strong></li>\n</ul>\n<p>它不是某个特定的工具，而是一种文化和流程的变革，是现代DevOps理念的核心支柱，已经成为中大型软件开发团队的标配。</p>\n<h1 id=\"OpenVpn与跳板机-堡垒机\"><a href=\"#OpenVpn与跳板机-堡垒机\" class=\"headerlink\" title=\"OpenVpn与跳板机&#x2F;堡垒机\"></a>OpenVpn与跳板机&#x2F;堡垒机</h1><h2 id=\"🔧-什么是-OpenVPN-客户端？\"><a href=\"#🔧-什么是-OpenVPN-客户端？\" class=\"headerlink\" title=\"🔧 什么是 OpenVPN 客户端？\"></a>🔧 什么是 OpenVPN 客户端？</h2><p><strong>OpenVPN 客户端</strong>是一个安装在您本地设备（如电脑、手机）上的<strong>软件程序</strong>。</p>\n<p>它的核心功能是：<strong>根据配置文件（.ovpn 文件），与远端的 OpenVPN 服务器建立一条加密的、安全的隧道连接。</strong></p>\n<ul>\n<li><strong>它是什么？</strong> 一个软件（例如：OpenVPN Connect、Tunnelblick等）。</li>\n<li><strong>它在哪里运行？</strong> 在你的个人设备上（Windows PC, Mac, Linux, 手机）。</li>\n<li><strong>它的作用？</strong> 创建加密通道，让你的所有或指定网络流量都通过这个通道流向VPN服务器。</li>\n</ul>\n<p><strong>就像一个专门的电话（客户端），用于拨打一个安全的号码（服务器）。</strong></p>\n<hr>\n<h2 id=\"🖥️-什么是跳板机？\"><a href=\"#🖥️-什么是跳板机？\" class=\"headerlink\" title=\"🖥️ 什么是跳板机？\"></a>🖥️ 什么是跳板机？</h2><p><strong>跳板机</strong>（Jump Server &#x2F; Bastion Host）是一台位于某个特定网络区域（如公司内网）的<strong>服务器</strong>。</p>\n<p>它的核心功能是：<strong>作为一个唯一的、受严格控制的访问入口，所有外部人员必须先连接到这台服务器，才能进一步访问目标网络内部的其他设备。</strong></p>\n<ul>\n<li><strong>它是什么？</strong> 一台物理或虚拟的服务器&#x2F;计算机。</li>\n<li><strong>它在哪里运行？</strong> 在目标网络的入口处（例如公司机房或公有云上）。</li>\n<li><strong>它的作用？</strong> 提供访问桥梁和安全审计。所有操作都通过它进行，便于监控和记录日志。</li>\n</ul>\n<p><strong>就像是大楼的门卫室（跳板机），所有访客（用户）必须先在门卫室登记、核实身份，由门卫带领才能进入大楼内部（内网）。</strong></p>\n<hr>\n<h2 id=\"🔄-它们如何协同工作？（两者的关系）\"><a href=\"#🔄-它们如何协同工作？（两者的关系）\" class=\"headerlink\" title=\"🔄 它们如何协同工作？（两者的关系）\"></a>🔄 它们如何协同工作？（两者的关系）</h2><p>OpenVPN 客户端和跳板机通常<strong>配合使用</strong>，但它们扮演完全不同的角色。</p>\n<h3 id=\"工作流程分解：\"><a href=\"#工作流程分解：\" class=\"headerlink\" title=\"工作流程分解：\"></a>工作流程分解：</h3><h4 id=\"阶段一：建立安全隧道（认证与连接）\"><a href=\"#阶段一：建立安全隧道（认证与连接）\" class=\"headerlink\" title=\"阶段一：建立安全隧道（认证与连接）\"></a>阶段一：建立安全隧道（认证与连接）</h4><ol>\n<li><strong>配置加载</strong>：用户在自己的电脑上启动OpenVPN客户端软件，并加载管理员提供的 <code>.ovpn</code>配置文件。这个文件包含了连接所需的所有信息：<ul>\n<li><strong>跳板机的公网IP&#x2F;域名</strong></li>\n<li>加密算法和协议类型</li>\n<li><strong>CA根证书</strong>（用于验证服务器身份）</li>\n<li><strong>客户端证书和私钥</strong>（用于向服务器证明自身身份）</li>\n<li>其他参数（如使用的端口、是否使用密码等）</li>\n</ul>\n</li>\n<li><strong>发起连接</strong>：客户端根据配置，向跳板机的公网IP和指定端口发起TCP&#x2F;UDP连接请求。</li>\n<li><strong>TLS双向认证</strong>（最关键的安全步骤）：<ul>\n<li><strong>服务器认证</strong>：跳板机上的OpenVPN服务端将自己的证书发给客户端。客户端用CA根证书验证服务器证书的有效性，<strong>确保连接的是真正的公司跳板机，而不是钓鱼服务器</strong>。</li>\n<li><strong>客户端认证</strong>：客户端将自己的证书和私钥签名发给服务器。服务器用CA根证书验证客户端证书，<strong>确保连接的是授权员工，而不是外人</strong>。</li>\n<li>这个过程通常还辅以用户名&#x2F;密码认证。</li>\n</ul>\n</li>\n<li><strong>隧道建立</strong>：认证通过后，双方利用协商好的密钥，建立一条<strong>加密隧道</strong>。跳板机为客户端分配一个内网IP地址（如 <code>10.8.0.100</code>）。此时，用户的电脑在逻辑上已经“接入”了公司内网。</li>\n</ol>\n<h4 id=\"阶段二：访问内部资源（路由与转发）\"><a href=\"#阶段二：访问内部资源（路由与转发）\" class=\"headerlink\" title=\"阶段二：访问内部资源（路由与转发）\"></a>阶段二：访问内部资源（路由与转发）</h4><ol>\n<li><strong>发起访问请求</strong>：用户需要访问内网的一台Web服务器（<code>192.168.1.100</code>）。他在本地使用SSH命令：<code>ssh developer@192.168.1.100</code>。</li>\n<li><strong>流量封装与路由</strong>：<ul>\n<li>客户端的操作系统会根据路由表规则，将所有发往 <code>192.168.1.0/24</code> 网段的流量，都指向OpenVPN创建的虚拟网卡。</li>\n<li>OpenVPN客户端将原始的SSH数据包（TCP协议）<strong>整个加密并包裹（封装）</strong> 在一个新的数据包内，这个新数据包的目的地是跳板机的公网IP。</li>\n<li>这个加密后的数据包通过互联网发送到跳板机。</li>\n</ul>\n</li>\n<li><strong>跳板机处理</strong>（流量枢纽）：<ul>\n<li>跳板机上的OpenVPN服务端<strong>解密</strong>收到的数据包，<strong>解出</strong>原始的SSH请求数据包。</li>\n<li>跳板机的<strong>操作系统内核</strong>根据其自身的路由表，发现这个目标是 <code>192.168.1.100</code> 的数据包需要从其内部网卡（如 <code>eth0</code>）发出。</li>\n<li><strong>防火墙和访问控制</strong>：在转发前，跳板机上的防火墙规则（如 <code>iptables</code>）会进行检查，判断源IP（<code>10.8.0.100</code>）是否有权限访问目标IP（<code>192.168.1.100</code>）的22端口。通过后，才将数据包转发给目标Web服务器。</li>\n</ul>\n</li>\n<li><strong>响应返回</strong>：<ul>\n<li>Web服务器处理SSH请求后，将响应包发回给跳板机（因为请求的来源IP是跳板机）。</li>\n<li>跳板机收到响应后，再将其加密，通过隧道发回给远端的用户客户端。</li>\n<li>客户端解密后，得到原始的SSH响应，完成一次完整的交互。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"🛡️-核心价值与优势\"><a href=\"#🛡️-核心价值与优势\" class=\"headerlink\" title=\"🛡️ 核心价值与优势\"></a>🛡️ 核心价值与优势</h4><p>这种架构的优势在于提供了<strong>双重安全性和极佳的可管理性</strong>：</p>\n<ol>\n<li><strong>强身份认证</strong>：通过证书方式，同时验证了服务器和客户端的身份，避免了密码泄露和中间人攻击。</li>\n<li><strong>通信加密</strong>：所有数据在公网上传输时都是加密的，保证机密性。</li>\n<li><strong>访问隔离</strong>：跳板机成为唯一的入口，外部无法直接访问任何其他内网机器，攻击面最小化。</li>\n<li><strong>集中审计与管控</strong>：所有对内网的访问都必须经过跳板机，便于<strong>记录完整的操作日志</strong>、<strong>监控会话</strong>和<strong>统一设置访问权限策略</strong>。管理员只需要在跳板机上修改规则，就可以控制所有用户的权限。</li>\n</ol>\n<h3 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h3><ul>\n<li><strong>OpenVPN客户端</strong>是您用来<strong>连接</strong>的<strong>软件</strong>。</li>\n<li><strong>跳板机</strong>是您<strong>连接上去</strong>的那台<strong>服务器</strong>。</li>\n<li>OpenVPN是<strong>实现安全连接的方式之一</strong>，而跳板机是<strong>一种网络访问策略和架构</strong>。</li>\n</ul>\n<p>您可以<strong>不使用OpenVPN</strong>而用其他方式（如SSH）登录跳板机；也可以<strong>使用OpenVPN</strong>连接到一台<strong>不是跳板机</strong>的服务器（例如只是为了加密咖啡店的公共Wi-Fi流量）。</p>\n<p>但当它们结合时，就构成了一个非常经典和强大的安全远程访问方案。</p>\n<h2 id=\"🧠-什么是堡垒机？\"><a href=\"#🧠-什么是堡垒机？\" class=\"headerlink\" title=\"🧠 什么是堡垒机？\"></a>🧠 什么是堡垒机？</h2><p>如果说「跳板机」是一个基础概念，那么「堡垒机」就是它的<strong>完全体、企业级、工业化</strong>的形态。</p>\n<p><strong>堡垒机</strong>（Bastion Host）是一种位于内部网络和外部网络之间的<strong>高性能、高安全性的专用服务器</strong>，其核心设计理念是 <strong>“网络要塞”</strong> 。所有内部设备的远程访问（如 SSH, RDP, SFTP）都必须通过它进行，它作为唯一的入口点，集中进行<strong>身份认证、授权、审计和监控</strong>。</p>\n<p>您可以把它想象成一个<strong>极其严格的银行金库门卫</strong>：</p>\n<ol>\n<li><strong>唯一入口</strong>：所有人都必须从这个门进出。</li>\n<li><strong>严格安检</strong>：需要多重身份验证（工牌、指纹、密码）。</li>\n<li><strong>权限分明</strong>：你只能进入你有权限进入的区域（金库、柜台、办公室）。</li>\n<li><strong>全程监控</strong>：你进去后的一举一动都被全程录像，说了什么话（执行的命令）、拿了什么东西（传输的文件）都有记录。</li>\n</ol>\n<hr>\n<h3 id=\"🆚-堡垒机-vs-简单跳板机：有何不同？\"><a href=\"#🆚-堡垒机-vs-简单跳板机：有何不同？\" class=\"headerlink\" title=\"🆚 堡垒机 vs. 简单跳板机：有何不同？\"></a>🆚 堡垒机 vs. 简单跳板机：有何不同？</h3><p>很多人会混用这两个词，但它们有本质上的区别：</p>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>简单跳板机 (Jump Server)</strong></th>\n<th><strong>堡垒机 (Bastion Host)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>核心功能</strong></td>\n<td><strong>网络转发</strong>、基础连接</td>\n<td><strong>4A管理</strong>：认证、授权、账号、审计</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>相对较低，依赖系统自身安全</td>\n<td><strong>极高</strong>，有专门的安全加固和防护</td>\n</tr>\n<tr>\n<td><strong>用户体验</strong></td>\n<td>命令行，原始</td>\n<td><strong>Web图形化界面</strong>，易于操作</td>\n</tr>\n<tr>\n<td><strong>权限控制</strong></td>\n<td>粗粒度（能&#x2F;不能登录某台机器）</td>\n<td><strong>细粒度</strong>（能登录，且只能执行某些命令）</td>\n</tr>\n<tr>\n<td><strong>审计能力</strong></td>\n<td>基础日志（谁什么时候登录了）</td>\n<td><strong>强大审计</strong><strong>：</strong>**   <strong><strong>-</strong></strong> **<strong>会话录像</strong>（全程录屏）   - <strong>命令记录</strong>（精确到每一条命令）   - <strong>文件传输记录</strong></td>\n</tr>\n<tr>\n<td><strong>账号管理</strong></td>\n<td>分散在各台服务器上</td>\n<td><strong>统一账号管理</strong>，单点登录（SSO）</td>\n</tr>\n<tr>\n<td><strong>本质</strong></td>\n<td><strong>一台功能单一的服务器</strong></td>\n<td><strong>一套完整的安全运维管控系统</strong></td>\n</tr>\n</tbody></table>\n<p><strong>简单说：跳板机主要解决“<strong>怎么进去</strong>”的问题，而堡垒机在此基础上，更解决了“<strong>谁能进</strong>”、“<strong>能干什么</strong>”和“<strong>干了什么</strong>”的问题。</strong></p>\n<hr>\n<h3 id=\"🛡️-堡垒机的核心功能（4A管理）\"><a href=\"#🛡️-堡垒机的核心功能（4A管理）\" class=\"headerlink\" title=\"🛡️ 堡垒机的核心功能（4A管理）\"></a>🛡️ 堡垒机的核心功能（4A管理）</h3><h4 id=\"1-认证-Authentication-：“你是谁？”\"><a href=\"#1-认证-Authentication-：“你是谁？”\" class=\"headerlink\" title=\"1. 认证 (Authentication)：“你是谁？”\"></a>1. 认证 (Authentication)：“你是谁？”</h4><ul>\n<li><strong>多种认证方式</strong>：支持密码、SSH密钥、动态令牌（如Google Authenticator）、LDAP&#x2F;AD域集成、生物识别等。</li>\n<li><strong>多因子认证 (MFA)</strong>：强制要求使用两种及以上方式验证身份，极大提升安全性。</li>\n</ul>\n<h4 id=\"2-授权-Authorization-：“你能干什么？”\"><a href=\"#2-授权-Authorization-：“你能干什么？”\" class=\"headerlink\" title=\"2. 授权 (Authorization)：“你能干什么？”\"></a>2. 授权 (Authorization)：“你能干什么？”</h4><ul>\n<li><strong>精细化的权限控制</strong>：<ul>\n<li><strong>主机权限</strong>：允许用户访问哪些服务器（如：只能访问Web服务器，不能访问数据库服务器）。</li>\n<li><strong>操作权限</strong>：允许用户执行哪些命令（如：可以执行 <code>systemctl restart nginx</code>，但不能执行 <code>rm -rf /</code>）。</li>\n<li><strong>时间权限</strong>：允许用户在什么时间段内访问（如：只能在工作时间访问）。</li>\n</ul>\n</li>\n<li><strong>临时权限申请与审批</strong>：如果需要临时获得更高权限，可以通过工单系统申请，由管理员审批后自动授权，过期自动回收。</li>\n</ul>\n<h4 id=\"3-账号-Account-：“你的身份是什么？”\"><a href=\"#3-账号-Account-：“你的身份是什么？”\" class=\"headerlink\" title=\"3. 账号 (Account)：“你的身份是什么？”\"></a>3. 账号 (Account)：“你的身份是什么？”</h4><ul>\n<li><strong>统一账号管理</strong>：在堡垒机上创建账号，即可映射到后端的多台服务器，无需在每个服务器上单独创建账号。实现了“一个堡垒机账号，访问所有授权资产”。</li>\n<li><strong>托管服务器账号</strong>：服务器账号和密码可以由堡垒机托管，用户无需知道目标服务器的真实密码。</li>\n</ul>\n<h4 id=\"4-审计-Audit-：“你干了什么？”（这是堡垒机的灵魂）\"><a href=\"#4-审计-Audit-：“你干了什么？”（这是堡垒机的灵魂）\" class=\"headerlink\" title=\"4. 审计 (Audit)：“你干了什么？”（这是堡垒机的灵魂）\"></a>4. 审计 (Audit)：“你干了什么？”（这是堡垒机的灵魂）</h4><ul>\n<li><strong><strong>会话录像 (Session Recording)</strong>：** 像录屏一样，完整记录用户在目标服务器上的**所有操作过程</strong>，包括敲打的命令、返回的结果。无法抵赖。</li>\n<li><strong>命令记录</strong>：详细记录执行过的每一条命令及其时间、来源IP。</li>\n<li><strong>文件传输审计</strong>：记录所有通过SFTP&#x2F;SCP&#x2F;RDP上传和下载的文件日志。</li>\n<li><strong>行为分析</strong>：对异常操作、危险命令（如 <code>rm</code>、<code>chmod</code>）进行实时告警。</li>\n</ul>\n<hr>\n<h3 id=\"🏗️-堡垒机的工作流程\"><a href=\"#🏗️-堡垒机的工作流程\" class=\"headerlink\" title=\"🏗️ 堡垒机的工作流程\"></a>🏗️ 堡垒机的工作流程</h3><p>下图以一个运维人员需要通过堡垒机修复网站为例，展示了其核心工作流程与4A功能：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/堡垒机工作流程.svg\"\n                      alt=\"堡垒机工作流程\" width=\"240\" height=\"auto\" style=\"display:block;\"\n                >\n\n\n\n<hr>\n<h3 id=\"🚀-常见的堡垒机方案\"><a href=\"#🚀-常见的堡垒机方案\" class=\"headerlink\" title=\"🚀 常见的堡垒机方案\"></a>🚀 常见的堡垒机方案</h3><ol>\n<li><strong>开源方案</strong>：<ul>\n<li><strong>Jumpserver</strong>：国内最流行的开源堡垒机，功能全面，对中文支持好，社区活跃。</li>\n<li><strong>Teleport</strong>：现代、轻量级，对云原生和Kubernetes环境支持良好。</li>\n<li><strong>Apache Guacamole</strong>：无客户端堡垒机，通过浏览器即可实现RDP、SSH、VNC等连接。</li>\n</ul>\n</li>\n<li><strong>商业方案</strong>：<ul>\n<li><strong>齐治堡垒机</strong>：国内老牌商业产品，市场份额大。</li>\n<li>** Cisco Secure Access (前Duo)**、<strong>CyberArk</strong>：国际知名的商业解决方案，功能强大，价格昂贵。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"✅-总结：为什么需要堡垒机？\"><a href=\"#✅-总结：为什么需要堡垒机？\" class=\"headerlink\" title=\"✅ 总结：为什么需要堡垒机？\"></a>✅ 总结：为什么需要堡垒机？</h3><ol>\n<li><strong>安全第一</strong>：极大缩小了网络攻击面，保护了内部资产。</li>\n<li><strong>合规要求</strong>：满足等保2.0、ISO27001、GDPR等法规对运维审计的强制性要求。</li>\n<li><strong>权限清晰</strong>：实现最小权限原则，避免权限滥用。</li>\n<li><strong>责任界定</strong>：出现问题时，可以通过录像和日志快速定位责任人、还原事故现场。</li>\n<li><strong>运维效率</strong>：统一入口，简化了账号管理和访问流程。</li>\n</ol>\n<p>简而言之，堡垒机是企业IT基础设施中<strong>不可或缺的安全与审计基石</strong>，尤其对于金融、政府、互联网等对安全性和合规性要求极高的行业来说，是标配产品。</p>\n<h1 id=\"OpenVpn-跳板机-堡垒机实现前端部署\"><a href=\"#OpenVpn-跳板机-堡垒机实现前端部署\" class=\"headerlink\" title=\"OpenVpn+跳板机&#x2F;堡垒机实现前端部署\"></a>OpenVpn+跳板机&#x2F;堡垒机实现前端部署</h1><p>这是一个非常经典的DevOps场景：OpenVpn+跳板机&#x2F;堡垒机与前端工程部署结合起来，可以构建一个既安全又高效的部署流程。</p>\n<p>这种架构的核心思想是：通过 OpenVPN 建立安全通道，通过跳板机&#x2F;堡垒机作为统一、受控的入口，来执行部署操作。</p>\n<h2 id=\"🧩-核心架构与角色分工\"><a href=\"#🧩-核心架构与角色分工\" class=\"headerlink\" title=\"🧩 核心架构与角色分工\"></a>🧩 核心架构与角色分工</h2><p>在这种架构下，各个组件的职责非常清晰：</p>\n<ol>\n<li><strong>OpenVPN Server</strong>：<strong>负责建“路”</strong>。建立一条从开发者本地到部署环境的加密隧道，确保传输安全。</li>\n<li><strong>跳板机&#x2F;堡垒机 (Bastion Host)</strong>：<strong>负责管“门”和看“人”</strong>。它是唯一的部署操作入口，负责身份验证、权限控制和操作审计。</li>\n<li><strong>部署目标服务器</strong>：<strong>负责住“应用”</strong>。这是最终运行前端项目（Nginx, Node.js 等）的服务器。</li>\n<li><strong>CI&#x2F;CD 工具 (可选但推荐)</strong>：<strong>负责自动“开车”</strong>。例如 Jenkins、GitLab Runner 等，它们可以自动从仓库拉取代码、构建，并通过跳板机执行部署脚本。</li>\n</ol>\n<p>整个从前端代码到部署上线的安全部署流程，如图所述：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/OpenVpn+堡垒机结合前端部署.svg\"\n                      alt=\"OpenVpn+堡垒机结合前端部署\" width=\"400\" height=\"auto\" style=\"display:block;\"\n                >\n\n\n\n\n<h2 id=\"🛠️-两种常见的部署模式\"><a href=\"#🛠️-两种常见的部署模式\" class=\"headerlink\" title=\"🛠️ 两种常见的部署模式\"></a>🛠️ 两种常见的部署模式</h2><h3 id=\"模式一：手动部署（适合小团队或初期）\"><a href=\"#模式一：手动部署（适合小团队或初期）\" class=\"headerlink\" title=\"模式一：手动部署（适合小团队或初期）\"></a>模式一：手动部署（适合小团队或初期）</h3><p><strong>流程：</strong> 开发者本地构建，然后通过跳板机手动上传文件。</p>\n<p><strong>本地构建</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n\n<p>这会在项目根目录生成 <code>dist</code> 或 <code>build</code> 文件夹，里面是静态文件（HTML, CSS, JS）。</p>\n<ol>\n<li><strong>连接VPN</strong>：确保 OpenVPN 客户端已连接，获得访问内网的权限。</li>\n<li><strong>通过跳板机上传文件</strong>：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 scp 命令，通过跳板机转发到目标服务器</span></span><br><span class=\"line\"><span class=\"comment\"># 注意：跳板机需要配置SSH代理转发或用户有直接权限</span></span><br><span class=\"line\">scp -r -o <span class=\"string\">&#x27;ProxyJump user@jumpbox-ip&#x27;</span> ./dist/* user@target-server-ip:/path/to/nginx/html/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或者使用更现代的 rsync</span></span><br><span class=\"line\">rsync -avz -e <span class=\"string\">&quot;ssh -J user@jumpbox-ip&quot;</span> ./dist/ user@target-server-ip:/path/to/nginx/html/</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>通过跳板机执行远程命令</strong>（如果需要）：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 登录跳板机，再从跳板机SSH到目标服务器</span></span><br><span class=\"line\">ssh user@jumpbox-ip</span><br><span class=\"line\"><span class=\"comment\"># 然后，在跳板机上执行</span></span><br><span class=\"line\">ssh user@target-server-ip <span class=\"string\">&quot;sudo nginx -s reload&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模式二：自动化部署（推荐，适合成熟团队）\"><a href=\"#模式二：自动化部署（推荐，适合成熟团队）\" class=\"headerlink\" title=\"模式二：自动化部署（推荐，适合成熟团队）\"></a>模式二：自动化部署（推荐，适合成熟团队）</h3><p><strong>流程：</strong> CI&#x2F;CD 工具（如 Jenkins、GitLab CI）在检测到 Git 标签或特定分支更新后，自动完成所有步骤。</p>\n<p>这是一个在 GitLab 中实现的自动化部署流程示例：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># .gitlab-ci.yml</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">stages:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">deploy</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">build_production:</span></span><br><span class=\"line\">  <span class=\"attr\">stage:</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"attr\">image:</span> <span class=\"string\">node:16</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">if:</span> <span class=\"string\">$CI_COMMIT_TAG</span> <span class=\"comment\"># 通常在打标签时触发生产环境部署</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"attr\">artifacts:</span></span><br><span class=\"line\">    <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">dist/</span> <span class=\"comment\"># 将构建产物传递给下一个阶段</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">deploy_to_production:</span></span><br><span class=\"line\">  <span class=\"attr\">stage:</span> <span class=\"string\">deploy</span></span><br><span class=\"line\">  <span class=\"attr\">image:</span> <span class=\"string\">alpine</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">if:</span> <span class=\"string\">$CI_COMMIT_TAG</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">apk</span> <span class=\"string\">add</span> <span class=\"string\">--no-cache</span> <span class=\"string\">openssh-client</span> <span class=\"string\">rsync</span></span><br><span class=\"line\">    <span class=\"comment\"># 使用 SSH 通过跳板机部署 (-o ProxyJump)</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">rsync</span> <span class=\"string\">-avz</span> <span class=\"string\">--delete</span> <span class=\"string\">-e</span> <span class=\"string\">&quot;ssh -o StrictHostKeyChecking=no -J $JUMPBOX_USER@$JUMPBOX_IP&quot;</span> <span class=\"string\">dist/</span> <span class=\"string\">$TARGET_SERVER_USER@$TARGET_SERVER_IP:/app/frontend/</span></span><br><span class=\"line\">    <span class=\"comment\"># 通过跳板机执行远程命令，重启服务</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ssh</span> <span class=\"string\">-J</span> <span class=\"string\">$JUMPBOX_USER@$JUMPBOX_IP</span> <span class=\"string\">$TARGET_SERVER_USER@$TARGET_SERVER_IP</span> <span class=\"string\">&quot;sudo systemctl reload nginx&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>$JUMPBOX_IP</code>, <code>$TARGET_SERVER_IP</code> 等变量在 GitLab 的 <strong>CI&#x2F;CD 设置</strong>中配置，避免写在代码里。</li>\n<li><code>-J</code> 参数是 SSH 的 <strong>代理跳跃</strong>，让 SSH 连接自动通过跳板机。</li>\n<li>堡垒机上需要存放 CI&#x2F;CD 工具的 <strong>SSH 私钥</strong>，并且该密钥对目标服务器有访问权限。</li>\n</ul>\n<hr>\n<h2 id=\"⚙️-部署前的重要准备工作\"><a href=\"#⚙️-部署前的重要准备工作\" class=\"headerlink\" title=\"⚙️ 部署前的重要准备工作\"></a>⚙️ 部署前的重要准备工作</h2><ol>\n<li><strong>网络与权限配置</strong>：<ul>\n<li>确保 OpenVPN 服务器配置的路由规则，能让客户端访问到跳板机和目标服务器。</li>\n<li>在跳板机上为每个开发者或CI&#x2F;CD服务创建账号，并配置严格的 SSH 密钥认证。</li>\n<li>配置跳板机的权限控制，确保用户只能访问特定的目标服务器。</li>\n</ul>\n</li>\n<li><strong>堡垒机审计</strong>：<ul>\n<li>开启堡垒机的会话录制功能，记录所有通过它执行的部署命令和文件传输操作。一旦出问题，可以快速回放定位。</li>\n</ul>\n</li>\n<li><strong>目标服务器配置</strong>：<ul>\n<li><strong>Nginx 配置示例</strong>：</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> your-app.com;</span><br><span class=\"line\">  <span class=\"attribute\">root</span> /app/frontend; <span class=\"comment\"># 前端文件部署的目录</span></span><br><span class=\"line\">  <span class=\"attribute\">index</span> index.html;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 处理 SPA 路由（如 Vue Router 的 history 模式）</span></span><br><span class=\"line\">  <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">    <span class=\"attribute\">try_files</span> <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.html;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 启用 gzip 压缩</span></span><br><span class=\"line\">  <span class=\"attribute\">gzip</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\">  <span class=\"attribute\">gzip_types</span> text/css application/javascript;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"✅-这种架构的优势\"><a href=\"#✅-这种架构的优势\" class=\"headerlink\" title=\"✅ 这种架构的优势\"></a>✅ 这种架构的优势</h2><ol>\n<li><strong>极致安全</strong>：<ul>\n<li>内部服务器<strong>完全不用暴露到公网</strong>，攻击者无法直接扫描到。</li>\n<li>所有部署操作都经过<strong>加密隧道</strong>和<strong>严格审计</strong>。</li>\n</ul>\n</li>\n<li><strong>权限清晰</strong>：<ul>\n<li>开发者可能根本不知道目标服务器的密码，而是通过堡垒机的授权来访问，实现了权限最小化原则。</li>\n</ul>\n</li>\n<li><strong>流程标准化</strong>：<ul>\n<li>无论是谁部署，都必须走同一个通道，执行相同的流程，减少了人为出错的可能。</li>\n</ul>\n</li>\n<li><strong>可追溯性</strong>：<ul>\n<li>结合堡垒机的录像功能，可以清晰看到<strong>谁</strong>、在<strong>什么时间</strong>、<strong>部署了什么</strong>、<strong>执行了什么命令</strong>，便于故障排查和审计。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"⚠️-注意事项\"><a href=\"#⚠️-注意事项\" class=\"headerlink\" title=\"⚠️ 注意事项\"></a>⚠️ 注意事项</h2><ul>\n<li><strong>复杂度</strong>：初始设置比直接部署到公网服务器要复杂，但长期来看收益巨大。</li>\n<li><strong>性能</strong>：如果 CI&#x2F;CD 服务器在海外，而跳板机和目标服务器在国内，传输大量文件可能会慢，可以考虑在目标服务器上直接构建。</li>\n<li><strong>成本</strong>：需要维护额外的跳板机&#x2F;堡垒机组件。</li>\n</ul>\n<p><strong>总结：</strong> <strong>OpenVPN + 跳板机&#x2F;堡垒机的部署模式，是企业级前端工程部署的最佳实践之一。</strong> 它通过牺牲一点点部署的便利性，换来了极高的安全性和规范性，非常适合对安全有要求的中大型项目。</p>\n<h1 id=\"SaaS使用的部署方式到底叫什么呢？\"><a href=\"#SaaS使用的部署方式到底叫什么呢？\" class=\"headerlink\" title=\"SaaS使用的部署方式到底叫什么呢？\"></a>SaaS使用的部署方式到底叫什么呢？</h1><p>描述：没有使用jenkins，开发者通过堡垒机连入目标网络中通过git拉取代码并执行打包命令后生成dist或build文件夹，执行shell脚本将打包后的静态资源放到对应的目标服务器的路径下。</p>\n<p><strong>手动或半自动的基于堡垒机的 Git 拉取部署。</strong></p>\n<p>更具体地说，它属于 <strong>“Git-Based Deployment”</strong> 的一种演变形式，核心特点是<strong>通过安全堡垒机作为跳板，直接在目标环境或邻近网络中执行构建和部署</strong>。</p>\n<h2 id=\"🧩-这种部署模式的详细流程拆解\"><a href=\"#🧩-这种部署模式的详细流程拆解\" class=\"headerlink\" title=\"🧩 这种部署模式的详细流程拆解\"></a>🧩 这种部署模式的详细流程拆解</h2><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/yjt中SaaS的前端部署方式.svg\"\n                      alt=\"yjt中SaaS的前端部署方式\" width=\"220\" height=\"auto\" style=\"display:block;\"\n                >\n\n\n<p>它与纯CI&#x2F;CD自动化部署的<strong>核心区别</strong>在于，流程图中<strong>黄色框线</strong>的部分（从 <code>git push</code> 到 <code>重启服务</code>）完全由<strong>开发者手动触发和执行</strong>，而非由CI&#x2F;CD工具（如Jenkins、GitLab CI）自动触发。</p>\n<hr>\n<h2 id=\"⚙️-这种模式的特点\"><a href=\"#⚙️-这种模式的特点\" class=\"headerlink\" title=\"⚙️ 这种模式的特点\"></a>⚙️ 这种模式的特点</h2><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li><strong>环境高度一致</strong>：在<strong>目标网络内</strong>进行构建，可以有效避免“在我本地是好的”这类问题。构建环境与生产环境一致（操作系统、Node版本等）。</li>\n<li><strong>安全性高</strong>：所有操作都通过受审计的堡垒机进行，目标服务器无需暴露到公网，也无需在本地和服务器之间开放额外的端口。</li>\n<li><strong>简单直接，无需复杂配置</strong>：不需要搭建和维护一整套CI&#x2F;CD系统（如Jenkins），对于小团队或项目初期来说，成本更低，更轻量。</li>\n<li><strong>依赖少</strong>：只需要目标服务器上有Git和Node.js环境即可，不需要安装CI&#x2F;CD的Agent。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li><strong>自动化程度低</strong>：严重依赖人工操作。开发者需要手动登录、执行一系列命令。容易因操作失误（比如忘了拉最新代码、在错误目录执行）导致部署失败。</li>\n<li><strong>无法实现真正的持续交付</strong>：部署过程不是自动触发的，通常需要人工干预，无法做到代码一提交就自动测试和部署。</li>\n<li><strong>可追溯性较差</strong>：虽然堡垒机会记录执行了哪些命令，但**“谁在什么时候部署了哪个版本的代码”** 这一信息没有与代码提交（Git Tag&#x2F;Commit ID）强关联地记录下来。出问题时，需要回溯堡垒机日志。</li>\n<li><strong>效率较低</strong>：每次部署都需要在服务器上重新执行完整的构建过程，占用服务器资源，如果服务器性能不佳，构建时间会很长。</li>\n</ol>\n<hr>\n<h2 id=\"🚀-如何优化这种模式？\"><a href=\"#🚀-如何优化这种模式？\" class=\"headerlink\" title=\"🚀 如何优化这种模式？\"></a>🚀 如何优化这种模式？</h2><p>即使不引入Jenkins，也可以让这个流程变得更高效、更可靠：</p>\n<h3 id=\"1-编写自动化部署脚本\"><a href=\"#1-编写自动化部署脚本\" class=\"headerlink\" title=\"1. 编写自动化部署脚本\"></a>1. 编写自动化部署脚本</h3><p>将一系列手动命令写成一个Shell脚本，例如 <code>deploy.sh</code>，放在代码库根目录。</p>\n<p><strong>（这就是SaaS的做法）</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># deploy.sh</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> -e <span class=\"comment\"># 遇到错误就退出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;1. Pulling latest code...&quot;</span></span><br><span class=\"line\">git pull origin main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;2. Installing dependencies...&quot;</span></span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;3. Building project...&quot;</span></span><br><span class=\"line\">npm run build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;4. Backing up old version...&quot;</span></span><br><span class=\"line\">tar -czf /app/backup/frontend-$(<span class=\"built_in\">date</span> +%Y%m%d-%H%M%S).tar.gz /usr/share/nginx/html/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;5. Deploying new version...&quot;</span></span><br><span class=\"line\">rsync -av --delete ./dist/ /usr/share/nginx/html/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;6. Reloading Nginx...&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl reload nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Deployment completed successfully!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>使用方式：</strong> 开发者登录后，只需要执行一条命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash deploy.sh</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用-Git-Hooks（简单CI）\"><a href=\"#2-使用-Git-Hooks（简单CI）\" class=\"headerlink\" title=\"2. 使用 Git Hooks（简单CI）\"></a>2. 使用 Git Hooks（简单CI）</h3><p>在<strong>代码服务器的Git仓库</strong>上配置 <code>post-receive</code> Hook（例如使用Gitea），当收到<code>push</code>时，自动通知目标服务器执行拉取和部署脚本。这实现了简单的自动触发。</p>\n<h3 id=\"3-使用-SSH-直接执行远程命令\"><a href=\"#3-使用-SSH-直接执行远程命令\" class=\"headerlink\" title=\"3. 使用 SSH 直接执行远程命令\"></a>3. 使用 SSH 直接执行远程命令</h3><p>开发者可以在本地电脑上通过一条命令完成部署，无需手动登录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -J user@jumpbox-ip user@target-server-ip <span class=\"string\">&quot;cd /path/to/project &amp;&amp; bash deploy.sh&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-引入版本标记\"><a href=\"#4-引入版本标记\" class=\"headerlink\" title=\"4. 引入版本标记\"></a>4. 引入版本标记</h3><p>在脚本中加入步骤，在部署成功后，给当前的提交打上一个Tag。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag deploy-$(<span class=\"built_in\">date</span> +%Y%m%d-%H%M%S)</span><br><span class=\"line\">git push origin --tags</span><br></pre></td></tr></table></figure>\n\n<p>这样就能清晰地知道生产环境对应的是哪个代码版本。</p>\n<hr>\n<h2 id=\"✅-总结-1\"><a href=\"#✅-总结-1\" class=\"headerlink\" title=\"✅ 总结\"></a>✅ 总结</h2><p>这是一种 <strong>“基于堡垒机的半自动 Git 拉取部署”</strong>。</p>\n<ul>\n<li><strong>它不是什么？</strong> 它不是全自动的CI&#x2F;CD（如Jenkins Pipeline），也不是传统的FTP上传部署。</li>\n<li><strong>它是什么？</strong> 它是一种在<strong>安全约束条件下</strong>、<strong>介于手动部署和全自动部署之间</strong>的实用型方案。</li>\n</ul>\n<p><strong>适用场景：</strong></p>\n<ul>\n<li>内部系统、管理后台等对发布频率要求不高的项目。</li>\n<li>团队规模较小，尚未引入完整CI&#x2F;CD工具链的初期阶段。</li>\n<li>对安全性要求极高，所有内部网络访问必须通过堡垒机的环境。</li>\n</ul>\n<p>对于很多项目来说，这是一个非常好的起点。随着项目发展，当您觉得每次手动运行脚本也很麻烦时，就是考虑引入 <strong>GitLab CI&#x2F;CD、Github Actions</strong> 等真正自动化工具的时候了。</p>\n<h1 id=\"待完善内容\"><a href=\"#待完善内容\" class=\"headerlink\" title=\" 待完善内容 \"></a><font style=\"color:#FFFFFF;background-color:#ED740C;\"> 待完善内容 </font></h1><ul>\n<li><input disabled=\"\" type=\"checkbox\"> CI&#x2F;CD工具：jekins</li>\n<li><input disabled=\"\" type=\"checkbox\"> Docker</li>\n</ul>\n","_processedHighlight":true},{"title":"SSR渲染","date":"2025-08-12T16:00:00.000Z","_content":"\n### 一、核心概念：什么是 SSR？\n**服务端渲染（Server-Side Rendering, SSR）** 指的是：**将原本在客户端（浏览器）执行的页面渲染工作，转移到服务器端完成**。\n\n服务器将渲染好的完整 HTML 页面直接发送给客户端，客户端接收到后无需等待 JavaScript 下载和执行就能直接显示内容。\n\n与之相对的是 **客户端渲染（Client-Side Rendering, CSR）**，也就是我们熟悉的 SPA（单页面应用）模式：服务器只发送一个空的 HTML 壳和一堆 JavaScript 文件，由浏览器下载并执行 JS，再由 JS（如 Vue、React）动态生成页面内容。\n\n---\n\n### 二、工作原理：SSR 与 CSR 的流程对比\n让我们通过两张图来直观理解两者的区别。\n\n#### 1. 客户端渲染 (CSR) 流程\n这是最常见的 Vue/React SPA 模式。\n\n<img src=\"/images/客户端渲染流程.png\" alt=\"客户端渲染流程\" height=\"auto\" style=\"width:60%; display:block;\">\n\n\n**痛点**：步骤 4-8 非常耗时，期间用户看到的是**白屏**，且不利于搜索引擎（SEO）抓取内容。\n\n#### 2. 服务端渲染 (SSR) 流程\n<img src=\"/images/服务端渲染流程.png\" alt=\"服务端渲染流程\" height=\"auto\" style=\"width:60%; display:block;\">\n\n\n**优势**：\n\n+ **步骤 6**：用户几乎立即看到完整内容，**首屏加载极快**，无白屏。\n+ **搜索引擎**：直接拿到完整 HTML，**极利于 SEO**。\n+ **步骤 9**：JS 加载完成后，会“激活”静态页面，使其成为可交互的 SPA。\n\n---\n\n### 三、技术核心：如何实现 SSR？\n实现 SSR 并非简单地在服务器上运行一遍 Vue/React 代码，它需要解决几个关键问题：\n\n#### 1. 双端构建与打包\n你的应用需要被打包成两份：\n\n+ **Client Bundle**：给浏览器用的，和传统的 SPA 包一样。\n+ **Server Bundle**：给服务器用的，它是一套用于渲染组件为 HTML 字符串的代码。\n\n#### 2. 服务器渲染引擎\n需要一个 Node.js 服务器（如 Express、Koa）来运行 **Server Bundle**。\n\n+ 当收到页面请求时，服务器会**创建并管理一个 Vue/React 应用实例**。\n+ 根据请求的 URL，找到对应的路由组件。\n+ 可能还会去后端 API **请求数据**。\n+ 调用框架的 SSR API（如 Vue 的 `vue-server-renderer`，React 的 `ReactDOMServer.renderToString()`）将组件**渲染成 HTML 字符串**。\n+ 最后将这个字符串插入到 HTML 模板中，返回给客户端。\n\n#### 3. 数据预取 (Data Prefetching)\n这是 SSR 的难点和精髓。服务器需要在渲染组件前，预先获取到该组件所需的数据。\n\n+ **约定方法**：为每个页面级组件定义一个异步的 `asyncData()` 方法。\n+ **服务器调用**：服务器在渲染前，会先调用匹配到的组件的 `asyncData()` 方法，等待数据返回。\n+ **注入状态**：将获取到的数据**序列化后内联到 HTML 中**（如放在 `window.__INITIAL_STATE__` 变量里）。\n+ **客户端接管**：客户端 Vue/React 在激活页面（Hydration）时，可以直接使用这份数据，而无需再发起同样的数据请求，避免页面“抖动”。\n\n#### 4. 客户端激活 (Hydration - “水合”)\n**这是最关键也最神奇的一步**，它连接了服务器渲染的静态页面和客户端的动态应用。\n\n+ 客户端收到服务器渲染的静态 HTML 并显示。\n+ 随后，它会加载 **Client Bundle**。\n+ Vue/React 会接管这个静态页面，将其“激活”。\n+ **过程**：Vue/React 会在这个已有的 DOM 结构上重新执行组件逻辑，附加事件监听器，恢复数据响应性，最终使其变成一个完全交互式的 SPA。\n+ **要求**：服务器生成的 DOM 结构必须与客户端 Vue/React 生成的虚拟 DOM 结构完全一致，否则会出现错误。\n\n---\n\n### 四、优缺点总结\n| 方面 | 服务端渲染 (SSR) | 客户端渲染 (CSR) |\n| --- | --- | --- |\n| **首屏速度** | **极快**，直接显示 HTML | 慢，需等待 JS 下载执行 |\n| **SEO** | **友好**，搜索引擎直接抓取 | 不友好，需爬虫执行 JS |\n| **服务器压力** | **大**，每次请求都需渲染 | 小，只返回静态文件 |\n| **开发复杂度** | **高**，需处理双端构建、数据预取等问题 | 低，流程简单 |\n| **技术栈** | 通常需基于特定框架（如 Nuxt.js, Next.js） | 任意 Vue/React 项目 |\n\n\n### 五、主流 SSR 框架\n由于手动搭建 SSR 环境非常复杂，通常使用成熟的框架：\n\n+ **Vue 生态**：**Nuxt.js**。它提供了“开箱即用”的 SSR 支持，极大地简化了配置和开发。\n+ **React 生态**：**Next.js**。是 React 的 SSR 首选框架，功能强大且完善。\n\n### 总结\nSSR 的原理可以概括为：**“服务器提前帮你把活儿干了”**。\n\n1. **服务器**收到请求后，**执行 JS**，预先请求数据，并渲染出**包含数据的完整 HTML** 字符串，直接返回。\n2. **客户端**收到后立即展示，然后再加载 JS，进行 **Hydration（水合）**，将静态页面“激活”为动态应用。\n\n它用**更高的服务器成本和开发复杂度**，换来了**卓越的首屏性能和 SEO 效果**，是内容驱动型网站（如电商、新闻、博客）的理想选择。\n\n","source":"_posts/SSR渲染.md","raw":"---\ntitle: SSR渲染\ndate: 2025-08-13\ntags: [SSR渲染]\ncategories: SSR渲染\n---\n\n### 一、核心概念：什么是 SSR？\n**服务端渲染（Server-Side Rendering, SSR）** 指的是：**将原本在客户端（浏览器）执行的页面渲染工作，转移到服务器端完成**。\n\n服务器将渲染好的完整 HTML 页面直接发送给客户端，客户端接收到后无需等待 JavaScript 下载和执行就能直接显示内容。\n\n与之相对的是 **客户端渲染（Client-Side Rendering, CSR）**，也就是我们熟悉的 SPA（单页面应用）模式：服务器只发送一个空的 HTML 壳和一堆 JavaScript 文件，由浏览器下载并执行 JS，再由 JS（如 Vue、React）动态生成页面内容。\n\n---\n\n### 二、工作原理：SSR 与 CSR 的流程对比\n让我们通过两张图来直观理解两者的区别。\n\n#### 1. 客户端渲染 (CSR) 流程\n这是最常见的 Vue/React SPA 模式。\n\n<img src=\"/images/客户端渲染流程.png\" alt=\"客户端渲染流程\" height=\"auto\" style=\"width:60%; display:block;\">\n\n\n**痛点**：步骤 4-8 非常耗时，期间用户看到的是**白屏**，且不利于搜索引擎（SEO）抓取内容。\n\n#### 2. 服务端渲染 (SSR) 流程\n<img src=\"/images/服务端渲染流程.png\" alt=\"服务端渲染流程\" height=\"auto\" style=\"width:60%; display:block;\">\n\n\n**优势**：\n\n+ **步骤 6**：用户几乎立即看到完整内容，**首屏加载极快**，无白屏。\n+ **搜索引擎**：直接拿到完整 HTML，**极利于 SEO**。\n+ **步骤 9**：JS 加载完成后，会“激活”静态页面，使其成为可交互的 SPA。\n\n---\n\n### 三、技术核心：如何实现 SSR？\n实现 SSR 并非简单地在服务器上运行一遍 Vue/React 代码，它需要解决几个关键问题：\n\n#### 1. 双端构建与打包\n你的应用需要被打包成两份：\n\n+ **Client Bundle**：给浏览器用的，和传统的 SPA 包一样。\n+ **Server Bundle**：给服务器用的，它是一套用于渲染组件为 HTML 字符串的代码。\n\n#### 2. 服务器渲染引擎\n需要一个 Node.js 服务器（如 Express、Koa）来运行 **Server Bundle**。\n\n+ 当收到页面请求时，服务器会**创建并管理一个 Vue/React 应用实例**。\n+ 根据请求的 URL，找到对应的路由组件。\n+ 可能还会去后端 API **请求数据**。\n+ 调用框架的 SSR API（如 Vue 的 `vue-server-renderer`，React 的 `ReactDOMServer.renderToString()`）将组件**渲染成 HTML 字符串**。\n+ 最后将这个字符串插入到 HTML 模板中，返回给客户端。\n\n#### 3. 数据预取 (Data Prefetching)\n这是 SSR 的难点和精髓。服务器需要在渲染组件前，预先获取到该组件所需的数据。\n\n+ **约定方法**：为每个页面级组件定义一个异步的 `asyncData()` 方法。\n+ **服务器调用**：服务器在渲染前，会先调用匹配到的组件的 `asyncData()` 方法，等待数据返回。\n+ **注入状态**：将获取到的数据**序列化后内联到 HTML 中**（如放在 `window.__INITIAL_STATE__` 变量里）。\n+ **客户端接管**：客户端 Vue/React 在激活页面（Hydration）时，可以直接使用这份数据，而无需再发起同样的数据请求，避免页面“抖动”。\n\n#### 4. 客户端激活 (Hydration - “水合”)\n**这是最关键也最神奇的一步**，它连接了服务器渲染的静态页面和客户端的动态应用。\n\n+ 客户端收到服务器渲染的静态 HTML 并显示。\n+ 随后，它会加载 **Client Bundle**。\n+ Vue/React 会接管这个静态页面，将其“激活”。\n+ **过程**：Vue/React 会在这个已有的 DOM 结构上重新执行组件逻辑，附加事件监听器，恢复数据响应性，最终使其变成一个完全交互式的 SPA。\n+ **要求**：服务器生成的 DOM 结构必须与客户端 Vue/React 生成的虚拟 DOM 结构完全一致，否则会出现错误。\n\n---\n\n### 四、优缺点总结\n| 方面 | 服务端渲染 (SSR) | 客户端渲染 (CSR) |\n| --- | --- | --- |\n| **首屏速度** | **极快**，直接显示 HTML | 慢，需等待 JS 下载执行 |\n| **SEO** | **友好**，搜索引擎直接抓取 | 不友好，需爬虫执行 JS |\n| **服务器压力** | **大**，每次请求都需渲染 | 小，只返回静态文件 |\n| **开发复杂度** | **高**，需处理双端构建、数据预取等问题 | 低，流程简单 |\n| **技术栈** | 通常需基于特定框架（如 Nuxt.js, Next.js） | 任意 Vue/React 项目 |\n\n\n### 五、主流 SSR 框架\n由于手动搭建 SSR 环境非常复杂，通常使用成熟的框架：\n\n+ **Vue 生态**：**Nuxt.js**。它提供了“开箱即用”的 SSR 支持，极大地简化了配置和开发。\n+ **React 生态**：**Next.js**。是 React 的 SSR 首选框架，功能强大且完善。\n\n### 总结\nSSR 的原理可以概括为：**“服务器提前帮你把活儿干了”**。\n\n1. **服务器**收到请求后，**执行 JS**，预先请求数据，并渲染出**包含数据的完整 HTML** 字符串，直接返回。\n2. **客户端**收到后立即展示，然后再加载 JS，进行 **Hydration（水合）**，将静态页面“激活”为动态应用。\n\n它用**更高的服务器成本和开发复杂度**，换来了**卓越的首屏性能和 SEO 效果**，是内容驱动型网站（如电商、新闻、博客）的理想选择。\n\n","slug":"SSR渲染","published":1,"updated":"2025-09-14T14:01:01.211Z","_id":"cmfjrcmnz0000175wdmfi64tf","comments":1,"layout":"post","photos":[],"content":"<h3 id=\"一、核心概念：什么是-SSR？\"><a href=\"#一、核心概念：什么是-SSR？\" class=\"headerlink\" title=\"一、核心概念：什么是 SSR？\"></a>一、核心概念：什么是 SSR？</h3><p><strong>服务端渲染（Server-Side Rendering, SSR）</strong> 指的是：<strong>将原本在客户端（浏览器）执行的页面渲染工作，转移到服务器端完成</strong>。</p>\n<p>服务器将渲染好的完整 HTML 页面直接发送给客户端，客户端接收到后无需等待 JavaScript 下载和执行就能直接显示内容。</p>\n<p>与之相对的是 <strong>客户端渲染（Client-Side Rendering, CSR）</strong>，也就是我们熟悉的 SPA（单页面应用）模式：服务器只发送一个空的 HTML 壳和一堆 JavaScript 文件，由浏览器下载并执行 JS，再由 JS（如 Vue、React）动态生成页面内容。</p>\n<hr>\n<h3 id=\"二、工作原理：SSR-与-CSR-的流程对比\"><a href=\"#二、工作原理：SSR-与-CSR-的流程对比\" class=\"headerlink\" title=\"二、工作原理：SSR 与 CSR 的流程对比\"></a>二、工作原理：SSR 与 CSR 的流程对比</h3><p>让我们通过两张图来直观理解两者的区别。</p>\n<h4 id=\"1-客户端渲染-CSR-流程\"><a href=\"#1-客户端渲染-CSR-流程\" class=\"headerlink\" title=\"1. 客户端渲染 (CSR) 流程\"></a>1. 客户端渲染 (CSR) 流程</h4><p>这是最常见的 Vue&#x2F;React SPA 模式。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/客户端渲染流程.png\"\n                      alt=\"客户端渲染流程\" height=\"auto\" style=\"width:60%; display:block;\"\n                >\n\n\n<p><strong>痛点</strong>：步骤 4-8 非常耗时，期间用户看到的是<strong>白屏</strong>，且不利于搜索引擎（SEO）抓取内容。</p>\n<h4 id=\"2-服务端渲染-SSR-流程\"><a href=\"#2-服务端渲染-SSR-流程\" class=\"headerlink\" title=\"2. 服务端渲染 (SSR) 流程\"></a>2. 服务端渲染 (SSR) 流程</h4><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/服务端渲染流程.png\"\n                      alt=\"服务端渲染流程\" height=\"auto\" style=\"width:60%; display:block;\"\n                >\n\n\n<p><strong>优势</strong>：</p>\n<ul>\n<li><strong>步骤 6</strong>：用户几乎立即看到完整内容，<strong>首屏加载极快</strong>，无白屏。</li>\n<li><strong>搜索引擎</strong>：直接拿到完整 HTML，<strong>极利于 SEO</strong>。</li>\n<li><strong>步骤 9</strong>：JS 加载完成后，会“激活”静态页面，使其成为可交互的 SPA。</li>\n</ul>\n<hr>\n<h3 id=\"三、技术核心：如何实现-SSR？\"><a href=\"#三、技术核心：如何实现-SSR？\" class=\"headerlink\" title=\"三、技术核心：如何实现 SSR？\"></a>三、技术核心：如何实现 SSR？</h3><p>实现 SSR 并非简单地在服务器上运行一遍 Vue&#x2F;React 代码，它需要解决几个关键问题：</p>\n<h4 id=\"1-双端构建与打包\"><a href=\"#1-双端构建与打包\" class=\"headerlink\" title=\"1. 双端构建与打包\"></a>1. 双端构建与打包</h4><p>你的应用需要被打包成两份：</p>\n<ul>\n<li><strong>Client Bundle</strong>：给浏览器用的，和传统的 SPA 包一样。</li>\n<li><strong>Server Bundle</strong>：给服务器用的，它是一套用于渲染组件为 HTML 字符串的代码。</li>\n</ul>\n<h4 id=\"2-服务器渲染引擎\"><a href=\"#2-服务器渲染引擎\" class=\"headerlink\" title=\"2. 服务器渲染引擎\"></a>2. 服务器渲染引擎</h4><p>需要一个 Node.js 服务器（如 Express、Koa）来运行 <strong>Server Bundle</strong>。</p>\n<ul>\n<li>当收到页面请求时，服务器会<strong>创建并管理一个 Vue&#x2F;React 应用实例</strong>。</li>\n<li>根据请求的 URL，找到对应的路由组件。</li>\n<li>可能还会去后端 API <strong>请求数据</strong>。</li>\n<li>调用框架的 SSR API（如 Vue 的 <code>vue-server-renderer</code>，React 的 <code>ReactDOMServer.renderToString()</code>）将组件<strong>渲染成 HTML 字符串</strong>。</li>\n<li>最后将这个字符串插入到 HTML 模板中，返回给客户端。</li>\n</ul>\n<h4 id=\"3-数据预取-Data-Prefetching\"><a href=\"#3-数据预取-Data-Prefetching\" class=\"headerlink\" title=\"3. 数据预取 (Data Prefetching)\"></a>3. 数据预取 (Data Prefetching)</h4><p>这是 SSR 的难点和精髓。服务器需要在渲染组件前，预先获取到该组件所需的数据。</p>\n<ul>\n<li><strong>约定方法</strong>：为每个页面级组件定义一个异步的 <code>asyncData()</code> 方法。</li>\n<li><strong>服务器调用</strong>：服务器在渲染前，会先调用匹配到的组件的 <code>asyncData()</code> 方法，等待数据返回。</li>\n<li><strong>注入状态</strong>：将获取到的数据<strong>序列化后内联到 HTML 中</strong>（如放在 <code>window.__INITIAL_STATE__</code> 变量里）。</li>\n<li><strong>客户端接管</strong>：客户端 Vue&#x2F;React 在激活页面（Hydration）时，可以直接使用这份数据，而无需再发起同样的数据请求，避免页面“抖动”。</li>\n</ul>\n<h4 id=\"4-客户端激活-Hydration-“水合”\"><a href=\"#4-客户端激活-Hydration-“水合”\" class=\"headerlink\" title=\"4. 客户端激活 (Hydration - “水合”)\"></a>4. 客户端激活 (Hydration - “水合”)</h4><p><strong>这是最关键也最神奇的一步</strong>，它连接了服务器渲染的静态页面和客户端的动态应用。</p>\n<ul>\n<li>客户端收到服务器渲染的静态 HTML 并显示。</li>\n<li>随后，它会加载 <strong>Client Bundle</strong>。</li>\n<li>Vue&#x2F;React 会接管这个静态页面，将其“激活”。</li>\n<li><strong>过程</strong>：Vue&#x2F;React 会在这个已有的 DOM 结构上重新执行组件逻辑，附加事件监听器，恢复数据响应性，最终使其变成一个完全交互式的 SPA。</li>\n<li><strong>要求</strong>：服务器生成的 DOM 结构必须与客户端 Vue&#x2F;React 生成的虚拟 DOM 结构完全一致，否则会出现错误。</li>\n</ul>\n<hr>\n<h3 id=\"四、优缺点总结\"><a href=\"#四、优缺点总结\" class=\"headerlink\" title=\"四、优缺点总结\"></a>四、优缺点总结</h3><table>\n<thead>\n<tr>\n<th>方面</th>\n<th>服务端渲染 (SSR)</th>\n<th>客户端渲染 (CSR)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>首屏速度</strong></td>\n<td><strong>极快</strong>，直接显示 HTML</td>\n<td>慢，需等待 JS 下载执行</td>\n</tr>\n<tr>\n<td><strong>SEO</strong></td>\n<td><strong>友好</strong>，搜索引擎直接抓取</td>\n<td>不友好，需爬虫执行 JS</td>\n</tr>\n<tr>\n<td><strong>服务器压力</strong></td>\n<td><strong>大</strong>，每次请求都需渲染</td>\n<td>小，只返回静态文件</td>\n</tr>\n<tr>\n<td><strong>开发复杂度</strong></td>\n<td><strong>高</strong>，需处理双端构建、数据预取等问题</td>\n<td>低，流程简单</td>\n</tr>\n<tr>\n<td><strong>技术栈</strong></td>\n<td>通常需基于特定框架（如 Nuxt.js, Next.js）</td>\n<td>任意 Vue&#x2F;React 项目</td>\n</tr>\n</tbody></table>\n<h3 id=\"五、主流-SSR-框架\"><a href=\"#五、主流-SSR-框架\" class=\"headerlink\" title=\"五、主流 SSR 框架\"></a>五、主流 SSR 框架</h3><p>由于手动搭建 SSR 环境非常复杂，通常使用成熟的框架：</p>\n<ul>\n<li><strong>Vue 生态</strong>：<strong>Nuxt.js</strong>。它提供了“开箱即用”的 SSR 支持，极大地简化了配置和开发。</li>\n<li><strong>React 生态</strong>：<strong>Next.js</strong>。是 React 的 SSR 首选框架，功能强大且完善。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>SSR 的原理可以概括为：<strong>“服务器提前帮你把活儿干了”</strong>。</p>\n<ol>\n<li><strong>服务器</strong>收到请求后，<strong>执行 JS</strong>，预先请求数据，并渲染出<strong>包含数据的完整 HTML</strong> 字符串，直接返回。</li>\n<li><strong>客户端</strong>收到后立即展示，然后再加载 JS，进行 <strong>Hydration（水合）</strong>，将静态页面“激活”为动态应用。</li>\n</ol>\n<p>它用<strong>更高的服务器成本和开发复杂度</strong>，换来了<strong>卓越的首屏性能和 SEO 效果</strong>，是内容驱动型网站（如电商、新闻、博客）的理想选择。</p>\n","excerpt":"","more":"<h3 id=\"一、核心概念：什么是-SSR？\"><a href=\"#一、核心概念：什么是-SSR？\" class=\"headerlink\" title=\"一、核心概念：什么是 SSR？\"></a>一、核心概念：什么是 SSR？</h3><p><strong>服务端渲染（Server-Side Rendering, SSR）</strong> 指的是：<strong>将原本在客户端（浏览器）执行的页面渲染工作，转移到服务器端完成</strong>。</p>\n<p>服务器将渲染好的完整 HTML 页面直接发送给客户端，客户端接收到后无需等待 JavaScript 下载和执行就能直接显示内容。</p>\n<p>与之相对的是 <strong>客户端渲染（Client-Side Rendering, CSR）</strong>，也就是我们熟悉的 SPA（单页面应用）模式：服务器只发送一个空的 HTML 壳和一堆 JavaScript 文件，由浏览器下载并执行 JS，再由 JS（如 Vue、React）动态生成页面内容。</p>\n<hr>\n<h3 id=\"二、工作原理：SSR-与-CSR-的流程对比\"><a href=\"#二、工作原理：SSR-与-CSR-的流程对比\" class=\"headerlink\" title=\"二、工作原理：SSR 与 CSR 的流程对比\"></a>二、工作原理：SSR 与 CSR 的流程对比</h3><p>让我们通过两张图来直观理解两者的区别。</p>\n<h4 id=\"1-客户端渲染-CSR-流程\"><a href=\"#1-客户端渲染-CSR-流程\" class=\"headerlink\" title=\"1. 客户端渲染 (CSR) 流程\"></a>1. 客户端渲染 (CSR) 流程</h4><p>这是最常见的 Vue&#x2F;React SPA 模式。</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/客户端渲染流程.png\"\n                      alt=\"客户端渲染流程\" height=\"auto\" style=\"width:60%; display:block;\"\n                >\n\n\n<p><strong>痛点</strong>：步骤 4-8 非常耗时，期间用户看到的是<strong>白屏</strong>，且不利于搜索引擎（SEO）抓取内容。</p>\n<h4 id=\"2-服务端渲染-SSR-流程\"><a href=\"#2-服务端渲染-SSR-流程\" class=\"headerlink\" title=\"2. 服务端渲染 (SSR) 流程\"></a>2. 服务端渲染 (SSR) 流程</h4><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/服务端渲染流程.png\"\n                      alt=\"服务端渲染流程\" height=\"auto\" style=\"width:60%; display:block;\"\n                >\n\n\n<p><strong>优势</strong>：</p>\n<ul>\n<li><strong>步骤 6</strong>：用户几乎立即看到完整内容，<strong>首屏加载极快</strong>，无白屏。</li>\n<li><strong>搜索引擎</strong>：直接拿到完整 HTML，<strong>极利于 SEO</strong>。</li>\n<li><strong>步骤 9</strong>：JS 加载完成后，会“激活”静态页面，使其成为可交互的 SPA。</li>\n</ul>\n<hr>\n<h3 id=\"三、技术核心：如何实现-SSR？\"><a href=\"#三、技术核心：如何实现-SSR？\" class=\"headerlink\" title=\"三、技术核心：如何实现 SSR？\"></a>三、技术核心：如何实现 SSR？</h3><p>实现 SSR 并非简单地在服务器上运行一遍 Vue&#x2F;React 代码，它需要解决几个关键问题：</p>\n<h4 id=\"1-双端构建与打包\"><a href=\"#1-双端构建与打包\" class=\"headerlink\" title=\"1. 双端构建与打包\"></a>1. 双端构建与打包</h4><p>你的应用需要被打包成两份：</p>\n<ul>\n<li><strong>Client Bundle</strong>：给浏览器用的，和传统的 SPA 包一样。</li>\n<li><strong>Server Bundle</strong>：给服务器用的，它是一套用于渲染组件为 HTML 字符串的代码。</li>\n</ul>\n<h4 id=\"2-服务器渲染引擎\"><a href=\"#2-服务器渲染引擎\" class=\"headerlink\" title=\"2. 服务器渲染引擎\"></a>2. 服务器渲染引擎</h4><p>需要一个 Node.js 服务器（如 Express、Koa）来运行 <strong>Server Bundle</strong>。</p>\n<ul>\n<li>当收到页面请求时，服务器会<strong>创建并管理一个 Vue&#x2F;React 应用实例</strong>。</li>\n<li>根据请求的 URL，找到对应的路由组件。</li>\n<li>可能还会去后端 API <strong>请求数据</strong>。</li>\n<li>调用框架的 SSR API（如 Vue 的 <code>vue-server-renderer</code>，React 的 <code>ReactDOMServer.renderToString()</code>）将组件<strong>渲染成 HTML 字符串</strong>。</li>\n<li>最后将这个字符串插入到 HTML 模板中，返回给客户端。</li>\n</ul>\n<h4 id=\"3-数据预取-Data-Prefetching\"><a href=\"#3-数据预取-Data-Prefetching\" class=\"headerlink\" title=\"3. 数据预取 (Data Prefetching)\"></a>3. 数据预取 (Data Prefetching)</h4><p>这是 SSR 的难点和精髓。服务器需要在渲染组件前，预先获取到该组件所需的数据。</p>\n<ul>\n<li><strong>约定方法</strong>：为每个页面级组件定义一个异步的 <code>asyncData()</code> 方法。</li>\n<li><strong>服务器调用</strong>：服务器在渲染前，会先调用匹配到的组件的 <code>asyncData()</code> 方法，等待数据返回。</li>\n<li><strong>注入状态</strong>：将获取到的数据<strong>序列化后内联到 HTML 中</strong>（如放在 <code>window.__INITIAL_STATE__</code> 变量里）。</li>\n<li><strong>客户端接管</strong>：客户端 Vue&#x2F;React 在激活页面（Hydration）时，可以直接使用这份数据，而无需再发起同样的数据请求，避免页面“抖动”。</li>\n</ul>\n<h4 id=\"4-客户端激活-Hydration-“水合”\"><a href=\"#4-客户端激活-Hydration-“水合”\" class=\"headerlink\" title=\"4. 客户端激活 (Hydration - “水合”)\"></a>4. 客户端激活 (Hydration - “水合”)</h4><p><strong>这是最关键也最神奇的一步</strong>，它连接了服务器渲染的静态页面和客户端的动态应用。</p>\n<ul>\n<li>客户端收到服务器渲染的静态 HTML 并显示。</li>\n<li>随后，它会加载 <strong>Client Bundle</strong>。</li>\n<li>Vue&#x2F;React 会接管这个静态页面，将其“激活”。</li>\n<li><strong>过程</strong>：Vue&#x2F;React 会在这个已有的 DOM 结构上重新执行组件逻辑，附加事件监听器，恢复数据响应性，最终使其变成一个完全交互式的 SPA。</li>\n<li><strong>要求</strong>：服务器生成的 DOM 结构必须与客户端 Vue&#x2F;React 生成的虚拟 DOM 结构完全一致，否则会出现错误。</li>\n</ul>\n<hr>\n<h3 id=\"四、优缺点总结\"><a href=\"#四、优缺点总结\" class=\"headerlink\" title=\"四、优缺点总结\"></a>四、优缺点总结</h3><table>\n<thead>\n<tr>\n<th>方面</th>\n<th>服务端渲染 (SSR)</th>\n<th>客户端渲染 (CSR)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>首屏速度</strong></td>\n<td><strong>极快</strong>，直接显示 HTML</td>\n<td>慢，需等待 JS 下载执行</td>\n</tr>\n<tr>\n<td><strong>SEO</strong></td>\n<td><strong>友好</strong>，搜索引擎直接抓取</td>\n<td>不友好，需爬虫执行 JS</td>\n</tr>\n<tr>\n<td><strong>服务器压力</strong></td>\n<td><strong>大</strong>，每次请求都需渲染</td>\n<td>小，只返回静态文件</td>\n</tr>\n<tr>\n<td><strong>开发复杂度</strong></td>\n<td><strong>高</strong>，需处理双端构建、数据预取等问题</td>\n<td>低，流程简单</td>\n</tr>\n<tr>\n<td><strong>技术栈</strong></td>\n<td>通常需基于特定框架（如 Nuxt.js, Next.js）</td>\n<td>任意 Vue&#x2F;React 项目</td>\n</tr>\n</tbody></table>\n<h3 id=\"五、主流-SSR-框架\"><a href=\"#五、主流-SSR-框架\" class=\"headerlink\" title=\"五、主流 SSR 框架\"></a>五、主流 SSR 框架</h3><p>由于手动搭建 SSR 环境非常复杂，通常使用成熟的框架：</p>\n<ul>\n<li><strong>Vue 生态</strong>：<strong>Nuxt.js</strong>。它提供了“开箱即用”的 SSR 支持，极大地简化了配置和开发。</li>\n<li><strong>React 生态</strong>：<strong>Next.js</strong>。是 React 的 SSR 首选框架，功能强大且完善。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>SSR 的原理可以概括为：<strong>“服务器提前帮你把活儿干了”</strong>。</p>\n<ol>\n<li><strong>服务器</strong>收到请求后，<strong>执行 JS</strong>，预先请求数据，并渲染出<strong>包含数据的完整 HTML</strong> 字符串，直接返回。</li>\n<li><strong>客户端</strong>收到后立即展示，然后再加载 JS，进行 <strong>Hydration（水合）</strong>，将静态页面“激活”为动态应用。</li>\n</ol>\n<p>它用<strong>更高的服务器成本和开发复杂度</strong>，换来了<strong>卓越的首屏性能和 SEO 效果</strong>，是内容驱动型网站（如电商、新闻、博客）的理想选择。</p>\n","_processedHighlight":true},{"title":"关于Webpack","date":"2024-08-12T16:00:00.000Z","_content":"\n概念：Webpack 是一种用于构建 JavaScript 应用程序的静态模块打包器，它能够以一种相对一致且开放的处理方式，加载应用中的所有资源文件（图片、CSS、视频、字体文件等），并将其合并打包成浏览器兼容的 Web 资源文件。\n\n功能：****\n\n+ 模块的打包：通过打包整合不同的模块文件保证各模块之间的引用和执行\n+ 代码编译：通过丰富的`**loader**`可以将不同格式文件如`**.sass/.vue/.jsx**`转译为浏览器可以执行的文件\n+ 扩展功能：通过社区丰富的`**plugin**`可以实现多种强大的功能，例如**代码分割、代码混淆、代码压缩、按需加载.....等等**\n\n### 常见的loader及其作用\n**<font style=\"color:#1DC0C9;\">-babel-loader</font>**：将es6转译为es5\n\n**<font style=\"color:#1DC0C9;\">-file-loader</font>**：可以指定要复制和放置资源文件的位置，以及如何使用版本哈希命名以获得更好的缓存，并在代码中通过**URL**去引用输出的文件\n\n**<font style=\"color:#1DC0C9;\">-url-loader</font>**：和`**file-loader**`功能相似，但是可以通过指定阈值来根据文件大小使用不同的处理方式（小于阈值则返回base64格式编码并将文件的 `data-url`内联到`bundle`中）\n\n**<font style=\"color:#1DC0C9;\">-raw-loader</font>**：加载文件原始内容\n\n> webpack5自身内置了`**file-loader/ url-loader/ raw-loader**`等loader，所以我们不需要再显示引入loader 只需要指定对应的type即可实现相同的功能 如`**file-loader**`等价于 `**type= \"asset/resource\"**`\n>\n\n**<font style=\"color:#1DC0C9;\">-image-webpack-loader</font>**： 加载并压缩图片资源\n\n**<font style=\"color:#1DC0C9;\">-awesome-typescirpt-loader</font>**: 将typescript转换为javaScript 并且性能优于`**ts-loader**`\n\n**<font style=\"color:#1DC0C9;\">-sass-loader</font>**: 将SCSS/SASS代码转换为CSS\n\n**<font style=\"color:#1DC0C9;\">-css-loader</font>**: 加载CSS代码 支持模块化、压缩、文件导入等功能特性**\n\n**<font style=\"color:#1DC0C9;\">-style-loader</font>**: 把CSS代码注入到js中，通过`DOM` 操作去加载CSS代码\n\n> 当我们使用类似于 `**less**` 或者 `**scss**` 等预处理器的时候，通常需要多个 **loader** 的配合使用如`**test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader']**`\n>\n\n**<font style=\"color:#1DC0C9;\">-source-map-loader</font>**: 加载额外的`Source Map`文件\n\n**<font style=\"color:#1DC0C9;\">-eslint-loader</font>**: 通过ESlint 检查js代码\n\n**<font style=\"color:#1DC0C9;\">-cache-loader</font>**: 可以在一些开销较大的`Loader`之前添加可以将结果缓存到磁盘中，提高构建的效率\n\n**<font style=\"color:#1DC0C9;\">-thread-loader</font>**: 多线程打包，加快打包速度\n\n### 常见的plugin及其作用\n**<font style=\"color:#1DC0C9;\">-splitChunkPlugin</font>**: 定义环境变量（webpack4之后可以通过指定`**mode：production/development**`实现同样效果）\n\n**<font style=\"color:#1DC0C9;\">-define-plugin</font>**: 定义环境变量（webpack4之后可以通过指定`**mode：production/development**`实现同样效果）\n\n**<font style=\"color:#1DC0C9;\">-web-webpack-plugin</font>**：为单页面应用输出HTML 性能优于`html-webpack-plugin`\n\n**<font style=\"color:#1DC0C9;\">-clean-webpack-plugin</font>**: 每次打包时删除上次打包的产物, 保证打包目录下的文件都是最新的\n\n**<font style=\"color:#1DC0C9;\">-webpack-merge</font>**： 用来合并公共配置文件,常用（例如分别配置`webpack.common.config.js/ webpack.dev.config.js/webpack.production.config.js`并将其合并）\n\n**<font style=\"color:#1DC0C9;\">-ignore-plugin</font>**: 忽略指定的文件，可以加快构建速度\n\n**<font style=\"color:#1DC0C9;\">-terser-webpack-plugin</font>**：压缩ES6的代码（tree-shaking）\n\n**<font style=\"color:#1DC0C9;\">-uglifyjs-webpack-plugin</font>**: 压缩js代码\n\n**<font style=\"color:#1DC0C9;\">-mini-css-extract-plugin</font>**: 将CSS提取为独立文件，支持按需加载x\n\n**<font style=\"color:#1DC0C9;\">-css-minimize-webpack-plugin</font>**：压缩CSS代码\n\n> css文件的压缩需要`**mini-css-extract-plugin**`和`**css-minimize-webpack-plugin** `的配合使用 即先使用`**mini-css-extract-plugin**`将css代码抽离成单独文件，之后使用` **css-minimize-webpack-plugin**`对css代码进行压缩\n>\n\n**<font style=\"color:#1DC0C9;\">-serviceworker-webpack-plugin</font>**: 为离线应用增加离线缓存功能\n\n**<font style=\"color:#1DC0C9;\">-ModuleconcatenationPlugin</font>**: 开启`**Scope Hositing**` 用于合并提升作用域， 减小代码体积\n\n**<font style=\"color:#1DC0C9;\">-copy-webpack-plugin</font>**： 在构建的时候，复制静态资源到打包目录。\n\n**<font style=\"color:#1DC0C9;\">-compression-webpack-plugin</font>**: 生产环境采用`**gzip**`压缩JS和CSS\n\n**<font style=\"color:#1DC0C9;\">-ParalleUglifyPlugin</font>**： 多进程并行压缩js\n\n**<font style=\"color:#1DC0C9;\">-webpack-bundle-analyzer</font>**: 可视化webpack输出文件大小的根据\n\n**<font style=\"color:#1DC0C9;\">-speed-measure-webpack-plugin</font>**: 用于分析各个loader和plugin的耗时，可用于性能分析\n\n**<font style=\"color:#1DC0C9;\">-webpack-dashboard</font>**: 可以更友好地展示打包相关信息\n\n**<font style=\"color:#1DC0C9;\">-Webpack Analysis</font>**：webpack 官方提供的可视化分析工具\n\n**<font style=\"color:#1DC0C9;\">-BundleAnalyzerPlugin</font>**：性能分析插件，可以在运行后查看是否包含重复模块/不必要模块等\n\n### loader和plugin的区别\n**<font style=\"color:#1DC0C9;\">Loader：</font>**\n\nLoader本质上是一个函数，负责代码的转译，即对接收到的内容进行转换后将转换后的结果返回 ，因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。\n\n配置Loader通过在 **module.rules **中以数组的形式配置，每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。\n\n**<font style=\"color:#1DC0C9;\">Plugin：</font>**\n\nPlugin可以扩展 Webpack 的功能，本质上是一个带有 **apply(compiler)** 的函数，基于 [tapable](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftapable) 这个事件流框架来监听**webpack**构建/打包过程中发布的hooks来通过自定义的逻辑和功能来改变输出结果。 \n\nPlugin通过 **plugins** 以数组的形式配置，每一项是一个 Plugin 的实例，参数都通过构造函数传入。\n\n**总结：**\n\n**Loader **主要负责将代码转译为**webpack**可以处理的JavaScript代码，而 **Plugin** 更多的是负责通过接入**webpack**构建过程来影响构建过程以及产物的输出，**Loader**的职责相对比较**单一**简单，而 **Plugin **更为丰富多样。\n\n### loader执行顺序\n##### 分类\n    - **<font style=\"color:#1DC0C9;\">pre</font>**：前置loader 用法：**module.rules** 中 **enforce** 属性指定\n    - **<font style=\"color:#1DC0C9;\">normal</font>**：普通loader 用法：**module.rules** 中 **enforce** 属性指定\n    - **<font style=\"color:#1DC0C9;\">inline</font>**：内联loader（不建议使用）用法：在import语句中显示指定loader 举例：`import Styles from 'style-loader|css-loader?modules!./styles.css';` 含义：用 css-loader 和 style-loader 处理 styles.css 文件，通过 ! 将资源中的loader分开\n    - **<font style=\"color:#1DC0C9;\">post</font>**：后置loader 用法：**module.rules** 中 **enforce** 属性指定\n\n##### 执行顺序\n    - 4类loader的执行顺序：`pre > normal > inline > post`\n    - 相同优先级的loader执行顺序：`从右到左，从下到上`\n\n##### pitching loader\n    - loader 上的 **<font style=\"color:#1DC0C9;\">pitch</font>** 方法\n\n```javascript\nmodule.exports = function (content) {\n  return content;\n};\nmodule.exports.pitch = function (remainingRequest, precedingRequest, data) {\n  console.log(\"do somethings\");\n};\n```\n\n    - webpack 会先从左到右执行 loader 链中的每个 loader 上的 pitch 方法（如果有），然后再从右到左执行 loader 链中的每个 loader 上的普通 loader 方法\n\n![pitching_loader_1](images/pitching_loader_1.png)\n\n    - 在这个过程中如果任何 pitch 有返回值，则 loader 链被阻断。webpack 会跳过后面所有的的 pitch 和 loader，直接进入上一个 loader \n\n![pitching_loader_2](images/pitching_loader_2.png)\n\n### webpack构建流程\nWebpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：\n\n+ **<font style=\"color:#1DC0C9;\">初始化参数</font>**：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数\n+ **<font style=\"color:#1DC0C9;\">开始编译</font>**：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译\n+ **<font style=\"color:#1DC0C9;\">确定入口</font>**：根据配置中的 entry 找出所有的入口文件\n+ **<font style=\"color:#1DC0C9;\">编译模块</font>**：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理\n+ **<font style=\"color:#1DC0C9;\">完成模块编译</font>**：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系\n+ **<font style=\"color:#1DC0C9;\">输出资源</font>**：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会\n+ **<font style=\"color:#1DC0C9;\">输出完成</font>**：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统\n\n在以上过程中，`Webpack` 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。\n\n简单说\n\n+ **<font style=\"color:#1DC0C9;\">初始化</font>**：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler\n+ **<font style=\"color:#1DC0C9;\">编译</font>**：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理\n+ **<font style=\"color:#1DC0C9;\">输出</font>**：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中\n\n### 文件指纹\n概念：文件指纹是打包后输出的文件名的后缀\n\n##### 种类：\n+ **<font style=\"background-color:rgba(222,253,255,1);\"> Hash </font>**：和整个项目的构建相关，只要项目文件有修改（**<font style=\"background-color:rgba(222,253,255,1);\"> compilation </font>**实例改变），整个项目构建的 Hash 值就会更改\n+ **<font style=\"background-color:rgba(222,253,255,1);\"> Chunkhash </font>**：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash，（不同 Chunkhash 之间的变化互不影响）\n+ <font style=\"background-color:rgba(222,253,255,1);\"> </font>**<font style=\"background-color:rgba(222,253,255,1);\">Contenthash</font>**<font style=\"background-color:rgba(222,253,255,1);\"> </font>：根据文件内容来定义 hash，文件内容不变，则 Contenthash 不变\n\n##### 使用：\n+ JS文件：使用 **<font style=\"background-color:rgba(222,253,255,1);\"> Chunkhash </font>**\n+ CSS文件：使用 <font style=\"background-color:rgba(222,253,255,1);\"> </font>**<font style=\"background-color:rgba(222,253,255,1);\">Contenthash</font>**<font style=\"background-color:rgba(222,253,255,1);\"> </font>\n+ 图片等静态资源： 使用 **<font style=\"background-color:rgba(222,253,255,1);\"> Hash </font>**\n\n> 生产环境的output为了区分版本变动，通过**<font style=\"background-color:rgba(222,253,255,1);\"> Contenthash </font>**来达到清理缓存及时更新的效果，而开发环境中为了加快构建效率，一般不引入**<font style=\"background-color:rgba(222,253,255,1);\"> Contenthash </font>**\n>\n\n##### JS的文件指纹设置\n设置 output 的 filename，用 chunkhash\n\n```javascript\nmodule.exports = {   \n  entry: {        \n    app: './scr/app.js',        \n    search: './src/search.js'    \n  },    \n  output: {        \n    filename: '[name][chunkhash:8].js', // chunkhash:8 保留8位    \n    path:__dirname + '/dist'    \n  }\n}\n\n```\n\n##### CSS的文件指纹设置\n设置 MiniCssExtractPlugin 的 filename，用 contenthash\n\n```javascript\nmodule.exports = {    \n  entry: {        \n    app: './scr/app.js',        \n    search: './src/search.js'   \n  },    \n  output: {        \n    filename: '[name][chunkhash:8].js',        \n    path:__dirname + '/dist'   \n  },    \n  plugins:[        \n    new MiniCssExtractPlugin({            \n      filename: `[name][contenthash:8].css`        })   \n  ]\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n##### 图片的文件指纹设置\n设置 file-loader 的 filename，用 hash，**webpack5后内置file-loader/url-loader/raw-loader，配置assets属性即可，无需再引入loader**\n\n占位符名称及含义\n\n+ ext 资源后缀名\n+ name 文件名称\n+ path 文件的相对路径\n+ folder 文件所在的文件夹\n+ contenthash 文件的内容hash，默认是md5生成\n+ hash 文件内容的hash，默认是md5生成\n+ emoji 一个随机的指代文件内容的emoj\n\n```javascript\nconst path = require('path');\nmodule.exports = {    \n  entry: './src/index.js',    \n  output: {        \n    filename:'bundle.js',        \n    path:path.resolve(__dirname, 'dist')   \n  },    \n  module:{        \n    rules:[{            \n      test:/\\.(png|svg|jpg|gif)$/,            \n      use:[{                \n        loader:'file-loader',                \n        options:{                    \n          name:'img/[name][hash:8].[ext]'               \n        }           \n      }]       \n    }]   \n  }\n}\n\n// webpack5配置参考如下：\n...\n// rules:[\n//   {\n//         test: /\\.(png|jpe?g|gif|webp|svg)$/,\n//         type: 'asset',\n//         parser: {\n//           dataUrlCondition: {\n//             // 小于10kb的图片转base64\n//             // 优点：减少请求数量  缺点：体积会更大\n//             maxSize: 10 * 1024 // 10kb \n//           }\n//         },\n//         generator: {\n//           // 输出图片名称\n//           // [hash:10] hash值取前10位\n//           filename: 'static/images/[hash:10][ext][query]'\n//         }\n//       },\n//   {\n//         test: /\\.(ttf|woff2?|mp3|mp4|avi)$/,\n//         type: 'asset/resource',\n//         generator: {\n//           // 输出名称\n//           // [hash:10] hash值取前10位\n//           filename: 'static/media/[hash:10][ext][query]'\n//         }\n//       },\n// ]\n// ...\n\n```\n\n### Babel的原理\n概述：大多数JavaScript Parser遵循 **estree** 规范，Babel 最初基于 **acorn** 项目(轻量级现代 JavaScript 解析器) 。\n\n**babel** 可以将代码转译为想要的目标代码，并且对目标环境不支持的**api** 自动 **<font style=\"background-color:rgba(222,253,255,1);\"> polyfill </font>** 。而 **babel **实现这些功能的流程是 **<font style=\"background-color:rgba(222,253,255,1);\"> 解析（parse）-转换（transfrom）-生成（generator）</font>** \n\n+ **<font style=\"background-color:rgba(77, 208, 225, 0.08);\">解析</font>**：根据代码生成对应的 **AST** 结构\n    - 词法分析：将代码(字符串)分割为 **token** 流，即语法单元成的数组\n    - 语法分析：分析 **token **流(上面生成的数组)并生成 AST\n+ **<font style=\"background-color:rgba(77, 208, 225, 0.08);\">转换</font>**：遍历 **AST** 节点并生成新的 **AST** 节点\n+ **<font style=\"background-color:rgba(77, 208, 225, 0.08);\">生成</font>**：根据新的 **AST** 生成目标代码\n\n### 文件监听原理\n在发现源码发生变化时，自动重新构建出新的输出文件\n\nWebpack开启监听模式，有两种方式：\n\n+ 启动 webpack 命令时，带上 --watch 参数\n+ 在配置 webpack.config.js 中设置 watch:true\n\n缺点：每次需要手动刷新浏览器\n\n原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 **aggregateTimeout** 后再统一执行。\n\n```javascript\nwatch: true, // 默认false，也就是不开启，只有开启监听模式时，watchOptions才有意义\nwatchOptions: {\n    // 不监听的文件或者文件夹，忽略一些大型的不经常变化的文件可以提高构建速度，支持正则匹配\n    ignored: /node_modules/,\n    //监听到变化会等多少时间再执行，默认300ms\n    aggregateTimeout: 300,\n    //判断文件是否发生变化是通过不断轮询指定文件有没有变化实现的，默认每秒问1000次\n    poll: 1000\n}\n\n```\n\n\n\n### 热更新原理\n参考链接：[轻松理解webpack热更新原理](https://juejin.cn/post/6844904008432222215?searchId=20250725014743FA245E0AE4142AA9178D) [从零实现webpack热更新HMR](https://juejin.cn/post/6844904020528594957?searchId=20250725014743FA245E0AE4142AA9178D)\n\n视频讲解：[Webpack 热更新原理与实战](https://www.bilibili.com/video/BV1To4y1f7Wo?spm_id_from=333.788.player.player_end_recommend&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89)\n\n概述：模块热替换（Hot Module Replacement，HMR）是 webpack 提供的最有用的功能之一。当我们**对代码修改并保存后，webpack将会对代码进行新的打包，并将新的模块发送到浏览器端，浏览器用新的模块替换掉旧的模块**，以实现在不刷新浏览器的前提下更新页面。\n\n刷新我们一般分为两种：\n\n+ 一种是页面刷新，不保留页面状态，就是简单粗暴，直接 **<font style=\"background-color:#FBE4E7;\">window.reload()</font>**\n+ 另一种是基于 **<font style=\"background-color:#FBE4E7;\">WDS（Wepack-dev-server）</font>**的模块热替换，只需要局部刷新页面上发生变化的模块，同时可以保留当前的页面状态，比如复选框的选中状态、输入框的输入等。\n\n##### 整体工作流程\n1. 文件修改：开发者保存修改后的文件\n2. Webpack 重新编译：生成新的模块代码和补丁（patch）\n3. 通知客户端：通过 websocket 向浏览器发送更新消息\n4. 客户端应用更新：获取新模块并替换旧模块\n5. 模块热替换：仅更新变化的模块，保持应用状态\n\n\n\n![pic_HMR](images/pic_HMR.png)\n\n详细解析图如下（含源码指导版）：\n\n![热更新](images/热更新.png)\n\n\n\n\n\n##### 核心组成部分\n###### 2.1 Webpack-dev-server (或 webpack-dev-middleware)\n+ 启动一个 Express 服务器\n+ 创建 websocket 服务（默认端口 8080）\n+ 监听文件变化并触发重新编译\n+ 通过 _webpack_hmr 端点与客户端通信\n\n###### 2.2 HMR Runtime（客户端部分）\n注入到 bundle 中的代码，负责：\n\n+ 建立与 dev-server 的 websocket 连接\n+ 接收更新通知\n+ 发起 JSONP 请求获取更新模块\n+ 执行模块替换逻辑\n\n###### 2.3 HMR Plugin（服务端部分）\nWebpack 内置的 HotModuleReplacementPlugin 负责：\n\n+ 生成每个模块的 HMR 标识（hash）\n+ 生成 manifest 文件（记录模块更新信息）\n+ 生成 update 补丁文件（[oldHash].hot-update.json/.js）\n\n##### 模块热更新策略\n###### 3.1不同类型模块的处理\n1. 普通 JS 模块：\n    - 直接替换模块导出对象\n    - 需要手动编写 module.hot.accept 逻辑\n2. 样式模块（通过 style-loader）：\n    - 自动处理：新样式替换旧样式（无需页面刷新）\n    - 实现原理：style-loader 会注入特殊的 HMR 代码\n3. React/Vue 组件：\n    - 需要框架特定的 HMR 支持\n    - React: 使用 react-hot-loader 或 React Refresh\n    - Vue: vue-loader 内置支持\n\n###### 3.2更新传播机制\n+ 接受依赖：当模块 A 调用 module.hot.accept，表示它能够接受自身或依赖模块的更新\n+ 冒泡更新：如果父模块不接受子模块更新，更新会向上冒泡直到找到接受者\n+ 无接受者：如果没有模块接受更新，则 fallback 到整页刷新\n\n### 代码分割\n参考文章：[webpack优化之玩转代码分割和公共代码提取](https://juejin.cn/post/6844904001792655373?searchId=202507231703353AC77072FBD359203430)\n\n概述：代码分割是 Webpack 的核心功能之一，它允许你将代码拆分成多个 bundle，然后可以按需加载或并行加载，从而优化应用性能。\n\n##### 为什么需要代码分割\n1. 减小初始加载体积：将应用拆分成多个 bundle，用户只需加载当前需要的代码\n2. 提高加载速度：并行加载多个 bundle 比加载单个大文件更快\n3. 缓存优化：将不常变动的代码单独打包，利用浏览器缓存\n\n##### 代码分割的三种主要方式\n1. 入口起点(Entry Points)\n\n```javascript\nmodule.exports = {\n  entry: {\n    app: './src/app.js',\n    vendor: './src/vendor.js'\n  },\n  output: {\n    filename: '[name].bundle.js'\n  }\n}\n```\n\n缺点：如果多个入口共享模块，这些模块会被重复打包到各个 bundle 中(用SplitChunksPlugin解决)\n\n2. 防止重复(SplitChunksPlugin)\n\nWebpack 4+ 内置了 SplitChunksPlugin，可以自动拆分公共依赖：\n\n```javascript\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      chunks: 'all',\n      minSize: 30000, // 模块的最小体积\n      minChunks: 1, // 模块的最小被引用次数\n      cacheGroups: {\n        vendors: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          priority: -10\n        },\n        default: {\n          minChunks: 2,\n          priority: -20,\n          reuseExistingChunk: true\n        }\n      }\n    }\n  }\n};\n```\n\n3. 动态导入(Dynamic Imports)\n\n使用 ES6 的 import() 语法或 Webpack 特定的 require.ensure：\n\n1. 默认行为：单独打包\n\n当使用 import() 动态导入语法时：\n\n```javascript\n// 点击按钮时动态加载模块\nbutton.addEventListener('click', () => {\n  import('./math.js').then(math => {\n    console.log(math.add(16, 26));\n  });\n});\n```\n\n    - Webpack 会将 math.js 及其依赖打包成一个独立的 chunk（如 1.bundle.js）。\n    - 运行时按需加载：只有当代码执行到 import() 时，浏览器才会发起网络请求加载这个 chunk。\n2. 控制打包名称（魔法注释）\n\n通过 webpackChunkName 注释可以自定义 chunk 名称：\n\n```javascript\nimport(/* webpackChunkName: \"math-lib\" */ './math.js')\n```\n\n    - 生成的文件名会变成 math-lib.bundle.js 而非数字 ID。\n    - 适合给重要模块命名，便于调试和长期缓存。\n3. 依赖关系处理\n    - 如果动态导入的模块 依赖其他模块，这些依赖会被 一起打包到同一个 \tchunk 中。\n    - 如果多个动态导入的模块 共享依赖，Webpack 默认会 重复打包（除非通过 SplitChunksPlugin 优化）。\n\n预获取/预加载模块\n\nWebpack 4.6+ 支持使用魔法注释实现资源预加载：\n\n```javascript\nimport(/* webpackPrefetch: true */ './path/to/LoginModal.js');\nimport(/* webpackPreload: true */ './path/to/ChartComponent.js');\n```\n\n+ prefetch：浏览器空闲时加载，用于未来可能需要的资源\n+ preload：与父 chunk 并行加载，用于当前导航可能需要的资源\n\n##### 代码分割最佳实践\n+ 按路由分割：为每个路由创建单独的 chunk\n+ 提取公共依赖：将第三方库(vendor)和公共模块单独打包\n+ 合理使用动态导入：对非关键功能使用懒加载\n+ 监控 bundle 大小：使用 webpack-bundle-analyzer 分析包内容\n\n示例配置：\n\n```javascript\nmodule.exports = {\n  // ...\n  optimization: {\n    splitChunks: {\n      chunks: 'all',\n      maxSize: 244 * 1024, // 尝试将大于244KB的块拆分成更小的块\n      cacheGroups: {\n        reactVendor: {\n          test: /[\\\\/]node_modules[\\\\/](react|react-dom)[\\\\/]/,\n          name: 'react-vendor',\n          chunks: 'all',\n        },\n        utilityVendor: {\n          test: /[\\\\/]node_modules[\\\\/](lodash|moment|axios)[\\\\/]/,\n          name: 'utility-vendor',\n          chunks: 'all',\n        },\n      },\n    },\n  },\n};\n```\n\n### 手写loaders和plugin\n文档：文稿/learning/chl-learning/webpack5/kejian/course/webpack_docs\n\n代码：文稿/learning/chl-learning/webpack5/SOURCE\n\n学习视频：[尚硅谷Webpack5入门到原理（面试开发一条龙](https://www.bilibili.com/video/BV14T4y1z7sw/?spm_id_from=333.788.videopod.episodes&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89&p=42)\n\n### tree-shaking\n参考链接：[Webpack 原理系列九：Tree-Shaking 实现原理](https://juejin.cn/post/7002410645316436004?searchId=2025080400284774D9A2A868649273E08D)\n\n概述：前端中的tree-shaking可以理解为通过工具\"摇\"我们的JS文件，将其中用不到的代码\"摇\"掉，是一个性能优化的范畴。具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。\n\n支持tree-shaking的构建工具：\n\n+ Rollup（最早实现）\n+ Webpack\n+ Closure compiler（google的）\n\n#### 工作原理\n##### 依赖关系图分析\n打包工具会构建模块的依赖关系图，标记哪些导出被实际使用\n\n##### 静态分析阶段\n1. 识别导出：分析每个模块的 export 语句。\n2. 追踪引用：从入口文件开始，追踪所有 import 的依赖链。\n3. 标记失效代码：未被引用的导出标记为“可删除”。\n\n##### 删除阶段\n通过压缩工具（如 Terser）移除标记为未使用的代码。\n\n#### 实现条件\n##### 1.必须使用ES Module（ESM）\n+ Tree Shaking 依赖 ESM 的 静态结构（import/export 必须在顶层声明）。\n+ CommonJS 无法被优化（require 是动态的，无法在编译时分析）。\n\n```javascript\n// ✅ 可被 Tree Shaking（ESM）\nimport { usedFunc } from './utils';\nusedFunc();\n\n// ❌ 无法被 Tree Shaking（CommonJS）\nconst utils = require('./utils');\nutils.usedFunc();\n```\n\n\n\n##### 2.避免副作用代码\n+ 工具会假设所有代码可能有副作用（如修改全局变量），除非显式声明。\n+ 通过 package.json 的 sideEffects 字段标记无副作用的模块：\n\n```javascript\n// package.json\n{\n  \"sideEffects\": false,  // 整个包无副作用\n  \"sideEffects\": [\"*.css\"]  // 仅 CSS 文件有副作用\n}\n```\n\n#### 副作用代码（Side Effects）\n概述**：**副作用代码是指在执行时会对外部环境产生可观察影响的代码，这类代码不仅返回计算结果，还会修改外部状态或与系统交互。理解副作用对编写可维护、可优化的代码至关重要。\n\n##### 核心概念\n###### 定义\n+ 纯函数（无副作用）：输出仅由输入决定，不修改外部状态（如数学函数 Math.sqrt(4)）。\n+ 副作用代码：执行时会产生额外影响，例如：\n    - 修改全局变量\n    - 操作 DOM\n    - 发起网络请求\n    - 读写文件/数据库\n    - 打印日志\n\n###### 示例对比\n| **无副作用** | **有副作用** |\n| --- | --- |\n| `const sum = (a, b) => a + b` | `let count = 0;`   `const add = () => { count++ }` |\n| `function capitalize(str) { return str.toUpperCase() }` | `document.title = \"新标题\"` |\n\n\n\n\n##### 副作用代码的类型\n###### 显式副作用\n直接对外部环境产生影响的代码：\n\n```javascript\n// 修改全局变量\nwindow.user = { name: \"Alice\" };\n\n// 操作 DOM\ndocument.body.style.backgroundColor = \"red\";\n\n// 写入文件（Node.js）\nfs.writeFileSync(\"log.txt\", \"数据已更新\");\n```\n\n###### 隐式副作用\n通过依赖外部状态间接产生副作用：\n\n```javascript\n// 依赖外部变量（结果不可预测）\nlet base = 10;\nconst impureAdd = (x) => base + x;\n\n// 读取用户输入（外部依赖）\nconst input = prompt(\"请输入内容\");\n```\n\n\n\n##### 副作用的影响\n###### 对代码优化的阻碍\n+ Tree Shaking失效：打包工具无法安全删除未使用的副作用代码：\n\n```javascript\n// 即使未使用，以下代码也会被保留\nArray.prototype.customMethod = () => {}; // 修改原型链\n```\n\n+ 难以测试和调试：依赖外部状态的代码行为不可预测。\n\n###### 对函数式编程的挑战\n副作用违背引用透明性（同一输入始终返回同一输出），例如：\n\n```javascript\n// ❌ 非引用透明（依赖 Date 外部状态）\nconst getTime = () => new Date().toISOString();\n```\n\n\n\n##### 如何管理副作用\n###### 隔离副作用\n将副作用代码集中管理，与纯逻辑分离：\n\n```javascript\n// 纯函数（核心逻辑）\nfunction calculateTotal(items) {\n  return items.reduce((sum, item) => sum + item.price, 0);\n}\n\n// 副作用集中处理\nfunction renderTotal(total) {\n  document.getElementById(\"total\").textContent = `$${total}`;\n}\n\n// 组合使用\nconst items = [{ price: 10 }, { price: 20 }];\nrenderTotal(calculateTotal(items));\n```\n\n###### 显式标记副作用\n通过 `package.json` 声明模块的副作用，帮助打包工具优化：\n\n```javascript\n{\n  \"sideEffects\": [\n    \"**/*.css\",  // CSS 文件有副作用（注入样式）\n    \"src/polyfills.js\" //  polyfill 修改全局对象\n  ]\n}\n```\n\n###### 使用函数式编程技术\n+ 不可变数据：避免直接修改对象/数组（使用 `...` 或 `Object.assign`）。\n+ 副作用延迟执行：如 React 的 `useEffect`、Redux 的中间件。\n\n#### 静态分析（Static Analysis）\n静态分析是指在不实际运行代码的情况下，通过分析源代码或编译后的中间表示（如 AST）来检查代码的结构、语法、依赖关系以及潜在问题的一种技术。它在编程语言、编译器、安全分析和开发工具中广泛应用。\n\n##### 静态分析的核心概念\n###### 1.1 静态分析 vs 动态分析\n| **特性****** | **静态分析** | **动态分析** |\n| --- | --- | --- |\n| **执行时机** | 代码运行前（编译时/构建时） | 代码运行时 |\n| **输入数据** | 源代码、AST、字节码等静态结构 | 程序运行时的内存、I/O、状态等 |\n| **典型工具** | ESLint、TypeScript、Flow、SonarQube | Chrome DevTools、Valgrind、Fuzz 测试 |\n| **优势** | 提前发现问题，不影响运行时性能 | 捕捉运行时行为（如内存泄漏） |\n| **局限性** | 无法分析动态行为（如 `eval`） | 需要实际运行，可能漏检某些路径 |\n\n\n\n\n###### 1.2 静态分析的主要目标\n+ 代码质量检查（如未使用的变量、代码风格）\n+ 安全漏洞检测（如 SQL 注入、XSS）\n+ 性能优化（如 Dead Code Elimination）\n+ 依赖分析（如 Tree Shaking）\n+ 类型检查（如 TypeScript）\n\n\n\n##### 静态分析的关键技术\n###### 2.1 抽象语法树（AST）\n静态分析的核心数据结构，将代码转换为树状结构，便于工具分析\n\n```javascript\n// 示例代码\nconst sum = (a, b) => a + b;\n\n// 对应的AST（简化版）\n{\n  type: \"Program\",\n    body: [{\n    type: \"VariableDeclaration\",\n    declarations: [{\n      type: \"VariableDeclarator\",\n      id: { type: \"Identifier\", name: \"sum\" },\n      init: {\n        type: \"ArrowFunctionExpression\",\n        params: [\n          { type: \"Identifier\", name: \"a\" },\n          { type: \"Identifier\", name: \"b\" }\n        ],\n        body: {\n          type: \"BinaryExpression\",\n          operator: \"+\",\n          left: { type: \"Identifier\", name: \"a\" },\n          right: { type: \"Identifier\", name: \"b\" }\n        }\n      }\n    }]\n  }]\n}\n```\n\n工具：Babel、ESlint、Prettier均基于AST操作代码\n\n\n\n###### 2.2 数据流分析（Data Flow Analysis）\n跟踪变量和值的流动，用于检测：\n\n+ 未初始化的变量\n+ 不可达代码\n+ 常量传播优化\n\n\n###### 2.3 控制流分析（Control Flow Analysis）\n+ 检测无限循环\n+ 识别异常处理遗漏\n\n```javascript\nfunction risky(x) {\n  if (x > 0) {\n    return \"ok\";\n  }\n  // 静态分析可警告：缺少 else 分支，可能返回 undefined\n}\n```\n\n###### 2.4 类型检查（Type Checking）\n在编译时验证类型一致性，如TypeScript的静态类型系统：\n\n```javascript\nfunction greet(name: string) {\n  return `Hello, ${name}`;\n}\ngreet(42); // 静态分析报错：类型不匹配\n```\n\n","source":"_posts/关于Webpack.md","raw":"---\ntitle: 关于Webpack\ndate: 2024-08-13\ntags: [Webpack, loader, plugin, 打包构建工具, 副作用函数, 静态分析]\ncategories: Webpack\n---\n\n概念：Webpack 是一种用于构建 JavaScript 应用程序的静态模块打包器，它能够以一种相对一致且开放的处理方式，加载应用中的所有资源文件（图片、CSS、视频、字体文件等），并将其合并打包成浏览器兼容的 Web 资源文件。\n\n功能：****\n\n+ 模块的打包：通过打包整合不同的模块文件保证各模块之间的引用和执行\n+ 代码编译：通过丰富的`**loader**`可以将不同格式文件如`**.sass/.vue/.jsx**`转译为浏览器可以执行的文件\n+ 扩展功能：通过社区丰富的`**plugin**`可以实现多种强大的功能，例如**代码分割、代码混淆、代码压缩、按需加载.....等等**\n\n### 常见的loader及其作用\n**<font style=\"color:#1DC0C9;\">-babel-loader</font>**：将es6转译为es5\n\n**<font style=\"color:#1DC0C9;\">-file-loader</font>**：可以指定要复制和放置资源文件的位置，以及如何使用版本哈希命名以获得更好的缓存，并在代码中通过**URL**去引用输出的文件\n\n**<font style=\"color:#1DC0C9;\">-url-loader</font>**：和`**file-loader**`功能相似，但是可以通过指定阈值来根据文件大小使用不同的处理方式（小于阈值则返回base64格式编码并将文件的 `data-url`内联到`bundle`中）\n\n**<font style=\"color:#1DC0C9;\">-raw-loader</font>**：加载文件原始内容\n\n> webpack5自身内置了`**file-loader/ url-loader/ raw-loader**`等loader，所以我们不需要再显示引入loader 只需要指定对应的type即可实现相同的功能 如`**file-loader**`等价于 `**type= \"asset/resource\"**`\n>\n\n**<font style=\"color:#1DC0C9;\">-image-webpack-loader</font>**： 加载并压缩图片资源\n\n**<font style=\"color:#1DC0C9;\">-awesome-typescirpt-loader</font>**: 将typescript转换为javaScript 并且性能优于`**ts-loader**`\n\n**<font style=\"color:#1DC0C9;\">-sass-loader</font>**: 将SCSS/SASS代码转换为CSS\n\n**<font style=\"color:#1DC0C9;\">-css-loader</font>**: 加载CSS代码 支持模块化、压缩、文件导入等功能特性**\n\n**<font style=\"color:#1DC0C9;\">-style-loader</font>**: 把CSS代码注入到js中，通过`DOM` 操作去加载CSS代码\n\n> 当我们使用类似于 `**less**` 或者 `**scss**` 等预处理器的时候，通常需要多个 **loader** 的配合使用如`**test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader']**`\n>\n\n**<font style=\"color:#1DC0C9;\">-source-map-loader</font>**: 加载额外的`Source Map`文件\n\n**<font style=\"color:#1DC0C9;\">-eslint-loader</font>**: 通过ESlint 检查js代码\n\n**<font style=\"color:#1DC0C9;\">-cache-loader</font>**: 可以在一些开销较大的`Loader`之前添加可以将结果缓存到磁盘中，提高构建的效率\n\n**<font style=\"color:#1DC0C9;\">-thread-loader</font>**: 多线程打包，加快打包速度\n\n### 常见的plugin及其作用\n**<font style=\"color:#1DC0C9;\">-splitChunkPlugin</font>**: 定义环境变量（webpack4之后可以通过指定`**mode：production/development**`实现同样效果）\n\n**<font style=\"color:#1DC0C9;\">-define-plugin</font>**: 定义环境变量（webpack4之后可以通过指定`**mode：production/development**`实现同样效果）\n\n**<font style=\"color:#1DC0C9;\">-web-webpack-plugin</font>**：为单页面应用输出HTML 性能优于`html-webpack-plugin`\n\n**<font style=\"color:#1DC0C9;\">-clean-webpack-plugin</font>**: 每次打包时删除上次打包的产物, 保证打包目录下的文件都是最新的\n\n**<font style=\"color:#1DC0C9;\">-webpack-merge</font>**： 用来合并公共配置文件,常用（例如分别配置`webpack.common.config.js/ webpack.dev.config.js/webpack.production.config.js`并将其合并）\n\n**<font style=\"color:#1DC0C9;\">-ignore-plugin</font>**: 忽略指定的文件，可以加快构建速度\n\n**<font style=\"color:#1DC0C9;\">-terser-webpack-plugin</font>**：压缩ES6的代码（tree-shaking）\n\n**<font style=\"color:#1DC0C9;\">-uglifyjs-webpack-plugin</font>**: 压缩js代码\n\n**<font style=\"color:#1DC0C9;\">-mini-css-extract-plugin</font>**: 将CSS提取为独立文件，支持按需加载x\n\n**<font style=\"color:#1DC0C9;\">-css-minimize-webpack-plugin</font>**：压缩CSS代码\n\n> css文件的压缩需要`**mini-css-extract-plugin**`和`**css-minimize-webpack-plugin** `的配合使用 即先使用`**mini-css-extract-plugin**`将css代码抽离成单独文件，之后使用` **css-minimize-webpack-plugin**`对css代码进行压缩\n>\n\n**<font style=\"color:#1DC0C9;\">-serviceworker-webpack-plugin</font>**: 为离线应用增加离线缓存功能\n\n**<font style=\"color:#1DC0C9;\">-ModuleconcatenationPlugin</font>**: 开启`**Scope Hositing**` 用于合并提升作用域， 减小代码体积\n\n**<font style=\"color:#1DC0C9;\">-copy-webpack-plugin</font>**： 在构建的时候，复制静态资源到打包目录。\n\n**<font style=\"color:#1DC0C9;\">-compression-webpack-plugin</font>**: 生产环境采用`**gzip**`压缩JS和CSS\n\n**<font style=\"color:#1DC0C9;\">-ParalleUglifyPlugin</font>**： 多进程并行压缩js\n\n**<font style=\"color:#1DC0C9;\">-webpack-bundle-analyzer</font>**: 可视化webpack输出文件大小的根据\n\n**<font style=\"color:#1DC0C9;\">-speed-measure-webpack-plugin</font>**: 用于分析各个loader和plugin的耗时，可用于性能分析\n\n**<font style=\"color:#1DC0C9;\">-webpack-dashboard</font>**: 可以更友好地展示打包相关信息\n\n**<font style=\"color:#1DC0C9;\">-Webpack Analysis</font>**：webpack 官方提供的可视化分析工具\n\n**<font style=\"color:#1DC0C9;\">-BundleAnalyzerPlugin</font>**：性能分析插件，可以在运行后查看是否包含重复模块/不必要模块等\n\n### loader和plugin的区别\n**<font style=\"color:#1DC0C9;\">Loader：</font>**\n\nLoader本质上是一个函数，负责代码的转译，即对接收到的内容进行转换后将转换后的结果返回 ，因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。\n\n配置Loader通过在 **module.rules **中以数组的形式配置，每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。\n\n**<font style=\"color:#1DC0C9;\">Plugin：</font>**\n\nPlugin可以扩展 Webpack 的功能，本质上是一个带有 **apply(compiler)** 的函数，基于 [tapable](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftapable) 这个事件流框架来监听**webpack**构建/打包过程中发布的hooks来通过自定义的逻辑和功能来改变输出结果。 \n\nPlugin通过 **plugins** 以数组的形式配置，每一项是一个 Plugin 的实例，参数都通过构造函数传入。\n\n**总结：**\n\n**Loader **主要负责将代码转译为**webpack**可以处理的JavaScript代码，而 **Plugin** 更多的是负责通过接入**webpack**构建过程来影响构建过程以及产物的输出，**Loader**的职责相对比较**单一**简单，而 **Plugin **更为丰富多样。\n\n### loader执行顺序\n##### 分类\n    - **<font style=\"color:#1DC0C9;\">pre</font>**：前置loader 用法：**module.rules** 中 **enforce** 属性指定\n    - **<font style=\"color:#1DC0C9;\">normal</font>**：普通loader 用法：**module.rules** 中 **enforce** 属性指定\n    - **<font style=\"color:#1DC0C9;\">inline</font>**：内联loader（不建议使用）用法：在import语句中显示指定loader 举例：`import Styles from 'style-loader|css-loader?modules!./styles.css';` 含义：用 css-loader 和 style-loader 处理 styles.css 文件，通过 ! 将资源中的loader分开\n    - **<font style=\"color:#1DC0C9;\">post</font>**：后置loader 用法：**module.rules** 中 **enforce** 属性指定\n\n##### 执行顺序\n    - 4类loader的执行顺序：`pre > normal > inline > post`\n    - 相同优先级的loader执行顺序：`从右到左，从下到上`\n\n##### pitching loader\n    - loader 上的 **<font style=\"color:#1DC0C9;\">pitch</font>** 方法\n\n```javascript\nmodule.exports = function (content) {\n  return content;\n};\nmodule.exports.pitch = function (remainingRequest, precedingRequest, data) {\n  console.log(\"do somethings\");\n};\n```\n\n    - webpack 会先从左到右执行 loader 链中的每个 loader 上的 pitch 方法（如果有），然后再从右到左执行 loader 链中的每个 loader 上的普通 loader 方法\n\n![pitching_loader_1](images/pitching_loader_1.png)\n\n    - 在这个过程中如果任何 pitch 有返回值，则 loader 链被阻断。webpack 会跳过后面所有的的 pitch 和 loader，直接进入上一个 loader \n\n![pitching_loader_2](images/pitching_loader_2.png)\n\n### webpack构建流程\nWebpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：\n\n+ **<font style=\"color:#1DC0C9;\">初始化参数</font>**：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数\n+ **<font style=\"color:#1DC0C9;\">开始编译</font>**：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译\n+ **<font style=\"color:#1DC0C9;\">确定入口</font>**：根据配置中的 entry 找出所有的入口文件\n+ **<font style=\"color:#1DC0C9;\">编译模块</font>**：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理\n+ **<font style=\"color:#1DC0C9;\">完成模块编译</font>**：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系\n+ **<font style=\"color:#1DC0C9;\">输出资源</font>**：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会\n+ **<font style=\"color:#1DC0C9;\">输出完成</font>**：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统\n\n在以上过程中，`Webpack` 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。\n\n简单说\n\n+ **<font style=\"color:#1DC0C9;\">初始化</font>**：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler\n+ **<font style=\"color:#1DC0C9;\">编译</font>**：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理\n+ **<font style=\"color:#1DC0C9;\">输出</font>**：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中\n\n### 文件指纹\n概念：文件指纹是打包后输出的文件名的后缀\n\n##### 种类：\n+ **<font style=\"background-color:rgba(222,253,255,1);\"> Hash </font>**：和整个项目的构建相关，只要项目文件有修改（**<font style=\"background-color:rgba(222,253,255,1);\"> compilation </font>**实例改变），整个项目构建的 Hash 值就会更改\n+ **<font style=\"background-color:rgba(222,253,255,1);\"> Chunkhash </font>**：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash，（不同 Chunkhash 之间的变化互不影响）\n+ <font style=\"background-color:rgba(222,253,255,1);\"> </font>**<font style=\"background-color:rgba(222,253,255,1);\">Contenthash</font>**<font style=\"background-color:rgba(222,253,255,1);\"> </font>：根据文件内容来定义 hash，文件内容不变，则 Contenthash 不变\n\n##### 使用：\n+ JS文件：使用 **<font style=\"background-color:rgba(222,253,255,1);\"> Chunkhash </font>**\n+ CSS文件：使用 <font style=\"background-color:rgba(222,253,255,1);\"> </font>**<font style=\"background-color:rgba(222,253,255,1);\">Contenthash</font>**<font style=\"background-color:rgba(222,253,255,1);\"> </font>\n+ 图片等静态资源： 使用 **<font style=\"background-color:rgba(222,253,255,1);\"> Hash </font>**\n\n> 生产环境的output为了区分版本变动，通过**<font style=\"background-color:rgba(222,253,255,1);\"> Contenthash </font>**来达到清理缓存及时更新的效果，而开发环境中为了加快构建效率，一般不引入**<font style=\"background-color:rgba(222,253,255,1);\"> Contenthash </font>**\n>\n\n##### JS的文件指纹设置\n设置 output 的 filename，用 chunkhash\n\n```javascript\nmodule.exports = {   \n  entry: {        \n    app: './scr/app.js',        \n    search: './src/search.js'    \n  },    \n  output: {        \n    filename: '[name][chunkhash:8].js', // chunkhash:8 保留8位    \n    path:__dirname + '/dist'    \n  }\n}\n\n```\n\n##### CSS的文件指纹设置\n设置 MiniCssExtractPlugin 的 filename，用 contenthash\n\n```javascript\nmodule.exports = {    \n  entry: {        \n    app: './scr/app.js',        \n    search: './src/search.js'   \n  },    \n  output: {        \n    filename: '[name][chunkhash:8].js',        \n    path:__dirname + '/dist'   \n  },    \n  plugins:[        \n    new MiniCssExtractPlugin({            \n      filename: `[name][contenthash:8].css`        })   \n  ]\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n##### 图片的文件指纹设置\n设置 file-loader 的 filename，用 hash，**webpack5后内置file-loader/url-loader/raw-loader，配置assets属性即可，无需再引入loader**\n\n占位符名称及含义\n\n+ ext 资源后缀名\n+ name 文件名称\n+ path 文件的相对路径\n+ folder 文件所在的文件夹\n+ contenthash 文件的内容hash，默认是md5生成\n+ hash 文件内容的hash，默认是md5生成\n+ emoji 一个随机的指代文件内容的emoj\n\n```javascript\nconst path = require('path');\nmodule.exports = {    \n  entry: './src/index.js',    \n  output: {        \n    filename:'bundle.js',        \n    path:path.resolve(__dirname, 'dist')   \n  },    \n  module:{        \n    rules:[{            \n      test:/\\.(png|svg|jpg|gif)$/,            \n      use:[{                \n        loader:'file-loader',                \n        options:{                    \n          name:'img/[name][hash:8].[ext]'               \n        }           \n      }]       \n    }]   \n  }\n}\n\n// webpack5配置参考如下：\n...\n// rules:[\n//   {\n//         test: /\\.(png|jpe?g|gif|webp|svg)$/,\n//         type: 'asset',\n//         parser: {\n//           dataUrlCondition: {\n//             // 小于10kb的图片转base64\n//             // 优点：减少请求数量  缺点：体积会更大\n//             maxSize: 10 * 1024 // 10kb \n//           }\n//         },\n//         generator: {\n//           // 输出图片名称\n//           // [hash:10] hash值取前10位\n//           filename: 'static/images/[hash:10][ext][query]'\n//         }\n//       },\n//   {\n//         test: /\\.(ttf|woff2?|mp3|mp4|avi)$/,\n//         type: 'asset/resource',\n//         generator: {\n//           // 输出名称\n//           // [hash:10] hash值取前10位\n//           filename: 'static/media/[hash:10][ext][query]'\n//         }\n//       },\n// ]\n// ...\n\n```\n\n### Babel的原理\n概述：大多数JavaScript Parser遵循 **estree** 规范，Babel 最初基于 **acorn** 项目(轻量级现代 JavaScript 解析器) 。\n\n**babel** 可以将代码转译为想要的目标代码，并且对目标环境不支持的**api** 自动 **<font style=\"background-color:rgba(222,253,255,1);\"> polyfill </font>** 。而 **babel **实现这些功能的流程是 **<font style=\"background-color:rgba(222,253,255,1);\"> 解析（parse）-转换（transfrom）-生成（generator）</font>** \n\n+ **<font style=\"background-color:rgba(77, 208, 225, 0.08);\">解析</font>**：根据代码生成对应的 **AST** 结构\n    - 词法分析：将代码(字符串)分割为 **token** 流，即语法单元成的数组\n    - 语法分析：分析 **token **流(上面生成的数组)并生成 AST\n+ **<font style=\"background-color:rgba(77, 208, 225, 0.08);\">转换</font>**：遍历 **AST** 节点并生成新的 **AST** 节点\n+ **<font style=\"background-color:rgba(77, 208, 225, 0.08);\">生成</font>**：根据新的 **AST** 生成目标代码\n\n### 文件监听原理\n在发现源码发生变化时，自动重新构建出新的输出文件\n\nWebpack开启监听模式，有两种方式：\n\n+ 启动 webpack 命令时，带上 --watch 参数\n+ 在配置 webpack.config.js 中设置 watch:true\n\n缺点：每次需要手动刷新浏览器\n\n原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 **aggregateTimeout** 后再统一执行。\n\n```javascript\nwatch: true, // 默认false，也就是不开启，只有开启监听模式时，watchOptions才有意义\nwatchOptions: {\n    // 不监听的文件或者文件夹，忽略一些大型的不经常变化的文件可以提高构建速度，支持正则匹配\n    ignored: /node_modules/,\n    //监听到变化会等多少时间再执行，默认300ms\n    aggregateTimeout: 300,\n    //判断文件是否发生变化是通过不断轮询指定文件有没有变化实现的，默认每秒问1000次\n    poll: 1000\n}\n\n```\n\n\n\n### 热更新原理\n参考链接：[轻松理解webpack热更新原理](https://juejin.cn/post/6844904008432222215?searchId=20250725014743FA245E0AE4142AA9178D) [从零实现webpack热更新HMR](https://juejin.cn/post/6844904020528594957?searchId=20250725014743FA245E0AE4142AA9178D)\n\n视频讲解：[Webpack 热更新原理与实战](https://www.bilibili.com/video/BV1To4y1f7Wo?spm_id_from=333.788.player.player_end_recommend&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89)\n\n概述：模块热替换（Hot Module Replacement，HMR）是 webpack 提供的最有用的功能之一。当我们**对代码修改并保存后，webpack将会对代码进行新的打包，并将新的模块发送到浏览器端，浏览器用新的模块替换掉旧的模块**，以实现在不刷新浏览器的前提下更新页面。\n\n刷新我们一般分为两种：\n\n+ 一种是页面刷新，不保留页面状态，就是简单粗暴，直接 **<font style=\"background-color:#FBE4E7;\">window.reload()</font>**\n+ 另一种是基于 **<font style=\"background-color:#FBE4E7;\">WDS（Wepack-dev-server）</font>**的模块热替换，只需要局部刷新页面上发生变化的模块，同时可以保留当前的页面状态，比如复选框的选中状态、输入框的输入等。\n\n##### 整体工作流程\n1. 文件修改：开发者保存修改后的文件\n2. Webpack 重新编译：生成新的模块代码和补丁（patch）\n3. 通知客户端：通过 websocket 向浏览器发送更新消息\n4. 客户端应用更新：获取新模块并替换旧模块\n5. 模块热替换：仅更新变化的模块，保持应用状态\n\n\n\n![pic_HMR](images/pic_HMR.png)\n\n详细解析图如下（含源码指导版）：\n\n![热更新](images/热更新.png)\n\n\n\n\n\n##### 核心组成部分\n###### 2.1 Webpack-dev-server (或 webpack-dev-middleware)\n+ 启动一个 Express 服务器\n+ 创建 websocket 服务（默认端口 8080）\n+ 监听文件变化并触发重新编译\n+ 通过 _webpack_hmr 端点与客户端通信\n\n###### 2.2 HMR Runtime（客户端部分）\n注入到 bundle 中的代码，负责：\n\n+ 建立与 dev-server 的 websocket 连接\n+ 接收更新通知\n+ 发起 JSONP 请求获取更新模块\n+ 执行模块替换逻辑\n\n###### 2.3 HMR Plugin（服务端部分）\nWebpack 内置的 HotModuleReplacementPlugin 负责：\n\n+ 生成每个模块的 HMR 标识（hash）\n+ 生成 manifest 文件（记录模块更新信息）\n+ 生成 update 补丁文件（[oldHash].hot-update.json/.js）\n\n##### 模块热更新策略\n###### 3.1不同类型模块的处理\n1. 普通 JS 模块：\n    - 直接替换模块导出对象\n    - 需要手动编写 module.hot.accept 逻辑\n2. 样式模块（通过 style-loader）：\n    - 自动处理：新样式替换旧样式（无需页面刷新）\n    - 实现原理：style-loader 会注入特殊的 HMR 代码\n3. React/Vue 组件：\n    - 需要框架特定的 HMR 支持\n    - React: 使用 react-hot-loader 或 React Refresh\n    - Vue: vue-loader 内置支持\n\n###### 3.2更新传播机制\n+ 接受依赖：当模块 A 调用 module.hot.accept，表示它能够接受自身或依赖模块的更新\n+ 冒泡更新：如果父模块不接受子模块更新，更新会向上冒泡直到找到接受者\n+ 无接受者：如果没有模块接受更新，则 fallback 到整页刷新\n\n### 代码分割\n参考文章：[webpack优化之玩转代码分割和公共代码提取](https://juejin.cn/post/6844904001792655373?searchId=202507231703353AC77072FBD359203430)\n\n概述：代码分割是 Webpack 的核心功能之一，它允许你将代码拆分成多个 bundle，然后可以按需加载或并行加载，从而优化应用性能。\n\n##### 为什么需要代码分割\n1. 减小初始加载体积：将应用拆分成多个 bundle，用户只需加载当前需要的代码\n2. 提高加载速度：并行加载多个 bundle 比加载单个大文件更快\n3. 缓存优化：将不常变动的代码单独打包，利用浏览器缓存\n\n##### 代码分割的三种主要方式\n1. 入口起点(Entry Points)\n\n```javascript\nmodule.exports = {\n  entry: {\n    app: './src/app.js',\n    vendor: './src/vendor.js'\n  },\n  output: {\n    filename: '[name].bundle.js'\n  }\n}\n```\n\n缺点：如果多个入口共享模块，这些模块会被重复打包到各个 bundle 中(用SplitChunksPlugin解决)\n\n2. 防止重复(SplitChunksPlugin)\n\nWebpack 4+ 内置了 SplitChunksPlugin，可以自动拆分公共依赖：\n\n```javascript\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      chunks: 'all',\n      minSize: 30000, // 模块的最小体积\n      minChunks: 1, // 模块的最小被引用次数\n      cacheGroups: {\n        vendors: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          priority: -10\n        },\n        default: {\n          minChunks: 2,\n          priority: -20,\n          reuseExistingChunk: true\n        }\n      }\n    }\n  }\n};\n```\n\n3. 动态导入(Dynamic Imports)\n\n使用 ES6 的 import() 语法或 Webpack 特定的 require.ensure：\n\n1. 默认行为：单独打包\n\n当使用 import() 动态导入语法时：\n\n```javascript\n// 点击按钮时动态加载模块\nbutton.addEventListener('click', () => {\n  import('./math.js').then(math => {\n    console.log(math.add(16, 26));\n  });\n});\n```\n\n    - Webpack 会将 math.js 及其依赖打包成一个独立的 chunk（如 1.bundle.js）。\n    - 运行时按需加载：只有当代码执行到 import() 时，浏览器才会发起网络请求加载这个 chunk。\n2. 控制打包名称（魔法注释）\n\n通过 webpackChunkName 注释可以自定义 chunk 名称：\n\n```javascript\nimport(/* webpackChunkName: \"math-lib\" */ './math.js')\n```\n\n    - 生成的文件名会变成 math-lib.bundle.js 而非数字 ID。\n    - 适合给重要模块命名，便于调试和长期缓存。\n3. 依赖关系处理\n    - 如果动态导入的模块 依赖其他模块，这些依赖会被 一起打包到同一个 \tchunk 中。\n    - 如果多个动态导入的模块 共享依赖，Webpack 默认会 重复打包（除非通过 SplitChunksPlugin 优化）。\n\n预获取/预加载模块\n\nWebpack 4.6+ 支持使用魔法注释实现资源预加载：\n\n```javascript\nimport(/* webpackPrefetch: true */ './path/to/LoginModal.js');\nimport(/* webpackPreload: true */ './path/to/ChartComponent.js');\n```\n\n+ prefetch：浏览器空闲时加载，用于未来可能需要的资源\n+ preload：与父 chunk 并行加载，用于当前导航可能需要的资源\n\n##### 代码分割最佳实践\n+ 按路由分割：为每个路由创建单独的 chunk\n+ 提取公共依赖：将第三方库(vendor)和公共模块单独打包\n+ 合理使用动态导入：对非关键功能使用懒加载\n+ 监控 bundle 大小：使用 webpack-bundle-analyzer 分析包内容\n\n示例配置：\n\n```javascript\nmodule.exports = {\n  // ...\n  optimization: {\n    splitChunks: {\n      chunks: 'all',\n      maxSize: 244 * 1024, // 尝试将大于244KB的块拆分成更小的块\n      cacheGroups: {\n        reactVendor: {\n          test: /[\\\\/]node_modules[\\\\/](react|react-dom)[\\\\/]/,\n          name: 'react-vendor',\n          chunks: 'all',\n        },\n        utilityVendor: {\n          test: /[\\\\/]node_modules[\\\\/](lodash|moment|axios)[\\\\/]/,\n          name: 'utility-vendor',\n          chunks: 'all',\n        },\n      },\n    },\n  },\n};\n```\n\n### 手写loaders和plugin\n文档：文稿/learning/chl-learning/webpack5/kejian/course/webpack_docs\n\n代码：文稿/learning/chl-learning/webpack5/SOURCE\n\n学习视频：[尚硅谷Webpack5入门到原理（面试开发一条龙](https://www.bilibili.com/video/BV14T4y1z7sw/?spm_id_from=333.788.videopod.episodes&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89&p=42)\n\n### tree-shaking\n参考链接：[Webpack 原理系列九：Tree-Shaking 实现原理](https://juejin.cn/post/7002410645316436004?searchId=2025080400284774D9A2A868649273E08D)\n\n概述：前端中的tree-shaking可以理解为通过工具\"摇\"我们的JS文件，将其中用不到的代码\"摇\"掉，是一个性能优化的范畴。具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。\n\n支持tree-shaking的构建工具：\n\n+ Rollup（最早实现）\n+ Webpack\n+ Closure compiler（google的）\n\n#### 工作原理\n##### 依赖关系图分析\n打包工具会构建模块的依赖关系图，标记哪些导出被实际使用\n\n##### 静态分析阶段\n1. 识别导出：分析每个模块的 export 语句。\n2. 追踪引用：从入口文件开始，追踪所有 import 的依赖链。\n3. 标记失效代码：未被引用的导出标记为“可删除”。\n\n##### 删除阶段\n通过压缩工具（如 Terser）移除标记为未使用的代码。\n\n#### 实现条件\n##### 1.必须使用ES Module（ESM）\n+ Tree Shaking 依赖 ESM 的 静态结构（import/export 必须在顶层声明）。\n+ CommonJS 无法被优化（require 是动态的，无法在编译时分析）。\n\n```javascript\n// ✅ 可被 Tree Shaking（ESM）\nimport { usedFunc } from './utils';\nusedFunc();\n\n// ❌ 无法被 Tree Shaking（CommonJS）\nconst utils = require('./utils');\nutils.usedFunc();\n```\n\n\n\n##### 2.避免副作用代码\n+ 工具会假设所有代码可能有副作用（如修改全局变量），除非显式声明。\n+ 通过 package.json 的 sideEffects 字段标记无副作用的模块：\n\n```javascript\n// package.json\n{\n  \"sideEffects\": false,  // 整个包无副作用\n  \"sideEffects\": [\"*.css\"]  // 仅 CSS 文件有副作用\n}\n```\n\n#### 副作用代码（Side Effects）\n概述**：**副作用代码是指在执行时会对外部环境产生可观察影响的代码，这类代码不仅返回计算结果，还会修改外部状态或与系统交互。理解副作用对编写可维护、可优化的代码至关重要。\n\n##### 核心概念\n###### 定义\n+ 纯函数（无副作用）：输出仅由输入决定，不修改外部状态（如数学函数 Math.sqrt(4)）。\n+ 副作用代码：执行时会产生额外影响，例如：\n    - 修改全局变量\n    - 操作 DOM\n    - 发起网络请求\n    - 读写文件/数据库\n    - 打印日志\n\n###### 示例对比\n| **无副作用** | **有副作用** |\n| --- | --- |\n| `const sum = (a, b) => a + b` | `let count = 0;`   `const add = () => { count++ }` |\n| `function capitalize(str) { return str.toUpperCase() }` | `document.title = \"新标题\"` |\n\n\n\n\n##### 副作用代码的类型\n###### 显式副作用\n直接对外部环境产生影响的代码：\n\n```javascript\n// 修改全局变量\nwindow.user = { name: \"Alice\" };\n\n// 操作 DOM\ndocument.body.style.backgroundColor = \"red\";\n\n// 写入文件（Node.js）\nfs.writeFileSync(\"log.txt\", \"数据已更新\");\n```\n\n###### 隐式副作用\n通过依赖外部状态间接产生副作用：\n\n```javascript\n// 依赖外部变量（结果不可预测）\nlet base = 10;\nconst impureAdd = (x) => base + x;\n\n// 读取用户输入（外部依赖）\nconst input = prompt(\"请输入内容\");\n```\n\n\n\n##### 副作用的影响\n###### 对代码优化的阻碍\n+ Tree Shaking失效：打包工具无法安全删除未使用的副作用代码：\n\n```javascript\n// 即使未使用，以下代码也会被保留\nArray.prototype.customMethod = () => {}; // 修改原型链\n```\n\n+ 难以测试和调试：依赖外部状态的代码行为不可预测。\n\n###### 对函数式编程的挑战\n副作用违背引用透明性（同一输入始终返回同一输出），例如：\n\n```javascript\n// ❌ 非引用透明（依赖 Date 外部状态）\nconst getTime = () => new Date().toISOString();\n```\n\n\n\n##### 如何管理副作用\n###### 隔离副作用\n将副作用代码集中管理，与纯逻辑分离：\n\n```javascript\n// 纯函数（核心逻辑）\nfunction calculateTotal(items) {\n  return items.reduce((sum, item) => sum + item.price, 0);\n}\n\n// 副作用集中处理\nfunction renderTotal(total) {\n  document.getElementById(\"total\").textContent = `$${total}`;\n}\n\n// 组合使用\nconst items = [{ price: 10 }, { price: 20 }];\nrenderTotal(calculateTotal(items));\n```\n\n###### 显式标记副作用\n通过 `package.json` 声明模块的副作用，帮助打包工具优化：\n\n```javascript\n{\n  \"sideEffects\": [\n    \"**/*.css\",  // CSS 文件有副作用（注入样式）\n    \"src/polyfills.js\" //  polyfill 修改全局对象\n  ]\n}\n```\n\n###### 使用函数式编程技术\n+ 不可变数据：避免直接修改对象/数组（使用 `...` 或 `Object.assign`）。\n+ 副作用延迟执行：如 React 的 `useEffect`、Redux 的中间件。\n\n#### 静态分析（Static Analysis）\n静态分析是指在不实际运行代码的情况下，通过分析源代码或编译后的中间表示（如 AST）来检查代码的结构、语法、依赖关系以及潜在问题的一种技术。它在编程语言、编译器、安全分析和开发工具中广泛应用。\n\n##### 静态分析的核心概念\n###### 1.1 静态分析 vs 动态分析\n| **特性****** | **静态分析** | **动态分析** |\n| --- | --- | --- |\n| **执行时机** | 代码运行前（编译时/构建时） | 代码运行时 |\n| **输入数据** | 源代码、AST、字节码等静态结构 | 程序运行时的内存、I/O、状态等 |\n| **典型工具** | ESLint、TypeScript、Flow、SonarQube | Chrome DevTools、Valgrind、Fuzz 测试 |\n| **优势** | 提前发现问题，不影响运行时性能 | 捕捉运行时行为（如内存泄漏） |\n| **局限性** | 无法分析动态行为（如 `eval`） | 需要实际运行，可能漏检某些路径 |\n\n\n\n\n###### 1.2 静态分析的主要目标\n+ 代码质量检查（如未使用的变量、代码风格）\n+ 安全漏洞检测（如 SQL 注入、XSS）\n+ 性能优化（如 Dead Code Elimination）\n+ 依赖分析（如 Tree Shaking）\n+ 类型检查（如 TypeScript）\n\n\n\n##### 静态分析的关键技术\n###### 2.1 抽象语法树（AST）\n静态分析的核心数据结构，将代码转换为树状结构，便于工具分析\n\n```javascript\n// 示例代码\nconst sum = (a, b) => a + b;\n\n// 对应的AST（简化版）\n{\n  type: \"Program\",\n    body: [{\n    type: \"VariableDeclaration\",\n    declarations: [{\n      type: \"VariableDeclarator\",\n      id: { type: \"Identifier\", name: \"sum\" },\n      init: {\n        type: \"ArrowFunctionExpression\",\n        params: [\n          { type: \"Identifier\", name: \"a\" },\n          { type: \"Identifier\", name: \"b\" }\n        ],\n        body: {\n          type: \"BinaryExpression\",\n          operator: \"+\",\n          left: { type: \"Identifier\", name: \"a\" },\n          right: { type: \"Identifier\", name: \"b\" }\n        }\n      }\n    }]\n  }]\n}\n```\n\n工具：Babel、ESlint、Prettier均基于AST操作代码\n\n\n\n###### 2.2 数据流分析（Data Flow Analysis）\n跟踪变量和值的流动，用于检测：\n\n+ 未初始化的变量\n+ 不可达代码\n+ 常量传播优化\n\n\n###### 2.3 控制流分析（Control Flow Analysis）\n+ 检测无限循环\n+ 识别异常处理遗漏\n\n```javascript\nfunction risky(x) {\n  if (x > 0) {\n    return \"ok\";\n  }\n  // 静态分析可警告：缺少 else 分支，可能返回 undefined\n}\n```\n\n###### 2.4 类型检查（Type Checking）\n在编译时验证类型一致性，如TypeScript的静态类型系统：\n\n```javascript\nfunction greet(name: string) {\n  return `Hello, ${name}`;\n}\ngreet(42); // 静态分析报错：类型不匹配\n```\n\n","slug":"关于Webpack","published":1,"updated":"2025-09-14T14:58:47.861Z","_id":"cmfjrl1il0000n05w96kz3gzm","comments":1,"layout":"post","photos":[],"content":"<p>概念：Webpack 是一种用于构建 JavaScript 应用程序的静态模块打包器，它能够以一种相对一致且开放的处理方式，加载应用中的所有资源文件（图片、CSS、视频、字体文件等），并将其合并打包成浏览器兼容的 Web 资源文件。</p>\n<p>功能：****</p>\n<ul>\n<li>模块的打包：通过打包整合不同的模块文件保证各模块之间的引用和执行</li>\n<li>代码编译：通过丰富的<code>**loader**</code>可以将不同格式文件如<code>**.sass/.vue/.jsx**</code>转译为浏览器可以执行的文件</li>\n<li>扩展功能：通过社区丰富的<code>**plugin**</code>可以实现多种强大的功能，例如<strong>代码分割、代码混淆、代码压缩、按需加载…..等等</strong></li>\n</ul>\n<h3 id=\"常见的loader及其作用\"><a href=\"#常见的loader及其作用\" class=\"headerlink\" title=\"常见的loader及其作用\"></a>常见的loader及其作用</h3><p><strong><font style=\"color:#1DC0C9;\">-babel-loader</font></strong>：将es6转译为es5</p>\n<p><strong><font style=\"color:#1DC0C9;\">-file-loader</font></strong>：可以指定要复制和放置资源文件的位置，以及如何使用版本哈希命名以获得更好的缓存，并在代码中通过<strong>URL</strong>去引用输出的文件</p>\n<p><strong><font style=\"color:#1DC0C9;\">-url-loader</font></strong>：和<code>**file-loader**</code>功能相似，但是可以通过指定阈值来根据文件大小使用不同的处理方式（小于阈值则返回base64格式编码并将文件的 <code>data-url</code>内联到<code>bundle</code>中）</p>\n<p><strong><font style=\"color:#1DC0C9;\">-raw-loader</font></strong>：加载文件原始内容</p>\n<blockquote>\n<p>webpack5自身内置了<code>**file-loader/ url-loader/ raw-loader**</code>等loader，所以我们不需要再显示引入loader 只需要指定对应的type即可实现相同的功能 如<code>**file-loader**</code>等价于 <code>**type= &quot;asset/resource&quot;**</code></p>\n</blockquote>\n<p><strong><font style=\"color:#1DC0C9;\">-image-webpack-loader</font></strong>： 加载并压缩图片资源</p>\n<p><strong><font style=\"color:#1DC0C9;\">-awesome-typescirpt-loader</font></strong>: 将typescript转换为javaScript 并且性能优于<code>**ts-loader**</code></p>\n<p><strong><font style=\"color:#1DC0C9;\">-sass-loader</font></strong>: 将SCSS&#x2F;SASS代码转换为CSS</p>\n<p><strong><font style=\"color:#1DC0C9;\">-css-loader</font></strong>: 加载CSS代码 支持模块化、压缩、文件导入等功能特性**</p>\n<p><strong><font style=\"color:#1DC0C9;\">-style-loader</font></strong>: 把CSS代码注入到js中，通过<code>DOM</code> 操作去加载CSS代码</p>\n<blockquote>\n<p>当我们使用类似于 <code>**less**</code> 或者 <code>**scss**</code> 等预处理器的时候，通常需要多个 <strong>loader</strong> 的配合使用如<code>**test: /\\.less$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]**</code></p>\n</blockquote>\n<p><strong><font style=\"color:#1DC0C9;\">-source-map-loader</font></strong>: 加载额外的<code>Source Map</code>文件</p>\n<p><strong><font style=\"color:#1DC0C9;\">-eslint-loader</font></strong>: 通过ESlint 检查js代码</p>\n<p><strong><font style=\"color:#1DC0C9;\">-cache-loader</font></strong>: 可以在一些开销较大的<code>Loader</code>之前添加可以将结果缓存到磁盘中，提高构建的效率</p>\n<p><strong><font style=\"color:#1DC0C9;\">-thread-loader</font></strong>: 多线程打包，加快打包速度</p>\n<h3 id=\"常见的plugin及其作用\"><a href=\"#常见的plugin及其作用\" class=\"headerlink\" title=\"常见的plugin及其作用\"></a>常见的plugin及其作用</h3><p><strong><font style=\"color:#1DC0C9;\">-splitChunkPlugin</font></strong>: 定义环境变量（webpack4之后可以通过指定<code>**mode：production/development**</code>实现同样效果）</p>\n<p><strong><font style=\"color:#1DC0C9;\">-define-plugin</font></strong>: 定义环境变量（webpack4之后可以通过指定<code>**mode：production/development**</code>实现同样效果）</p>\n<p><strong><font style=\"color:#1DC0C9;\">-web-webpack-plugin</font></strong>：为单页面应用输出HTML 性能优于<code>html-webpack-plugin</code></p>\n<p><strong><font style=\"color:#1DC0C9;\">-clean-webpack-plugin</font></strong>: 每次打包时删除上次打包的产物, 保证打包目录下的文件都是最新的</p>\n<p><strong><font style=\"color:#1DC0C9;\">-webpack-merge</font></strong>： 用来合并公共配置文件,常用（例如分别配置<code>webpack.common.config.js/ webpack.dev.config.js/webpack.production.config.js</code>并将其合并）</p>\n<p><strong><font style=\"color:#1DC0C9;\">-ignore-plugin</font></strong>: 忽略指定的文件，可以加快构建速度</p>\n<p><strong><font style=\"color:#1DC0C9;\">-terser-webpack-plugin</font></strong>：压缩ES6的代码（tree-shaking）</p>\n<p><strong><font style=\"color:#1DC0C9;\">-uglifyjs-webpack-plugin</font></strong>: 压缩js代码</p>\n<p><strong><font style=\"color:#1DC0C9;\">-mini-css-extract-plugin</font></strong>: 将CSS提取为独立文件，支持按需加载x</p>\n<p><strong><font style=\"color:#1DC0C9;\">-css-minimize-webpack-plugin</font></strong>：压缩CSS代码</p>\n<blockquote>\n<p>css文件的压缩需要<code>**mini-css-extract-plugin**</code>和<code>**css-minimize-webpack-plugin** </code>的配合使用 即先使用<code>**mini-css-extract-plugin**</code>将css代码抽离成单独文件，之后使用<code> **css-minimize-webpack-plugin**</code>对css代码进行压缩</p>\n</blockquote>\n<p><strong><font style=\"color:#1DC0C9;\">-serviceworker-webpack-plugin</font></strong>: 为离线应用增加离线缓存功能</p>\n<p><strong><font style=\"color:#1DC0C9;\">-ModuleconcatenationPlugin</font></strong>: 开启<code>**Scope Hositing**</code> 用于合并提升作用域， 减小代码体积</p>\n<p><strong><font style=\"color:#1DC0C9;\">-copy-webpack-plugin</font></strong>： 在构建的时候，复制静态资源到打包目录。</p>\n<p><strong><font style=\"color:#1DC0C9;\">-compression-webpack-plugin</font></strong>: 生产环境采用<code>**gzip**</code>压缩JS和CSS</p>\n<p><strong><font style=\"color:#1DC0C9;\">-ParalleUglifyPlugin</font></strong>： 多进程并行压缩js</p>\n<p><strong><font style=\"color:#1DC0C9;\">-webpack-bundle-analyzer</font></strong>: 可视化webpack输出文件大小的根据</p>\n<p><strong><font style=\"color:#1DC0C9;\">-speed-measure-webpack-plugin</font></strong>: 用于分析各个loader和plugin的耗时，可用于性能分析</p>\n<p><strong><font style=\"color:#1DC0C9;\">-webpack-dashboard</font></strong>: 可以更友好地展示打包相关信息</p>\n<p><strong><font style=\"color:#1DC0C9;\">-Webpack Analysis</font></strong>：webpack 官方提供的可视化分析工具</p>\n<p><strong><font style=\"color:#1DC0C9;\">-BundleAnalyzerPlugin</font></strong>：性能分析插件，可以在运行后查看是否包含重复模块&#x2F;不必要模块等</p>\n<h3 id=\"loader和plugin的区别\"><a href=\"#loader和plugin的区别\" class=\"headerlink\" title=\"loader和plugin的区别\"></a>loader和plugin的区别</h3><p><strong><font style=\"color:#1DC0C9;\">Loader：</font></strong></p>\n<p>Loader本质上是一个函数，负责代码的转译，即对接收到的内容进行转换后将转换后的结果返回 ，因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p>\n<p>配置Loader通过在 **module.rules **中以数组的形式配置，每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。</p>\n<p><strong><font style=\"color:#1DC0C9;\">Plugin：</font></strong></p>\n<p>Plugin可以扩展 Webpack 的功能，本质上是一个带有 <strong>apply(compiler)</strong> 的函数，基于 <a class=\"link\"   href=\"https://link.juejin.cn/?target=https://www.npmjs.com/package/tapable\" >tapable<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 这个事件流框架来监听<strong>webpack</strong>构建&#x2F;打包过程中发布的hooks来通过自定义的逻辑和功能来改变输出结果。 </p>\n<p>Plugin通过 <strong>plugins</strong> 以数组的形式配置，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</p>\n<p><strong>总结：</strong></p>\n<p><strong>Loader <strong>主要负责将代码转译为</strong>webpack</strong>可以处理的JavaScript代码，而 <strong>Plugin</strong> 更多的是负责通过接入<strong>webpack</strong>构建过程来影响构建过程以及产物的输出，<strong>Loader</strong>的职责相对比较<strong>单一</strong>简单，而 **Plugin **更为丰富多样。</p>\n<h3 id=\"loader执行顺序\"><a href=\"#loader执行顺序\" class=\"headerlink\" title=\"loader执行顺序\"></a>loader执行顺序</h3><h5 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h5><pre><code>- **&lt;font style=&quot;color:#1DC0C9;&quot;&gt;pre&lt;/font&gt;**：前置loader 用法：**module.rules** 中 **enforce** 属性指定\n- **&lt;font style=&quot;color:#1DC0C9;&quot;&gt;normal&lt;/font&gt;**：普通loader 用法：**module.rules** 中 **enforce** 属性指定\n- **&lt;font style=&quot;color:#1DC0C9;&quot;&gt;inline&lt;/font&gt;**：内联loader（不建议使用）用法：在import语句中显示指定loader 举例：`import Styles from &#39;style-loader|css-loader?modules!./styles.css&#39;;` 含义：用 css-loader 和 style-loader 处理 styles.css 文件，通过 ! 将资源中的loader分开\n- **&lt;font style=&quot;color:#1DC0C9;&quot;&gt;post&lt;/font&gt;**：后置loader 用法：**module.rules** 中 **enforce** 属性指定\n</code></pre>\n<h5 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h5><pre><code>- 4类loader的执行顺序：`pre &gt; normal &gt; inline &gt; post`\n- 相同优先级的loader执行顺序：`从右到左，从下到上`\n</code></pre>\n<h5 id=\"pitching-loader\"><a href=\"#pitching-loader\" class=\"headerlink\" title=\"pitching loader\"></a>pitching loader</h5><pre><code>- loader 上的 **&lt;font style=&quot;color:#1DC0C9;&quot;&gt;pitch&lt;/font&gt;** 方法\n</code></pre>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"keyword\">function</span> (<span class=\"params\">content</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span>.<span class=\"property\">pitch</span> = <span class=\"keyword\">function</span> (<span class=\"params\">remainingRequest, precedingRequest, data</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;do somethings&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<pre><code>- webpack 会先从左到右执行 loader 链中的每个 loader 上的 pitch 方法（如果有），然后再从右到左执行 loader 链中的每个 loader 上的普通 loader 方法\n</code></pre>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/pitching_loader_1.png\"\n                      alt=\"pitching_loader_1\"\n                ></p>\n<pre><code>- 在这个过程中如果任何 pitch 有返回值，则 loader 链被阻断。webpack 会跳过后面所有的的 pitch 和 loader，直接进入上一个 loader \n</code></pre>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/pitching_loader_2.png\"\n                      alt=\"pitching_loader_2\"\n                ></p>\n<h3 id=\"webpack构建流程\"><a href=\"#webpack构建流程\" class=\"headerlink\" title=\"webpack构建流程\"></a>webpack构建流程</h3><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>\n<ul>\n<li><strong><font style=\"color:#1DC0C9;\">初始化参数</font></strong>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li>\n<li><strong><font style=\"color:#1DC0C9;\">开始编译</font></strong>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li>\n<li><strong><font style=\"color:#1DC0C9;\">确定入口</font></strong>：根据配置中的 entry 找出所有的入口文件</li>\n<li><strong><font style=\"color:#1DC0C9;\">编译模块</font></strong>：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li>\n<li><strong><font style=\"color:#1DC0C9;\">完成模块编译</font></strong>：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li>\n<li><strong><font style=\"color:#1DC0C9;\">输出资源</font></strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>\n<li><strong><font style=\"color:#1DC0C9;\">输出完成</font></strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li>\n</ul>\n<p>在以上过程中，<code>Webpack</code> 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p>\n<p>简单说</p>\n<ul>\n<li><strong><font style=\"color:#1DC0C9;\">初始化</font></strong>：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler</li>\n<li><strong><font style=\"color:#1DC0C9;\">编译</font></strong>：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li>\n<li><strong><font style=\"color:#1DC0C9;\">输出</font></strong>：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</li>\n</ul>\n<h3 id=\"文件指纹\"><a href=\"#文件指纹\" class=\"headerlink\" title=\"文件指纹\"></a>文件指纹</h3><p>概念：文件指纹是打包后输出的文件名的后缀</p>\n<h5 id=\"种类：\"><a href=\"#种类：\" class=\"headerlink\" title=\"种类：\"></a>种类：</h5><ul>\n<li><strong><font style=\"background-color:rgba(222,253,255,1);\"> Hash </font></strong>：和整个项目的构建相关，只要项目文件有修改（**<font style=\"background-color:rgba(222,253,255,1);\"> compilation </font>**实例改变），整个项目构建的 Hash 值就会更改</li>\n<li><strong><font style=\"background-color:rgba(222,253,255,1);\"> Chunkhash </font></strong>：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash，（不同 Chunkhash 之间的变化互不影响）</li>\n<li><font style=\"background-color:rgba(222,253,255,1);\"> </font><strong><font style=\"background-color:rgba(222,253,255,1);\">Contenthash</font></strong><font style=\"background-color:rgba(222,253,255,1);\"> </font>：根据文件内容来定义 hash，文件内容不变，则 Contenthash 不变</li>\n</ul>\n<h5 id=\"使用：\"><a href=\"#使用：\" class=\"headerlink\" title=\"使用：\"></a>使用：</h5><ul>\n<li>JS文件：使用 <strong><font style=\"background-color:rgba(222,253,255,1);\"> Chunkhash </font></strong></li>\n<li>CSS文件：使用 <font style=\"background-color:rgba(222,253,255,1);\"> </font><strong><font style=\"background-color:rgba(222,253,255,1);\">Contenthash</font></strong><font style=\"background-color:rgba(222,253,255,1);\"> </font></li>\n<li>图片等静态资源： 使用 <strong><font style=\"background-color:rgba(222,253,255,1);\"> Hash </font></strong></li>\n</ul>\n<blockquote>\n<p>生产环境的output为了区分版本变动，通过**<font style=\"background-color:rgba(222,253,255,1);\"> Contenthash </font><strong>来达到清理缓存及时更新的效果，而开发环境中为了加快构建效率，一般不引入</strong><font style=\"background-color:rgba(222,253,255,1);\"> Contenthash </font>**</p>\n</blockquote>\n<h5 id=\"JS的文件指纹设置\"><a href=\"#JS的文件指纹设置\" class=\"headerlink\" title=\"JS的文件指纹设置\"></a>JS的文件指纹设置</h5><p>设置 output 的 filename，用 chunkhash</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;   </span><br><span class=\"line\">  <span class=\"attr\">entry</span>: &#123;        </span><br><span class=\"line\">    <span class=\"attr\">app</span>: <span class=\"string\">&#x27;./scr/app.js&#x27;</span>,        </span><br><span class=\"line\">    <span class=\"attr\">search</span>: <span class=\"string\">&#x27;./src/search.js&#x27;</span>    </span><br><span class=\"line\">  &#125;,    </span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;        </span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;[name][chunkhash:8].js&#x27;</span>, <span class=\"comment\">// chunkhash:8 保留8位    </span></span><br><span class=\"line\">    <span class=\"attr\">path</span>:__dirname + <span class=\"string\">&#x27;/dist&#x27;</span>    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<h5 id=\"CSS的文件指纹设置\"><a href=\"#CSS的文件指纹设置\" class=\"headerlink\" title=\"CSS的文件指纹设置\"></a>CSS的文件指纹设置</h5><p>设置 MiniCssExtractPlugin 的 filename，用 contenthash</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;    </span><br><span class=\"line\">  <span class=\"attr\">entry</span>: &#123;        </span><br><span class=\"line\">    <span class=\"attr\">app</span>: <span class=\"string\">&#x27;./scr/app.js&#x27;</span>,        </span><br><span class=\"line\">    <span class=\"attr\">search</span>: <span class=\"string\">&#x27;./src/search.js&#x27;</span>   </span><br><span class=\"line\">  &#125;,    </span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;        </span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;[name][chunkhash:8].js&#x27;</span>,        </span><br><span class=\"line\">    <span class=\"attr\">path</span>:__dirname + <span class=\"string\">&#x27;/dist&#x27;</span>   </span><br><span class=\"line\">  &#125;,    </span><br><span class=\"line\">  <span class=\"attr\">plugins</span>:[        </span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MiniCssExtractPlugin</span>(&#123;            </span><br><span class=\"line\">      <span class=\"attr\">filename</span>: <span class=\"string\">`[name][contenthash:8].css`</span>        &#125;)   </span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h5 id=\"图片的文件指纹设置\"><a href=\"#图片的文件指纹设置\" class=\"headerlink\" title=\"图片的文件指纹设置\"></a>图片的文件指纹设置</h5><p>设置 file-loader 的 filename，用 hash，<strong>webpack5后内置file-loader&#x2F;url-loader&#x2F;raw-loader，配置assets属性即可，无需再引入loader</strong></p>\n<p>占位符名称及含义</p>\n<ul>\n<li>ext 资源后缀名</li>\n<li>name 文件名称</li>\n<li>path 文件的相对路径</li>\n<li>folder 文件所在的文件夹</li>\n<li>contenthash 文件的内容hash，默认是md5生成</li>\n<li>hash 文件内容的hash，默认是md5生成</li>\n<li>emoji 一个随机的指代文件内容的emoj</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;    </span><br><span class=\"line\">  <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;./src/index.js&#x27;</span>,    </span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;        </span><br><span class=\"line\">    <span class=\"attr\">filename</span>:<span class=\"string\">&#x27;bundle.js&#x27;</span>,        </span><br><span class=\"line\">    <span class=\"attr\">path</span>:path.<span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;dist&#x27;</span>)   </span><br><span class=\"line\">  &#125;,    </span><br><span class=\"line\">  <span class=\"attr\">module</span>:&#123;        </span><br><span class=\"line\">    <span class=\"attr\">rules</span>:[&#123;            </span><br><span class=\"line\">      <span class=\"attr\">test</span>:<span class=\"regexp\">/\\.(png|svg|jpg|gif)$/</span>,            </span><br><span class=\"line\">      <span class=\"attr\">use</span>:[&#123;                </span><br><span class=\"line\">        <span class=\"attr\">loader</span>:<span class=\"string\">&#x27;file-loader&#x27;</span>,                </span><br><span class=\"line\">        <span class=\"attr\">options</span>:&#123;                    </span><br><span class=\"line\">          <span class=\"attr\">name</span>:<span class=\"string\">&#x27;img/[name][hash:8].[ext]&#x27;</span>               </span><br><span class=\"line\">        &#125;           </span><br><span class=\"line\">      &#125;]       </span><br><span class=\"line\">    &#125;]   </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// webpack5配置参考如下：</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// rules:[</span></span><br><span class=\"line\"><span class=\"comment\">//   &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         test: /\\.(png|jpe?g|gif|webp|svg)$/,</span></span><br><span class=\"line\"><span class=\"comment\">//         type: &#x27;asset&#x27;,</span></span><br><span class=\"line\"><span class=\"comment\">//         parser: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//           dataUrlCondition: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             // 小于10kb的图片转base64</span></span><br><span class=\"line\"><span class=\"comment\">//             // 优点：减少请求数量  缺点：体积会更大</span></span><br><span class=\"line\"><span class=\"comment\">//             maxSize: 10 * 1024 // 10kb </span></span><br><span class=\"line\"><span class=\"comment\">//           &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//         generator: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//           // 输出图片名称</span></span><br><span class=\"line\"><span class=\"comment\">//           // [hash:10] hash值取前10位</span></span><br><span class=\"line\"><span class=\"comment\">//           filename: &#x27;static/images/[hash:10][ext][query]&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//       &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//   &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         test: /\\.(ttf|woff2?|mp3|mp4|avi)$/,</span></span><br><span class=\"line\"><span class=\"comment\">//         type: &#x27;asset/resource&#x27;,</span></span><br><span class=\"line\"><span class=\"comment\">//         generator: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//           // 输出名称</span></span><br><span class=\"line\"><span class=\"comment\">//           // [hash:10] hash值取前10位</span></span><br><span class=\"line\"><span class=\"comment\">//           filename: &#x27;static/media/[hash:10][ext][query]&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//       &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// ]</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"Babel的原理\"><a href=\"#Babel的原理\" class=\"headerlink\" title=\"Babel的原理\"></a>Babel的原理</h3><p>概述：大多数JavaScript Parser遵循 <strong>estree</strong> 规范，Babel 最初基于 <strong>acorn</strong> 项目(轻量级现代 JavaScript 解析器) 。</p>\n<p><strong>babel</strong> 可以将代码转译为想要的目标代码，并且对目标环境不支持的<strong>api</strong> 自动 <strong><font style=\"background-color:rgba(222,253,255,1);\"> polyfill </font></strong> 。而 **babel **实现这些功能的流程是 <strong><font style=\"background-color:rgba(222,253,255,1);\"> 解析（parse）-转换（transfrom）-生成（generator）</font></strong> </p>\n<ul>\n<li><strong><font style=\"background-color:rgba(77, 208, 225, 0.08);\">解析</font></strong>：根据代码生成对应的 <strong>AST</strong> 结构<ul>\n<li>词法分析：将代码(字符串)分割为 <strong>token</strong> 流，即语法单元成的数组</li>\n<li>语法分析：分析 **token **流(上面生成的数组)并生成 AST</li>\n</ul>\n</li>\n<li><strong><font style=\"background-color:rgba(77, 208, 225, 0.08);\">转换</font></strong>：遍历 <strong>AST</strong> 节点并生成新的 <strong>AST</strong> 节点</li>\n<li><strong><font style=\"background-color:rgba(77, 208, 225, 0.08);\">生成</font></strong>：根据新的 <strong>AST</strong> 生成目标代码</li>\n</ul>\n<h3 id=\"文件监听原理\"><a href=\"#文件监听原理\" class=\"headerlink\" title=\"文件监听原理\"></a>文件监听原理</h3><p>在发现源码发生变化时，自动重新构建出新的输出文件</p>\n<p>Webpack开启监听模式，有两种方式：</p>\n<ul>\n<li>启动 webpack 命令时，带上 –watch 参数</li>\n<li>在配置 webpack.config.js 中设置 watch:true</li>\n</ul>\n<p>缺点：每次需要手动刷新浏览器</p>\n<p>原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 <strong>aggregateTimeout</strong> 后再统一执行。</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">watch</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 默认false，也就是不开启，只有开启监听模式时，watchOptions才有意义</span></span><br><span class=\"line\"><span class=\"attr\">watchOptions</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不监听的文件或者文件夹，忽略一些大型的不经常变化的文件可以提高构建速度，支持正则匹配</span></span><br><span class=\"line\">    <span class=\"attr\">ignored</span>: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">    <span class=\"comment\">//监听到变化会等多少时间再执行，默认300ms</span></span><br><span class=\"line\">    <span class=\"attr\">aggregateTimeout</span>: <span class=\"number\">300</span>,</span><br><span class=\"line\">    <span class=\"comment\">//判断文件是否发生变化是通过不断轮询指定文件有没有变化实现的，默认每秒问1000次</span></span><br><span class=\"line\">    <span class=\"attr\">poll</span>: <span class=\"number\">1000</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h3 id=\"热更新原理\"><a href=\"#热更新原理\" class=\"headerlink\" title=\"热更新原理\"></a>热更新原理</h3><p>参考链接：<a class=\"link\"   href=\"https://juejin.cn/post/6844904008432222215?searchId=20250725014743FA245E0AE4142AA9178D\" >轻松理解webpack热更新原理<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> <a class=\"link\"   href=\"https://juejin.cn/post/6844904020528594957?searchId=20250725014743FA245E0AE4142AA9178D\" >从零实现webpack热更新HMR<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p>视频讲解：<a class=\"link\"   href=\"https://www.bilibili.com/video/BV1To4y1f7Wo?spm_id_from=333.788.player.player_end_recommend&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89\" >Webpack 热更新原理与实战<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p>概述：模块热替换（Hot Module Replacement，HMR）是 webpack 提供的最有用的功能之一。当我们<strong>对代码修改并保存后，webpack将会对代码进行新的打包，并将新的模块发送到浏览器端，浏览器用新的模块替换掉旧的模块</strong>，以实现在不刷新浏览器的前提下更新页面。</p>\n<p>刷新我们一般分为两种：</p>\n<ul>\n<li>一种是页面刷新，不保留页面状态，就是简单粗暴，直接 <strong><font style=\"background-color:#FBE4E7;\">window.reload()</font></strong></li>\n<li>另一种是基于 **<font style=\"background-color:#FBE4E7;\">WDS（Wepack-dev-server）</font>**的模块热替换，只需要局部刷新页面上发生变化的模块，同时可以保留当前的页面状态，比如复选框的选中状态、输入框的输入等。</li>\n</ul>\n<h5 id=\"整体工作流程\"><a href=\"#整体工作流程\" class=\"headerlink\" title=\"整体工作流程\"></a>整体工作流程</h5><ol>\n<li>文件修改：开发者保存修改后的文件</li>\n<li>Webpack 重新编译：生成新的模块代码和补丁（patch）</li>\n<li>通知客户端：通过 websocket 向浏览器发送更新消息</li>\n<li>客户端应用更新：获取新模块并替换旧模块</li>\n<li>模块热替换：仅更新变化的模块，保持应用状态</li>\n</ol>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/pic_HMR.png\"\n                      alt=\"pic_HMR\"\n                ></p>\n<p>详细解析图如下（含源码指导版）：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/%E7%83%AD%E6%9B%B4%E6%96%B0.png\"\n                      alt=\"热更新\"\n                ></p>\n<h5 id=\"核心组成部分\"><a href=\"#核心组成部分\" class=\"headerlink\" title=\"核心组成部分\"></a>核心组成部分</h5><h6 id=\"2-1-Webpack-dev-server-或-webpack-dev-middleware\"><a href=\"#2-1-Webpack-dev-server-或-webpack-dev-middleware\" class=\"headerlink\" title=\"2.1 Webpack-dev-server (或 webpack-dev-middleware)\"></a>2.1 Webpack-dev-server (或 webpack-dev-middleware)</h6><ul>\n<li>启动一个 Express 服务器</li>\n<li>创建 websocket 服务（默认端口 8080）</li>\n<li>监听文件变化并触发重新编译</li>\n<li>通过 _webpack_hmr 端点与客户端通信</li>\n</ul>\n<h6 id=\"2-2-HMR-Runtime（客户端部分）\"><a href=\"#2-2-HMR-Runtime（客户端部分）\" class=\"headerlink\" title=\"2.2 HMR Runtime（客户端部分）\"></a>2.2 HMR Runtime（客户端部分）</h6><p>注入到 bundle 中的代码，负责：</p>\n<ul>\n<li>建立与 dev-server 的 websocket 连接</li>\n<li>接收更新通知</li>\n<li>发起 JSONP 请求获取更新模块</li>\n<li>执行模块替换逻辑</li>\n</ul>\n<h6 id=\"2-3-HMR-Plugin（服务端部分）\"><a href=\"#2-3-HMR-Plugin（服务端部分）\" class=\"headerlink\" title=\"2.3 HMR Plugin（服务端部分）\"></a>2.3 HMR Plugin（服务端部分）</h6><p>Webpack 内置的 HotModuleReplacementPlugin 负责：</p>\n<ul>\n<li>生成每个模块的 HMR 标识（hash）</li>\n<li>生成 manifest 文件（记录模块更新信息）</li>\n<li>生成 update 补丁文件（[oldHash].hot-update.json&#x2F;.js）</li>\n</ul>\n<h5 id=\"模块热更新策略\"><a href=\"#模块热更新策略\" class=\"headerlink\" title=\"模块热更新策略\"></a>模块热更新策略</h5><h6 id=\"3-1不同类型模块的处理\"><a href=\"#3-1不同类型模块的处理\" class=\"headerlink\" title=\"3.1不同类型模块的处理\"></a>3.1不同类型模块的处理</h6><ol>\n<li>普通 JS 模块：<ul>\n<li>直接替换模块导出对象</li>\n<li>需要手动编写 module.hot.accept 逻辑</li>\n</ul>\n</li>\n<li>样式模块（通过 style-loader）：<ul>\n<li>自动处理：新样式替换旧样式（无需页面刷新）</li>\n<li>实现原理：style-loader 会注入特殊的 HMR 代码</li>\n</ul>\n</li>\n<li>React&#x2F;Vue 组件：<ul>\n<li>需要框架特定的 HMR 支持</li>\n<li>React: 使用 react-hot-loader 或 React Refresh</li>\n<li>Vue: vue-loader 内置支持</li>\n</ul>\n</li>\n</ol>\n<h6 id=\"3-2更新传播机制\"><a href=\"#3-2更新传播机制\" class=\"headerlink\" title=\"3.2更新传播机制\"></a>3.2更新传播机制</h6><ul>\n<li>接受依赖：当模块 A 调用 module.hot.accept，表示它能够接受自身或依赖模块的更新</li>\n<li>冒泡更新：如果父模块不接受子模块更新，更新会向上冒泡直到找到接受者</li>\n<li>无接受者：如果没有模块接受更新，则 fallback 到整页刷新</li>\n</ul>\n<h3 id=\"代码分割\"><a href=\"#代码分割\" class=\"headerlink\" title=\"代码分割\"></a>代码分割</h3><p>参考文章：<a class=\"link\"   href=\"https://juejin.cn/post/6844904001792655373?searchId=202507231703353AC77072FBD359203430\" >webpack优化之玩转代码分割和公共代码提取<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p>概述：代码分割是 Webpack 的核心功能之一，它允许你将代码拆分成多个 bundle，然后可以按需加载或并行加载，从而优化应用性能。</p>\n<h5 id=\"为什么需要代码分割\"><a href=\"#为什么需要代码分割\" class=\"headerlink\" title=\"为什么需要代码分割\"></a>为什么需要代码分割</h5><ol>\n<li>减小初始加载体积：将应用拆分成多个 bundle，用户只需加载当前需要的代码</li>\n<li>提高加载速度：并行加载多个 bundle 比加载单个大文件更快</li>\n<li>缓存优化：将不常变动的代码单独打包，利用浏览器缓存</li>\n</ol>\n<h5 id=\"代码分割的三种主要方式\"><a href=\"#代码分割的三种主要方式\" class=\"headerlink\" title=\"代码分割的三种主要方式\"></a>代码分割的三种主要方式</h5><ol>\n<li>入口起点(Entry Points)</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">app</span>: <span class=\"string\">&#x27;./src/app.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">vendor</span>: <span class=\"string\">&#x27;./src/vendor.js&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;[name].bundle.js&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>缺点：如果多个入口共享模块，这些模块会被重复打包到各个 bundle 中(用SplitChunksPlugin解决)</p>\n<ol start=\"2\">\n<li>防止重复(SplitChunksPlugin)</li>\n</ol>\n<p>Webpack 4+ 内置了 SplitChunksPlugin，可以自动拆分公共依赖：</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">optimization</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">splitChunks</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">chunks</span>: <span class=\"string\">&#x27;all&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">minSize</span>: <span class=\"number\">30000</span>, <span class=\"comment\">// 模块的最小体积</span></span><br><span class=\"line\">      <span class=\"attr\">minChunks</span>: <span class=\"number\">1</span>, <span class=\"comment\">// 模块的最小被引用次数</span></span><br><span class=\"line\">      <span class=\"attr\">cacheGroups</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">vendors</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">test</span>: <span class=\"regexp\">/[\\\\/]node_modules[\\\\/]/</span>,</span><br><span class=\"line\">          <span class=\"attr\">priority</span>: -<span class=\"number\">10</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">default</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">minChunks</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">          <span class=\"attr\">priority</span>: -<span class=\"number\">20</span>,</span><br><span class=\"line\">          <span class=\"attr\">reuseExistingChunk</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"3\">\n<li>动态导入(Dynamic Imports)</li>\n</ol>\n<p>使用 ES6 的 import() 语法或 Webpack 特定的 require.ensure：</p>\n<ol>\n<li>默认行为：单独打包</li>\n</ol>\n<p>当使用 import() 动态导入语法时：</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 点击按钮时动态加载模块</span></span><br><span class=\"line\">button.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;./math.js&#x27;</span>).<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">math</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(math.<span class=\"title function_\">add</span>(<span class=\"number\">16</span>, <span class=\"number\">26</span>));</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<pre><code>- Webpack 会将 math.js 及其依赖打包成一个独立的 chunk（如 1.bundle.js）。\n- 运行时按需加载：只有当代码执行到 import() 时，浏览器才会发起网络请求加载这个 chunk。\n</code></pre>\n<ol start=\"2\">\n<li>控制打包名称（魔法注释）</li>\n</ol>\n<p>通过 webpackChunkName 注释可以自定义 chunk 名称：</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: &quot;math-lib&quot; */</span> <span class=\"string\">&#x27;./math.js&#x27;</span>)</span><br></pre></td></tr></table></figure></div>\n\n<pre><code>- 生成的文件名会变成 math-lib.bundle.js 而非数字 ID。\n- 适合给重要模块命名，便于调试和长期缓存。\n</code></pre>\n<ol start=\"3\">\n<li>依赖关系处理<ul>\n<li>如果动态导入的模块 依赖其他模块，这些依赖会被 一起打包到同一个     chunk 中。</li>\n<li>如果多个动态导入的模块 共享依赖，Webpack 默认会 重复打包（除非通过 SplitChunksPlugin 优化）。</li>\n</ul>\n</li>\n</ol>\n<p>预获取&#x2F;预加载模块</p>\n<p>Webpack 4.6+ 支持使用魔法注释实现资源预加载：</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackPrefetch: true */</span> <span class=\"string\">&#x27;./path/to/LoginModal.js&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackPreload: true */</span> <span class=\"string\">&#x27;./path/to/ChartComponent.js&#x27;</span>);</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>prefetch：浏览器空闲时加载，用于未来可能需要的资源</li>\n<li>preload：与父 chunk 并行加载，用于当前导航可能需要的资源</li>\n</ul>\n<h5 id=\"代码分割最佳实践\"><a href=\"#代码分割最佳实践\" class=\"headerlink\" title=\"代码分割最佳实践\"></a>代码分割最佳实践</h5><ul>\n<li>按路由分割：为每个路由创建单独的 chunk</li>\n<li>提取公共依赖：将第三方库(vendor)和公共模块单独打包</li>\n<li>合理使用动态导入：对非关键功能使用懒加载</li>\n<li>监控 bundle 大小：使用 webpack-bundle-analyzer 分析包内容</li>\n</ul>\n<p>示例配置：</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">optimization</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">splitChunks</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">chunks</span>: <span class=\"string\">&#x27;all&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">maxSize</span>: <span class=\"number\">244</span> * <span class=\"number\">1024</span>, <span class=\"comment\">// 尝试将大于244KB的块拆分成更小的块</span></span><br><span class=\"line\">      <span class=\"attr\">cacheGroups</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">reactVendor</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">test</span>: <span class=\"regexp\">/[\\\\/]node_modules[\\\\/](react|react-dom)[\\\\/]/</span>,</span><br><span class=\"line\">          <span class=\"attr\">name</span>: <span class=\"string\">&#x27;react-vendor&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">chunks</span>: <span class=\"string\">&#x27;all&#x27;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">utilityVendor</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">test</span>: <span class=\"regexp\">/[\\\\/]node_modules[\\\\/](lodash|moment|axios)[\\\\/]/</span>,</span><br><span class=\"line\">          <span class=\"attr\">name</span>: <span class=\"string\">&#x27;utility-vendor&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">chunks</span>: <span class=\"string\">&#x27;all&#x27;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"手写loaders和plugin\"><a href=\"#手写loaders和plugin\" class=\"headerlink\" title=\"手写loaders和plugin\"></a>手写loaders和plugin</h3><p>文档：文稿&#x2F;learning&#x2F;chl-learning&#x2F;webpack5&#x2F;kejian&#x2F;course&#x2F;webpack_docs</p>\n<p>代码：文稿&#x2F;learning&#x2F;chl-learning&#x2F;webpack5&#x2F;SOURCE</p>\n<p>学习视频：<a class=\"link\"   href=\"https://www.bilibili.com/video/BV14T4y1z7sw/?spm_id_from=333.788.videopod.episodes&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89&p=42\" >尚硅谷Webpack5入门到原理（面试开发一条龙<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<h3 id=\"tree-shaking\"><a href=\"#tree-shaking\" class=\"headerlink\" title=\"tree-shaking\"></a>tree-shaking</h3><p>参考链接：<a class=\"link\"   href=\"https://juejin.cn/post/7002410645316436004?searchId=2025080400284774D9A2A868649273E08D\" >Webpack 原理系列九：Tree-Shaking 实现原理<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p>概述：前端中的tree-shaking可以理解为通过工具”摇”我们的JS文件，将其中用不到的代码”摇”掉，是一个性能优化的范畴。具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。</p>\n<p>支持tree-shaking的构建工具：</p>\n<ul>\n<li>Rollup（最早实现）</li>\n<li>Webpack</li>\n<li>Closure compiler（google的）</li>\n</ul>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><h5 id=\"依赖关系图分析\"><a href=\"#依赖关系图分析\" class=\"headerlink\" title=\"依赖关系图分析\"></a>依赖关系图分析</h5><p>打包工具会构建模块的依赖关系图，标记哪些导出被实际使用</p>\n<h5 id=\"静态分析阶段\"><a href=\"#静态分析阶段\" class=\"headerlink\" title=\"静态分析阶段\"></a>静态分析阶段</h5><ol>\n<li>识别导出：分析每个模块的 export 语句。</li>\n<li>追踪引用：从入口文件开始，追踪所有 import 的依赖链。</li>\n<li>标记失效代码：未被引用的导出标记为“可删除”。</li>\n</ol>\n<h5 id=\"删除阶段\"><a href=\"#删除阶段\" class=\"headerlink\" title=\"删除阶段\"></a>删除阶段</h5><p>通过压缩工具（如 Terser）移除标记为未使用的代码。</p>\n<h4 id=\"实现条件\"><a href=\"#实现条件\" class=\"headerlink\" title=\"实现条件\"></a>实现条件</h4><h5 id=\"1-必须使用ES-Module（ESM）\"><a href=\"#1-必须使用ES-Module（ESM）\" class=\"headerlink\" title=\"1.必须使用ES Module（ESM）\"></a>1.必须使用ES Module（ESM）</h5><ul>\n<li>Tree Shaking 依赖 ESM 的 静态结构（import&#x2F;export 必须在顶层声明）。</li>\n<li>CommonJS 无法被优化（require 是动态的，无法在编译时分析）。</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ✅ 可被 Tree Shaking（ESM）</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; usedFunc &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./utils&#x27;</span>;</span><br><span class=\"line\"><span class=\"title function_\">usedFunc</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ❌ 无法被 Tree Shaking（CommonJS）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> utils = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./utils&#x27;</span>);</span><br><span class=\"line\">utils.<span class=\"title function_\">usedFunc</span>();</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h5 id=\"2-避免副作用代码\"><a href=\"#2-避免副作用代码\" class=\"headerlink\" title=\"2.避免副作用代码\"></a>2.避免副作用代码</h5><ul>\n<li>工具会假设所有代码可能有副作用（如修改全局变量），除非显式声明。</li>\n<li>通过 package.json 的 sideEffects 字段标记无副作用的模块：</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// package.json</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;sideEffects&quot;</span>: <span class=\"literal\">false</span>,  <span class=\"comment\">// 整个包无副作用</span></span><br><span class=\"line\">  <span class=\"string\">&quot;sideEffects&quot;</span>: [<span class=\"string\">&quot;*.css&quot;</span>]  <span class=\"comment\">// 仅 CSS 文件有副作用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"副作用代码（Side-Effects）\"><a href=\"#副作用代码（Side-Effects）\" class=\"headerlink\" title=\"副作用代码（Side Effects）\"></a>副作用代码（Side Effects）</h4><p>概述**：**副作用代码是指在执行时会对外部环境产生可观察影响的代码，这类代码不仅返回计算结果，还会修改外部状态或与系统交互。理解副作用对编写可维护、可优化的代码至关重要。</p>\n<h5 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h5><h6 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h6><ul>\n<li>纯函数（无副作用）：输出仅由输入决定，不修改外部状态（如数学函数 Math.sqrt(4)）。</li>\n<li>副作用代码：执行时会产生额外影响，例如：<ul>\n<li>修改全局变量</li>\n<li>操作 DOM</li>\n<li>发起网络请求</li>\n<li>读写文件&#x2F;数据库</li>\n<li>打印日志</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"示例对比\"><a href=\"#示例对比\" class=\"headerlink\" title=\"示例对比\"></a>示例对比</h6><table>\n<thead>\n<tr>\n<th><strong>无副作用</strong></th>\n<th><strong>有副作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>const sum = (a, b) =&gt; a + b</code></td>\n<td><code>let count = 0;</code>   <code>const add = () =&gt; &#123; count++ &#125;</code></td>\n</tr>\n<tr>\n<td><code>function capitalize(str) &#123; return str.toUpperCase() &#125;</code></td>\n<td><code>document.title = &quot;新标题&quot;</code></td>\n</tr>\n</tbody></table>\n<h5 id=\"副作用代码的类型\"><a href=\"#副作用代码的类型\" class=\"headerlink\" title=\"副作用代码的类型\"></a>副作用代码的类型</h5><h6 id=\"显式副作用\"><a href=\"#显式副作用\" class=\"headerlink\" title=\"显式副作用\"></a>显式副作用</h6><p>直接对外部环境产生影响的代码：</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改全局变量</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">user</span> = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 操作 DOM</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = <span class=\"string\">&quot;red&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写入文件（Node.js）</span></span><br><span class=\"line\">fs.<span class=\"title function_\">writeFileSync</span>(<span class=\"string\">&quot;log.txt&quot;</span>, <span class=\"string\">&quot;数据已更新&quot;</span>);</span><br></pre></td></tr></table></figure></div>\n\n<h6 id=\"隐式副作用\"><a href=\"#隐式副作用\" class=\"headerlink\" title=\"隐式副作用\"></a>隐式副作用</h6><p>通过依赖外部状态间接产生副作用：</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 依赖外部变量（结果不可预测）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> base = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">impureAdd</span> = (<span class=\"params\">x</span>) =&gt; base + x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取用户输入（外部依赖）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = <span class=\"title function_\">prompt</span>(<span class=\"string\">&quot;请输入内容&quot;</span>);</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h5 id=\"副作用的影响\"><a href=\"#副作用的影响\" class=\"headerlink\" title=\"副作用的影响\"></a>副作用的影响</h5><h6 id=\"对代码优化的阻碍\"><a href=\"#对代码优化的阻碍\" class=\"headerlink\" title=\"对代码优化的阻碍\"></a>对代码优化的阻碍</h6><ul>\n<li>Tree Shaking失效：打包工具无法安全删除未使用的副作用代码：</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 即使未使用，以下代码也会被保留</span></span><br><span class=\"line\"><span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">customMethod</span> = <span class=\"function\">() =&gt;</span> &#123;&#125;; <span class=\"comment\">// 修改原型链</span></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>难以测试和调试：依赖外部状态的代码行为不可预测。</li>\n</ul>\n<h6 id=\"对函数式编程的挑战\"><a href=\"#对函数式编程的挑战\" class=\"headerlink\" title=\"对函数式编程的挑战\"></a>对函数式编程的挑战</h6><p>副作用违背引用透明性（同一输入始终返回同一输出），例如：</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ❌ 非引用透明（依赖 Date 外部状态）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">getTime</span> = (<span class=\"params\"></span>) =&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">toISOString</span>();</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h5 id=\"如何管理副作用\"><a href=\"#如何管理副作用\" class=\"headerlink\" title=\"如何管理副作用\"></a>如何管理副作用</h5><h6 id=\"隔离副作用\"><a href=\"#隔离副作用\" class=\"headerlink\" title=\"隔离副作用\"></a>隔离副作用</h6><p>将副作用代码集中管理，与纯逻辑分离：</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 纯函数（核心逻辑）</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">calculateTotal</span>(<span class=\"params\">items</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> items.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">sum, item</span>) =&gt;</span> sum + item.<span class=\"property\">price</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 副作用集中处理</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">renderTotal</span>(<span class=\"params\">total</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;total&quot;</span>).<span class=\"property\">textContent</span> = <span class=\"string\">`$<span class=\"subst\">$&#123;total&#125;</span>`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 组合使用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> items = [&#123; <span class=\"attr\">price</span>: <span class=\"number\">10</span> &#125;, &#123; <span class=\"attr\">price</span>: <span class=\"number\">20</span> &#125;];</span><br><span class=\"line\"><span class=\"title function_\">renderTotal</span>(<span class=\"title function_\">calculateTotal</span>(items));</span><br></pre></td></tr></table></figure></div>\n\n<h6 id=\"显式标记副作用\"><a href=\"#显式标记副作用\" class=\"headerlink\" title=\"显式标记副作用\"></a>显式标记副作用</h6><p>通过 <code>package.json</code> 声明模块的副作用，帮助打包工具优化：</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;sideEffects&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;**/*.css&quot;</span>,  <span class=\"comment\">// CSS 文件有副作用（注入样式）</span></span><br><span class=\"line\">    <span class=\"string\">&quot;src/polyfills.js&quot;</span> <span class=\"comment\">//  polyfill 修改全局对象</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h6 id=\"使用函数式编程技术\"><a href=\"#使用函数式编程技术\" class=\"headerlink\" title=\"使用函数式编程技术\"></a>使用函数式编程技术</h6><ul>\n<li>不可变数据：避免直接修改对象&#x2F;数组（使用 <code>...</code> 或 <code>Object.assign</code>）。</li>\n<li>副作用延迟执行：如 React 的 <code>useEffect</code>、Redux 的中间件。</li>\n</ul>\n<h4 id=\"静态分析（Static-Analysis）\"><a href=\"#静态分析（Static-Analysis）\" class=\"headerlink\" title=\"静态分析（Static Analysis）\"></a>静态分析（Static Analysis）</h4><p>静态分析是指在不实际运行代码的情况下，通过分析源代码或编译后的中间表示（如 AST）来检查代码的结构、语法、依赖关系以及潜在问题的一种技术。它在编程语言、编译器、安全分析和开发工具中广泛应用。</p>\n<h5 id=\"静态分析的核心概念\"><a href=\"#静态分析的核心概念\" class=\"headerlink\" title=\"静态分析的核心概念\"></a>静态分析的核心概念</h5><h6 id=\"1-1-静态分析-vs-动态分析\"><a href=\"#1-1-静态分析-vs-动态分析\" class=\"headerlink\" title=\"1.1 静态分析 vs 动态分析\"></a>1.1 静态分析 vs 动态分析</h6><table>\n<thead>\n<tr>\n<th><strong>特性</strong>****</th>\n<th><strong>静态分析</strong></th>\n<th><strong>动态分析</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>执行时机</strong></td>\n<td>代码运行前（编译时&#x2F;构建时）</td>\n<td>代码运行时</td>\n</tr>\n<tr>\n<td><strong>输入数据</strong></td>\n<td>源代码、AST、字节码等静态结构</td>\n<td>程序运行时的内存、I&#x2F;O、状态等</td>\n</tr>\n<tr>\n<td><strong>典型工具</strong></td>\n<td>ESLint、TypeScript、Flow、SonarQube</td>\n<td>Chrome DevTools、Valgrind、Fuzz 测试</td>\n</tr>\n<tr>\n<td><strong>优势</strong></td>\n<td>提前发现问题，不影响运行时性能</td>\n<td>捕捉运行时行为（如内存泄漏）</td>\n</tr>\n<tr>\n<td><strong>局限性</strong></td>\n<td>无法分析动态行为（如 <code>eval</code>）</td>\n<td>需要实际运行，可能漏检某些路径</td>\n</tr>\n</tbody></table>\n<h6 id=\"1-2-静态分析的主要目标\"><a href=\"#1-2-静态分析的主要目标\" class=\"headerlink\" title=\"1.2 静态分析的主要目标\"></a>1.2 静态分析的主要目标</h6><ul>\n<li>代码质量检查（如未使用的变量、代码风格）</li>\n<li>安全漏洞检测（如 SQL 注入、XSS）</li>\n<li>性能优化（如 Dead Code Elimination）</li>\n<li>依赖分析（如 Tree Shaking）</li>\n<li>类型检查（如 TypeScript）</li>\n</ul>\n<h5 id=\"静态分析的关键技术\"><a href=\"#静态分析的关键技术\" class=\"headerlink\" title=\"静态分析的关键技术\"></a>静态分析的关键技术</h5><h6 id=\"2-1-抽象语法树（AST）\"><a href=\"#2-1-抽象语法树（AST）\" class=\"headerlink\" title=\"2.1 抽象语法树（AST）\"></a>2.1 抽象语法树（AST）</h6><p>静态分析的核心数据结构，将代码转换为树状结构，便于工具分析</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例代码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">sum</span> = (<span class=\"params\">a, b</span>) =&gt; a + b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对应的AST（简化版）</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;Program&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">body</span>: [&#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&quot;VariableDeclaration&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">declarations</span>: [&#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"string\">&quot;VariableDeclarator&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">id</span>: &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;Identifier&quot;</span>, <span class=\"attr\">name</span>: <span class=\"string\">&quot;sum&quot;</span> &#125;,</span><br><span class=\"line\">      <span class=\"attr\">init</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">&quot;ArrowFunctionExpression&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">params</span>: [</span><br><span class=\"line\">          &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;Identifier&quot;</span>, <span class=\"attr\">name</span>: <span class=\"string\">&quot;a&quot;</span> &#125;,</span><br><span class=\"line\">          &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;Identifier&quot;</span>, <span class=\"attr\">name</span>: <span class=\"string\">&quot;b&quot;</span> &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        <span class=\"attr\">body</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">type</span>: <span class=\"string\">&quot;BinaryExpression&quot;</span>,</span><br><span class=\"line\">          <span class=\"attr\">operator</span>: <span class=\"string\">&quot;+&quot;</span>,</span><br><span class=\"line\">          <span class=\"attr\">left</span>: &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;Identifier&quot;</span>, <span class=\"attr\">name</span>: <span class=\"string\">&quot;a&quot;</span> &#125;,</span><br><span class=\"line\">          <span class=\"attr\">right</span>: &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;Identifier&quot;</span>, <span class=\"attr\">name</span>: <span class=\"string\">&quot;b&quot;</span> &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>工具：Babel、ESlint、Prettier均基于AST操作代码</p>\n<h6 id=\"2-2-数据流分析（Data-Flow-Analysis）\"><a href=\"#2-2-数据流分析（Data-Flow-Analysis）\" class=\"headerlink\" title=\"2.2 数据流分析（Data Flow Analysis）\"></a>2.2 数据流分析（Data Flow Analysis）</h6><p>跟踪变量和值的流动，用于检测：</p>\n<ul>\n<li>未初始化的变量</li>\n<li>不可达代码</li>\n<li>常量传播优化</li>\n</ul>\n<h6 id=\"2-3-控制流分析（Control-Flow-Analysis）\"><a href=\"#2-3-控制流分析（Control-Flow-Analysis）\" class=\"headerlink\" title=\"2.3 控制流分析（Control Flow Analysis）\"></a>2.3 控制流分析（Control Flow Analysis）</h6><ul>\n<li>检测无限循环</li>\n<li>识别异常处理遗漏</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">risky</span>(<span class=\"params\">x</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;ok&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 静态分析可警告：缺少 else 分支，可能返回 undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h6 id=\"2-4-类型检查（Type-Checking）\"><a href=\"#2-4-类型检查（Type-Checking）\" class=\"headerlink\" title=\"2.4 类型检查（Type Checking）\"></a>2.4 类型检查（Type Checking）</h6><p>在编译时验证类型一致性，如TypeScript的静态类型系统：</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">name: string</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`Hello, <span class=\"subst\">$&#123;name&#125;</span>`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"number\">42</span>); <span class=\"comment\">// 静态分析报错：类型不匹配</span></span><br></pre></td></tr></table></figure></div>\n\n","excerpt":"","more":"<p>概念：Webpack 是一种用于构建 JavaScript 应用程序的静态模块打包器，它能够以一种相对一致且开放的处理方式，加载应用中的所有资源文件（图片、CSS、视频、字体文件等），并将其合并打包成浏览器兼容的 Web 资源文件。</p>\n<p>功能：****</p>\n<ul>\n<li>模块的打包：通过打包整合不同的模块文件保证各模块之间的引用和执行</li>\n<li>代码编译：通过丰富的<code>**loader**</code>可以将不同格式文件如<code>**.sass/.vue/.jsx**</code>转译为浏览器可以执行的文件</li>\n<li>扩展功能：通过社区丰富的<code>**plugin**</code>可以实现多种强大的功能，例如<strong>代码分割、代码混淆、代码压缩、按需加载…..等等</strong></li>\n</ul>\n<h3 id=\"常见的loader及其作用\"><a href=\"#常见的loader及其作用\" class=\"headerlink\" title=\"常见的loader及其作用\"></a>常见的loader及其作用</h3><p><strong><font style=\"color:#1DC0C9;\">-babel-loader</font></strong>：将es6转译为es5</p>\n<p><strong><font style=\"color:#1DC0C9;\">-file-loader</font></strong>：可以指定要复制和放置资源文件的位置，以及如何使用版本哈希命名以获得更好的缓存，并在代码中通过<strong>URL</strong>去引用输出的文件</p>\n<p><strong><font style=\"color:#1DC0C9;\">-url-loader</font></strong>：和<code>**file-loader**</code>功能相似，但是可以通过指定阈值来根据文件大小使用不同的处理方式（小于阈值则返回base64格式编码并将文件的 <code>data-url</code>内联到<code>bundle</code>中）</p>\n<p><strong><font style=\"color:#1DC0C9;\">-raw-loader</font></strong>：加载文件原始内容</p>\n<blockquote>\n<p>webpack5自身内置了<code>**file-loader/ url-loader/ raw-loader**</code>等loader，所以我们不需要再显示引入loader 只需要指定对应的type即可实现相同的功能 如<code>**file-loader**</code>等价于 <code>**type= &quot;asset/resource&quot;**</code></p>\n</blockquote>\n<p><strong><font style=\"color:#1DC0C9;\">-image-webpack-loader</font></strong>： 加载并压缩图片资源</p>\n<p><strong><font style=\"color:#1DC0C9;\">-awesome-typescirpt-loader</font></strong>: 将typescript转换为javaScript 并且性能优于<code>**ts-loader**</code></p>\n<p><strong><font style=\"color:#1DC0C9;\">-sass-loader</font></strong>: 将SCSS&#x2F;SASS代码转换为CSS</p>\n<p><strong><font style=\"color:#1DC0C9;\">-css-loader</font></strong>: 加载CSS代码 支持模块化、压缩、文件导入等功能特性**</p>\n<p><strong><font style=\"color:#1DC0C9;\">-style-loader</font></strong>: 把CSS代码注入到js中，通过<code>DOM</code> 操作去加载CSS代码</p>\n<blockquote>\n<p>当我们使用类似于 <code>**less**</code> 或者 <code>**scss**</code> 等预处理器的时候，通常需要多个 <strong>loader</strong> 的配合使用如<code>**test: /\\.less$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]**</code></p>\n</blockquote>\n<p><strong><font style=\"color:#1DC0C9;\">-source-map-loader</font></strong>: 加载额外的<code>Source Map</code>文件</p>\n<p><strong><font style=\"color:#1DC0C9;\">-eslint-loader</font></strong>: 通过ESlint 检查js代码</p>\n<p><strong><font style=\"color:#1DC0C9;\">-cache-loader</font></strong>: 可以在一些开销较大的<code>Loader</code>之前添加可以将结果缓存到磁盘中，提高构建的效率</p>\n<p><strong><font style=\"color:#1DC0C9;\">-thread-loader</font></strong>: 多线程打包，加快打包速度</p>\n<h3 id=\"常见的plugin及其作用\"><a href=\"#常见的plugin及其作用\" class=\"headerlink\" title=\"常见的plugin及其作用\"></a>常见的plugin及其作用</h3><p><strong><font style=\"color:#1DC0C9;\">-splitChunkPlugin</font></strong>: 定义环境变量（webpack4之后可以通过指定<code>**mode：production/development**</code>实现同样效果）</p>\n<p><strong><font style=\"color:#1DC0C9;\">-define-plugin</font></strong>: 定义环境变量（webpack4之后可以通过指定<code>**mode：production/development**</code>实现同样效果）</p>\n<p><strong><font style=\"color:#1DC0C9;\">-web-webpack-plugin</font></strong>：为单页面应用输出HTML 性能优于<code>html-webpack-plugin</code></p>\n<p><strong><font style=\"color:#1DC0C9;\">-clean-webpack-plugin</font></strong>: 每次打包时删除上次打包的产物, 保证打包目录下的文件都是最新的</p>\n<p><strong><font style=\"color:#1DC0C9;\">-webpack-merge</font></strong>： 用来合并公共配置文件,常用（例如分别配置<code>webpack.common.config.js/ webpack.dev.config.js/webpack.production.config.js</code>并将其合并）</p>\n<p><strong><font style=\"color:#1DC0C9;\">-ignore-plugin</font></strong>: 忽略指定的文件，可以加快构建速度</p>\n<p><strong><font style=\"color:#1DC0C9;\">-terser-webpack-plugin</font></strong>：压缩ES6的代码（tree-shaking）</p>\n<p><strong><font style=\"color:#1DC0C9;\">-uglifyjs-webpack-plugin</font></strong>: 压缩js代码</p>\n<p><strong><font style=\"color:#1DC0C9;\">-mini-css-extract-plugin</font></strong>: 将CSS提取为独立文件，支持按需加载x</p>\n<p><strong><font style=\"color:#1DC0C9;\">-css-minimize-webpack-plugin</font></strong>：压缩CSS代码</p>\n<blockquote>\n<p>css文件的压缩需要<code>**mini-css-extract-plugin**</code>和<code>**css-minimize-webpack-plugin** </code>的配合使用 即先使用<code>**mini-css-extract-plugin**</code>将css代码抽离成单独文件，之后使用<code> **css-minimize-webpack-plugin**</code>对css代码进行压缩</p>\n</blockquote>\n<p><strong><font style=\"color:#1DC0C9;\">-serviceworker-webpack-plugin</font></strong>: 为离线应用增加离线缓存功能</p>\n<p><strong><font style=\"color:#1DC0C9;\">-ModuleconcatenationPlugin</font></strong>: 开启<code>**Scope Hositing**</code> 用于合并提升作用域， 减小代码体积</p>\n<p><strong><font style=\"color:#1DC0C9;\">-copy-webpack-plugin</font></strong>： 在构建的时候，复制静态资源到打包目录。</p>\n<p><strong><font style=\"color:#1DC0C9;\">-compression-webpack-plugin</font></strong>: 生产环境采用<code>**gzip**</code>压缩JS和CSS</p>\n<p><strong><font style=\"color:#1DC0C9;\">-ParalleUglifyPlugin</font></strong>： 多进程并行压缩js</p>\n<p><strong><font style=\"color:#1DC0C9;\">-webpack-bundle-analyzer</font></strong>: 可视化webpack输出文件大小的根据</p>\n<p><strong><font style=\"color:#1DC0C9;\">-speed-measure-webpack-plugin</font></strong>: 用于分析各个loader和plugin的耗时，可用于性能分析</p>\n<p><strong><font style=\"color:#1DC0C9;\">-webpack-dashboard</font></strong>: 可以更友好地展示打包相关信息</p>\n<p><strong><font style=\"color:#1DC0C9;\">-Webpack Analysis</font></strong>：webpack 官方提供的可视化分析工具</p>\n<p><strong><font style=\"color:#1DC0C9;\">-BundleAnalyzerPlugin</font></strong>：性能分析插件，可以在运行后查看是否包含重复模块&#x2F;不必要模块等</p>\n<h3 id=\"loader和plugin的区别\"><a href=\"#loader和plugin的区别\" class=\"headerlink\" title=\"loader和plugin的区别\"></a>loader和plugin的区别</h3><p><strong><font style=\"color:#1DC0C9;\">Loader：</font></strong></p>\n<p>Loader本质上是一个函数，负责代码的转译，即对接收到的内容进行转换后将转换后的结果返回 ，因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。</p>\n<p>配置Loader通过在 **module.rules **中以数组的形式配置，每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。</p>\n<p><strong><font style=\"color:#1DC0C9;\">Plugin：</font></strong></p>\n<p>Plugin可以扩展 Webpack 的功能，本质上是一个带有 <strong>apply(compiler)</strong> 的函数，基于 <a class=\"link\"   href=\"https://link.juejin.cn/?target=https://www.npmjs.com/package/tapable\" >tapable<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 这个事件流框架来监听<strong>webpack</strong>构建&#x2F;打包过程中发布的hooks来通过自定义的逻辑和功能来改变输出结果。 </p>\n<p>Plugin通过 <strong>plugins</strong> 以数组的形式配置，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</p>\n<p><strong>总结：</strong></p>\n<p><strong>Loader <strong>主要负责将代码转译为</strong>webpack</strong>可以处理的JavaScript代码，而 <strong>Plugin</strong> 更多的是负责通过接入<strong>webpack</strong>构建过程来影响构建过程以及产物的输出，<strong>Loader</strong>的职责相对比较<strong>单一</strong>简单，而 **Plugin **更为丰富多样。</p>\n<h3 id=\"loader执行顺序\"><a href=\"#loader执行顺序\" class=\"headerlink\" title=\"loader执行顺序\"></a>loader执行顺序</h3><h5 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h5><pre><code>- **&lt;font style=&quot;color:#1DC0C9;&quot;&gt;pre&lt;/font&gt;**：前置loader 用法：**module.rules** 中 **enforce** 属性指定\n- **&lt;font style=&quot;color:#1DC0C9;&quot;&gt;normal&lt;/font&gt;**：普通loader 用法：**module.rules** 中 **enforce** 属性指定\n- **&lt;font style=&quot;color:#1DC0C9;&quot;&gt;inline&lt;/font&gt;**：内联loader（不建议使用）用法：在import语句中显示指定loader 举例：`import Styles from &#39;style-loader|css-loader?modules!./styles.css&#39;;` 含义：用 css-loader 和 style-loader 处理 styles.css 文件，通过 ! 将资源中的loader分开\n- **&lt;font style=&quot;color:#1DC0C9;&quot;&gt;post&lt;/font&gt;**：后置loader 用法：**module.rules** 中 **enforce** 属性指定\n</code></pre>\n<h5 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h5><pre><code>- 4类loader的执行顺序：`pre &gt; normal &gt; inline &gt; post`\n- 相同优先级的loader执行顺序：`从右到左，从下到上`\n</code></pre>\n<h5 id=\"pitching-loader\"><a href=\"#pitching-loader\" class=\"headerlink\" title=\"pitching loader\"></a>pitching loader</h5><pre><code>- loader 上的 **&lt;font style=&quot;color:#1DC0C9;&quot;&gt;pitch&lt;/font&gt;** 方法\n</code></pre>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = <span class=\"keyword\">function</span> (<span class=\"params\">content</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span>.<span class=\"property\">pitch</span> = <span class=\"keyword\">function</span> (<span class=\"params\">remainingRequest, precedingRequest, data</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;do somethings&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<pre><code>- webpack 会先从左到右执行 loader 链中的每个 loader 上的 pitch 方法（如果有），然后再从右到左执行 loader 链中的每个 loader 上的普通 loader 方法\n</code></pre>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/pitching_loader_1.png\"\n                      alt=\"pitching_loader_1\"\n                ></p>\n<pre><code>- 在这个过程中如果任何 pitch 有返回值，则 loader 链被阻断。webpack 会跳过后面所有的的 pitch 和 loader，直接进入上一个 loader \n</code></pre>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/pitching_loader_2.png\"\n                      alt=\"pitching_loader_2\"\n                ></p>\n<h3 id=\"webpack构建流程\"><a href=\"#webpack构建流程\" class=\"headerlink\" title=\"webpack构建流程\"></a>webpack构建流程</h3><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p>\n<ul>\n<li><strong><font style=\"color:#1DC0C9;\">初始化参数</font></strong>：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数</li>\n<li><strong><font style=\"color:#1DC0C9;\">开始编译</font></strong>：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译</li>\n<li><strong><font style=\"color:#1DC0C9;\">确定入口</font></strong>：根据配置中的 entry 找出所有的入口文件</li>\n<li><strong><font style=\"color:#1DC0C9;\">编译模块</font></strong>：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理</li>\n<li><strong><font style=\"color:#1DC0C9;\">完成模块编译</font></strong>：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系</li>\n<li><strong><font style=\"color:#1DC0C9;\">输出资源</font></strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>\n<li><strong><font style=\"color:#1DC0C9;\">输出完成</font></strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li>\n</ul>\n<p>在以上过程中，<code>Webpack</code> 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p>\n<p>简单说</p>\n<ul>\n<li><strong><font style=\"color:#1DC0C9;\">初始化</font></strong>：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler</li>\n<li><strong><font style=\"color:#1DC0C9;\">编译</font></strong>：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理</li>\n<li><strong><font style=\"color:#1DC0C9;\">输出</font></strong>：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中</li>\n</ul>\n<h3 id=\"文件指纹\"><a href=\"#文件指纹\" class=\"headerlink\" title=\"文件指纹\"></a>文件指纹</h3><p>概念：文件指纹是打包后输出的文件名的后缀</p>\n<h5 id=\"种类：\"><a href=\"#种类：\" class=\"headerlink\" title=\"种类：\"></a>种类：</h5><ul>\n<li><strong><font style=\"background-color:rgba(222,253,255,1);\"> Hash </font></strong>：和整个项目的构建相关，只要项目文件有修改（**<font style=\"background-color:rgba(222,253,255,1);\"> compilation </font>**实例改变），整个项目构建的 Hash 值就会更改</li>\n<li><strong><font style=\"background-color:rgba(222,253,255,1);\"> Chunkhash </font></strong>：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash，（不同 Chunkhash 之间的变化互不影响）</li>\n<li><font style=\"background-color:rgba(222,253,255,1);\"> </font><strong><font style=\"background-color:rgba(222,253,255,1);\">Contenthash</font></strong><font style=\"background-color:rgba(222,253,255,1);\"> </font>：根据文件内容来定义 hash，文件内容不变，则 Contenthash 不变</li>\n</ul>\n<h5 id=\"使用：\"><a href=\"#使用：\" class=\"headerlink\" title=\"使用：\"></a>使用：</h5><ul>\n<li>JS文件：使用 <strong><font style=\"background-color:rgba(222,253,255,1);\"> Chunkhash </font></strong></li>\n<li>CSS文件：使用 <font style=\"background-color:rgba(222,253,255,1);\"> </font><strong><font style=\"background-color:rgba(222,253,255,1);\">Contenthash</font></strong><font style=\"background-color:rgba(222,253,255,1);\"> </font></li>\n<li>图片等静态资源： 使用 <strong><font style=\"background-color:rgba(222,253,255,1);\"> Hash </font></strong></li>\n</ul>\n<blockquote>\n<p>生产环境的output为了区分版本变动，通过**<font style=\"background-color:rgba(222,253,255,1);\"> Contenthash </font><strong>来达到清理缓存及时更新的效果，而开发环境中为了加快构建效率，一般不引入</strong><font style=\"background-color:rgba(222,253,255,1);\"> Contenthash </font>**</p>\n</blockquote>\n<h5 id=\"JS的文件指纹设置\"><a href=\"#JS的文件指纹设置\" class=\"headerlink\" title=\"JS的文件指纹设置\"></a>JS的文件指纹设置</h5><p>设置 output 的 filename，用 chunkhash</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;   </span><br><span class=\"line\">  <span class=\"attr\">entry</span>: &#123;        </span><br><span class=\"line\">    <span class=\"attr\">app</span>: <span class=\"string\">&#x27;./scr/app.js&#x27;</span>,        </span><br><span class=\"line\">    <span class=\"attr\">search</span>: <span class=\"string\">&#x27;./src/search.js&#x27;</span>    </span><br><span class=\"line\">  &#125;,    </span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;        </span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;[name][chunkhash:8].js&#x27;</span>, <span class=\"comment\">// chunkhash:8 保留8位    </span></span><br><span class=\"line\">    <span class=\"attr\">path</span>:__dirname + <span class=\"string\">&#x27;/dist&#x27;</span>    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"CSS的文件指纹设置\"><a href=\"#CSS的文件指纹设置\" class=\"headerlink\" title=\"CSS的文件指纹设置\"></a>CSS的文件指纹设置</h5><p>设置 MiniCssExtractPlugin 的 filename，用 contenthash</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;    </span><br><span class=\"line\">  <span class=\"attr\">entry</span>: &#123;        </span><br><span class=\"line\">    <span class=\"attr\">app</span>: <span class=\"string\">&#x27;./scr/app.js&#x27;</span>,        </span><br><span class=\"line\">    <span class=\"attr\">search</span>: <span class=\"string\">&#x27;./src/search.js&#x27;</span>   </span><br><span class=\"line\">  &#125;,    </span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;        </span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;[name][chunkhash:8].js&#x27;</span>,        </span><br><span class=\"line\">    <span class=\"attr\">path</span>:__dirname + <span class=\"string\">&#x27;/dist&#x27;</span>   </span><br><span class=\"line\">  &#125;,    </span><br><span class=\"line\">  <span class=\"attr\">plugins</span>:[        </span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">MiniCssExtractPlugin</span>(&#123;            </span><br><span class=\"line\">      <span class=\"attr\">filename</span>: <span class=\"string\">`[name][contenthash:8].css`</span>        &#125;)   </span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h5 id=\"图片的文件指纹设置\"><a href=\"#图片的文件指纹设置\" class=\"headerlink\" title=\"图片的文件指纹设置\"></a>图片的文件指纹设置</h5><p>设置 file-loader 的 filename，用 hash，<strong>webpack5后内置file-loader&#x2F;url-loader&#x2F;raw-loader，配置assets属性即可，无需再引入loader</strong></p>\n<p>占位符名称及含义</p>\n<ul>\n<li>ext 资源后缀名</li>\n<li>name 文件名称</li>\n<li>path 文件的相对路径</li>\n<li>folder 文件所在的文件夹</li>\n<li>contenthash 文件的内容hash，默认是md5生成</li>\n<li>hash 文件内容的hash，默认是md5生成</li>\n<li>emoji 一个随机的指代文件内容的emoj</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;    </span><br><span class=\"line\">  <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;./src/index.js&#x27;</span>,    </span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;        </span><br><span class=\"line\">    <span class=\"attr\">filename</span>:<span class=\"string\">&#x27;bundle.js&#x27;</span>,        </span><br><span class=\"line\">    <span class=\"attr\">path</span>:path.<span class=\"title function_\">resolve</span>(__dirname, <span class=\"string\">&#x27;dist&#x27;</span>)   </span><br><span class=\"line\">  &#125;,    </span><br><span class=\"line\">  <span class=\"attr\">module</span>:&#123;        </span><br><span class=\"line\">    <span class=\"attr\">rules</span>:[&#123;            </span><br><span class=\"line\">      <span class=\"attr\">test</span>:<span class=\"regexp\">/\\.(png|svg|jpg|gif)$/</span>,            </span><br><span class=\"line\">      <span class=\"attr\">use</span>:[&#123;                </span><br><span class=\"line\">        <span class=\"attr\">loader</span>:<span class=\"string\">&#x27;file-loader&#x27;</span>,                </span><br><span class=\"line\">        <span class=\"attr\">options</span>:&#123;                    </span><br><span class=\"line\">          <span class=\"attr\">name</span>:<span class=\"string\">&#x27;img/[name][hash:8].[ext]&#x27;</span>               </span><br><span class=\"line\">        &#125;           </span><br><span class=\"line\">      &#125;]       </span><br><span class=\"line\">    &#125;]   </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// webpack5配置参考如下：</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// rules:[</span></span><br><span class=\"line\"><span class=\"comment\">//   &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         test: /\\.(png|jpe?g|gif|webp|svg)$/,</span></span><br><span class=\"line\"><span class=\"comment\">//         type: &#x27;asset&#x27;,</span></span><br><span class=\"line\"><span class=\"comment\">//         parser: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//           dataUrlCondition: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//             // 小于10kb的图片转base64</span></span><br><span class=\"line\"><span class=\"comment\">//             // 优点：减少请求数量  缺点：体积会更大</span></span><br><span class=\"line\"><span class=\"comment\">//             maxSize: 10 * 1024 // 10kb </span></span><br><span class=\"line\"><span class=\"comment\">//           &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//         generator: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//           // 输出图片名称</span></span><br><span class=\"line\"><span class=\"comment\">//           // [hash:10] hash值取前10位</span></span><br><span class=\"line\"><span class=\"comment\">//           filename: &#x27;static/images/[hash:10][ext][query]&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//       &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//   &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//         test: /\\.(ttf|woff2?|mp3|mp4|avi)$/,</span></span><br><span class=\"line\"><span class=\"comment\">//         type: &#x27;asset/resource&#x27;,</span></span><br><span class=\"line\"><span class=\"comment\">//         generator: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//           // 输出名称</span></span><br><span class=\"line\"><span class=\"comment\">//           // [hash:10] hash值取前10位</span></span><br><span class=\"line\"><span class=\"comment\">//           filename: &#x27;static/media/[hash:10][ext][query]&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">//         &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//       &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">// ]</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Babel的原理\"><a href=\"#Babel的原理\" class=\"headerlink\" title=\"Babel的原理\"></a>Babel的原理</h3><p>概述：大多数JavaScript Parser遵循 <strong>estree</strong> 规范，Babel 最初基于 <strong>acorn</strong> 项目(轻量级现代 JavaScript 解析器) 。</p>\n<p><strong>babel</strong> 可以将代码转译为想要的目标代码，并且对目标环境不支持的<strong>api</strong> 自动 <strong><font style=\"background-color:rgba(222,253,255,1);\"> polyfill </font></strong> 。而 **babel **实现这些功能的流程是 <strong><font style=\"background-color:rgba(222,253,255,1);\"> 解析（parse）-转换（transfrom）-生成（generator）</font></strong> </p>\n<ul>\n<li><strong><font style=\"background-color:rgba(77, 208, 225, 0.08);\">解析</font></strong>：根据代码生成对应的 <strong>AST</strong> 结构<ul>\n<li>词法分析：将代码(字符串)分割为 <strong>token</strong> 流，即语法单元成的数组</li>\n<li>语法分析：分析 **token **流(上面生成的数组)并生成 AST</li>\n</ul>\n</li>\n<li><strong><font style=\"background-color:rgba(77, 208, 225, 0.08);\">转换</font></strong>：遍历 <strong>AST</strong> 节点并生成新的 <strong>AST</strong> 节点</li>\n<li><strong><font style=\"background-color:rgba(77, 208, 225, 0.08);\">生成</font></strong>：根据新的 <strong>AST</strong> 生成目标代码</li>\n</ul>\n<h3 id=\"文件监听原理\"><a href=\"#文件监听原理\" class=\"headerlink\" title=\"文件监听原理\"></a>文件监听原理</h3><p>在发现源码发生变化时，自动重新构建出新的输出文件</p>\n<p>Webpack开启监听模式，有两种方式：</p>\n<ul>\n<li>启动 webpack 命令时，带上 –watch 参数</li>\n<li>在配置 webpack.config.js 中设置 watch:true</li>\n</ul>\n<p>缺点：每次需要手动刷新浏览器</p>\n<p>原理：轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 <strong>aggregateTimeout</strong> 后再统一执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">watch</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 默认false，也就是不开启，只有开启监听模式时，watchOptions才有意义</span></span><br><span class=\"line\"><span class=\"attr\">watchOptions</span>: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不监听的文件或者文件夹，忽略一些大型的不经常变化的文件可以提高构建速度，支持正则匹配</span></span><br><span class=\"line\">    <span class=\"attr\">ignored</span>: <span class=\"regexp\">/node_modules/</span>,</span><br><span class=\"line\">    <span class=\"comment\">//监听到变化会等多少时间再执行，默认300ms</span></span><br><span class=\"line\">    <span class=\"attr\">aggregateTimeout</span>: <span class=\"number\">300</span>,</span><br><span class=\"line\">    <span class=\"comment\">//判断文件是否发生变化是通过不断轮询指定文件有没有变化实现的，默认每秒问1000次</span></span><br><span class=\"line\">    <span class=\"attr\">poll</span>: <span class=\"number\">1000</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"热更新原理\"><a href=\"#热更新原理\" class=\"headerlink\" title=\"热更新原理\"></a>热更新原理</h3><p>参考链接：<a class=\"link\"   href=\"https://juejin.cn/post/6844904008432222215?searchId=20250725014743FA245E0AE4142AA9178D\" >轻松理解webpack热更新原理<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> <a class=\"link\"   href=\"https://juejin.cn/post/6844904020528594957?searchId=20250725014743FA245E0AE4142AA9178D\" >从零实现webpack热更新HMR<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p>视频讲解：<a class=\"link\"   href=\"https://www.bilibili.com/video/BV1To4y1f7Wo?spm_id_from=333.788.player.player_end_recommend&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89\" >Webpack 热更新原理与实战<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p>概述：模块热替换（Hot Module Replacement，HMR）是 webpack 提供的最有用的功能之一。当我们<strong>对代码修改并保存后，webpack将会对代码进行新的打包，并将新的模块发送到浏览器端，浏览器用新的模块替换掉旧的模块</strong>，以实现在不刷新浏览器的前提下更新页面。</p>\n<p>刷新我们一般分为两种：</p>\n<ul>\n<li>一种是页面刷新，不保留页面状态，就是简单粗暴，直接 <strong><font style=\"background-color:#FBE4E7;\">window.reload()</font></strong></li>\n<li>另一种是基于 **<font style=\"background-color:#FBE4E7;\">WDS（Wepack-dev-server）</font>**的模块热替换，只需要局部刷新页面上发生变化的模块，同时可以保留当前的页面状态，比如复选框的选中状态、输入框的输入等。</li>\n</ul>\n<h5 id=\"整体工作流程\"><a href=\"#整体工作流程\" class=\"headerlink\" title=\"整体工作流程\"></a>整体工作流程</h5><ol>\n<li>文件修改：开发者保存修改后的文件</li>\n<li>Webpack 重新编译：生成新的模块代码和补丁（patch）</li>\n<li>通知客户端：通过 websocket 向浏览器发送更新消息</li>\n<li>客户端应用更新：获取新模块并替换旧模块</li>\n<li>模块热替换：仅更新变化的模块，保持应用状态</li>\n</ol>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/pic_HMR.png\"\n                      alt=\"pic_HMR\"\n                ></p>\n<p>详细解析图如下（含源码指导版）：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/%E7%83%AD%E6%9B%B4%E6%96%B0.png\"\n                      alt=\"热更新\"\n                ></p>\n<h5 id=\"核心组成部分\"><a href=\"#核心组成部分\" class=\"headerlink\" title=\"核心组成部分\"></a>核心组成部分</h5><h6 id=\"2-1-Webpack-dev-server-或-webpack-dev-middleware\"><a href=\"#2-1-Webpack-dev-server-或-webpack-dev-middleware\" class=\"headerlink\" title=\"2.1 Webpack-dev-server (或 webpack-dev-middleware)\"></a>2.1 Webpack-dev-server (或 webpack-dev-middleware)</h6><ul>\n<li>启动一个 Express 服务器</li>\n<li>创建 websocket 服务（默认端口 8080）</li>\n<li>监听文件变化并触发重新编译</li>\n<li>通过 _webpack_hmr 端点与客户端通信</li>\n</ul>\n<h6 id=\"2-2-HMR-Runtime（客户端部分）\"><a href=\"#2-2-HMR-Runtime（客户端部分）\" class=\"headerlink\" title=\"2.2 HMR Runtime（客户端部分）\"></a>2.2 HMR Runtime（客户端部分）</h6><p>注入到 bundle 中的代码，负责：</p>\n<ul>\n<li>建立与 dev-server 的 websocket 连接</li>\n<li>接收更新通知</li>\n<li>发起 JSONP 请求获取更新模块</li>\n<li>执行模块替换逻辑</li>\n</ul>\n<h6 id=\"2-3-HMR-Plugin（服务端部分）\"><a href=\"#2-3-HMR-Plugin（服务端部分）\" class=\"headerlink\" title=\"2.3 HMR Plugin（服务端部分）\"></a>2.3 HMR Plugin（服务端部分）</h6><p>Webpack 内置的 HotModuleReplacementPlugin 负责：</p>\n<ul>\n<li>生成每个模块的 HMR 标识（hash）</li>\n<li>生成 manifest 文件（记录模块更新信息）</li>\n<li>生成 update 补丁文件（[oldHash].hot-update.json&#x2F;.js）</li>\n</ul>\n<h5 id=\"模块热更新策略\"><a href=\"#模块热更新策略\" class=\"headerlink\" title=\"模块热更新策略\"></a>模块热更新策略</h5><h6 id=\"3-1不同类型模块的处理\"><a href=\"#3-1不同类型模块的处理\" class=\"headerlink\" title=\"3.1不同类型模块的处理\"></a>3.1不同类型模块的处理</h6><ol>\n<li>普通 JS 模块：<ul>\n<li>直接替换模块导出对象</li>\n<li>需要手动编写 module.hot.accept 逻辑</li>\n</ul>\n</li>\n<li>样式模块（通过 style-loader）：<ul>\n<li>自动处理：新样式替换旧样式（无需页面刷新）</li>\n<li>实现原理：style-loader 会注入特殊的 HMR 代码</li>\n</ul>\n</li>\n<li>React&#x2F;Vue 组件：<ul>\n<li>需要框架特定的 HMR 支持</li>\n<li>React: 使用 react-hot-loader 或 React Refresh</li>\n<li>Vue: vue-loader 内置支持</li>\n</ul>\n</li>\n</ol>\n<h6 id=\"3-2更新传播机制\"><a href=\"#3-2更新传播机制\" class=\"headerlink\" title=\"3.2更新传播机制\"></a>3.2更新传播机制</h6><ul>\n<li>接受依赖：当模块 A 调用 module.hot.accept，表示它能够接受自身或依赖模块的更新</li>\n<li>冒泡更新：如果父模块不接受子模块更新，更新会向上冒泡直到找到接受者</li>\n<li>无接受者：如果没有模块接受更新，则 fallback 到整页刷新</li>\n</ul>\n<h3 id=\"代码分割\"><a href=\"#代码分割\" class=\"headerlink\" title=\"代码分割\"></a>代码分割</h3><p>参考文章：<a class=\"link\"   href=\"https://juejin.cn/post/6844904001792655373?searchId=202507231703353AC77072FBD359203430\" >webpack优化之玩转代码分割和公共代码提取<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p>概述：代码分割是 Webpack 的核心功能之一，它允许你将代码拆分成多个 bundle，然后可以按需加载或并行加载，从而优化应用性能。</p>\n<h5 id=\"为什么需要代码分割\"><a href=\"#为什么需要代码分割\" class=\"headerlink\" title=\"为什么需要代码分割\"></a>为什么需要代码分割</h5><ol>\n<li>减小初始加载体积：将应用拆分成多个 bundle，用户只需加载当前需要的代码</li>\n<li>提高加载速度：并行加载多个 bundle 比加载单个大文件更快</li>\n<li>缓存优化：将不常变动的代码单独打包，利用浏览器缓存</li>\n</ol>\n<h5 id=\"代码分割的三种主要方式\"><a href=\"#代码分割的三种主要方式\" class=\"headerlink\" title=\"代码分割的三种主要方式\"></a>代码分割的三种主要方式</h5><ol>\n<li>入口起点(Entry Points)</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">app</span>: <span class=\"string\">&#x27;./src/app.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">vendor</span>: <span class=\"string\">&#x27;./src/vendor.js&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;[name].bundle.js&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>缺点：如果多个入口共享模块，这些模块会被重复打包到各个 bundle 中(用SplitChunksPlugin解决)</p>\n<ol start=\"2\">\n<li>防止重复(SplitChunksPlugin)</li>\n</ol>\n<p>Webpack 4+ 内置了 SplitChunksPlugin，可以自动拆分公共依赖：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"attr\">optimization</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">splitChunks</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">chunks</span>: <span class=\"string\">&#x27;all&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">minSize</span>: <span class=\"number\">30000</span>, <span class=\"comment\">// 模块的最小体积</span></span><br><span class=\"line\">      <span class=\"attr\">minChunks</span>: <span class=\"number\">1</span>, <span class=\"comment\">// 模块的最小被引用次数</span></span><br><span class=\"line\">      <span class=\"attr\">cacheGroups</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">vendors</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">test</span>: <span class=\"regexp\">/[\\\\/]node_modules[\\\\/]/</span>,</span><br><span class=\"line\">          <span class=\"attr\">priority</span>: -<span class=\"number\">10</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">default</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">minChunks</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">          <span class=\"attr\">priority</span>: -<span class=\"number\">20</span>,</span><br><span class=\"line\">          <span class=\"attr\">reuseExistingChunk</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>动态导入(Dynamic Imports)</li>\n</ol>\n<p>使用 ES6 的 import() 语法或 Webpack 特定的 require.ensure：</p>\n<ol>\n<li>默认行为：单独打包</li>\n</ol>\n<p>当使用 import() 动态导入语法时：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 点击按钮时动态加载模块</span></span><br><span class=\"line\">button.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;./math.js&#x27;</span>).<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">math</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(math.<span class=\"title function_\">add</span>(<span class=\"number\">16</span>, <span class=\"number\">26</span>));</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<pre><code>- Webpack 会将 math.js 及其依赖打包成一个独立的 chunk（如 1.bundle.js）。\n- 运行时按需加载：只有当代码执行到 import() 时，浏览器才会发起网络请求加载这个 chunk。\n</code></pre>\n<ol start=\"2\">\n<li>控制打包名称（魔法注释）</li>\n</ol>\n<p>通过 webpackChunkName 注释可以自定义 chunk 名称：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackChunkName: &quot;math-lib&quot; */</span> <span class=\"string\">&#x27;./math.js&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<pre><code>- 生成的文件名会变成 math-lib.bundle.js 而非数字 ID。\n- 适合给重要模块命名，便于调试和长期缓存。\n</code></pre>\n<ol start=\"3\">\n<li>依赖关系处理<ul>\n<li>如果动态导入的模块 依赖其他模块，这些依赖会被 一起打包到同一个     chunk 中。</li>\n<li>如果多个动态导入的模块 共享依赖，Webpack 默认会 重复打包（除非通过 SplitChunksPlugin 优化）。</li>\n</ul>\n</li>\n</ol>\n<p>预获取&#x2F;预加载模块</p>\n<p>Webpack 4.6+ 支持使用魔法注释实现资源预加载：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackPrefetch: true */</span> <span class=\"string\">&#x27;./path/to/LoginModal.js&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">import</span>(<span class=\"comment\">/* webpackPreload: true */</span> <span class=\"string\">&#x27;./path/to/ChartComponent.js&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>prefetch：浏览器空闲时加载，用于未来可能需要的资源</li>\n<li>preload：与父 chunk 并行加载，用于当前导航可能需要的资源</li>\n</ul>\n<h5 id=\"代码分割最佳实践\"><a href=\"#代码分割最佳实践\" class=\"headerlink\" title=\"代码分割最佳实践\"></a>代码分割最佳实践</h5><ul>\n<li>按路由分割：为每个路由创建单独的 chunk</li>\n<li>提取公共依赖：将第三方库(vendor)和公共模块单独打包</li>\n<li>合理使用动态导入：对非关键功能使用懒加载</li>\n<li>监控 bundle 大小：使用 webpack-bundle-analyzer 分析包内容</li>\n</ul>\n<p>示例配置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"attr\">optimization</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">splitChunks</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">chunks</span>: <span class=\"string\">&#x27;all&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">maxSize</span>: <span class=\"number\">244</span> * <span class=\"number\">1024</span>, <span class=\"comment\">// 尝试将大于244KB的块拆分成更小的块</span></span><br><span class=\"line\">      <span class=\"attr\">cacheGroups</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">reactVendor</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">test</span>: <span class=\"regexp\">/[\\\\/]node_modules[\\\\/](react|react-dom)[\\\\/]/</span>,</span><br><span class=\"line\">          <span class=\"attr\">name</span>: <span class=\"string\">&#x27;react-vendor&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">chunks</span>: <span class=\"string\">&#x27;all&#x27;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"attr\">utilityVendor</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">test</span>: <span class=\"regexp\">/[\\\\/]node_modules[\\\\/](lodash|moment|axios)[\\\\/]/</span>,</span><br><span class=\"line\">          <span class=\"attr\">name</span>: <span class=\"string\">&#x27;utility-vendor&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">chunks</span>: <span class=\"string\">&#x27;all&#x27;</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"手写loaders和plugin\"><a href=\"#手写loaders和plugin\" class=\"headerlink\" title=\"手写loaders和plugin\"></a>手写loaders和plugin</h3><p>文档：文稿&#x2F;learning&#x2F;chl-learning&#x2F;webpack5&#x2F;kejian&#x2F;course&#x2F;webpack_docs</p>\n<p>代码：文稿&#x2F;learning&#x2F;chl-learning&#x2F;webpack5&#x2F;SOURCE</p>\n<p>学习视频：<a class=\"link\"   href=\"https://www.bilibili.com/video/BV14T4y1z7sw/?spm_id_from=333.788.videopod.episodes&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89&p=42\" >尚硅谷Webpack5入门到原理（面试开发一条龙<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<h3 id=\"tree-shaking\"><a href=\"#tree-shaking\" class=\"headerlink\" title=\"tree-shaking\"></a>tree-shaking</h3><p>参考链接：<a class=\"link\"   href=\"https://juejin.cn/post/7002410645316436004?searchId=2025080400284774D9A2A868649273E08D\" >Webpack 原理系列九：Tree-Shaking 实现原理<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p>概述：前端中的tree-shaking可以理解为通过工具”摇”我们的JS文件，将其中用不到的代码”摇”掉，是一个性能优化的范畴。具体来说，在 webpack 项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过 tree-shaking，将没有使用的模块摇掉，这样来达到删除无用代码的目的。</p>\n<p>支持tree-shaking的构建工具：</p>\n<ul>\n<li>Rollup（最早实现）</li>\n<li>Webpack</li>\n<li>Closure compiler（google的）</li>\n</ul>\n<h4 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h4><h5 id=\"依赖关系图分析\"><a href=\"#依赖关系图分析\" class=\"headerlink\" title=\"依赖关系图分析\"></a>依赖关系图分析</h5><p>打包工具会构建模块的依赖关系图，标记哪些导出被实际使用</p>\n<h5 id=\"静态分析阶段\"><a href=\"#静态分析阶段\" class=\"headerlink\" title=\"静态分析阶段\"></a>静态分析阶段</h5><ol>\n<li>识别导出：分析每个模块的 export 语句。</li>\n<li>追踪引用：从入口文件开始，追踪所有 import 的依赖链。</li>\n<li>标记失效代码：未被引用的导出标记为“可删除”。</li>\n</ol>\n<h5 id=\"删除阶段\"><a href=\"#删除阶段\" class=\"headerlink\" title=\"删除阶段\"></a>删除阶段</h5><p>通过压缩工具（如 Terser）移除标记为未使用的代码。</p>\n<h4 id=\"实现条件\"><a href=\"#实现条件\" class=\"headerlink\" title=\"实现条件\"></a>实现条件</h4><h5 id=\"1-必须使用ES-Module（ESM）\"><a href=\"#1-必须使用ES-Module（ESM）\" class=\"headerlink\" title=\"1.必须使用ES Module（ESM）\"></a>1.必须使用ES Module（ESM）</h5><ul>\n<li>Tree Shaking 依赖 ESM 的 静态结构（import&#x2F;export 必须在顶层声明）。</li>\n<li>CommonJS 无法被优化（require 是动态的，无法在编译时分析）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ✅ 可被 Tree Shaking（ESM）</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; usedFunc &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./utils&#x27;</span>;</span><br><span class=\"line\"><span class=\"title function_\">usedFunc</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ❌ 无法被 Tree Shaking（CommonJS）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> utils = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./utils&#x27;</span>);</span><br><span class=\"line\">utils.<span class=\"title function_\">usedFunc</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"2-避免副作用代码\"><a href=\"#2-避免副作用代码\" class=\"headerlink\" title=\"2.避免副作用代码\"></a>2.避免副作用代码</h5><ul>\n<li>工具会假设所有代码可能有副作用（如修改全局变量），除非显式声明。</li>\n<li>通过 package.json 的 sideEffects 字段标记无副作用的模块：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// package.json</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;sideEffects&quot;</span>: <span class=\"literal\">false</span>,  <span class=\"comment\">// 整个包无副作用</span></span><br><span class=\"line\">  <span class=\"string\">&quot;sideEffects&quot;</span>: [<span class=\"string\">&quot;*.css&quot;</span>]  <span class=\"comment\">// 仅 CSS 文件有副作用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"副作用代码（Side-Effects）\"><a href=\"#副作用代码（Side-Effects）\" class=\"headerlink\" title=\"副作用代码（Side Effects）\"></a>副作用代码（Side Effects）</h4><p>概述**：**副作用代码是指在执行时会对外部环境产生可观察影响的代码，这类代码不仅返回计算结果，还会修改外部状态或与系统交互。理解副作用对编写可维护、可优化的代码至关重要。</p>\n<h5 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h5><h6 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h6><ul>\n<li>纯函数（无副作用）：输出仅由输入决定，不修改外部状态（如数学函数 Math.sqrt(4)）。</li>\n<li>副作用代码：执行时会产生额外影响，例如：<ul>\n<li>修改全局变量</li>\n<li>操作 DOM</li>\n<li>发起网络请求</li>\n<li>读写文件&#x2F;数据库</li>\n<li>打印日志</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"示例对比\"><a href=\"#示例对比\" class=\"headerlink\" title=\"示例对比\"></a>示例对比</h6><table>\n<thead>\n<tr>\n<th><strong>无副作用</strong></th>\n<th><strong>有副作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>const sum = (a, b) =&gt; a + b</code></td>\n<td><code>let count = 0;</code>   <code>const add = () =&gt; &#123; count++ &#125;</code></td>\n</tr>\n<tr>\n<td><code>function capitalize(str) &#123; return str.toUpperCase() &#125;</code></td>\n<td><code>document.title = &quot;新标题&quot;</code></td>\n</tr>\n</tbody></table>\n<h5 id=\"副作用代码的类型\"><a href=\"#副作用代码的类型\" class=\"headerlink\" title=\"副作用代码的类型\"></a>副作用代码的类型</h5><h6 id=\"显式副作用\"><a href=\"#显式副作用\" class=\"headerlink\" title=\"显式副作用\"></a>显式副作用</h6><p>直接对外部环境产生影响的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改全局变量</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">user</span> = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 操作 DOM</span></span><br><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = <span class=\"string\">&quot;red&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写入文件（Node.js）</span></span><br><span class=\"line\">fs.<span class=\"title function_\">writeFileSync</span>(<span class=\"string\">&quot;log.txt&quot;</span>, <span class=\"string\">&quot;数据已更新&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"隐式副作用\"><a href=\"#隐式副作用\" class=\"headerlink\" title=\"隐式副作用\"></a>隐式副作用</h6><p>通过依赖外部状态间接产生副作用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 依赖外部变量（结果不可预测）</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> base = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">impureAdd</span> = (<span class=\"params\">x</span>) =&gt; base + x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取用户输入（外部依赖）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = <span class=\"title function_\">prompt</span>(<span class=\"string\">&quot;请输入内容&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"副作用的影响\"><a href=\"#副作用的影响\" class=\"headerlink\" title=\"副作用的影响\"></a>副作用的影响</h5><h6 id=\"对代码优化的阻碍\"><a href=\"#对代码优化的阻碍\" class=\"headerlink\" title=\"对代码优化的阻碍\"></a>对代码优化的阻碍</h6><ul>\n<li>Tree Shaking失效：打包工具无法安全删除未使用的副作用代码：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 即使未使用，以下代码也会被保留</span></span><br><span class=\"line\"><span class=\"title class_\">Array</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">customMethod</span> = <span class=\"function\">() =&gt;</span> &#123;&#125;; <span class=\"comment\">// 修改原型链</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>难以测试和调试：依赖外部状态的代码行为不可预测。</li>\n</ul>\n<h6 id=\"对函数式编程的挑战\"><a href=\"#对函数式编程的挑战\" class=\"headerlink\" title=\"对函数式编程的挑战\"></a>对函数式编程的挑战</h6><p>副作用违背引用透明性（同一输入始终返回同一输出），例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ❌ 非引用透明（依赖 Date 外部状态）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">getTime</span> = (<span class=\"params\"></span>) =&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>().<span class=\"title function_\">toISOString</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<h5 id=\"如何管理副作用\"><a href=\"#如何管理副作用\" class=\"headerlink\" title=\"如何管理副作用\"></a>如何管理副作用</h5><h6 id=\"隔离副作用\"><a href=\"#隔离副作用\" class=\"headerlink\" title=\"隔离副作用\"></a>隔离副作用</h6><p>将副作用代码集中管理，与纯逻辑分离：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 纯函数（核心逻辑）</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">calculateTotal</span>(<span class=\"params\">items</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> items.<span class=\"title function_\">reduce</span>(<span class=\"function\">(<span class=\"params\">sum, item</span>) =&gt;</span> sum + item.<span class=\"property\">price</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 副作用集中处理</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">renderTotal</span>(<span class=\"params\">total</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&quot;total&quot;</span>).<span class=\"property\">textContent</span> = <span class=\"string\">`$<span class=\"subst\">$&#123;total&#125;</span>`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 组合使用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> items = [&#123; <span class=\"attr\">price</span>: <span class=\"number\">10</span> &#125;, &#123; <span class=\"attr\">price</span>: <span class=\"number\">20</span> &#125;];</span><br><span class=\"line\"><span class=\"title function_\">renderTotal</span>(<span class=\"title function_\">calculateTotal</span>(items));</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"显式标记副作用\"><a href=\"#显式标记副作用\" class=\"headerlink\" title=\"显式标记副作用\"></a>显式标记副作用</h6><p>通过 <code>package.json</code> 声明模块的副作用，帮助打包工具优化：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;sideEffects&quot;</span>: [</span><br><span class=\"line\">    <span class=\"string\">&quot;**/*.css&quot;</span>,  <span class=\"comment\">// CSS 文件有副作用（注入样式）</span></span><br><span class=\"line\">    <span class=\"string\">&quot;src/polyfills.js&quot;</span> <span class=\"comment\">//  polyfill 修改全局对象</span></span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"使用函数式编程技术\"><a href=\"#使用函数式编程技术\" class=\"headerlink\" title=\"使用函数式编程技术\"></a>使用函数式编程技术</h6><ul>\n<li>不可变数据：避免直接修改对象&#x2F;数组（使用 <code>...</code> 或 <code>Object.assign</code>）。</li>\n<li>副作用延迟执行：如 React 的 <code>useEffect</code>、Redux 的中间件。</li>\n</ul>\n<h4 id=\"静态分析（Static-Analysis）\"><a href=\"#静态分析（Static-Analysis）\" class=\"headerlink\" title=\"静态分析（Static Analysis）\"></a>静态分析（Static Analysis）</h4><p>静态分析是指在不实际运行代码的情况下，通过分析源代码或编译后的中间表示（如 AST）来检查代码的结构、语法、依赖关系以及潜在问题的一种技术。它在编程语言、编译器、安全分析和开发工具中广泛应用。</p>\n<h5 id=\"静态分析的核心概念\"><a href=\"#静态分析的核心概念\" class=\"headerlink\" title=\"静态分析的核心概念\"></a>静态分析的核心概念</h5><h6 id=\"1-1-静态分析-vs-动态分析\"><a href=\"#1-1-静态分析-vs-动态分析\" class=\"headerlink\" title=\"1.1 静态分析 vs 动态分析\"></a>1.1 静态分析 vs 动态分析</h6><table>\n<thead>\n<tr>\n<th><strong>特性</strong>****</th>\n<th><strong>静态分析</strong></th>\n<th><strong>动态分析</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>执行时机</strong></td>\n<td>代码运行前（编译时&#x2F;构建时）</td>\n<td>代码运行时</td>\n</tr>\n<tr>\n<td><strong>输入数据</strong></td>\n<td>源代码、AST、字节码等静态结构</td>\n<td>程序运行时的内存、I&#x2F;O、状态等</td>\n</tr>\n<tr>\n<td><strong>典型工具</strong></td>\n<td>ESLint、TypeScript、Flow、SonarQube</td>\n<td>Chrome DevTools、Valgrind、Fuzz 测试</td>\n</tr>\n<tr>\n<td><strong>优势</strong></td>\n<td>提前发现问题，不影响运行时性能</td>\n<td>捕捉运行时行为（如内存泄漏）</td>\n</tr>\n<tr>\n<td><strong>局限性</strong></td>\n<td>无法分析动态行为（如 <code>eval</code>）</td>\n<td>需要实际运行，可能漏检某些路径</td>\n</tr>\n</tbody></table>\n<h6 id=\"1-2-静态分析的主要目标\"><a href=\"#1-2-静态分析的主要目标\" class=\"headerlink\" title=\"1.2 静态分析的主要目标\"></a>1.2 静态分析的主要目标</h6><ul>\n<li>代码质量检查（如未使用的变量、代码风格）</li>\n<li>安全漏洞检测（如 SQL 注入、XSS）</li>\n<li>性能优化（如 Dead Code Elimination）</li>\n<li>依赖分析（如 Tree Shaking）</li>\n<li>类型检查（如 TypeScript）</li>\n</ul>\n<h5 id=\"静态分析的关键技术\"><a href=\"#静态分析的关键技术\" class=\"headerlink\" title=\"静态分析的关键技术\"></a>静态分析的关键技术</h5><h6 id=\"2-1-抽象语法树（AST）\"><a href=\"#2-1-抽象语法树（AST）\" class=\"headerlink\" title=\"2.1 抽象语法树（AST）\"></a>2.1 抽象语法树（AST）</h6><p>静态分析的核心数据结构，将代码转换为树状结构，便于工具分析</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例代码</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">sum</span> = (<span class=\"params\">a, b</span>) =&gt; a + b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对应的AST（简化版）</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">type</span>: <span class=\"string\">&quot;Program&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">body</span>: [&#123;</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&quot;VariableDeclaration&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">declarations</span>: [&#123;</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"string\">&quot;VariableDeclarator&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">id</span>: &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;Identifier&quot;</span>, <span class=\"attr\">name</span>: <span class=\"string\">&quot;sum&quot;</span> &#125;,</span><br><span class=\"line\">      <span class=\"attr\">init</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">type</span>: <span class=\"string\">&quot;ArrowFunctionExpression&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">params</span>: [</span><br><span class=\"line\">          &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;Identifier&quot;</span>, <span class=\"attr\">name</span>: <span class=\"string\">&quot;a&quot;</span> &#125;,</span><br><span class=\"line\">          &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;Identifier&quot;</span>, <span class=\"attr\">name</span>: <span class=\"string\">&quot;b&quot;</span> &#125;</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        <span class=\"attr\">body</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">type</span>: <span class=\"string\">&quot;BinaryExpression&quot;</span>,</span><br><span class=\"line\">          <span class=\"attr\">operator</span>: <span class=\"string\">&quot;+&quot;</span>,</span><br><span class=\"line\">          <span class=\"attr\">left</span>: &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;Identifier&quot;</span>, <span class=\"attr\">name</span>: <span class=\"string\">&quot;a&quot;</span> &#125;,</span><br><span class=\"line\">          <span class=\"attr\">right</span>: &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;Identifier&quot;</span>, <span class=\"attr\">name</span>: <span class=\"string\">&quot;b&quot;</span> &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>工具：Babel、ESlint、Prettier均基于AST操作代码</p>\n<h6 id=\"2-2-数据流分析（Data-Flow-Analysis）\"><a href=\"#2-2-数据流分析（Data-Flow-Analysis）\" class=\"headerlink\" title=\"2.2 数据流分析（Data Flow Analysis）\"></a>2.2 数据流分析（Data Flow Analysis）</h6><p>跟踪变量和值的流动，用于检测：</p>\n<ul>\n<li>未初始化的变量</li>\n<li>不可达代码</li>\n<li>常量传播优化</li>\n</ul>\n<h6 id=\"2-3-控制流分析（Control-Flow-Analysis）\"><a href=\"#2-3-控制流分析（Control-Flow-Analysis）\" class=\"headerlink\" title=\"2.3 控制流分析（Control Flow Analysis）\"></a>2.3 控制流分析（Control Flow Analysis）</h6><ul>\n<li>检测无限循环</li>\n<li>识别异常处理遗漏</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">risky</span>(<span class=\"params\">x</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;ok&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 静态分析可警告：缺少 else 分支，可能返回 undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-4-类型检查（Type-Checking）\"><a href=\"#2-4-类型检查（Type-Checking）\" class=\"headerlink\" title=\"2.4 类型检查（Type Checking）\"></a>2.4 类型检查（Type Checking）</h6><p>在编译时验证类型一致性，如TypeScript的静态类型系统：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greet</span>(<span class=\"params\">name: string</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`Hello, <span class=\"subst\">$&#123;name&#125;</span>`</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">greet</span>(<span class=\"number\">42</span>); <span class=\"comment\">// 静态分析报错：类型不匹配</span></span><br></pre></td></tr></table></figure>\n\n","_processedHighlight":true},{"title":"Vue","date":"2024-02-06T16:00:00.000Z","_content":"\n# 一个重要的内置关系：\n**VueComponent.prototype.__proto__=Vue.prototype**\n\n**让组建实例对象（vc）可以访问到 Vue 原型上的属性、方法**\n\n![vm、vc的原型关系](images/vue_prototype.png)\n\n\n\n# 关于不同版本的Vue：\n**<font style=\"background-color:#E7E9E8;\"> vue.js </font>** **与 <font style=\"background-color:#E7E9E8;\"> </font>**<font style=\"background-color:#E7E9E8;\">vue.runtime.xxx.js </font>** 的区别：\n\n1. **<font style=\"background-color:#E7E9E8;\">vue.js</font>** 是完整版的vue。包含：核心功能+模板解析器。\n2. **<font style=\"background-color:#E7E9E8;\">vue.runtime.xxx.js</font>** 是运行版的Vue。只包含：核心功能，没有模板解析器。\n\n因为 **<font style=\"background-color:#E7E9E8;\"> vue.runtime.xxx.js </font>** 没有模板解析器，所以 **<font style=\"background-color:#E7E9E8;\"> main.js（入口文件）</font>** 创建 **<font style=\"background-color:#E7E9E8;\"> vue实例（new Vue(...)）</font>** 时不能使用 **<font style=\"background-color:#E7E9E8;\"> template</font>** 配置项，需要使用 **<font style=\"background-color:#E7E9E8;\"> render</font>** 函数接收到的 **<font style=\"background-color:#E7E9E8;\">  createElement </font>** 函数去指定具体内容。而 **<font style=\"background-color:#E7E9E8;\"> .vue文件 </font>** 中的模板字符串语法 **<font style=\"background-color:#E7E9E8;\"> <template></template> </font>** 是由 **<font style=\"background-color:#E7E9E8;\"> vue-template-compiler </font>** 去解析的。\n\n# Vue Cli脚手架\n###### 查看配置\nVue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，请执行：<font style=\"background-color:#E7E9E8;\"> </font>**<font style=\"background-color:#E7E9E8;\">vue inspect > output.js </font>**\n\n会在项目根路径下输出一个 **output.js **文件，**注意：该文件仅供查看，修改无效。**\n\n![vue-cli默认配置](images/vue-cli默认配置.png)\n\n###### 修改配置\n`vue.config.js` 是一个可选的配置文件，如果项目的 (和 `package.json` 同级的) 根目录中存在这个文件，那么它会被 `@vue/cli-service` 自动加载。可以对脚手架进行个性化定制，详情见vue-cli文档：[https://cli.vuejs.org/zh/config/](https://cli.vuejs.org/zh/config/)\n\n\n\n# vue2与vue3\n## 响应式实现：\n[面试官的步步紧逼：Vue2 和 Vue3 的响应式原理比对](https://juejin.cn/post/7124351370521477128?searchId=20250818012335EC20BB0273AF51843CB1)**（超绝文章！醍醐灌顶！！**\n\nvue2：**Object.defineProperty **遍历递归对象，改造属性getter、setter\n\nvue3：**Proxy( + Reflect ) **原始类型：类的访问器属性（get value(...){}, set value(...){}）\n\n| **特性** | **Vue 2** | **Vue 3** |\n| --- | --- | --- |\n| **实现方式** | Object.defineProperty | Proxy |\n| **检测范围** | 仅能劫持已有属性 | 可拦截对象所有操作 |\n| **数组处理** | 重写数组方法 | 原生支持数组操作 |\n| **新增属性** | 需用Vue.set/$set/$delete | 自动检测 |\n| **性能** | 递归遍历所有属性初始化 | 惰性代理，按需响应 |\n| **嵌套对象** | 初始化时递归劫持 | 访问时递归代理 |\n\n\n1. **数组监测**：\n    - Vue 2中需要特殊方法触发更新\n    - Vue 3中所有数组操作自动触发\n2. **动态属性**：\n    - Vue 2中需使用Vue.set\n    - Vue 3中可直接赋值\n3. **性能敏感场景**：\n    - Vue 3的readonly/shallowRef/shallowReactive提供更细粒度控制\n\n### 关于一些关键概念（vue2：Watcher / vue3：ReactiveEffect）\n#### vue2：Watcher \n##### 一、Watcher 的三种类型与职责\nWatcher 并不是单一功能的，根据其执行的任务不同，主要分为三种：\n\n| 类型 | 触发场景 | 职责 | 代码中的体现 |\n| --- | --- | --- | --- |\n| **渲染 Watcher** | 每个组件实例只有一个 | **负责组件的视图更新**。当它依赖的数据变化时，会触发组件的重新渲染（`_update`<br/>）。 | 你写的模板中的每一个数据绑定 `{{ message }}`<br/>、`v-bind`<br/>，最终都依赖于它。 |\n| **计算属性Watcher** | 每个 `computed`属性一个 | **监控计算属性所依赖的数据**，依赖变则重新计算计算属性的值，并缓存结果。 | 你在 `computed`<br/> 中定义的每一个函数，Vue 都会为其创建一个对应的 Watcher。 |\n| **用户 Watcher** | 每个 `watch`选项一个 | **监听一个特定的数据变化，并执行用户定义的回调函数**。 |  |\n\n\n##### 二、Watcher 的工作流程：与 Dep 和 Observer 联动\n**Watcher** 不能单独工作，它必须和 **Observer**（数据劫持者）和 **Dep**（依赖管理器）协同工作。这三者的关系是 Vue 响应式的铁三角。\n\n让我们用一个经典的流程图来揭示它们是如何协作的，**并以一个简单的模板 **`**{{ user.name }}**`** 为例**：\n\n<img src=\"/images/Watcher工作流程.svg\" alt=\"Watcher工作流程\" height=\"auto\" style=\"width:50%; display:block;\">\n\n:::tips\n**关键步骤解读**：\n\n1. `**Observer**`：通过 `Object.defineProperty` 将 `data` 中的每个属性（如 `user`）转换为 `getter` 和 `setter`。\n2. `**Dep**`：每个被监听的属性都会拥有一个自己的 `Dep` 实例（依赖管理器），用来存储所有“依赖”这个数据的 `Watcher`。\n3. `**Watcher**` 的创建：\n    - 当 Vue 初始化组件时，会创建一个**渲染 Watcher**。\n    - 这个 Watcher 在执行它的第一个任务（即渲染页面）时，会去读取模板中用到的数据，如 `user.name`。\n4. **依赖收集（Depend）**：\n    - 读取 `user.name` 会触发之前定义的 `getter`。\n    - 在 `getter` 中，会检查当前是否有正在执行的 Watcher（通过 `Dep.target` 静态属性指向它）。**有！** 就是刚才创建的渲染 Watcher（W1）。\n    - `getter` 会调用 `dep.depend()`，将当前这个 Watcher（W1）**收集**到 `user.name` 的 Dep 的订阅者列表中。从此，Dep 就知道：“哦，W1 依赖我。”\n5. **派发更新（Notify）**：\n    - 当我们修改数据：`user.name = 'New'` 时，会触发 `setter`。\n    - `setter` 会调用 `dep.notify()`。\n    - `dep.notify()` 会遍历它收集的所有 Watcher（这里只有 W1），通知它们：“我变了，你们该干活了！”\n6. **执行更新**：\n    - 每个被通知的 Watcher（W1）会执行自己的 `update()` 方法。\n    - 对于**渲染 Watcher**，这个“干活”就是重新执行组件的渲染函数（`render`），生成新的虚拟 DOM，然后进行 patch（Diff）更新真实 DOM。页面就这样更新了。\n\n:::\n\n#### vue3：ReactiveEffect\n##### 一、什么是 ReactiveEffect？\n它的核心思想来源于函数式编程中的 **“副作用”（Effect）** 概念。任何会“对外部世界”造成影响的操作都是副作用，例如：修改 DOM、发送网络请求、操作本地存储等。\n\n在 Vue 的上下文中，**最常见的“副作用”就是“渲染视图”**。当响应式数据变化时，我们需要重新执行这个副作用来更新视图。\n\n`ReactiveEffect` 就是一个**封装了这些副作用函数的对象**。它的职责和 Vue 2 的 `Watcher` 类似，但设计和实现更加优雅和强大。\n\n**一个极简的 ReactiveEffect 示例：**\n\n```javascript\nimport { reactive, effect } from 'vue'; // 注意：effect 在 Vue 3 中是一个底层 API\n\nconst state = reactive({ count: 0 });\n\n// 创建一个 Effect：副作用是打印 count 的值\nconst myEffect = new ReactiveEffect(() => {\n  console.log(`Count is: ${state.count}`);\n});\n\n// 首次手动执行副作用\nmyEffect.run(); // 输出: Count is: 0\n\n// 当 state.count 变化时，这个 effect 会自动重新执行\nstate.count++; // 自动输出: Count is: 1\n```\n\n**关键点**：\n\n1. 你创建一个 `ReactiveEffect` 实例，并传入一个**副作用函数**。\n2. 当你执行 `effect.run()` 时，Vue 3 会：\n    - 设置一个全局的“活动效应”（`activeEffect`）为当前这个 `ReactiveEffect`。\n    - 然后执行你传入的副作用函数。\n3. 在执行过程中，如果副作用函数**读取**了某个响应式数据（如 `state.count`），就会触发该数据的 `getter`。\n4. 在 `getter` 中，Vue 3 会发现当前有一个 `activeEffect` 正在运行，于是就会**建立依赖关系**：将这个 `ReactiveEffect` 收集为这个响应式数据的依赖。\n5. 将来该数据**变化**时，就会通知所有依赖它的 `ReactiveEffect` 实例，调用它们的 `run` 方法（或调度函数），从而重新执行副作用。\n\n##### 二、ReactiveEffect 与 Vue 2 Watcher 的核心差异\n虽然目标一致（追踪依赖、执行副作用），但两者在设计和能力上有天壤之别。\n\n| 特性 | Vue 2 **Watcher** | Vue 3 **ReactiveEffect** |\n| --- | --- | --- |\n| **设计理念** | **“全能型员工”**   与组件实例、选项式 API 强耦合，种类繁多（渲染、计算、用户）。 | **“纯粹的工具”**   一个**与上下文无关**的、**单一职责**的副作用封装器。它不知道自己是用于渲染、计算还是监听。 |\n| **与组件的关系** | **紧密耦合**   每个组件实例必然对应一个渲染 Watcher。Watcher 知道自己是哪个组件的。 | **松散耦合**   `ReactiveEffect`<br/> 本身不知道组件。组件的 `setup`<br/> 函数本身就是一个大的 `ReactiveEffect`<br/>。 |\n| **依赖收集** | **显式、侵入式**   通过 `Dep`<br/> 类和 `pushTarget`<br/>/`popTarget`<br/> 等全局状态管理。 | **隐式、基于栈**   通过全局变量 `activeEffect`<br/> 和 `effectStack`<br/> 来追踪当前正在运行的 effect，更加清晰可靠。 |\n| **功能与灵活性** | **功能固定**   种类和行为在创建时就确定了（如 `lazy`<br/>, `sync`<br/> 等配置）。 | **极其灵活**   通过 `**scheduler**`<br/>** ****调度器** 实现各种高级功能（如 `computed`<br/> 的懒计算、`watch`<br/> 的异步回调）。 |\n| **性能优化** | **较差**   在依赖收集阶段需要频繁创建和遍历 Dep 实例。 | **更优**   使用 `Set`<br/> 和 `Map`<br/> 等原生数据结构管理依赖，效率更高。依赖关系更精细。 |\n\n\n---\n\n##### 三、最重要的差异：调度器 (scheduler)\n这是 `ReactiveEffect` 相比 `Watcher` 最强大的设计优势。\n\n在创建 `ReactiveEffect` 时，你可以传入一个 `**scheduler**`** ****函数**。当依赖变化时，**默认行为是直接调用**** **`**effect.run()**`，但如果你提供了 `scheduler`，则会**改为调用**** **`**scheduler(effect)**`，把**何时、如何执行副作用**的控制权完全交给了你。\n\n**正是这个**** **`**scheduler**`**，实现了 Vue 3 的所有高级特性：**\n\n**1. 实现 **`**computed**`\n\n```javascript\nfunction computed(getter) {\n  let dirty = true; // 标记是否需要重新计算\n  let value;\n\n  // 1. 创建一个“懒执行”的 effect\n  const effect = new ReactiveEffect(getter, () => {\n    // 2. 这个 scheduler 只标记 dirty，但不立刻计算值\n    if (!dirty) {\n      dirty = true;\n      // 3. 通知依赖此 computed 的 effect 更新（例如模板）\n      trigger(computedRef, TriggerOpTypes.SET, 'value');\n    }\n  });\n\n  const computedRef = {\n    get value() {\n      if (dirty) {\n        value = effect.run(); // 只有在需要时才执行计算\n        dirty = false;\n      }\n      track(computedRef, TrackOpTypes.GET, 'value'); // 收集依赖\n      return value;\n    }\n  };\n  return computedRef;\n}\n```\n\n**2. 实现 **`**watch**`** / **`**watchEffect**`\n\n```javascript\nfunction watch(source, cb, options) {\n  let getter = () => source();\n  let oldValue;\n\n  // scheduler 决定回调的执行时机（同步、异步、前置等）\n  const scheduler = () => {\n    if (options.flush === 'sync') {\n      // 同步执行\n      run();\n    } else {\n      // 异步执行（默认是 'pre'，在组件更新前）\n      queueJob(run);\n    }\n  };\n\n  const effect = new ReactiveEffect(getter, scheduler); // 传入 scheduler!\n\n  const run = () => {\n    const newValue = effect.run();\n    cb(newValue, oldValue); // 执行用户回调\n    oldValue = newValue;\n  };\n\n  effect.run(); // 首次运行\n}\n```\n\n**3. 实现组件的异步更新队列**\n\n组件的渲染本身也是一个 `ReactiveEffect`。它的 `scheduler` 是一个将渲染任务推入**异步队列**的函数，这才实现了 Vue “批量更新”和“异步更新”的特性。\n\njavascript\n\n```plain\n// 组件更新 effect\nconst updateEffect = new ReactiveEffect(\n  componentUpdateFn, // 副作用：组件渲染函数\n  () => queueJob(updateEffect) // scheduler: 不是立即执行，而是放入队列\n);\n```\n\n---\n\n##### 总结：演进与优势\n|  | Vue 2 **Watcher** | Vue 3 **ReactiveEffect** |\n| --- | --- | --- |\n| **定位** | 一个与组件生命周期绑定的**具体概念** | 一个抽象的、可复用的**副作用容器** |\n| **设计** | **“大而全”**，多种类型，逻辑复杂 | **“小而美”**，职责单一，通过**调度器**注入不同行为 |\n| **能力** | 功能固定，扩展性差 | **极其灵活**，通过 `scheduler`<br/> 可实现各种高级异步和控制流程 |\n| **关系** | **继承与分类**（RenderWatcher, ComputedWatcher...） | **组合与赋能**（一个 Effect + 不同的 scheduler = 不同功能） |\n\n\n**结论：**  \n`ReactiveEffect` 是 Vue 3 对 `Watcher` 概念的**一次彻底的重构和升级**。它通过**分离“副作用本身”和“副作用的执行时机（调度）”**，将响应式系统从一个相对僵化的模型解放为一个极其灵活和强大的架构。这种设计不仅使代码更清晰、更易于维护，更重要的是为 `computed`、`watch` 以及未来的所有响应式高级功能提供了一个统一而强大的底层基础。\n\n## Composition api (组合式api) 和 Options api (选项式api)\n1. 代码组织方式改变\n2. composition api优势\n    - 更好的逻辑复用（自定义hooks）\n    - 更灵活的代码组织\n    - 更好的TypeScript支持\n    - 更小的代码打包体积\n1. 模板和组件变化\n2. 多根节点支持\n3. v-model升级：v-model:title=\"pageTitle\"\n4. 组件生命周期变化\n\n\n\n## Fragment/Teleport/Suspense\n+ Fragment：多根节点组件\n+ Teleport：将内容渲染到DOM其他位置\n+ Suspense：异步组件加载状态处理\n\n# diff算法\n\n\n","source":"_posts/vue.md","raw":"---\ntitle: Vue\ndate: 2024-02-07\ntags: [Vue]\ncategories: Vue\n---\n\n# 一个重要的内置关系：\n**VueComponent.prototype.__proto__=Vue.prototype**\n\n**让组建实例对象（vc）可以访问到 Vue 原型上的属性、方法**\n\n![vm、vc的原型关系](images/vue_prototype.png)\n\n\n\n# 关于不同版本的Vue：\n**<font style=\"background-color:#E7E9E8;\"> vue.js </font>** **与 <font style=\"background-color:#E7E9E8;\"> </font>**<font style=\"background-color:#E7E9E8;\">vue.runtime.xxx.js </font>** 的区别：\n\n1. **<font style=\"background-color:#E7E9E8;\">vue.js</font>** 是完整版的vue。包含：核心功能+模板解析器。\n2. **<font style=\"background-color:#E7E9E8;\">vue.runtime.xxx.js</font>** 是运行版的Vue。只包含：核心功能，没有模板解析器。\n\n因为 **<font style=\"background-color:#E7E9E8;\"> vue.runtime.xxx.js </font>** 没有模板解析器，所以 **<font style=\"background-color:#E7E9E8;\"> main.js（入口文件）</font>** 创建 **<font style=\"background-color:#E7E9E8;\"> vue实例（new Vue(...)）</font>** 时不能使用 **<font style=\"background-color:#E7E9E8;\"> template</font>** 配置项，需要使用 **<font style=\"background-color:#E7E9E8;\"> render</font>** 函数接收到的 **<font style=\"background-color:#E7E9E8;\">  createElement </font>** 函数去指定具体内容。而 **<font style=\"background-color:#E7E9E8;\"> .vue文件 </font>** 中的模板字符串语法 **<font style=\"background-color:#E7E9E8;\"> <template></template> </font>** 是由 **<font style=\"background-color:#E7E9E8;\"> vue-template-compiler </font>** 去解析的。\n\n# Vue Cli脚手架\n###### 查看配置\nVue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，请执行：<font style=\"background-color:#E7E9E8;\"> </font>**<font style=\"background-color:#E7E9E8;\">vue inspect > output.js </font>**\n\n会在项目根路径下输出一个 **output.js **文件，**注意：该文件仅供查看，修改无效。**\n\n![vue-cli默认配置](images/vue-cli默认配置.png)\n\n###### 修改配置\n`vue.config.js` 是一个可选的配置文件，如果项目的 (和 `package.json` 同级的) 根目录中存在这个文件，那么它会被 `@vue/cli-service` 自动加载。可以对脚手架进行个性化定制，详情见vue-cli文档：[https://cli.vuejs.org/zh/config/](https://cli.vuejs.org/zh/config/)\n\n\n\n# vue2与vue3\n## 响应式实现：\n[面试官的步步紧逼：Vue2 和 Vue3 的响应式原理比对](https://juejin.cn/post/7124351370521477128?searchId=20250818012335EC20BB0273AF51843CB1)**（超绝文章！醍醐灌顶！！**\n\nvue2：**Object.defineProperty **遍历递归对象，改造属性getter、setter\n\nvue3：**Proxy( + Reflect ) **原始类型：类的访问器属性（get value(...){}, set value(...){}）\n\n| **特性** | **Vue 2** | **Vue 3** |\n| --- | --- | --- |\n| **实现方式** | Object.defineProperty | Proxy |\n| **检测范围** | 仅能劫持已有属性 | 可拦截对象所有操作 |\n| **数组处理** | 重写数组方法 | 原生支持数组操作 |\n| **新增属性** | 需用Vue.set/$set/$delete | 自动检测 |\n| **性能** | 递归遍历所有属性初始化 | 惰性代理，按需响应 |\n| **嵌套对象** | 初始化时递归劫持 | 访问时递归代理 |\n\n\n1. **数组监测**：\n    - Vue 2中需要特殊方法触发更新\n    - Vue 3中所有数组操作自动触发\n2. **动态属性**：\n    - Vue 2中需使用Vue.set\n    - Vue 3中可直接赋值\n3. **性能敏感场景**：\n    - Vue 3的readonly/shallowRef/shallowReactive提供更细粒度控制\n\n### 关于一些关键概念（vue2：Watcher / vue3：ReactiveEffect）\n#### vue2：Watcher \n##### 一、Watcher 的三种类型与职责\nWatcher 并不是单一功能的，根据其执行的任务不同，主要分为三种：\n\n| 类型 | 触发场景 | 职责 | 代码中的体现 |\n| --- | --- | --- | --- |\n| **渲染 Watcher** | 每个组件实例只有一个 | **负责组件的视图更新**。当它依赖的数据变化时，会触发组件的重新渲染（`_update`<br/>）。 | 你写的模板中的每一个数据绑定 `{{ message }}`<br/>、`v-bind`<br/>，最终都依赖于它。 |\n| **计算属性Watcher** | 每个 `computed`属性一个 | **监控计算属性所依赖的数据**，依赖变则重新计算计算属性的值，并缓存结果。 | 你在 `computed`<br/> 中定义的每一个函数，Vue 都会为其创建一个对应的 Watcher。 |\n| **用户 Watcher** | 每个 `watch`选项一个 | **监听一个特定的数据变化，并执行用户定义的回调函数**。 |  |\n\n\n##### 二、Watcher 的工作流程：与 Dep 和 Observer 联动\n**Watcher** 不能单独工作，它必须和 **Observer**（数据劫持者）和 **Dep**（依赖管理器）协同工作。这三者的关系是 Vue 响应式的铁三角。\n\n让我们用一个经典的流程图来揭示它们是如何协作的，**并以一个简单的模板 **`**{{ user.name }}**`** 为例**：\n\n<img src=\"/images/Watcher工作流程.svg\" alt=\"Watcher工作流程\" height=\"auto\" style=\"width:50%; display:block;\">\n\n:::tips\n**关键步骤解读**：\n\n1. `**Observer**`：通过 `Object.defineProperty` 将 `data` 中的每个属性（如 `user`）转换为 `getter` 和 `setter`。\n2. `**Dep**`：每个被监听的属性都会拥有一个自己的 `Dep` 实例（依赖管理器），用来存储所有“依赖”这个数据的 `Watcher`。\n3. `**Watcher**` 的创建：\n    - 当 Vue 初始化组件时，会创建一个**渲染 Watcher**。\n    - 这个 Watcher 在执行它的第一个任务（即渲染页面）时，会去读取模板中用到的数据，如 `user.name`。\n4. **依赖收集（Depend）**：\n    - 读取 `user.name` 会触发之前定义的 `getter`。\n    - 在 `getter` 中，会检查当前是否有正在执行的 Watcher（通过 `Dep.target` 静态属性指向它）。**有！** 就是刚才创建的渲染 Watcher（W1）。\n    - `getter` 会调用 `dep.depend()`，将当前这个 Watcher（W1）**收集**到 `user.name` 的 Dep 的订阅者列表中。从此，Dep 就知道：“哦，W1 依赖我。”\n5. **派发更新（Notify）**：\n    - 当我们修改数据：`user.name = 'New'` 时，会触发 `setter`。\n    - `setter` 会调用 `dep.notify()`。\n    - `dep.notify()` 会遍历它收集的所有 Watcher（这里只有 W1），通知它们：“我变了，你们该干活了！”\n6. **执行更新**：\n    - 每个被通知的 Watcher（W1）会执行自己的 `update()` 方法。\n    - 对于**渲染 Watcher**，这个“干活”就是重新执行组件的渲染函数（`render`），生成新的虚拟 DOM，然后进行 patch（Diff）更新真实 DOM。页面就这样更新了。\n\n:::\n\n#### vue3：ReactiveEffect\n##### 一、什么是 ReactiveEffect？\n它的核心思想来源于函数式编程中的 **“副作用”（Effect）** 概念。任何会“对外部世界”造成影响的操作都是副作用，例如：修改 DOM、发送网络请求、操作本地存储等。\n\n在 Vue 的上下文中，**最常见的“副作用”就是“渲染视图”**。当响应式数据变化时，我们需要重新执行这个副作用来更新视图。\n\n`ReactiveEffect` 就是一个**封装了这些副作用函数的对象**。它的职责和 Vue 2 的 `Watcher` 类似，但设计和实现更加优雅和强大。\n\n**一个极简的 ReactiveEffect 示例：**\n\n```javascript\nimport { reactive, effect } from 'vue'; // 注意：effect 在 Vue 3 中是一个底层 API\n\nconst state = reactive({ count: 0 });\n\n// 创建一个 Effect：副作用是打印 count 的值\nconst myEffect = new ReactiveEffect(() => {\n  console.log(`Count is: ${state.count}`);\n});\n\n// 首次手动执行副作用\nmyEffect.run(); // 输出: Count is: 0\n\n// 当 state.count 变化时，这个 effect 会自动重新执行\nstate.count++; // 自动输出: Count is: 1\n```\n\n**关键点**：\n\n1. 你创建一个 `ReactiveEffect` 实例，并传入一个**副作用函数**。\n2. 当你执行 `effect.run()` 时，Vue 3 会：\n    - 设置一个全局的“活动效应”（`activeEffect`）为当前这个 `ReactiveEffect`。\n    - 然后执行你传入的副作用函数。\n3. 在执行过程中，如果副作用函数**读取**了某个响应式数据（如 `state.count`），就会触发该数据的 `getter`。\n4. 在 `getter` 中，Vue 3 会发现当前有一个 `activeEffect` 正在运行，于是就会**建立依赖关系**：将这个 `ReactiveEffect` 收集为这个响应式数据的依赖。\n5. 将来该数据**变化**时，就会通知所有依赖它的 `ReactiveEffect` 实例，调用它们的 `run` 方法（或调度函数），从而重新执行副作用。\n\n##### 二、ReactiveEffect 与 Vue 2 Watcher 的核心差异\n虽然目标一致（追踪依赖、执行副作用），但两者在设计和能力上有天壤之别。\n\n| 特性 | Vue 2 **Watcher** | Vue 3 **ReactiveEffect** |\n| --- | --- | --- |\n| **设计理念** | **“全能型员工”**   与组件实例、选项式 API 强耦合，种类繁多（渲染、计算、用户）。 | **“纯粹的工具”**   一个**与上下文无关**的、**单一职责**的副作用封装器。它不知道自己是用于渲染、计算还是监听。 |\n| **与组件的关系** | **紧密耦合**   每个组件实例必然对应一个渲染 Watcher。Watcher 知道自己是哪个组件的。 | **松散耦合**   `ReactiveEffect`<br/> 本身不知道组件。组件的 `setup`<br/> 函数本身就是一个大的 `ReactiveEffect`<br/>。 |\n| **依赖收集** | **显式、侵入式**   通过 `Dep`<br/> 类和 `pushTarget`<br/>/`popTarget`<br/> 等全局状态管理。 | **隐式、基于栈**   通过全局变量 `activeEffect`<br/> 和 `effectStack`<br/> 来追踪当前正在运行的 effect，更加清晰可靠。 |\n| **功能与灵活性** | **功能固定**   种类和行为在创建时就确定了（如 `lazy`<br/>, `sync`<br/> 等配置）。 | **极其灵活**   通过 `**scheduler**`<br/>** ****调度器** 实现各种高级功能（如 `computed`<br/> 的懒计算、`watch`<br/> 的异步回调）。 |\n| **性能优化** | **较差**   在依赖收集阶段需要频繁创建和遍历 Dep 实例。 | **更优**   使用 `Set`<br/> 和 `Map`<br/> 等原生数据结构管理依赖，效率更高。依赖关系更精细。 |\n\n\n---\n\n##### 三、最重要的差异：调度器 (scheduler)\n这是 `ReactiveEffect` 相比 `Watcher` 最强大的设计优势。\n\n在创建 `ReactiveEffect` 时，你可以传入一个 `**scheduler**`** ****函数**。当依赖变化时，**默认行为是直接调用**** **`**effect.run()**`，但如果你提供了 `scheduler`，则会**改为调用**** **`**scheduler(effect)**`，把**何时、如何执行副作用**的控制权完全交给了你。\n\n**正是这个**** **`**scheduler**`**，实现了 Vue 3 的所有高级特性：**\n\n**1. 实现 **`**computed**`\n\n```javascript\nfunction computed(getter) {\n  let dirty = true; // 标记是否需要重新计算\n  let value;\n\n  // 1. 创建一个“懒执行”的 effect\n  const effect = new ReactiveEffect(getter, () => {\n    // 2. 这个 scheduler 只标记 dirty，但不立刻计算值\n    if (!dirty) {\n      dirty = true;\n      // 3. 通知依赖此 computed 的 effect 更新（例如模板）\n      trigger(computedRef, TriggerOpTypes.SET, 'value');\n    }\n  });\n\n  const computedRef = {\n    get value() {\n      if (dirty) {\n        value = effect.run(); // 只有在需要时才执行计算\n        dirty = false;\n      }\n      track(computedRef, TrackOpTypes.GET, 'value'); // 收集依赖\n      return value;\n    }\n  };\n  return computedRef;\n}\n```\n\n**2. 实现 **`**watch**`** / **`**watchEffect**`\n\n```javascript\nfunction watch(source, cb, options) {\n  let getter = () => source();\n  let oldValue;\n\n  // scheduler 决定回调的执行时机（同步、异步、前置等）\n  const scheduler = () => {\n    if (options.flush === 'sync') {\n      // 同步执行\n      run();\n    } else {\n      // 异步执行（默认是 'pre'，在组件更新前）\n      queueJob(run);\n    }\n  };\n\n  const effect = new ReactiveEffect(getter, scheduler); // 传入 scheduler!\n\n  const run = () => {\n    const newValue = effect.run();\n    cb(newValue, oldValue); // 执行用户回调\n    oldValue = newValue;\n  };\n\n  effect.run(); // 首次运行\n}\n```\n\n**3. 实现组件的异步更新队列**\n\n组件的渲染本身也是一个 `ReactiveEffect`。它的 `scheduler` 是一个将渲染任务推入**异步队列**的函数，这才实现了 Vue “批量更新”和“异步更新”的特性。\n\njavascript\n\n```plain\n// 组件更新 effect\nconst updateEffect = new ReactiveEffect(\n  componentUpdateFn, // 副作用：组件渲染函数\n  () => queueJob(updateEffect) // scheduler: 不是立即执行，而是放入队列\n);\n```\n\n---\n\n##### 总结：演进与优势\n|  | Vue 2 **Watcher** | Vue 3 **ReactiveEffect** |\n| --- | --- | --- |\n| **定位** | 一个与组件生命周期绑定的**具体概念** | 一个抽象的、可复用的**副作用容器** |\n| **设计** | **“大而全”**，多种类型，逻辑复杂 | **“小而美”**，职责单一，通过**调度器**注入不同行为 |\n| **能力** | 功能固定，扩展性差 | **极其灵活**，通过 `scheduler`<br/> 可实现各种高级异步和控制流程 |\n| **关系** | **继承与分类**（RenderWatcher, ComputedWatcher...） | **组合与赋能**（一个 Effect + 不同的 scheduler = 不同功能） |\n\n\n**结论：**  \n`ReactiveEffect` 是 Vue 3 对 `Watcher` 概念的**一次彻底的重构和升级**。它通过**分离“副作用本身”和“副作用的执行时机（调度）”**，将响应式系统从一个相对僵化的模型解放为一个极其灵活和强大的架构。这种设计不仅使代码更清晰、更易于维护，更重要的是为 `computed`、`watch` 以及未来的所有响应式高级功能提供了一个统一而强大的底层基础。\n\n## Composition api (组合式api) 和 Options api (选项式api)\n1. 代码组织方式改变\n2. composition api优势\n    - 更好的逻辑复用（自定义hooks）\n    - 更灵活的代码组织\n    - 更好的TypeScript支持\n    - 更小的代码打包体积\n1. 模板和组件变化\n2. 多根节点支持\n3. v-model升级：v-model:title=\"pageTitle\"\n4. 组件生命周期变化\n\n\n\n## Fragment/Teleport/Suspense\n+ Fragment：多根节点组件\n+ Teleport：将内容渲染到DOM其他位置\n+ Suspense：异步组件加载状态处理\n\n# diff算法\n\n\n","slug":"vue","published":1,"updated":"2025-09-14T14:57:13.586Z","_id":"cmfjspu9a000kn05w1bl5hjaq","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"一个重要的内置关系：\"><a href=\"#一个重要的内置关系：\" class=\"headerlink\" title=\"一个重要的内置关系：\"></a>一个重要的内置关系：</h1><p><strong>VueComponent.prototype.<strong>proto</strong>&#x3D;Vue.prototype</strong></p>\n<p><strong>让组建实例对象（vc）可以访问到 Vue 原型上的属性、方法</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/vue_prototype.png\"\n                      alt=\"vm、vc的原型关系\"\n                ></p>\n<h1 id=\"关于不同版本的Vue：\"><a href=\"#关于不同版本的Vue：\" class=\"headerlink\" title=\"关于不同版本的Vue：\"></a>关于不同版本的Vue：</h1><p><strong><font style=\"background-color:#E7E9E8;\"> vue.js </font></strong> <strong>与 <font style=\"background-color:#E7E9E8;\"> </font></strong><font style=\"background-color:#E7E9E8;\">vue.runtime.xxx.js </font>** 的区别：</p>\n<ol>\n<li><strong><font style=\"background-color:#E7E9E8;\">vue.js</font></strong> 是完整版的vue。包含：核心功能+模板解析器。</li>\n<li><strong><font style=\"background-color:#E7E9E8;\">vue.runtime.xxx.js</font></strong> 是运行版的Vue。只包含：核心功能，没有模板解析器。</li>\n</ol>\n<p>因为 <strong><font style=\"background-color:#E7E9E8;\"> vue.runtime.xxx.js </font></strong> 没有模板解析器，所以 <strong><font style=\"background-color:#E7E9E8;\"> main.js（入口文件）</font></strong> 创建 <strong><font style=\"background-color:#E7E9E8;\"> vue实例（new Vue(…)）</font></strong> 时不能使用 <strong><font style=\"background-color:#E7E9E8;\"> template</font></strong> 配置项，需要使用 <strong><font style=\"background-color:#E7E9E8;\"> render</font></strong> 函数接收到的 <strong><font style=\"background-color:#E7E9E8;\">  createElement </font></strong> 函数去指定具体内容。而 <strong><font style=\"background-color:#E7E9E8;\"> .vue文件 </font></strong> 中的模板字符串语法 <strong><font style=\"background-color:#E7E9E8;\"> <template></template> </font></strong> 是由 <strong><font style=\"background-color:#E7E9E8;\"> vue-template-compiler </font></strong> 去解析的。</p>\n<h1 id=\"Vue-Cli脚手架\"><a href=\"#Vue-Cli脚手架\" class=\"headerlink\" title=\"Vue Cli脚手架\"></a>Vue Cli脚手架</h1><h6 id=\"查看配置\"><a href=\"#查看配置\" class=\"headerlink\" title=\"查看配置\"></a>查看配置</h6><p>Vue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，请执行：<font style=\"background-color:#E7E9E8;\"> </font><strong><font style=\"background-color:#E7E9E8;\">vue inspect &gt; output.js </font></strong></p>\n<p>会在项目根路径下输出一个 **output.js **文件，<strong>注意：该文件仅供查看，修改无效。</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/vue-cli%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE.png\"\n                      alt=\"vue-cli默认配置\"\n                ></p>\n<h6 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h6><p><code>vue.config.js</code> 是一个可选的配置文件，如果项目的 (和 <code>package.json</code> 同级的) 根目录中存在这个文件，那么它会被 <code>@vue/cli-service</code> 自动加载。可以对脚手架进行个性化定制，详情见vue-cli文档：<a class=\"link\"   href=\"https://cli.vuejs.org/zh/config/\" >https://cli.vuejs.org/zh/config/<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<h1 id=\"vue2与vue3\"><a href=\"#vue2与vue3\" class=\"headerlink\" title=\"vue2与vue3\"></a>vue2与vue3</h1><h2 id=\"响应式实现：\"><a href=\"#响应式实现：\" class=\"headerlink\" title=\"响应式实现：\"></a>响应式实现：</h2><p><a class=\"link\"   href=\"https://juejin.cn/post/7124351370521477128?searchId=20250818012335EC20BB0273AF51843CB1\" >面试官的步步紧逼：Vue2 和 Vue3 的响应式原理比对<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a><strong>（超绝文章！醍醐灌顶！！</strong></p>\n<p>vue2：**Object.defineProperty **遍历递归对象，改造属性getter、setter</p>\n<p>vue3：**Proxy( + Reflect ) **原始类型：类的访问器属性（get value(…){}, set value(…){}）</p>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>Vue 2</strong></th>\n<th><strong>Vue 3</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>实现方式</strong></td>\n<td>Object.defineProperty</td>\n<td>Proxy</td>\n</tr>\n<tr>\n<td><strong>检测范围</strong></td>\n<td>仅能劫持已有属性</td>\n<td>可拦截对象所有操作</td>\n</tr>\n<tr>\n<td><strong>数组处理</strong></td>\n<td>重写数组方法</td>\n<td>原生支持数组操作</td>\n</tr>\n<tr>\n<td><strong>新增属性</strong></td>\n<td>需用Vue.set&#x2F;$set&#x2F;$delete</td>\n<td>自动检测</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>递归遍历所有属性初始化</td>\n<td>惰性代理，按需响应</td>\n</tr>\n<tr>\n<td><strong>嵌套对象</strong></td>\n<td>初始化时递归劫持</td>\n<td>访问时递归代理</td>\n</tr>\n</tbody></table>\n<ol>\n<li><strong>数组监测</strong>：<ul>\n<li>Vue 2中需要特殊方法触发更新</li>\n<li>Vue 3中所有数组操作自动触发</li>\n</ul>\n</li>\n<li><strong>动态属性</strong>：<ul>\n<li>Vue 2中需使用Vue.set</li>\n<li>Vue 3中可直接赋值</li>\n</ul>\n</li>\n<li><strong>性能敏感场景</strong>：<ul>\n<li>Vue 3的readonly&#x2F;shallowRef&#x2F;shallowReactive提供更细粒度控制</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"关于一些关键概念（vue2：Watcher-vue3：ReactiveEffect）\"><a href=\"#关于一些关键概念（vue2：Watcher-vue3：ReactiveEffect）\" class=\"headerlink\" title=\"关于一些关键概念（vue2：Watcher &#x2F; vue3：ReactiveEffect）\"></a>关于一些关键概念（vue2：Watcher &#x2F; vue3：ReactiveEffect）</h3><h4 id=\"vue2：Watcher\"><a href=\"#vue2：Watcher\" class=\"headerlink\" title=\"vue2：Watcher\"></a>vue2：Watcher</h4><h5 id=\"一、Watcher-的三种类型与职责\"><a href=\"#一、Watcher-的三种类型与职责\" class=\"headerlink\" title=\"一、Watcher 的三种类型与职责\"></a>一、Watcher 的三种类型与职责</h5><p>Watcher 并不是单一功能的，根据其执行的任务不同，主要分为三种：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>触发场景</th>\n<th>职责</th>\n<th>代码中的体现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>渲染 Watcher</strong></td>\n<td>每个组件实例只有一个</td>\n<td><strong>负责组件的视图更新</strong>。当它依赖的数据变化时，会触发组件的重新渲染（<code>_update</code><br/>）。</td>\n<td>你写的模板中的每一个数据绑定 <code>&#123;&#123; message &#125;&#125;</code><br/>、<code>v-bind</code><br/>，最终都依赖于它。</td>\n</tr>\n<tr>\n<td><strong>计算属性Watcher</strong></td>\n<td>每个 <code>computed</code>属性一个</td>\n<td><strong>监控计算属性所依赖的数据</strong>，依赖变则重新计算计算属性的值，并缓存结果。</td>\n<td>你在 <code>computed</code><br/> 中定义的每一个函数，Vue 都会为其创建一个对应的 Watcher。</td>\n</tr>\n<tr>\n<td><strong>用户 Watcher</strong></td>\n<td>每个 <code>watch</code>选项一个</td>\n<td><strong>监听一个特定的数据变化，并执行用户定义的回调函数</strong>。</td>\n<td></td>\n</tr>\n</tbody></table>\n<h5 id=\"二、Watcher-的工作流程：与-Dep-和-Observer-联动\"><a href=\"#二、Watcher-的工作流程：与-Dep-和-Observer-联动\" class=\"headerlink\" title=\"二、Watcher 的工作流程：与 Dep 和 Observer 联动\"></a>二、Watcher 的工作流程：与 Dep 和 Observer 联动</h5><p><strong>Watcher</strong> 不能单独工作，它必须和 <strong>Observer</strong>（数据劫持者）和 <strong>Dep</strong>（依赖管理器）协同工作。这三者的关系是 Vue 响应式的铁三角。</p>\n<p>让我们用一个经典的流程图来揭示它们是如何协作的，<strong>并以一个简单的模板 <strong><code>**&#123;&#123; user.name &#125;&#125;**</code></strong> 为例</strong>：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/Watcher工作流程.svg\"\n                      alt=\"Watcher工作流程\" height=\"auto\" style=\"width:50%; display:block;\"\n                >\n\n<p>:::tips<br><strong>关键步骤解读</strong>：</p>\n<ol>\n<li><code>**Observer**</code>：通过 <code>Object.defineProperty</code> 将 <code>data</code> 中的每个属性（如 <code>user</code>）转换为 <code>getter</code> 和 <code>setter</code>。</li>\n<li><code>**Dep**</code>：每个被监听的属性都会拥有一个自己的 <code>Dep</code> 实例（依赖管理器），用来存储所有“依赖”这个数据的 <code>Watcher</code>。</li>\n<li><code>**Watcher**</code> 的创建：<ul>\n<li>当 Vue 初始化组件时，会创建一个<strong>渲染 Watcher</strong>。</li>\n<li>这个 Watcher 在执行它的第一个任务（即渲染页面）时，会去读取模板中用到的数据，如 <code>user.name</code>。</li>\n</ul>\n</li>\n<li><strong>依赖收集（Depend）</strong>：<ul>\n<li>读取 <code>user.name</code> 会触发之前定义的 <code>getter</code>。</li>\n<li>在 <code>getter</code> 中，会检查当前是否有正在执行的 Watcher（通过 <code>Dep.target</code> 静态属性指向它）。<strong>有！</strong> 就是刚才创建的渲染 Watcher（W1）。</li>\n<li><code>getter</code> 会调用 <code>dep.depend()</code>，将当前这个 Watcher（W1）<strong>收集</strong>到 <code>user.name</code> 的 Dep 的订阅者列表中。从此，Dep 就知道：“哦，W1 依赖我。”</li>\n</ul>\n</li>\n<li><strong>派发更新（Notify）</strong>：<ul>\n<li>当我们修改数据：<code>user.name = &#39;New&#39;</code> 时，会触发 <code>setter</code>。</li>\n<li><code>setter</code> 会调用 <code>dep.notify()</code>。</li>\n<li><code>dep.notify()</code> 会遍历它收集的所有 Watcher（这里只有 W1），通知它们：“我变了，你们该干活了！”</li>\n</ul>\n</li>\n<li><strong>执行更新</strong>：<ul>\n<li>每个被通知的 Watcher（W1）会执行自己的 <code>update()</code> 方法。</li>\n<li>对于<strong>渲染 Watcher</strong>，这个“干活”就是重新执行组件的渲染函数（<code>render</code>），生成新的虚拟 DOM，然后进行 patch（Diff）更新真实 DOM。页面就这样更新了。</li>\n</ul>\n</li>\n</ol>\n<p>:::</p>\n<h4 id=\"vue3：ReactiveEffect\"><a href=\"#vue3：ReactiveEffect\" class=\"headerlink\" title=\"vue3：ReactiveEffect\"></a>vue3：ReactiveEffect</h4><h5 id=\"一、什么是-ReactiveEffect？\"><a href=\"#一、什么是-ReactiveEffect？\" class=\"headerlink\" title=\"一、什么是 ReactiveEffect？\"></a>一、什么是 ReactiveEffect？</h5><p>它的核心思想来源于函数式编程中的 <strong>“副作用”（Effect）</strong> 概念。任何会“对外部世界”造成影响的操作都是副作用，例如：修改 DOM、发送网络请求、操作本地存储等。</p>\n<p>在 Vue 的上下文中，<strong>最常见的“副作用”就是“渲染视图”</strong>。当响应式数据变化时，我们需要重新执行这个副作用来更新视图。</p>\n<p><code>ReactiveEffect</code> 就是一个<strong>封装了这些副作用函数的对象</strong>。它的职责和 Vue 2 的 <code>Watcher</code> 类似，但设计和实现更加优雅和强大。</p>\n<p><strong>一个极简的 ReactiveEffect 示例：</strong></p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; reactive, effect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>; <span class=\"comment\">// 注意：effect 在 Vue 3 中是一个底层 API</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个 Effect：副作用是打印 count 的值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myEffect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Count is: <span class=\"subst\">$&#123;state.count&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首次手动执行副作用</span></span><br><span class=\"line\">myEffect.<span class=\"title function_\">run</span>(); <span class=\"comment\">// 输出: Count is: 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当 state.count 变化时，这个 effect 会自动重新执行</span></span><br><span class=\"line\">state.<span class=\"property\">count</span>++; <span class=\"comment\">// 自动输出: Count is: 1</span></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>关键点</strong>：</p>\n<ol>\n<li>你创建一个 <code>ReactiveEffect</code> 实例，并传入一个<strong>副作用函数</strong>。</li>\n<li>当你执行 <code>effect.run()</code> 时，Vue 3 会：<ul>\n<li>设置一个全局的“活动效应”（<code>activeEffect</code>）为当前这个 <code>ReactiveEffect</code>。</li>\n<li>然后执行你传入的副作用函数。</li>\n</ul>\n</li>\n<li>在执行过程中，如果副作用函数<strong>读取</strong>了某个响应式数据（如 <code>state.count</code>），就会触发该数据的 <code>getter</code>。</li>\n<li>在 <code>getter</code> 中，Vue 3 会发现当前有一个 <code>activeEffect</code> 正在运行，于是就会<strong>建立依赖关系</strong>：将这个 <code>ReactiveEffect</code> 收集为这个响应式数据的依赖。</li>\n<li>将来该数据<strong>变化</strong>时，就会通知所有依赖它的 <code>ReactiveEffect</code> 实例，调用它们的 <code>run</code> 方法（或调度函数），从而重新执行副作用。</li>\n</ol>\n<h5 id=\"二、ReactiveEffect-与-Vue-2-Watcher-的核心差异\"><a href=\"#二、ReactiveEffect-与-Vue-2-Watcher-的核心差异\" class=\"headerlink\" title=\"二、ReactiveEffect 与 Vue 2 Watcher 的核心差异\"></a>二、ReactiveEffect 与 Vue 2 Watcher 的核心差异</h5><p>虽然目标一致（追踪依赖、执行副作用），但两者在设计和能力上有天壤之别。</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Vue 2 <strong>Watcher</strong></th>\n<th>Vue 3 <strong>ReactiveEffect</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>设计理念</strong></td>\n<td><strong>“全能型员工”</strong>   与组件实例、选项式 API 强耦合，种类繁多（渲染、计算、用户）。</td>\n<td><strong>“纯粹的工具”</strong>   一个<strong>与上下文无关</strong>的、<strong>单一职责</strong>的副作用封装器。它不知道自己是用于渲染、计算还是监听。</td>\n</tr>\n<tr>\n<td><strong>与组件的关系</strong></td>\n<td><strong>紧密耦合</strong>   每个组件实例必然对应一个渲染 Watcher。Watcher 知道自己是哪个组件的。</td>\n<td><strong>松散耦合</strong>   <code>ReactiveEffect</code><br/> 本身不知道组件。组件的 <code>setup</code><br/> 函数本身就是一个大的 <code>ReactiveEffect</code><br/>。</td>\n</tr>\n<tr>\n<td><strong>依赖收集</strong></td>\n<td><strong>显式、侵入式</strong>   通过 <code>Dep</code><br/> 类和 <code>pushTarget</code><br/>&#x2F;<code>popTarget</code><br/> 等全局状态管理。</td>\n<td><strong>隐式、基于栈</strong>   通过全局变量 <code>activeEffect</code><br/> 和 <code>effectStack</code><br/> 来追踪当前正在运行的 effect，更加清晰可靠。</td>\n</tr>\n<tr>\n<td><strong>功能与灵活性</strong></td>\n<td><strong>功能固定</strong>   种类和行为在创建时就确定了（如 <code>lazy</code><br/>, <code>sync</code><br/> 等配置）。</td>\n<td><strong>极其灵活</strong>   通过 <code>**scheduler**</code><br/>** **<strong>调度器</strong> 实现各种高级功能（如 <code>computed</code><br/> 的懒计算、<code>watch</code><br/> 的异步回调）。</td>\n</tr>\n<tr>\n<td><strong>性能优化</strong></td>\n<td><strong>较差</strong>   在依赖收集阶段需要频繁创建和遍历 Dep 实例。</td>\n<td><strong>更优</strong>   使用 <code>Set</code><br/> 和 <code>Map</code><br/> 等原生数据结构管理依赖，效率更高。依赖关系更精细。</td>\n</tr>\n</tbody></table>\n<hr>\n<h5 id=\"三、最重要的差异：调度器-scheduler\"><a href=\"#三、最重要的差异：调度器-scheduler\" class=\"headerlink\" title=\"三、最重要的差异：调度器 (scheduler)\"></a>三、最重要的差异：调度器 (scheduler)</h5><p>这是 <code>ReactiveEffect</code> 相比 <code>Watcher</code> 最强大的设计优势。</p>\n<p>在创建 <code>ReactiveEffect</code> 时，你可以传入一个 <code>**scheduler**</code>** <strong><strong>函数</strong>。当依赖变化时，<strong>默认行为是直接调用</strong></strong> <strong><code>**effect.run()**</code>，但如果你提供了 <code>scheduler</code>，则会</strong>改为调用**** <strong><code>**scheduler(effect)**</code>，把</strong>何时、如何执行副作用**的控制权完全交给了你。</p>\n<p><strong>正是这个</strong>** <strong><code>**scheduler**</code></strong>，实现了 Vue 3 的所有高级特性：**</p>\n<p>**1. 实现 **<code>**computed**</code></p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">computed</span>(<span class=\"params\">getter</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> dirty = <span class=\"literal\">true</span>; <span class=\"comment\">// 标记是否需要重新计算</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 1. 创建一个“懒执行”的 effect</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> effect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(getter, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 这个 scheduler 只标记 dirty，但不立刻计算值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!dirty) &#123;</span><br><span class=\"line\">      dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 3. 通知依赖此 computed 的 effect 更新（例如模板）</span></span><br><span class=\"line\">      <span class=\"title function_\">trigger</span>(computedRef, <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">SET</span>, <span class=\"string\">&#x27;value&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> computedRef = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (dirty) &#123;</span><br><span class=\"line\">        value = effect.<span class=\"title function_\">run</span>(); <span class=\"comment\">// 只有在需要时才执行计算</span></span><br><span class=\"line\">        dirty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"title function_\">track</span>(computedRef, <span class=\"title class_\">TrackOpTypes</span>.<span class=\"property\">GET</span>, <span class=\"string\">&#x27;value&#x27;</span>); <span class=\"comment\">// 收集依赖</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> computedRef;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>**2. 实现 <strong><code>**watch**</code></strong> &#x2F; **<code>**watchEffect**</code></p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">watch</span>(<span class=\"params\">source, cb, options</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"title function_\">getter</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title function_\">source</span>();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldValue;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// scheduler 决定回调的执行时机（同步、异步、前置等）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">scheduler</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.<span class=\"property\">flush</span> === <span class=\"string\">&#x27;sync&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 同步执行</span></span><br><span class=\"line\">      <span class=\"title function_\">run</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 异步执行（默认是 &#x27;pre&#x27;，在组件更新前）</span></span><br><span class=\"line\">      <span class=\"title function_\">queueJob</span>(run);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> effect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(getter, scheduler); <span class=\"comment\">// 传入 scheduler!</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">run</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> newValue = effect.<span class=\"title function_\">run</span>();</span><br><span class=\"line\">    <span class=\"title function_\">cb</span>(newValue, oldValue); <span class=\"comment\">// 执行用户回调</span></span><br><span class=\"line\">    oldValue = newValue;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  effect.<span class=\"title function_\">run</span>(); <span class=\"comment\">// 首次运行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>3. 实现组件的异步更新队列</strong></p>\n<p>组件的渲染本身也是一个 <code>ReactiveEffect</code>。它的 <code>scheduler</code> 是一个将渲染任务推入<strong>异步队列</strong>的函数，这才实现了 Vue “批量更新”和“异步更新”的特性。</p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 组件更新 effect</span><br><span class=\"line\">const updateEffect = new ReactiveEffect(</span><br><span class=\"line\">  componentUpdateFn, // 副作用：组件渲染函数</span><br><span class=\"line\">  () =&gt; queueJob(updateEffect) // scheduler: 不是立即执行，而是放入队列</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h5 id=\"总结：演进与优势\"><a href=\"#总结：演进与优势\" class=\"headerlink\" title=\"总结：演进与优势\"></a>总结：演进与优势</h5><table>\n<thead>\n<tr>\n<th></th>\n<th>Vue 2 <strong>Watcher</strong></th>\n<th>Vue 3 <strong>ReactiveEffect</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>定位</strong></td>\n<td>一个与组件生命周期绑定的<strong>具体概念</strong></td>\n<td>一个抽象的、可复用的<strong>副作用容器</strong></td>\n</tr>\n<tr>\n<td><strong>设计</strong></td>\n<td><strong>“大而全”</strong>，多种类型，逻辑复杂</td>\n<td><strong>“小而美”</strong>，职责单一，通过<strong>调度器</strong>注入不同行为</td>\n</tr>\n<tr>\n<td><strong>能力</strong></td>\n<td>功能固定，扩展性差</td>\n<td><strong>极其灵活</strong>，通过 <code>scheduler</code><br/> 可实现各种高级异步和控制流程</td>\n</tr>\n<tr>\n<td><strong>关系</strong></td>\n<td><strong>继承与分类</strong>（RenderWatcher, ComputedWatcher…）</td>\n<td><strong>组合与赋能</strong>（一个 Effect + 不同的 scheduler &#x3D; 不同功能）</td>\n</tr>\n</tbody></table>\n<p><strong>结论：</strong><br><code>ReactiveEffect</code> 是 Vue 3 对 <code>Watcher</code> 概念的<strong>一次彻底的重构和升级</strong>。它通过<strong>分离“副作用本身”和“副作用的执行时机（调度）”</strong>，将响应式系统从一个相对僵化的模型解放为一个极其灵活和强大的架构。这种设计不仅使代码更清晰、更易于维护，更重要的是为 <code>computed</code>、<code>watch</code> 以及未来的所有响应式高级功能提供了一个统一而强大的底层基础。</p>\n<h2 id=\"Composition-api-组合式api-和-Options-api-选项式api\"><a href=\"#Composition-api-组合式api-和-Options-api-选项式api\" class=\"headerlink\" title=\"Composition api (组合式api) 和 Options api (选项式api)\"></a>Composition api (组合式api) 和 Options api (选项式api)</h2><ol>\n<li>代码组织方式改变</li>\n<li>composition api优势<ul>\n<li>更好的逻辑复用（自定义hooks）</li>\n<li>更灵活的代码组织</li>\n<li>更好的TypeScript支持</li>\n<li>更小的代码打包体积</li>\n</ul>\n</li>\n<li>模板和组件变化</li>\n<li>多根节点支持</li>\n<li>v-model升级：v-model:title&#x3D;”pageTitle”</li>\n<li>组件生命周期变化</li>\n</ol>\n<h2 id=\"Fragment-Teleport-Suspense\"><a href=\"#Fragment-Teleport-Suspense\" class=\"headerlink\" title=\"Fragment&#x2F;Teleport&#x2F;Suspense\"></a>Fragment&#x2F;Teleport&#x2F;Suspense</h2><ul>\n<li>Fragment：多根节点组件</li>\n<li>Teleport：将内容渲染到DOM其他位置</li>\n<li>Suspense：异步组件加载状态处理</li>\n</ul>\n<h1 id=\"diff算法\"><a href=\"#diff算法\" class=\"headerlink\" title=\"diff算法\"></a>diff算法</h1>","excerpt":"","more":"<h1 id=\"一个重要的内置关系：\"><a href=\"#一个重要的内置关系：\" class=\"headerlink\" title=\"一个重要的内置关系：\"></a>一个重要的内置关系：</h1><p><strong>VueComponent.prototype.<strong>proto</strong>&#x3D;Vue.prototype</strong></p>\n<p><strong>让组建实例对象（vc）可以访问到 Vue 原型上的属性、方法</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/vue_prototype.png\"\n                      alt=\"vm、vc的原型关系\"\n                ></p>\n<h1 id=\"关于不同版本的Vue：\"><a href=\"#关于不同版本的Vue：\" class=\"headerlink\" title=\"关于不同版本的Vue：\"></a>关于不同版本的Vue：</h1><p><strong><font style=\"background-color:#E7E9E8;\"> vue.js </font></strong> <strong>与 <font style=\"background-color:#E7E9E8;\"> </font></strong><font style=\"background-color:#E7E9E8;\">vue.runtime.xxx.js </font>** 的区别：</p>\n<ol>\n<li><strong><font style=\"background-color:#E7E9E8;\">vue.js</font></strong> 是完整版的vue。包含：核心功能+模板解析器。</li>\n<li><strong><font style=\"background-color:#E7E9E8;\">vue.runtime.xxx.js</font></strong> 是运行版的Vue。只包含：核心功能，没有模板解析器。</li>\n</ol>\n<p>因为 <strong><font style=\"background-color:#E7E9E8;\"> vue.runtime.xxx.js </font></strong> 没有模板解析器，所以 <strong><font style=\"background-color:#E7E9E8;\"> main.js（入口文件）</font></strong> 创建 <strong><font style=\"background-color:#E7E9E8;\"> vue实例（new Vue(…)）</font></strong> 时不能使用 <strong><font style=\"background-color:#E7E9E8;\"> template</font></strong> 配置项，需要使用 <strong><font style=\"background-color:#E7E9E8;\"> render</font></strong> 函数接收到的 <strong><font style=\"background-color:#E7E9E8;\">  createElement </font></strong> 函数去指定具体内容。而 <strong><font style=\"background-color:#E7E9E8;\"> .vue文件 </font></strong> 中的模板字符串语法 <strong><font style=\"background-color:#E7E9E8;\"> <template></template> </font></strong> 是由 <strong><font style=\"background-color:#E7E9E8;\"> vue-template-compiler </font></strong> 去解析的。</p>\n<h1 id=\"Vue-Cli脚手架\"><a href=\"#Vue-Cli脚手架\" class=\"headerlink\" title=\"Vue Cli脚手架\"></a>Vue Cli脚手架</h1><h6 id=\"查看配置\"><a href=\"#查看配置\" class=\"headerlink\" title=\"查看配置\"></a>查看配置</h6><p>Vue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，请执行：<font style=\"background-color:#E7E9E8;\"> </font><strong><font style=\"background-color:#E7E9E8;\">vue inspect &gt; output.js </font></strong></p>\n<p>会在项目根路径下输出一个 **output.js **文件，<strong>注意：该文件仅供查看，修改无效。</strong></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/vue-cli%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE.png\"\n                      alt=\"vue-cli默认配置\"\n                ></p>\n<h6 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h6><p><code>vue.config.js</code> 是一个可选的配置文件，如果项目的 (和 <code>package.json</code> 同级的) 根目录中存在这个文件，那么它会被 <code>@vue/cli-service</code> 自动加载。可以对脚手架进行个性化定制，详情见vue-cli文档：<a class=\"link\"   href=\"https://cli.vuejs.org/zh/config/\" >https://cli.vuejs.org/zh/config/<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<h1 id=\"vue2与vue3\"><a href=\"#vue2与vue3\" class=\"headerlink\" title=\"vue2与vue3\"></a>vue2与vue3</h1><h2 id=\"响应式实现：\"><a href=\"#响应式实现：\" class=\"headerlink\" title=\"响应式实现：\"></a>响应式实现：</h2><p><a class=\"link\"   href=\"https://juejin.cn/post/7124351370521477128?searchId=20250818012335EC20BB0273AF51843CB1\" >面试官的步步紧逼：Vue2 和 Vue3 的响应式原理比对<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a><strong>（超绝文章！醍醐灌顶！！</strong></p>\n<p>vue2：**Object.defineProperty **遍历递归对象，改造属性getter、setter</p>\n<p>vue3：**Proxy( + Reflect ) **原始类型：类的访问器属性（get value(…){}, set value(…){}）</p>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>Vue 2</strong></th>\n<th><strong>Vue 3</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>实现方式</strong></td>\n<td>Object.defineProperty</td>\n<td>Proxy</td>\n</tr>\n<tr>\n<td><strong>检测范围</strong></td>\n<td>仅能劫持已有属性</td>\n<td>可拦截对象所有操作</td>\n</tr>\n<tr>\n<td><strong>数组处理</strong></td>\n<td>重写数组方法</td>\n<td>原生支持数组操作</td>\n</tr>\n<tr>\n<td><strong>新增属性</strong></td>\n<td>需用Vue.set&#x2F;$set&#x2F;$delete</td>\n<td>自动检测</td>\n</tr>\n<tr>\n<td><strong>性能</strong></td>\n<td>递归遍历所有属性初始化</td>\n<td>惰性代理，按需响应</td>\n</tr>\n<tr>\n<td><strong>嵌套对象</strong></td>\n<td>初始化时递归劫持</td>\n<td>访问时递归代理</td>\n</tr>\n</tbody></table>\n<ol>\n<li><strong>数组监测</strong>：<ul>\n<li>Vue 2中需要特殊方法触发更新</li>\n<li>Vue 3中所有数组操作自动触发</li>\n</ul>\n</li>\n<li><strong>动态属性</strong>：<ul>\n<li>Vue 2中需使用Vue.set</li>\n<li>Vue 3中可直接赋值</li>\n</ul>\n</li>\n<li><strong>性能敏感场景</strong>：<ul>\n<li>Vue 3的readonly&#x2F;shallowRef&#x2F;shallowReactive提供更细粒度控制</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"关于一些关键概念（vue2：Watcher-vue3：ReactiveEffect）\"><a href=\"#关于一些关键概念（vue2：Watcher-vue3：ReactiveEffect）\" class=\"headerlink\" title=\"关于一些关键概念（vue2：Watcher &#x2F; vue3：ReactiveEffect）\"></a>关于一些关键概念（vue2：Watcher &#x2F; vue3：ReactiveEffect）</h3><h4 id=\"vue2：Watcher\"><a href=\"#vue2：Watcher\" class=\"headerlink\" title=\"vue2：Watcher\"></a>vue2：Watcher</h4><h5 id=\"一、Watcher-的三种类型与职责\"><a href=\"#一、Watcher-的三种类型与职责\" class=\"headerlink\" title=\"一、Watcher 的三种类型与职责\"></a>一、Watcher 的三种类型与职责</h5><p>Watcher 并不是单一功能的，根据其执行的任务不同，主要分为三种：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>触发场景</th>\n<th>职责</th>\n<th>代码中的体现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>渲染 Watcher</strong></td>\n<td>每个组件实例只有一个</td>\n<td><strong>负责组件的视图更新</strong>。当它依赖的数据变化时，会触发组件的重新渲染（<code>_update</code><br/>）。</td>\n<td>你写的模板中的每一个数据绑定 <code>&#123;&#123; message &#125;&#125;</code><br/>、<code>v-bind</code><br/>，最终都依赖于它。</td>\n</tr>\n<tr>\n<td><strong>计算属性Watcher</strong></td>\n<td>每个 <code>computed</code>属性一个</td>\n<td><strong>监控计算属性所依赖的数据</strong>，依赖变则重新计算计算属性的值，并缓存结果。</td>\n<td>你在 <code>computed</code><br/> 中定义的每一个函数，Vue 都会为其创建一个对应的 Watcher。</td>\n</tr>\n<tr>\n<td><strong>用户 Watcher</strong></td>\n<td>每个 <code>watch</code>选项一个</td>\n<td><strong>监听一个特定的数据变化，并执行用户定义的回调函数</strong>。</td>\n<td></td>\n</tr>\n</tbody></table>\n<h5 id=\"二、Watcher-的工作流程：与-Dep-和-Observer-联动\"><a href=\"#二、Watcher-的工作流程：与-Dep-和-Observer-联动\" class=\"headerlink\" title=\"二、Watcher 的工作流程：与 Dep 和 Observer 联动\"></a>二、Watcher 的工作流程：与 Dep 和 Observer 联动</h5><p><strong>Watcher</strong> 不能单独工作，它必须和 <strong>Observer</strong>（数据劫持者）和 <strong>Dep</strong>（依赖管理器）协同工作。这三者的关系是 Vue 响应式的铁三角。</p>\n<p>让我们用一个经典的流程图来揭示它们是如何协作的，<strong>并以一个简单的模板 <strong><code>**&#123;&#123; user.name &#125;&#125;**</code></strong> 为例</strong>：</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/Watcher工作流程.svg\"\n                      alt=\"Watcher工作流程\" height=\"auto\" style=\"width:50%; display:block;\"\n                >\n\n<p>:::tips<br><strong>关键步骤解读</strong>：</p>\n<ol>\n<li><code>**Observer**</code>：通过 <code>Object.defineProperty</code> 将 <code>data</code> 中的每个属性（如 <code>user</code>）转换为 <code>getter</code> 和 <code>setter</code>。</li>\n<li><code>**Dep**</code>：每个被监听的属性都会拥有一个自己的 <code>Dep</code> 实例（依赖管理器），用来存储所有“依赖”这个数据的 <code>Watcher</code>。</li>\n<li><code>**Watcher**</code> 的创建：<ul>\n<li>当 Vue 初始化组件时，会创建一个<strong>渲染 Watcher</strong>。</li>\n<li>这个 Watcher 在执行它的第一个任务（即渲染页面）时，会去读取模板中用到的数据，如 <code>user.name</code>。</li>\n</ul>\n</li>\n<li><strong>依赖收集（Depend）</strong>：<ul>\n<li>读取 <code>user.name</code> 会触发之前定义的 <code>getter</code>。</li>\n<li>在 <code>getter</code> 中，会检查当前是否有正在执行的 Watcher（通过 <code>Dep.target</code> 静态属性指向它）。<strong>有！</strong> 就是刚才创建的渲染 Watcher（W1）。</li>\n<li><code>getter</code> 会调用 <code>dep.depend()</code>，将当前这个 Watcher（W1）<strong>收集</strong>到 <code>user.name</code> 的 Dep 的订阅者列表中。从此，Dep 就知道：“哦，W1 依赖我。”</li>\n</ul>\n</li>\n<li><strong>派发更新（Notify）</strong>：<ul>\n<li>当我们修改数据：<code>user.name = &#39;New&#39;</code> 时，会触发 <code>setter</code>。</li>\n<li><code>setter</code> 会调用 <code>dep.notify()</code>。</li>\n<li><code>dep.notify()</code> 会遍历它收集的所有 Watcher（这里只有 W1），通知它们：“我变了，你们该干活了！”</li>\n</ul>\n</li>\n<li><strong>执行更新</strong>：<ul>\n<li>每个被通知的 Watcher（W1）会执行自己的 <code>update()</code> 方法。</li>\n<li>对于<strong>渲染 Watcher</strong>，这个“干活”就是重新执行组件的渲染函数（<code>render</code>），生成新的虚拟 DOM，然后进行 patch（Diff）更新真实 DOM。页面就这样更新了。</li>\n</ul>\n</li>\n</ol>\n<p>:::</p>\n<h4 id=\"vue3：ReactiveEffect\"><a href=\"#vue3：ReactiveEffect\" class=\"headerlink\" title=\"vue3：ReactiveEffect\"></a>vue3：ReactiveEffect</h4><h5 id=\"一、什么是-ReactiveEffect？\"><a href=\"#一、什么是-ReactiveEffect？\" class=\"headerlink\" title=\"一、什么是 ReactiveEffect？\"></a>一、什么是 ReactiveEffect？</h5><p>它的核心思想来源于函数式编程中的 <strong>“副作用”（Effect）</strong> 概念。任何会“对外部世界”造成影响的操作都是副作用，例如：修改 DOM、发送网络请求、操作本地存储等。</p>\n<p>在 Vue 的上下文中，<strong>最常见的“副作用”就是“渲染视图”</strong>。当响应式数据变化时，我们需要重新执行这个副作用来更新视图。</p>\n<p><code>ReactiveEffect</code> 就是一个<strong>封装了这些副作用函数的对象</strong>。它的职责和 Vue 2 的 <code>Watcher</code> 类似，但设计和实现更加优雅和强大。</p>\n<p><strong>一个极简的 ReactiveEffect 示例：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; reactive, effect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>; <span class=\"comment\">// 注意：effect 在 Vue 3 中是一个底层 API</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> state = <span class=\"title function_\">reactive</span>(&#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个 Effect：副作用是打印 count 的值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myEffect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Count is: <span class=\"subst\">$&#123;state.count&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首次手动执行副作用</span></span><br><span class=\"line\">myEffect.<span class=\"title function_\">run</span>(); <span class=\"comment\">// 输出: Count is: 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当 state.count 变化时，这个 effect 会自动重新执行</span></span><br><span class=\"line\">state.<span class=\"property\">count</span>++; <span class=\"comment\">// 自动输出: Count is: 1</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>关键点</strong>：</p>\n<ol>\n<li>你创建一个 <code>ReactiveEffect</code> 实例，并传入一个<strong>副作用函数</strong>。</li>\n<li>当你执行 <code>effect.run()</code> 时，Vue 3 会：<ul>\n<li>设置一个全局的“活动效应”（<code>activeEffect</code>）为当前这个 <code>ReactiveEffect</code>。</li>\n<li>然后执行你传入的副作用函数。</li>\n</ul>\n</li>\n<li>在执行过程中，如果副作用函数<strong>读取</strong>了某个响应式数据（如 <code>state.count</code>），就会触发该数据的 <code>getter</code>。</li>\n<li>在 <code>getter</code> 中，Vue 3 会发现当前有一个 <code>activeEffect</code> 正在运行，于是就会<strong>建立依赖关系</strong>：将这个 <code>ReactiveEffect</code> 收集为这个响应式数据的依赖。</li>\n<li>将来该数据<strong>变化</strong>时，就会通知所有依赖它的 <code>ReactiveEffect</code> 实例，调用它们的 <code>run</code> 方法（或调度函数），从而重新执行副作用。</li>\n</ol>\n<h5 id=\"二、ReactiveEffect-与-Vue-2-Watcher-的核心差异\"><a href=\"#二、ReactiveEffect-与-Vue-2-Watcher-的核心差异\" class=\"headerlink\" title=\"二、ReactiveEffect 与 Vue 2 Watcher 的核心差异\"></a>二、ReactiveEffect 与 Vue 2 Watcher 的核心差异</h5><p>虽然目标一致（追踪依赖、执行副作用），但两者在设计和能力上有天壤之别。</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Vue 2 <strong>Watcher</strong></th>\n<th>Vue 3 <strong>ReactiveEffect</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>设计理念</strong></td>\n<td><strong>“全能型员工”</strong>   与组件实例、选项式 API 强耦合，种类繁多（渲染、计算、用户）。</td>\n<td><strong>“纯粹的工具”</strong>   一个<strong>与上下文无关</strong>的、<strong>单一职责</strong>的副作用封装器。它不知道自己是用于渲染、计算还是监听。</td>\n</tr>\n<tr>\n<td><strong>与组件的关系</strong></td>\n<td><strong>紧密耦合</strong>   每个组件实例必然对应一个渲染 Watcher。Watcher 知道自己是哪个组件的。</td>\n<td><strong>松散耦合</strong>   <code>ReactiveEffect</code><br/> 本身不知道组件。组件的 <code>setup</code><br/> 函数本身就是一个大的 <code>ReactiveEffect</code><br/>。</td>\n</tr>\n<tr>\n<td><strong>依赖收集</strong></td>\n<td><strong>显式、侵入式</strong>   通过 <code>Dep</code><br/> 类和 <code>pushTarget</code><br/>&#x2F;<code>popTarget</code><br/> 等全局状态管理。</td>\n<td><strong>隐式、基于栈</strong>   通过全局变量 <code>activeEffect</code><br/> 和 <code>effectStack</code><br/> 来追踪当前正在运行的 effect，更加清晰可靠。</td>\n</tr>\n<tr>\n<td><strong>功能与灵活性</strong></td>\n<td><strong>功能固定</strong>   种类和行为在创建时就确定了（如 <code>lazy</code><br/>, <code>sync</code><br/> 等配置）。</td>\n<td><strong>极其灵活</strong>   通过 <code>**scheduler**</code><br/>** **<strong>调度器</strong> 实现各种高级功能（如 <code>computed</code><br/> 的懒计算、<code>watch</code><br/> 的异步回调）。</td>\n</tr>\n<tr>\n<td><strong>性能优化</strong></td>\n<td><strong>较差</strong>   在依赖收集阶段需要频繁创建和遍历 Dep 实例。</td>\n<td><strong>更优</strong>   使用 <code>Set</code><br/> 和 <code>Map</code><br/> 等原生数据结构管理依赖，效率更高。依赖关系更精细。</td>\n</tr>\n</tbody></table>\n<hr>\n<h5 id=\"三、最重要的差异：调度器-scheduler\"><a href=\"#三、最重要的差异：调度器-scheduler\" class=\"headerlink\" title=\"三、最重要的差异：调度器 (scheduler)\"></a>三、最重要的差异：调度器 (scheduler)</h5><p>这是 <code>ReactiveEffect</code> 相比 <code>Watcher</code> 最强大的设计优势。</p>\n<p>在创建 <code>ReactiveEffect</code> 时，你可以传入一个 <code>**scheduler**</code>** <strong><strong>函数</strong>。当依赖变化时，<strong>默认行为是直接调用</strong></strong> <strong><code>**effect.run()**</code>，但如果你提供了 <code>scheduler</code>，则会</strong>改为调用**** <strong><code>**scheduler(effect)**</code>，把</strong>何时、如何执行副作用**的控制权完全交给了你。</p>\n<p><strong>正是这个</strong>** <strong><code>**scheduler**</code></strong>，实现了 Vue 3 的所有高级特性：**</p>\n<p>**1. 实现 **<code>**computed**</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">computed</span>(<span class=\"params\">getter</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> dirty = <span class=\"literal\">true</span>; <span class=\"comment\">// 标记是否需要重新计算</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 1. 创建一个“懒执行”的 effect</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> effect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(getter, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 2. 这个 scheduler 只标记 dirty，但不立刻计算值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!dirty) &#123;</span><br><span class=\"line\">      dirty = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 3. 通知依赖此 computed 的 effect 更新（例如模板）</span></span><br><span class=\"line\">      <span class=\"title function_\">trigger</span>(computedRef, <span class=\"title class_\">TriggerOpTypes</span>.<span class=\"property\">SET</span>, <span class=\"string\">&#x27;value&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> computedRef = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> <span class=\"title function_\">value</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (dirty) &#123;</span><br><span class=\"line\">        value = effect.<span class=\"title function_\">run</span>(); <span class=\"comment\">// 只有在需要时才执行计算</span></span><br><span class=\"line\">        dirty = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"title function_\">track</span>(computedRef, <span class=\"title class_\">TrackOpTypes</span>.<span class=\"property\">GET</span>, <span class=\"string\">&#x27;value&#x27;</span>); <span class=\"comment\">// 收集依赖</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> computedRef;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>**2. 实现 <strong><code>**watch**</code></strong> &#x2F; **<code>**watchEffect**</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">watch</span>(<span class=\"params\">source, cb, options</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> <span class=\"title function_\">getter</span> = (<span class=\"params\"></span>) =&gt; <span class=\"title function_\">source</span>();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> oldValue;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// scheduler 决定回调的执行时机（同步、异步、前置等）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">scheduler</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (options.<span class=\"property\">flush</span> === <span class=\"string\">&#x27;sync&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 同步执行</span></span><br><span class=\"line\">      <span class=\"title function_\">run</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 异步执行（默认是 &#x27;pre&#x27;，在组件更新前）</span></span><br><span class=\"line\">      <span class=\"title function_\">queueJob</span>(run);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> effect = <span class=\"keyword\">new</span> <span class=\"title class_\">ReactiveEffect</span>(getter, scheduler); <span class=\"comment\">// 传入 scheduler!</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">run</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> newValue = effect.<span class=\"title function_\">run</span>();</span><br><span class=\"line\">    <span class=\"title function_\">cb</span>(newValue, oldValue); <span class=\"comment\">// 执行用户回调</span></span><br><span class=\"line\">    oldValue = newValue;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  effect.<span class=\"title function_\">run</span>(); <span class=\"comment\">// 首次运行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>3. 实现组件的异步更新队列</strong></p>\n<p>组件的渲染本身也是一个 <code>ReactiveEffect</code>。它的 <code>scheduler</code> 是一个将渲染任务推入<strong>异步队列</strong>的函数，这才实现了 Vue “批量更新”和“异步更新”的特性。</p>\n<p>javascript</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 组件更新 effect</span><br><span class=\"line\">const updateEffect = new ReactiveEffect(</span><br><span class=\"line\">  componentUpdateFn, // 副作用：组件渲染函数</span><br><span class=\"line\">  () =&gt; queueJob(updateEffect) // scheduler: 不是立即执行，而是放入队列</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h5 id=\"总结：演进与优势\"><a href=\"#总结：演进与优势\" class=\"headerlink\" title=\"总结：演进与优势\"></a>总结：演进与优势</h5><table>\n<thead>\n<tr>\n<th></th>\n<th>Vue 2 <strong>Watcher</strong></th>\n<th>Vue 3 <strong>ReactiveEffect</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>定位</strong></td>\n<td>一个与组件生命周期绑定的<strong>具体概念</strong></td>\n<td>一个抽象的、可复用的<strong>副作用容器</strong></td>\n</tr>\n<tr>\n<td><strong>设计</strong></td>\n<td><strong>“大而全”</strong>，多种类型，逻辑复杂</td>\n<td><strong>“小而美”</strong>，职责单一，通过<strong>调度器</strong>注入不同行为</td>\n</tr>\n<tr>\n<td><strong>能力</strong></td>\n<td>功能固定，扩展性差</td>\n<td><strong>极其灵活</strong>，通过 <code>scheduler</code><br/> 可实现各种高级异步和控制流程</td>\n</tr>\n<tr>\n<td><strong>关系</strong></td>\n<td><strong>继承与分类</strong>（RenderWatcher, ComputedWatcher…）</td>\n<td><strong>组合与赋能</strong>（一个 Effect + 不同的 scheduler &#x3D; 不同功能）</td>\n</tr>\n</tbody></table>\n<p><strong>结论：</strong><br><code>ReactiveEffect</code> 是 Vue 3 对 <code>Watcher</code> 概念的<strong>一次彻底的重构和升级</strong>。它通过<strong>分离“副作用本身”和“副作用的执行时机（调度）”</strong>，将响应式系统从一个相对僵化的模型解放为一个极其灵活和强大的架构。这种设计不仅使代码更清晰、更易于维护，更重要的是为 <code>computed</code>、<code>watch</code> 以及未来的所有响应式高级功能提供了一个统一而强大的底层基础。</p>\n<h2 id=\"Composition-api-组合式api-和-Options-api-选项式api\"><a href=\"#Composition-api-组合式api-和-Options-api-选项式api\" class=\"headerlink\" title=\"Composition api (组合式api) 和 Options api (选项式api)\"></a>Composition api (组合式api) 和 Options api (选项式api)</h2><ol>\n<li>代码组织方式改变</li>\n<li>composition api优势<ul>\n<li>更好的逻辑复用（自定义hooks）</li>\n<li>更灵活的代码组织</li>\n<li>更好的TypeScript支持</li>\n<li>更小的代码打包体积</li>\n</ul>\n</li>\n<li>模板和组件变化</li>\n<li>多根节点支持</li>\n<li>v-model升级：v-model:title&#x3D;”pageTitle”</li>\n<li>组件生命周期变化</li>\n</ol>\n<h2 id=\"Fragment-Teleport-Suspense\"><a href=\"#Fragment-Teleport-Suspense\" class=\"headerlink\" title=\"Fragment&#x2F;Teleport&#x2F;Suspense\"></a>Fragment&#x2F;Teleport&#x2F;Suspense</h2><ul>\n<li>Fragment：多根节点组件</li>\n<li>Teleport：将内容渲染到DOM其他位置</li>\n<li>Suspense：异步组件加载状态处理</li>\n</ul>\n<h1 id=\"diff算法\"><a href=\"#diff算法\" class=\"headerlink\" title=\"diff算法\"></a>diff算法</h1>","_processedHighlight":true},{"title":"浏览器渲染机制","date":"2023-12-15T16:00:00.000Z","_content":"\n#### 参考视频\n1. [浏览器渲染页面的流程](https://www.bilibili.com/video/BV18f4y1H7Zu/?spm_id_from=333.337.search-card.all.click&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89)\n2. [【干货】浏览器是如何运作的？](https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.337.search-card.all.click&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89)\n\n## 浏览器渲染机制：从 HTML 到像素的完整解析\n### 渲染流水线概览\n<img src=\"/images/浏览器渲染流程.png\" alt=\"浏览器渲染流程\" height=\"auto\" style=\"width:16%; display:block;\">\n\n\n## 详细渲染阶段解析\n### 1. 解析 HTML 构建 DOM 树\n+ **过程**：\n    - 字节 → 字符 → 令牌（token化） → 节点 → DOM 树\n    - 遇到 `<script>` 标签会暂停解析，执行 JavaScript\n+ **优化点**：\n    - 使用 `async` 或 `defer` 属性异步加载脚本\n    - 将脚本放在 body 底部\n\n### 2. 解析 CSS 构建 CSSOM 树\n+ **特点**：\n    - CSS 是渲染阻塞资源\n    - 选择器复杂度影响构建速度\n+ **优化点**：\n    - 精简 CSS 选择器复杂度\n    - 使用媒体查询避免不必要的加载\n\n### 3. 构建渲染树（Render Tree）\n+ **组合过程**：\n    - DOM + CSSOM = 渲染树\n    - 只包含可见节点（排除 `display: none` 等元素）\n+ **关键规则**：\n    - CSS 层叠规则决定最终样式\n\n### 4. 布局（Layout / Reflow）\n+ **计算**：\n    - 确定所有元素的几何位置和尺寸\n    - 基于视口大小计算位置\n+ **触发条件**：\n    - 窗口大小调整\n    - 元素位置/尺寸变化\n    - 字体大小变化\n\n### 5. 分层（Layer）\n+ **分层原因**：\n    - 实现高效动画和滚动\n    - 独立处理不同层\n+ **创建层条件**：\n    - 3D 变换\n    - 视频/Canvas 元素\n    - 有动画的元素\n    - `will-change: transform` 属性\n\n### 6. 绘制（Paint）\n+ **过程**：\n    - 将渲染树转换为像素操作\n    - 生成绘制指令列表\n+ **特点**：\n    - 最耗时的渲染阶段之一\n    - 文本和边框绘制成本高\n\n### 7. 光栅化（Rasterization）\n+ **任务**：\n    - 将绘制指令转换为位图\n    - 在合成线程中执行\n+ **优化**：\n    - 分块光栅化（Tile-based）\n    - GPU 加速\n\n### 8. 合成显示（Compositing）\n+ **过程**：\n    - 合成器线程组合所有层\n    - 通过 IPC 传递给浏览器进程\n    - 最终显示在屏幕上\n+ **优势**：\n    - 避免完整重绘\n    - 高效处理滚动和动画\n\n### 关键渲染路径（Critical Rendering Path）\n![关键渲染路径（Critical Rendering Path）](images/关键渲染路径.png)\n\n### 回流与重绘\n#### 1. 回流（Reflow）\n**定义**：当渲染树（Render Tree）中的一部分或全部因为元素的尺寸、布局、隐藏等改变而需要重新构建的过程称为回流。回流会导致子元素和后续元素重新计算布局，成本很高。  \n**触发条件**（常见）：\n\n+ 页面首次渲染（无法避免）\n+ 浏览器窗口大小改变\n+ 元素尺寸、位置、内容改变（如宽度、高度、内边距变化）\n+ 添加或删除可见的DOM元素\n+ 激活CSS伪类（如`:hover`）\n+ 查询某些属性或调用某些方法（如`offsetWidth`、`scrollTo()`等）  \n**影响**：回流会使浏览器重新计算所有受影响元素的几何属性，然后重新构建渲染树。\n\n---\n\n#### 2. 重绘（Repaint）\n**定义**：当元素的外观（如颜色、背景、边框等）发生改变，但不影响布局时，浏览器会重新绘制元素，这个过程称为重绘。重绘的成本通常小于回流。  \n**触发条件**：\n\n+ 颜色、背景色、边框颜色等样式改变\n+ 文本方向修改\n+ 阴影变化（但不影响布局）\n+ `visibility`属性改变（注意：`display: none`会触发回流，而`visibility: hidden`只触发重绘）\n\n---\n\n#### 关键区别：\n| **特点** | **回流（Reflow）** | **重绘（Repaint）** |\n| --- | --- | --- |\n| **触发原因** | 布局改变（几何属性） | 外观改变（非几何属性） |\n| **性能影响** | 高（涉及子元素和后续元素重新布局） | 低（只重新绘制，不重新计算布局） |\n| **依赖关系** | 必然引起重绘 | 不一定引起回流 |\n\n\n## 渲染性能优化策略\n### 1. 减少渲染阻塞\n+ **CSS**：\n    - 内联关键 CSS\n    - 使用媒体查询分割 CSS\n    - 避免使用 `@import`\n+ **JavaScript**：\n\n```html\n<!-- 推荐写法 -->\n<script defer src=\"script.js\"></script>\n<script async src=\"analytics.js\"></script>\n```\n\n### 2. 优化布局和重绘\n+ **减少回流（Reflow）**：\n    - 避免频繁读写布局属性（offsetTop 等）\n    - 使用 CSS 类批量修改样式\n    - 使用 `position: absolute/fixed` 脱离文档流\n+ **减少重绘（Repaint）**：\n    - 使用 `transform` 和 `opacity` 实现动画\n    - 使用 `will-change` 提示浏览器\n    - 避免使用渐变和阴影等昂贵效果\n\n### 3. 高效利用图层\n+ **图层优化**：\n\n```css\n.animate-element {\n  will-change: transform; /* 提前告知浏览器 */\n  transform: translateZ(0); /* 强制创建新层 */\n}\n```\n\n+ **注意事项**：\n    - 避免过多图层（内存开销）\n    - 平衡图层数量和渲染性能\n\n### 4. 虚拟滚动和列表优化\n+ **大数据集处理**：\n    - 实现虚拟滚动：只渲染可视区域元素\n    - 使用内容分块加载\n    - 懒加载非关键资源\n\n### 5. 性能检测工具\n+ **Chrome DevTools**：\n    - Performance 面板分析渲染瀑布流\n    - Layers 面板查看图层结构\n    - Rendering 面板检测重绘区域\n+ **API**：\n\n```javascript\n// 获取布局性能数据\nconst perfEntries = performance.getEntriesByType(\"layout\");\nperfEntries.forEach(entry => {\n  console.log(`布局耗时: ${entry.duration}ms`);\n});\n```\n\n## 现代浏览器渲染优化技术\n### 1. 合成器线程（Compositor Thread）\n+ 独立于主线程运行（浏览器渲染进程的主线程）\n+ 处理滚动、动画等无需 JS 的操作\n+ 直接操作已光栅化的图层\n\n### 2. 时间切片（Time Slicing）\n+ 将大型任务拆分为小任务\n+ 通过 `requestIdleCallback` 实现\n\n```javascript\nfunction processTask() {\n  // 执行小段任务\n  \n  if (hasMoreWork) {\n    requestIdleCallback(processTask);\n  }\n}\nrequestIdleCallback(processTask);\n```\n\n### 3. 增量渲染\n+ 逐步显示部分渲染内容\n+ 优先渲染视口内内容\n+ 后台继续处理剩余内容\n\n### 4. GPU 加速\n+ 使用 CSS 硬件加速：\n\n```css\n.accelerated {\n  transform: translate3d(0, 0, 0);\n  /* 或者 */\n  backface-visibility: hidden;\n}\n```\n\n+ 将渲染工作转移到 GPU\n\n## 渲染过程中的 JavaScript 交互\n### JS 执行对渲染的影响\n+ **同步 JS**：\n    - 阻塞 DOM 构建\n    - 延迟页面渲染\n+ **异步 JS**：\n    - `defer`：HTML 解析完成后执行\n    - `async`：下载完成后立即执行\n\n### 事件循环与渲染协调\n+ **处理模型**：\n    1. 执行 JavaScript 任务\n    2. 处理微任务队列\n    3. 执行渲染步骤（可选）\n    4. 处理宏任务队列\n+ **requestAnimationFrame**：\n\n```javascript\nfunction update() {\n  // 在渲染前更新动画\n  element.style.transform = `translateX(${position}px)`;\n\n  position += 5;\n  if (position < 300) {\n    requestAnimationFrame(update);\n  }\n}\nrequestAnimationFrame(update);\n```\n\n最佳时机：在浏览器重绘前执行动画更新\n\n## 移动端渲染的特殊考虑\n### 触摸事件处理：\n    - 300ms 点击延迟问题\n    - 使用 `touch-action` 优化滚动\n\n```css\n.scrollable {\n  touch-action: pan-y; /* 只允许垂直滚动 */\n}\n```\n\n### 电池效率优化：\n+ 减少不必要的动画\n+ 使用 `matchMedia` 检测设备能力\n\n```javascript\nconst isLowPower = matchMedia(\"(prefers-reduced-motion: reduce)\").matches;\nif (isLowPower) {\n  // 简化动画效果\n}\n```\n\n### 内存限制：\n    - 移动设备图层内存限制更严格\n    - 避免大型 Canvas 操作\n    - 及时释放不再使用的资源\n\n## 未来趋势：WebGPU 和渲染新特性\n1. **WebGPU**：\n    - 下一代图形 API\n    - 更直接的 GPU 访问\n    - 适用于复杂 3D 和计算任务\n2. **Houdini API**：\n\n```javascript\n// 自定义绘制API示例\nregisterPaint('circle-ripple', class {\n  paint(ctx, size) {\n    ctx.fillStyle = 'rgba(255,0,0,0.5)';\n    ctx.beginPath();\n    ctx.arc(size.width/2, size.height/2, 50, 0, 2*Math.PI);\n    ctx.fill();\n  }\n});\n```\n\n    - 使开发者能介入渲染管线\n    - 创建高性能自定义渲染效果\n3. **OffscreenCanvas**：\n    - 在 Web Worker 中执行 Canvas 操作\n    - 避免阻塞主线程\n\n```javascript\nconst offscreen = canvas.transferControlToOffscreen();\nworker.postMessage({ canvas: offscreen }, [offscreen]);\n```\n\n","source":"_posts/浏览器渲染机制.md","raw":"---\ntitle: 浏览器渲染机制\ndate: 2023-12-16\ntags: [浏览器渲染机制, js基础]\ncategories: 浏览器渲染机制\n---\n\n#### 参考视频\n1. [浏览器渲染页面的流程](https://www.bilibili.com/video/BV18f4y1H7Zu/?spm_id_from=333.337.search-card.all.click&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89)\n2. [【干货】浏览器是如何运作的？](https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.337.search-card.all.click&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89)\n\n## 浏览器渲染机制：从 HTML 到像素的完整解析\n### 渲染流水线概览\n<img src=\"/images/浏览器渲染流程.png\" alt=\"浏览器渲染流程\" height=\"auto\" style=\"width:16%; display:block;\">\n\n\n## 详细渲染阶段解析\n### 1. 解析 HTML 构建 DOM 树\n+ **过程**：\n    - 字节 → 字符 → 令牌（token化） → 节点 → DOM 树\n    - 遇到 `<script>` 标签会暂停解析，执行 JavaScript\n+ **优化点**：\n    - 使用 `async` 或 `defer` 属性异步加载脚本\n    - 将脚本放在 body 底部\n\n### 2. 解析 CSS 构建 CSSOM 树\n+ **特点**：\n    - CSS 是渲染阻塞资源\n    - 选择器复杂度影响构建速度\n+ **优化点**：\n    - 精简 CSS 选择器复杂度\n    - 使用媒体查询避免不必要的加载\n\n### 3. 构建渲染树（Render Tree）\n+ **组合过程**：\n    - DOM + CSSOM = 渲染树\n    - 只包含可见节点（排除 `display: none` 等元素）\n+ **关键规则**：\n    - CSS 层叠规则决定最终样式\n\n### 4. 布局（Layout / Reflow）\n+ **计算**：\n    - 确定所有元素的几何位置和尺寸\n    - 基于视口大小计算位置\n+ **触发条件**：\n    - 窗口大小调整\n    - 元素位置/尺寸变化\n    - 字体大小变化\n\n### 5. 分层（Layer）\n+ **分层原因**：\n    - 实现高效动画和滚动\n    - 独立处理不同层\n+ **创建层条件**：\n    - 3D 变换\n    - 视频/Canvas 元素\n    - 有动画的元素\n    - `will-change: transform` 属性\n\n### 6. 绘制（Paint）\n+ **过程**：\n    - 将渲染树转换为像素操作\n    - 生成绘制指令列表\n+ **特点**：\n    - 最耗时的渲染阶段之一\n    - 文本和边框绘制成本高\n\n### 7. 光栅化（Rasterization）\n+ **任务**：\n    - 将绘制指令转换为位图\n    - 在合成线程中执行\n+ **优化**：\n    - 分块光栅化（Tile-based）\n    - GPU 加速\n\n### 8. 合成显示（Compositing）\n+ **过程**：\n    - 合成器线程组合所有层\n    - 通过 IPC 传递给浏览器进程\n    - 最终显示在屏幕上\n+ **优势**：\n    - 避免完整重绘\n    - 高效处理滚动和动画\n\n### 关键渲染路径（Critical Rendering Path）\n![关键渲染路径（Critical Rendering Path）](images/关键渲染路径.png)\n\n### 回流与重绘\n#### 1. 回流（Reflow）\n**定义**：当渲染树（Render Tree）中的一部分或全部因为元素的尺寸、布局、隐藏等改变而需要重新构建的过程称为回流。回流会导致子元素和后续元素重新计算布局，成本很高。  \n**触发条件**（常见）：\n\n+ 页面首次渲染（无法避免）\n+ 浏览器窗口大小改变\n+ 元素尺寸、位置、内容改变（如宽度、高度、内边距变化）\n+ 添加或删除可见的DOM元素\n+ 激活CSS伪类（如`:hover`）\n+ 查询某些属性或调用某些方法（如`offsetWidth`、`scrollTo()`等）  \n**影响**：回流会使浏览器重新计算所有受影响元素的几何属性，然后重新构建渲染树。\n\n---\n\n#### 2. 重绘（Repaint）\n**定义**：当元素的外观（如颜色、背景、边框等）发生改变，但不影响布局时，浏览器会重新绘制元素，这个过程称为重绘。重绘的成本通常小于回流。  \n**触发条件**：\n\n+ 颜色、背景色、边框颜色等样式改变\n+ 文本方向修改\n+ 阴影变化（但不影响布局）\n+ `visibility`属性改变（注意：`display: none`会触发回流，而`visibility: hidden`只触发重绘）\n\n---\n\n#### 关键区别：\n| **特点** | **回流（Reflow）** | **重绘（Repaint）** |\n| --- | --- | --- |\n| **触发原因** | 布局改变（几何属性） | 外观改变（非几何属性） |\n| **性能影响** | 高（涉及子元素和后续元素重新布局） | 低（只重新绘制，不重新计算布局） |\n| **依赖关系** | 必然引起重绘 | 不一定引起回流 |\n\n\n## 渲染性能优化策略\n### 1. 减少渲染阻塞\n+ **CSS**：\n    - 内联关键 CSS\n    - 使用媒体查询分割 CSS\n    - 避免使用 `@import`\n+ **JavaScript**：\n\n```html\n<!-- 推荐写法 -->\n<script defer src=\"script.js\"></script>\n<script async src=\"analytics.js\"></script>\n```\n\n### 2. 优化布局和重绘\n+ **减少回流（Reflow）**：\n    - 避免频繁读写布局属性（offsetTop 等）\n    - 使用 CSS 类批量修改样式\n    - 使用 `position: absolute/fixed` 脱离文档流\n+ **减少重绘（Repaint）**：\n    - 使用 `transform` 和 `opacity` 实现动画\n    - 使用 `will-change` 提示浏览器\n    - 避免使用渐变和阴影等昂贵效果\n\n### 3. 高效利用图层\n+ **图层优化**：\n\n```css\n.animate-element {\n  will-change: transform; /* 提前告知浏览器 */\n  transform: translateZ(0); /* 强制创建新层 */\n}\n```\n\n+ **注意事项**：\n    - 避免过多图层（内存开销）\n    - 平衡图层数量和渲染性能\n\n### 4. 虚拟滚动和列表优化\n+ **大数据集处理**：\n    - 实现虚拟滚动：只渲染可视区域元素\n    - 使用内容分块加载\n    - 懒加载非关键资源\n\n### 5. 性能检测工具\n+ **Chrome DevTools**：\n    - Performance 面板分析渲染瀑布流\n    - Layers 面板查看图层结构\n    - Rendering 面板检测重绘区域\n+ **API**：\n\n```javascript\n// 获取布局性能数据\nconst perfEntries = performance.getEntriesByType(\"layout\");\nperfEntries.forEach(entry => {\n  console.log(`布局耗时: ${entry.duration}ms`);\n});\n```\n\n## 现代浏览器渲染优化技术\n### 1. 合成器线程（Compositor Thread）\n+ 独立于主线程运行（浏览器渲染进程的主线程）\n+ 处理滚动、动画等无需 JS 的操作\n+ 直接操作已光栅化的图层\n\n### 2. 时间切片（Time Slicing）\n+ 将大型任务拆分为小任务\n+ 通过 `requestIdleCallback` 实现\n\n```javascript\nfunction processTask() {\n  // 执行小段任务\n  \n  if (hasMoreWork) {\n    requestIdleCallback(processTask);\n  }\n}\nrequestIdleCallback(processTask);\n```\n\n### 3. 增量渲染\n+ 逐步显示部分渲染内容\n+ 优先渲染视口内内容\n+ 后台继续处理剩余内容\n\n### 4. GPU 加速\n+ 使用 CSS 硬件加速：\n\n```css\n.accelerated {\n  transform: translate3d(0, 0, 0);\n  /* 或者 */\n  backface-visibility: hidden;\n}\n```\n\n+ 将渲染工作转移到 GPU\n\n## 渲染过程中的 JavaScript 交互\n### JS 执行对渲染的影响\n+ **同步 JS**：\n    - 阻塞 DOM 构建\n    - 延迟页面渲染\n+ **异步 JS**：\n    - `defer`：HTML 解析完成后执行\n    - `async`：下载完成后立即执行\n\n### 事件循环与渲染协调\n+ **处理模型**：\n    1. 执行 JavaScript 任务\n    2. 处理微任务队列\n    3. 执行渲染步骤（可选）\n    4. 处理宏任务队列\n+ **requestAnimationFrame**：\n\n```javascript\nfunction update() {\n  // 在渲染前更新动画\n  element.style.transform = `translateX(${position}px)`;\n\n  position += 5;\n  if (position < 300) {\n    requestAnimationFrame(update);\n  }\n}\nrequestAnimationFrame(update);\n```\n\n最佳时机：在浏览器重绘前执行动画更新\n\n## 移动端渲染的特殊考虑\n### 触摸事件处理：\n    - 300ms 点击延迟问题\n    - 使用 `touch-action` 优化滚动\n\n```css\n.scrollable {\n  touch-action: pan-y; /* 只允许垂直滚动 */\n}\n```\n\n### 电池效率优化：\n+ 减少不必要的动画\n+ 使用 `matchMedia` 检测设备能力\n\n```javascript\nconst isLowPower = matchMedia(\"(prefers-reduced-motion: reduce)\").matches;\nif (isLowPower) {\n  // 简化动画效果\n}\n```\n\n### 内存限制：\n    - 移动设备图层内存限制更严格\n    - 避免大型 Canvas 操作\n    - 及时释放不再使用的资源\n\n## 未来趋势：WebGPU 和渲染新特性\n1. **WebGPU**：\n    - 下一代图形 API\n    - 更直接的 GPU 访问\n    - 适用于复杂 3D 和计算任务\n2. **Houdini API**：\n\n```javascript\n// 自定义绘制API示例\nregisterPaint('circle-ripple', class {\n  paint(ctx, size) {\n    ctx.fillStyle = 'rgba(255,0,0,0.5)';\n    ctx.beginPath();\n    ctx.arc(size.width/2, size.height/2, 50, 0, 2*Math.PI);\n    ctx.fill();\n  }\n});\n```\n\n    - 使开发者能介入渲染管线\n    - 创建高性能自定义渲染效果\n3. **OffscreenCanvas**：\n    - 在 Web Worker 中执行 Canvas 操作\n    - 避免阻塞主线程\n\n```javascript\nconst offscreen = canvas.transferControlToOffscreen();\nworker.postMessage({ canvas: offscreen }, [offscreen]);\n```\n\n","slug":"浏览器渲染机制","published":1,"updated":"2025-09-14T14:56:58.859Z","_id":"cmfjszzkf000on05w5jpf77d0","comments":1,"layout":"post","photos":[],"content":"<h4 id=\"参考视频\"><a href=\"#参考视频\" class=\"headerlink\" title=\"参考视频\"></a>参考视频</h4><ol>\n<li><a class=\"link\"   href=\"https://www.bilibili.com/video/BV18f4y1H7Zu/?spm_id_from=333.337.search-card.all.click&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89\" >浏览器渲染页面的流程<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.337.search-card.all.click&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89\" >【干货】浏览器是如何运作的？<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ol>\n<h2 id=\"浏览器渲染机制：从-HTML-到像素的完整解析\"><a href=\"#浏览器渲染机制：从-HTML-到像素的完整解析\" class=\"headerlink\" title=\"浏览器渲染机制：从 HTML 到像素的完整解析\"></a>浏览器渲染机制：从 HTML 到像素的完整解析</h2><h3 id=\"渲染流水线概览\"><a href=\"#渲染流水线概览\" class=\"headerlink\" title=\"渲染流水线概览\"></a>渲染流水线概览</h3><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/浏览器渲染流程.png\"\n                      alt=\"浏览器渲染流程\" height=\"auto\" style=\"width:16%; display:block;\"\n                >\n\n\n<h2 id=\"详细渲染阶段解析\"><a href=\"#详细渲染阶段解析\" class=\"headerlink\" title=\"详细渲染阶段解析\"></a>详细渲染阶段解析</h2><h3 id=\"1-解析-HTML-构建-DOM-树\"><a href=\"#1-解析-HTML-构建-DOM-树\" class=\"headerlink\" title=\"1. 解析 HTML 构建 DOM 树\"></a>1. 解析 HTML 构建 DOM 树</h3><ul>\n<li><strong>过程</strong>：<ul>\n<li>字节 → 字符 → 令牌（token化） → 节点 → DOM 树</li>\n<li>遇到 <code>&lt;script&gt;</code> 标签会暂停解析，执行 JavaScript</li>\n</ul>\n</li>\n<li><strong>优化点</strong>：<ul>\n<li>使用 <code>async</code> 或 <code>defer</code> 属性异步加载脚本</li>\n<li>将脚本放在 body 底部</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-解析-CSS-构建-CSSOM-树\"><a href=\"#2-解析-CSS-构建-CSSOM-树\" class=\"headerlink\" title=\"2. 解析 CSS 构建 CSSOM 树\"></a>2. 解析 CSS 构建 CSSOM 树</h3><ul>\n<li><strong>特点</strong>：<ul>\n<li>CSS 是渲染阻塞资源</li>\n<li>选择器复杂度影响构建速度</li>\n</ul>\n</li>\n<li><strong>优化点</strong>：<ul>\n<li>精简 CSS 选择器复杂度</li>\n<li>使用媒体查询避免不必要的加载</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-构建渲染树（Render-Tree）\"><a href=\"#3-构建渲染树（Render-Tree）\" class=\"headerlink\" title=\"3. 构建渲染树（Render Tree）\"></a>3. 构建渲染树（Render Tree）</h3><ul>\n<li><strong>组合过程</strong>：<ul>\n<li>DOM + CSSOM &#x3D; 渲染树</li>\n<li>只包含可见节点（排除 <code>display: none</code> 等元素）</li>\n</ul>\n</li>\n<li><strong>关键规则</strong>：<ul>\n<li>CSS 层叠规则决定最终样式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-布局（Layout-Reflow）\"><a href=\"#4-布局（Layout-Reflow）\" class=\"headerlink\" title=\"4. 布局（Layout &#x2F; Reflow）\"></a>4. 布局（Layout &#x2F; Reflow）</h3><ul>\n<li><strong>计算</strong>：<ul>\n<li>确定所有元素的几何位置和尺寸</li>\n<li>基于视口大小计算位置</li>\n</ul>\n</li>\n<li><strong>触发条件</strong>：<ul>\n<li>窗口大小调整</li>\n<li>元素位置&#x2F;尺寸变化</li>\n<li>字体大小变化</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-分层（Layer）\"><a href=\"#5-分层（Layer）\" class=\"headerlink\" title=\"5. 分层（Layer）\"></a>5. 分层（Layer）</h3><ul>\n<li><strong>分层原因</strong>：<ul>\n<li>实现高效动画和滚动</li>\n<li>独立处理不同层</li>\n</ul>\n</li>\n<li><strong>创建层条件</strong>：<ul>\n<li>3D 变换</li>\n<li>视频&#x2F;Canvas 元素</li>\n<li>有动画的元素</li>\n<li><code>will-change: transform</code> 属性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-绘制（Paint）\"><a href=\"#6-绘制（Paint）\" class=\"headerlink\" title=\"6. 绘制（Paint）\"></a>6. 绘制（Paint）</h3><ul>\n<li><strong>过程</strong>：<ul>\n<li>将渲染树转换为像素操作</li>\n<li>生成绘制指令列表</li>\n</ul>\n</li>\n<li><strong>特点</strong>：<ul>\n<li>最耗时的渲染阶段之一</li>\n<li>文本和边框绘制成本高</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"7-光栅化（Rasterization）\"><a href=\"#7-光栅化（Rasterization）\" class=\"headerlink\" title=\"7. 光栅化（Rasterization）\"></a>7. 光栅化（Rasterization）</h3><ul>\n<li><strong>任务</strong>：<ul>\n<li>将绘制指令转换为位图</li>\n<li>在合成线程中执行</li>\n</ul>\n</li>\n<li><strong>优化</strong>：<ul>\n<li>分块光栅化（Tile-based）</li>\n<li>GPU 加速</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"8-合成显示（Compositing）\"><a href=\"#8-合成显示（Compositing）\" class=\"headerlink\" title=\"8. 合成显示（Compositing）\"></a>8. 合成显示（Compositing）</h3><ul>\n<li><strong>过程</strong>：<ul>\n<li>合成器线程组合所有层</li>\n<li>通过 IPC 传递给浏览器进程</li>\n<li>最终显示在屏幕上</li>\n</ul>\n</li>\n<li><strong>优势</strong>：<ul>\n<li>避免完整重绘</li>\n<li>高效处理滚动和动画</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"关键渲染路径（Critical-Rendering-Path）\"><a href=\"#关键渲染路径（Critical-Rendering-Path）\" class=\"headerlink\" title=\"关键渲染路径（Critical Rendering Path）\"></a>关键渲染路径（Critical Rendering Path）</h3><p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84.png\"\n                      alt=\"关键渲染路径（Critical Rendering Path）\"\n                ></p>\n<h3 id=\"回流与重绘\"><a href=\"#回流与重绘\" class=\"headerlink\" title=\"回流与重绘\"></a>回流与重绘</h3><h4 id=\"1-回流（Reflow）\"><a href=\"#1-回流（Reflow）\" class=\"headerlink\" title=\"1. 回流（Reflow）\"></a>1. 回流（Reflow）</h4><p><strong>定义</strong>：当渲染树（Render Tree）中的一部分或全部因为元素的尺寸、布局、隐藏等改变而需要重新构建的过程称为回流。回流会导致子元素和后续元素重新计算布局，成本很高。<br><strong>触发条件</strong>（常见）：</p>\n<ul>\n<li>页面首次渲染（无法避免）</li>\n<li>浏览器窗口大小改变</li>\n<li>元素尺寸、位置、内容改变（如宽度、高度、内边距变化）</li>\n<li>添加或删除可见的DOM元素</li>\n<li>激活CSS伪类（如<code>:hover</code>）</li>\n<li>查询某些属性或调用某些方法（如<code>offsetWidth</code>、<code>scrollTo()</code>等）<br><strong>影响</strong>：回流会使浏览器重新计算所有受影响元素的几何属性，然后重新构建渲染树。</li>\n</ul>\n<hr>\n<h4 id=\"2-重绘（Repaint）\"><a href=\"#2-重绘（Repaint）\" class=\"headerlink\" title=\"2. 重绘（Repaint）\"></a>2. 重绘（Repaint）</h4><p><strong>定义</strong>：当元素的外观（如颜色、背景、边框等）发生改变，但不影响布局时，浏览器会重新绘制元素，这个过程称为重绘。重绘的成本通常小于回流。<br><strong>触发条件</strong>：</p>\n<ul>\n<li>颜色、背景色、边框颜色等样式改变</li>\n<li>文本方向修改</li>\n<li>阴影变化（但不影响布局）</li>\n<li><code>visibility</code>属性改变（注意：<code>display: none</code>会触发回流，而<code>visibility: hidden</code>只触发重绘）</li>\n</ul>\n<hr>\n<h4 id=\"关键区别：\"><a href=\"#关键区别：\" class=\"headerlink\" title=\"关键区别：\"></a>关键区别：</h4><table>\n<thead>\n<tr>\n<th><strong>特点</strong></th>\n<th><strong>回流（Reflow）</strong></th>\n<th><strong>重绘（Repaint）</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>触发原因</strong></td>\n<td>布局改变（几何属性）</td>\n<td>外观改变（非几何属性）</td>\n</tr>\n<tr>\n<td><strong>性能影响</strong></td>\n<td>高（涉及子元素和后续元素重新布局）</td>\n<td>低（只重新绘制，不重新计算布局）</td>\n</tr>\n<tr>\n<td><strong>依赖关系</strong></td>\n<td>必然引起重绘</td>\n<td>不一定引起回流</td>\n</tr>\n</tbody></table>\n<h2 id=\"渲染性能优化策略\"><a href=\"#渲染性能优化策略\" class=\"headerlink\" title=\"渲染性能优化策略\"></a>渲染性能优化策略</h2><h3 id=\"1-减少渲染阻塞\"><a href=\"#1-减少渲染阻塞\" class=\"headerlink\" title=\"1. 减少渲染阻塞\"></a>1. 减少渲染阻塞</h3><ul>\n<li><strong>CSS</strong>：<ul>\n<li>内联关键 CSS</li>\n<li>使用媒体查询分割 CSS</li>\n<li>避免使用 <code>@import</code></li>\n</ul>\n</li>\n<li><strong>JavaScript</strong>：</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 推荐写法 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;script.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;analytics.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"2-优化布局和重绘\"><a href=\"#2-优化布局和重绘\" class=\"headerlink\" title=\"2. 优化布局和重绘\"></a>2. 优化布局和重绘</h3><ul>\n<li><strong>减少回流（Reflow）</strong>：<ul>\n<li>避免频繁读写布局属性（offsetTop 等）</li>\n<li>使用 CSS 类批量修改样式</li>\n<li>使用 <code>position: absolute/fixed</code> 脱离文档流</li>\n</ul>\n</li>\n<li><strong>减少重绘（Repaint）</strong>：<ul>\n<li>使用 <code>transform</code> 和 <code>opacity</code> 实现动画</li>\n<li>使用 <code>will-change</code> 提示浏览器</li>\n<li>避免使用渐变和阴影等昂贵效果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-高效利用图层\"><a href=\"#3-高效利用图层\" class=\"headerlink\" title=\"3. 高效利用图层\"></a>3. 高效利用图层</h3><ul>\n<li><strong>图层优化</strong>：</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Css\"><figure class=\"iseeu highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.animate-element</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">will-change</span>: transform; <span class=\"comment\">/* 提前告知浏览器 */</span></span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateZ</span>(<span class=\"number\">0</span>); <span class=\"comment\">/* 强制创建新层 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><strong>注意事项</strong>：<ul>\n<li>避免过多图层（内存开销）</li>\n<li>平衡图层数量和渲染性能</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-虚拟滚动和列表优化\"><a href=\"#4-虚拟滚动和列表优化\" class=\"headerlink\" title=\"4. 虚拟滚动和列表优化\"></a>4. 虚拟滚动和列表优化</h3><ul>\n<li><strong>大数据集处理</strong>：<ul>\n<li>实现虚拟滚动：只渲染可视区域元素</li>\n<li>使用内容分块加载</li>\n<li>懒加载非关键资源</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-性能检测工具\"><a href=\"#5-性能检测工具\" class=\"headerlink\" title=\"5. 性能检测工具\"></a>5. 性能检测工具</h3><ul>\n<li><strong>Chrome DevTools</strong>：<ul>\n<li>Performance 面板分析渲染瀑布流</li>\n<li>Layers 面板查看图层结构</li>\n<li>Rendering 面板检测重绘区域</li>\n</ul>\n</li>\n<li><strong>API</strong>：</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取布局性能数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> perfEntries = performance.<span class=\"title function_\">getEntriesByType</span>(<span class=\"string\">&quot;layout&quot;</span>);</span><br><span class=\"line\">perfEntries.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">entry</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`布局耗时: <span class=\"subst\">$&#123;entry.duration&#125;</span>ms`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"现代浏览器渲染优化技术\"><a href=\"#现代浏览器渲染优化技术\" class=\"headerlink\" title=\"现代浏览器渲染优化技术\"></a>现代浏览器渲染优化技术</h2><h3 id=\"1-合成器线程（Compositor-Thread）\"><a href=\"#1-合成器线程（Compositor-Thread）\" class=\"headerlink\" title=\"1. 合成器线程（Compositor Thread）\"></a>1. 合成器线程（Compositor Thread）</h3><ul>\n<li>独立于主线程运行（浏览器渲染进程的主线程）</li>\n<li>处理滚动、动画等无需 JS 的操作</li>\n<li>直接操作已光栅化的图层</li>\n</ul>\n<h3 id=\"2-时间切片（Time-Slicing）\"><a href=\"#2-时间切片（Time-Slicing）\" class=\"headerlink\" title=\"2. 时间切片（Time Slicing）\"></a>2. 时间切片（Time Slicing）</h3><ul>\n<li>将大型任务拆分为小任务</li>\n<li>通过 <code>requestIdleCallback</code> 实现</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">processTask</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 执行小段任务</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hasMoreWork) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">requestIdleCallback</span>(processTask);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">requestIdleCallback</span>(processTask);</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"3-增量渲染\"><a href=\"#3-增量渲染\" class=\"headerlink\" title=\"3. 增量渲染\"></a>3. 增量渲染</h3><ul>\n<li>逐步显示部分渲染内容</li>\n<li>优先渲染视口内内容</li>\n<li>后台继续处理剩余内容</li>\n</ul>\n<h3 id=\"4-GPU-加速\"><a href=\"#4-GPU-加速\" class=\"headerlink\" title=\"4. GPU 加速\"></a>4. GPU 加速</h3><ul>\n<li>使用 CSS 硬件加速：</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Css\"><figure class=\"iseeu highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.accelerated</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate3d</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* 或者 */</span></span><br><span class=\"line\">  <span class=\"attribute\">backface-visibility</span>: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>将渲染工作转移到 GPU</li>\n</ul>\n<h2 id=\"渲染过程中的-JavaScript-交互\"><a href=\"#渲染过程中的-JavaScript-交互\" class=\"headerlink\" title=\"渲染过程中的 JavaScript 交互\"></a>渲染过程中的 JavaScript 交互</h2><h3 id=\"JS-执行对渲染的影响\"><a href=\"#JS-执行对渲染的影响\" class=\"headerlink\" title=\"JS 执行对渲染的影响\"></a>JS 执行对渲染的影响</h3><ul>\n<li><strong>同步 JS</strong>：<ul>\n<li>阻塞 DOM 构建</li>\n<li>延迟页面渲染</li>\n</ul>\n</li>\n<li><strong>异步 JS</strong>：<ul>\n<li><code>defer</code>：HTML 解析完成后执行</li>\n<li><code>async</code>：下载完成后立即执行</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"事件循环与渲染协调\"><a href=\"#事件循环与渲染协调\" class=\"headerlink\" title=\"事件循环与渲染协调\"></a>事件循环与渲染协调</h3><ul>\n<li><strong>处理模型</strong>：<ol>\n<li>执行 JavaScript 任务</li>\n<li>处理微任务队列</li>\n<li>执行渲染步骤（可选）</li>\n<li>处理宏任务队列</li>\n</ol>\n</li>\n<li><strong>requestAnimationFrame</strong>：</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">update</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在渲染前更新动画</span></span><br><span class=\"line\">  element.<span class=\"property\">style</span>.<span class=\"property\">transform</span> = <span class=\"string\">`translateX(<span class=\"subst\">$&#123;position&#125;</span>px)`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  position += <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">300</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">requestAnimationFrame</span>(update);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">requestAnimationFrame</span>(update);</span><br></pre></td></tr></table></figure></div>\n\n<p>最佳时机：在浏览器重绘前执行动画更新</p>\n<h2 id=\"移动端渲染的特殊考虑\"><a href=\"#移动端渲染的特殊考虑\" class=\"headerlink\" title=\"移动端渲染的特殊考虑\"></a>移动端渲染的特殊考虑</h2><h3 id=\"触摸事件处理：\"><a href=\"#触摸事件处理：\" class=\"headerlink\" title=\"触摸事件处理：\"></a>触摸事件处理：</h3><pre><code>- 300ms 点击延迟问题\n- 使用 `touch-action` 优化滚动\n</code></pre>\n<div class=\"code-container\" data-rel=\"Css\"><figure class=\"iseeu highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.scrollable</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">touch-action</span>: pan-y; <span class=\"comment\">/* 只允许垂直滚动 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"电池效率优化：\"><a href=\"#电池效率优化：\" class=\"headerlink\" title=\"电池效率优化：\"></a>电池效率优化：</h3><ul>\n<li>减少不必要的动画</li>\n<li>使用 <code>matchMedia</code> 检测设备能力</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isLowPower = <span class=\"title function_\">matchMedia</span>(<span class=\"string\">&quot;(prefers-reduced-motion: reduce)&quot;</span>).<span class=\"property\">matches</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (isLowPower) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 简化动画效果</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"内存限制：\"><a href=\"#内存限制：\" class=\"headerlink\" title=\"内存限制：\"></a>内存限制：</h3><pre><code>- 移动设备图层内存限制更严格\n- 避免大型 Canvas 操作\n- 及时释放不再使用的资源\n</code></pre>\n<h2 id=\"未来趋势：WebGPU-和渲染新特性\"><a href=\"#未来趋势：WebGPU-和渲染新特性\" class=\"headerlink\" title=\"未来趋势：WebGPU 和渲染新特性\"></a>未来趋势：WebGPU 和渲染新特性</h2><ol>\n<li><strong>WebGPU</strong>：<ul>\n<li>下一代图形 API</li>\n<li>更直接的 GPU 访问</li>\n<li>适用于复杂 3D 和计算任务</li>\n</ul>\n</li>\n<li><strong>Houdini API</strong>：</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义绘制API示例</span></span><br><span class=\"line\"><span class=\"title function_\">registerPaint</span>(<span class=\"string\">&#x27;circle-ripple&#x27;</span>, <span class=\"keyword\">class</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">paint</span>(<span class=\"params\">ctx, size</span>) &#123;</span><br><span class=\"line\">    ctx.<span class=\"property\">fillStyle</span> = <span class=\"string\">&#x27;rgba(255,0,0,0.5)&#x27;</span>;</span><br><span class=\"line\">    ctx.<span class=\"title function_\">beginPath</span>();</span><br><span class=\"line\">    ctx.<span class=\"title function_\">arc</span>(size.<span class=\"property\">width</span>/<span class=\"number\">2</span>, size.<span class=\"property\">height</span>/<span class=\"number\">2</span>, <span class=\"number\">50</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>*<span class=\"title class_\">Math</span>.<span class=\"property\">PI</span>);</span><br><span class=\"line\">    ctx.<span class=\"title function_\">fill</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<pre><code>- 使开发者能介入渲染管线\n- 创建高性能自定义渲染效果\n</code></pre>\n<ol start=\"3\">\n<li><strong>OffscreenCanvas</strong>：<ul>\n<li>在 Web Worker 中执行 Canvas 操作</li>\n<li>避免阻塞主线程</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> offscreen = canvas.<span class=\"title function_\">transferControlToOffscreen</span>();</span><br><span class=\"line\">worker.<span class=\"title function_\">postMessage</span>(&#123; <span class=\"attr\">canvas</span>: offscreen &#125;, [offscreen]);</span><br></pre></td></tr></table></figure></div>\n\n","excerpt":"","more":"<h4 id=\"参考视频\"><a href=\"#参考视频\" class=\"headerlink\" title=\"参考视频\"></a>参考视频</h4><ol>\n<li><a class=\"link\"   href=\"https://www.bilibili.com/video/BV18f4y1H7Zu/?spm_id_from=333.337.search-card.all.click&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89\" >浏览器渲染页面的流程<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.337.search-card.all.click&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89\" >【干货】浏览器是如何运作的？<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ol>\n<h2 id=\"浏览器渲染机制：从-HTML-到像素的完整解析\"><a href=\"#浏览器渲染机制：从-HTML-到像素的完整解析\" class=\"headerlink\" title=\"浏览器渲染机制：从 HTML 到像素的完整解析\"></a>浏览器渲染机制：从 HTML 到像素的完整解析</h2><h3 id=\"渲染流水线概览\"><a href=\"#渲染流水线概览\" class=\"headerlink\" title=\"渲染流水线概览\"></a>渲染流水线概览</h3><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/浏览器渲染流程.png\"\n                      alt=\"浏览器渲染流程\" height=\"auto\" style=\"width:16%; display:block;\"\n                >\n\n\n<h2 id=\"详细渲染阶段解析\"><a href=\"#详细渲染阶段解析\" class=\"headerlink\" title=\"详细渲染阶段解析\"></a>详细渲染阶段解析</h2><h3 id=\"1-解析-HTML-构建-DOM-树\"><a href=\"#1-解析-HTML-构建-DOM-树\" class=\"headerlink\" title=\"1. 解析 HTML 构建 DOM 树\"></a>1. 解析 HTML 构建 DOM 树</h3><ul>\n<li><strong>过程</strong>：<ul>\n<li>字节 → 字符 → 令牌（token化） → 节点 → DOM 树</li>\n<li>遇到 <code>&lt;script&gt;</code> 标签会暂停解析，执行 JavaScript</li>\n</ul>\n</li>\n<li><strong>优化点</strong>：<ul>\n<li>使用 <code>async</code> 或 <code>defer</code> 属性异步加载脚本</li>\n<li>将脚本放在 body 底部</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-解析-CSS-构建-CSSOM-树\"><a href=\"#2-解析-CSS-构建-CSSOM-树\" class=\"headerlink\" title=\"2. 解析 CSS 构建 CSSOM 树\"></a>2. 解析 CSS 构建 CSSOM 树</h3><ul>\n<li><strong>特点</strong>：<ul>\n<li>CSS 是渲染阻塞资源</li>\n<li>选择器复杂度影响构建速度</li>\n</ul>\n</li>\n<li><strong>优化点</strong>：<ul>\n<li>精简 CSS 选择器复杂度</li>\n<li>使用媒体查询避免不必要的加载</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-构建渲染树（Render-Tree）\"><a href=\"#3-构建渲染树（Render-Tree）\" class=\"headerlink\" title=\"3. 构建渲染树（Render Tree）\"></a>3. 构建渲染树（Render Tree）</h3><ul>\n<li><strong>组合过程</strong>：<ul>\n<li>DOM + CSSOM &#x3D; 渲染树</li>\n<li>只包含可见节点（排除 <code>display: none</code> 等元素）</li>\n</ul>\n</li>\n<li><strong>关键规则</strong>：<ul>\n<li>CSS 层叠规则决定最终样式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-布局（Layout-Reflow）\"><a href=\"#4-布局（Layout-Reflow）\" class=\"headerlink\" title=\"4. 布局（Layout &#x2F; Reflow）\"></a>4. 布局（Layout &#x2F; Reflow）</h3><ul>\n<li><strong>计算</strong>：<ul>\n<li>确定所有元素的几何位置和尺寸</li>\n<li>基于视口大小计算位置</li>\n</ul>\n</li>\n<li><strong>触发条件</strong>：<ul>\n<li>窗口大小调整</li>\n<li>元素位置&#x2F;尺寸变化</li>\n<li>字体大小变化</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-分层（Layer）\"><a href=\"#5-分层（Layer）\" class=\"headerlink\" title=\"5. 分层（Layer）\"></a>5. 分层（Layer）</h3><ul>\n<li><strong>分层原因</strong>：<ul>\n<li>实现高效动画和滚动</li>\n<li>独立处理不同层</li>\n</ul>\n</li>\n<li><strong>创建层条件</strong>：<ul>\n<li>3D 变换</li>\n<li>视频&#x2F;Canvas 元素</li>\n<li>有动画的元素</li>\n<li><code>will-change: transform</code> 属性</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-绘制（Paint）\"><a href=\"#6-绘制（Paint）\" class=\"headerlink\" title=\"6. 绘制（Paint）\"></a>6. 绘制（Paint）</h3><ul>\n<li><strong>过程</strong>：<ul>\n<li>将渲染树转换为像素操作</li>\n<li>生成绘制指令列表</li>\n</ul>\n</li>\n<li><strong>特点</strong>：<ul>\n<li>最耗时的渲染阶段之一</li>\n<li>文本和边框绘制成本高</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"7-光栅化（Rasterization）\"><a href=\"#7-光栅化（Rasterization）\" class=\"headerlink\" title=\"7. 光栅化（Rasterization）\"></a>7. 光栅化（Rasterization）</h3><ul>\n<li><strong>任务</strong>：<ul>\n<li>将绘制指令转换为位图</li>\n<li>在合成线程中执行</li>\n</ul>\n</li>\n<li><strong>优化</strong>：<ul>\n<li>分块光栅化（Tile-based）</li>\n<li>GPU 加速</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"8-合成显示（Compositing）\"><a href=\"#8-合成显示（Compositing）\" class=\"headerlink\" title=\"8. 合成显示（Compositing）\"></a>8. 合成显示（Compositing）</h3><ul>\n<li><strong>过程</strong>：<ul>\n<li>合成器线程组合所有层</li>\n<li>通过 IPC 传递给浏览器进程</li>\n<li>最终显示在屏幕上</li>\n</ul>\n</li>\n<li><strong>优势</strong>：<ul>\n<li>避免完整重绘</li>\n<li>高效处理滚动和动画</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"关键渲染路径（Critical-Rendering-Path）\"><a href=\"#关键渲染路径（Critical-Rendering-Path）\" class=\"headerlink\" title=\"关键渲染路径（Critical Rendering Path）\"></a>关键渲染路径（Critical Rendering Path）</h3><p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84.png\"\n                      alt=\"关键渲染路径（Critical Rendering Path）\"\n                ></p>\n<h3 id=\"回流与重绘\"><a href=\"#回流与重绘\" class=\"headerlink\" title=\"回流与重绘\"></a>回流与重绘</h3><h4 id=\"1-回流（Reflow）\"><a href=\"#1-回流（Reflow）\" class=\"headerlink\" title=\"1. 回流（Reflow）\"></a>1. 回流（Reflow）</h4><p><strong>定义</strong>：当渲染树（Render Tree）中的一部分或全部因为元素的尺寸、布局、隐藏等改变而需要重新构建的过程称为回流。回流会导致子元素和后续元素重新计算布局，成本很高。<br><strong>触发条件</strong>（常见）：</p>\n<ul>\n<li>页面首次渲染（无法避免）</li>\n<li>浏览器窗口大小改变</li>\n<li>元素尺寸、位置、内容改变（如宽度、高度、内边距变化）</li>\n<li>添加或删除可见的DOM元素</li>\n<li>激活CSS伪类（如<code>:hover</code>）</li>\n<li>查询某些属性或调用某些方法（如<code>offsetWidth</code>、<code>scrollTo()</code>等）<br><strong>影响</strong>：回流会使浏览器重新计算所有受影响元素的几何属性，然后重新构建渲染树。</li>\n</ul>\n<hr>\n<h4 id=\"2-重绘（Repaint）\"><a href=\"#2-重绘（Repaint）\" class=\"headerlink\" title=\"2. 重绘（Repaint）\"></a>2. 重绘（Repaint）</h4><p><strong>定义</strong>：当元素的外观（如颜色、背景、边框等）发生改变，但不影响布局时，浏览器会重新绘制元素，这个过程称为重绘。重绘的成本通常小于回流。<br><strong>触发条件</strong>：</p>\n<ul>\n<li>颜色、背景色、边框颜色等样式改变</li>\n<li>文本方向修改</li>\n<li>阴影变化（但不影响布局）</li>\n<li><code>visibility</code>属性改变（注意：<code>display: none</code>会触发回流，而<code>visibility: hidden</code>只触发重绘）</li>\n</ul>\n<hr>\n<h4 id=\"关键区别：\"><a href=\"#关键区别：\" class=\"headerlink\" title=\"关键区别：\"></a>关键区别：</h4><table>\n<thead>\n<tr>\n<th><strong>特点</strong></th>\n<th><strong>回流（Reflow）</strong></th>\n<th><strong>重绘（Repaint）</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>触发原因</strong></td>\n<td>布局改变（几何属性）</td>\n<td>外观改变（非几何属性）</td>\n</tr>\n<tr>\n<td><strong>性能影响</strong></td>\n<td>高（涉及子元素和后续元素重新布局）</td>\n<td>低（只重新绘制，不重新计算布局）</td>\n</tr>\n<tr>\n<td><strong>依赖关系</strong></td>\n<td>必然引起重绘</td>\n<td>不一定引起回流</td>\n</tr>\n</tbody></table>\n<h2 id=\"渲染性能优化策略\"><a href=\"#渲染性能优化策略\" class=\"headerlink\" title=\"渲染性能优化策略\"></a>渲染性能优化策略</h2><h3 id=\"1-减少渲染阻塞\"><a href=\"#1-减少渲染阻塞\" class=\"headerlink\" title=\"1. 减少渲染阻塞\"></a>1. 减少渲染阻塞</h3><ul>\n<li><strong>CSS</strong>：<ul>\n<li>内联关键 CSS</li>\n<li>使用媒体查询分割 CSS</li>\n<li>避免使用 <code>@import</code></li>\n</ul>\n</li>\n<li><strong>JavaScript</strong>：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 推荐写法 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">defer</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;script.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">async</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;analytics.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-优化布局和重绘\"><a href=\"#2-优化布局和重绘\" class=\"headerlink\" title=\"2. 优化布局和重绘\"></a>2. 优化布局和重绘</h3><ul>\n<li><strong>减少回流（Reflow）</strong>：<ul>\n<li>避免频繁读写布局属性（offsetTop 等）</li>\n<li>使用 CSS 类批量修改样式</li>\n<li>使用 <code>position: absolute/fixed</code> 脱离文档流</li>\n</ul>\n</li>\n<li><strong>减少重绘（Repaint）</strong>：<ul>\n<li>使用 <code>transform</code> 和 <code>opacity</code> 实现动画</li>\n<li>使用 <code>will-change</code> 提示浏览器</li>\n<li>避免使用渐变和阴影等昂贵效果</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-高效利用图层\"><a href=\"#3-高效利用图层\" class=\"headerlink\" title=\"3. 高效利用图层\"></a>3. 高效利用图层</h3><ul>\n<li><strong>图层优化</strong>：</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.animate-element</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">will-change</span>: transform; <span class=\"comment\">/* 提前告知浏览器 */</span></span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateZ</span>(<span class=\"number\">0</span>); <span class=\"comment\">/* 强制创建新层 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>注意事项</strong>：<ul>\n<li>避免过多图层（内存开销）</li>\n<li>平衡图层数量和渲染性能</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-虚拟滚动和列表优化\"><a href=\"#4-虚拟滚动和列表优化\" class=\"headerlink\" title=\"4. 虚拟滚动和列表优化\"></a>4. 虚拟滚动和列表优化</h3><ul>\n<li><strong>大数据集处理</strong>：<ul>\n<li>实现虚拟滚动：只渲染可视区域元素</li>\n<li>使用内容分块加载</li>\n<li>懒加载非关键资源</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-性能检测工具\"><a href=\"#5-性能检测工具\" class=\"headerlink\" title=\"5. 性能检测工具\"></a>5. 性能检测工具</h3><ul>\n<li><strong>Chrome DevTools</strong>：<ul>\n<li>Performance 面板分析渲染瀑布流</li>\n<li>Layers 面板查看图层结构</li>\n<li>Rendering 面板检测重绘区域</li>\n</ul>\n</li>\n<li><strong>API</strong>：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取布局性能数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> perfEntries = performance.<span class=\"title function_\">getEntriesByType</span>(<span class=\"string\">&quot;layout&quot;</span>);</span><br><span class=\"line\">perfEntries.<span class=\"title function_\">forEach</span>(<span class=\"function\"><span class=\"params\">entry</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`布局耗时: <span class=\"subst\">$&#123;entry.duration&#125;</span>ms`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"现代浏览器渲染优化技术\"><a href=\"#现代浏览器渲染优化技术\" class=\"headerlink\" title=\"现代浏览器渲染优化技术\"></a>现代浏览器渲染优化技术</h2><h3 id=\"1-合成器线程（Compositor-Thread）\"><a href=\"#1-合成器线程（Compositor-Thread）\" class=\"headerlink\" title=\"1. 合成器线程（Compositor Thread）\"></a>1. 合成器线程（Compositor Thread）</h3><ul>\n<li>独立于主线程运行（浏览器渲染进程的主线程）</li>\n<li>处理滚动、动画等无需 JS 的操作</li>\n<li>直接操作已光栅化的图层</li>\n</ul>\n<h3 id=\"2-时间切片（Time-Slicing）\"><a href=\"#2-时间切片（Time-Slicing）\" class=\"headerlink\" title=\"2. 时间切片（Time Slicing）\"></a>2. 时间切片（Time Slicing）</h3><ul>\n<li>将大型任务拆分为小任务</li>\n<li>通过 <code>requestIdleCallback</code> 实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">processTask</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 执行小段任务</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hasMoreWork) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">requestIdleCallback</span>(processTask);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">requestIdleCallback</span>(processTask);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-增量渲染\"><a href=\"#3-增量渲染\" class=\"headerlink\" title=\"3. 增量渲染\"></a>3. 增量渲染</h3><ul>\n<li>逐步显示部分渲染内容</li>\n<li>优先渲染视口内内容</li>\n<li>后台继续处理剩余内容</li>\n</ul>\n<h3 id=\"4-GPU-加速\"><a href=\"#4-GPU-加速\" class=\"headerlink\" title=\"4. GPU 加速\"></a>4. GPU 加速</h3><ul>\n<li>使用 CSS 硬件加速：</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.accelerated</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate3d</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"comment\">/* 或者 */</span></span><br><span class=\"line\">  <span class=\"attribute\">backface-visibility</span>: hidden;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>将渲染工作转移到 GPU</li>\n</ul>\n<h2 id=\"渲染过程中的-JavaScript-交互\"><a href=\"#渲染过程中的-JavaScript-交互\" class=\"headerlink\" title=\"渲染过程中的 JavaScript 交互\"></a>渲染过程中的 JavaScript 交互</h2><h3 id=\"JS-执行对渲染的影响\"><a href=\"#JS-执行对渲染的影响\" class=\"headerlink\" title=\"JS 执行对渲染的影响\"></a>JS 执行对渲染的影响</h3><ul>\n<li><strong>同步 JS</strong>：<ul>\n<li>阻塞 DOM 构建</li>\n<li>延迟页面渲染</li>\n</ul>\n</li>\n<li><strong>异步 JS</strong>：<ul>\n<li><code>defer</code>：HTML 解析完成后执行</li>\n<li><code>async</code>：下载完成后立即执行</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"事件循环与渲染协调\"><a href=\"#事件循环与渲染协调\" class=\"headerlink\" title=\"事件循环与渲染协调\"></a>事件循环与渲染协调</h3><ul>\n<li><strong>处理模型</strong>：<ol>\n<li>执行 JavaScript 任务</li>\n<li>处理微任务队列</li>\n<li>执行渲染步骤（可选）</li>\n<li>处理宏任务队列</li>\n</ol>\n</li>\n<li><strong>requestAnimationFrame</strong>：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">update</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在渲染前更新动画</span></span><br><span class=\"line\">  element.<span class=\"property\">style</span>.<span class=\"property\">transform</span> = <span class=\"string\">`translateX(<span class=\"subst\">$&#123;position&#125;</span>px)`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  position += <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (position &lt; <span class=\"number\">300</span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">requestAnimationFrame</span>(update);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">requestAnimationFrame</span>(update);</span><br></pre></td></tr></table></figure>\n\n<p>最佳时机：在浏览器重绘前执行动画更新</p>\n<h2 id=\"移动端渲染的特殊考虑\"><a href=\"#移动端渲染的特殊考虑\" class=\"headerlink\" title=\"移动端渲染的特殊考虑\"></a>移动端渲染的特殊考虑</h2><h3 id=\"触摸事件处理：\"><a href=\"#触摸事件处理：\" class=\"headerlink\" title=\"触摸事件处理：\"></a>触摸事件处理：</h3><pre><code>- 300ms 点击延迟问题\n- 使用 `touch-action` 优化滚动\n</code></pre>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.scrollable</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">touch-action</span>: pan-y; <span class=\"comment\">/* 只允许垂直滚动 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"电池效率优化：\"><a href=\"#电池效率优化：\" class=\"headerlink\" title=\"电池效率优化：\"></a>电池效率优化：</h3><ul>\n<li>减少不必要的动画</li>\n<li>使用 <code>matchMedia</code> 检测设备能力</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isLowPower = <span class=\"title function_\">matchMedia</span>(<span class=\"string\">&quot;(prefers-reduced-motion: reduce)&quot;</span>).<span class=\"property\">matches</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (isLowPower) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 简化动画效果</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内存限制：\"><a href=\"#内存限制：\" class=\"headerlink\" title=\"内存限制：\"></a>内存限制：</h3><pre><code>- 移动设备图层内存限制更严格\n- 避免大型 Canvas 操作\n- 及时释放不再使用的资源\n</code></pre>\n<h2 id=\"未来趋势：WebGPU-和渲染新特性\"><a href=\"#未来趋势：WebGPU-和渲染新特性\" class=\"headerlink\" title=\"未来趋势：WebGPU 和渲染新特性\"></a>未来趋势：WebGPU 和渲染新特性</h2><ol>\n<li><strong>WebGPU</strong>：<ul>\n<li>下一代图形 API</li>\n<li>更直接的 GPU 访问</li>\n<li>适用于复杂 3D 和计算任务</li>\n</ul>\n</li>\n<li><strong>Houdini API</strong>：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 自定义绘制API示例</span></span><br><span class=\"line\"><span class=\"title function_\">registerPaint</span>(<span class=\"string\">&#x27;circle-ripple&#x27;</span>, <span class=\"keyword\">class</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">paint</span>(<span class=\"params\">ctx, size</span>) &#123;</span><br><span class=\"line\">    ctx.<span class=\"property\">fillStyle</span> = <span class=\"string\">&#x27;rgba(255,0,0,0.5)&#x27;</span>;</span><br><span class=\"line\">    ctx.<span class=\"title function_\">beginPath</span>();</span><br><span class=\"line\">    ctx.<span class=\"title function_\">arc</span>(size.<span class=\"property\">width</span>/<span class=\"number\">2</span>, size.<span class=\"property\">height</span>/<span class=\"number\">2</span>, <span class=\"number\">50</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>*<span class=\"title class_\">Math</span>.<span class=\"property\">PI</span>);</span><br><span class=\"line\">    ctx.<span class=\"title function_\">fill</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<pre><code>- 使开发者能介入渲染管线\n- 创建高性能自定义渲染效果\n</code></pre>\n<ol start=\"3\">\n<li><strong>OffscreenCanvas</strong>：<ul>\n<li>在 Web Worker 中执行 Canvas 操作</li>\n<li>避免阻塞主线程</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> offscreen = canvas.<span class=\"title function_\">transferControlToOffscreen</span>();</span><br><span class=\"line\">worker.<span class=\"title function_\">postMessage</span>(&#123; <span class=\"attr\">canvas</span>: offscreen &#125;, [offscreen]);</span><br></pre></td></tr></table></figure>\n\n","_processedHighlight":true},{"title":"关于eventloop","date":"2023-10-07T16:00:00.000Z","_content":"\n一些参考：\n\n测试eventloop地址：[https://www.jsv9000.app](https://www.jsv9000.app)\n\n参考视频：[【事件循环】【前端】事件原理讲解](https://www.bilibili.com/video/BV1K4411D7Jb/?spm_id_from=333.337.search-card.all.click&vd_source=a1a75df55f32a09493aa84363d0e2aa0)\n\n## 浏览器的事件循环机制（EventLoop）\n概述：\n\n要真正理解事件循环，我们需要先了解浏览器的多进程架构：\n\n+ **浏览器主进程**：负责界面显示、用户交互\n+ **GPU进程**：处理图形渲染\n+ **网络进程**：处理网络请求\n+ **渲染进程**（核心）：每个标签页一个渲染进程，包含：\n    - **主线程**：<u>执行JS、解析HTML/CSS、布局、绘制（就是我们常说的JS线程）</u>\n    - **合成线程**：负责图层分割\n    - **光栅线程**：将图层转换为像素\n\n> <font style=\"background-color:rgba(77, 208, 225, 0.15);\">关键点：JS引擎（如V8）只是渲染进程的一部分，JS的\"单线程\"指的是主线程的单线程，浏览器整体是多线程的。</font>\n>\n\n\n\n关于浏览器渲染机制的笔记，可以查看：[浏览器渲染机制](https://www.yuque.com/u54400072/kgraay/gyclhvv7y5wogkf0)\n\n\n\n### JavaScript的单线程特性与异步机制\n#### JS为什么是单线程的？\nJavaScript被设计成单线程的，主要是为了避免DOM操作的复杂性。如果JavaScript是多线程的，那么当多个线程同时操作同一个DOM元素时，就会出现竞态条件（Race Condition），导致不可预测的结果。例如，一个线程要删除某个DOM元素，另一个线程要修改它，那么到底应该以哪个线程的操作为准呢？为了避免这种复杂性，JavaScript从诞生之初就被设计为单线程。\n\n#### 单线程带来的问题与解决方案\n（1）阻塞问题\n\n+ 单线程意味着所有任务需按顺序执行，若某个任务耗时过长（如复杂计算或网络请求），会阻塞后续代码执行，导致页面卡顿\n+ 解决方案：\n    - **异步编程模型**：通过回调函数、Promise、async/await 处理异步操作，避免阻塞主线程\n\n```javascript\n// 示例：使用 Promise 处理异步请求\nfetch('https://api.example.com/data')\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error(error));\n```\n\n    - **Web Worker**：将耗时任务交给后台线程处理，不阻塞主线程\n\n```javascript\n// 主线程\nconst worker = new Worker('worker.js');\nworker.postMessage('开始计算');\nworker.onmessage = (e) => {\n  console.log('计算结果:', e.data);\n};\n\n// worker.js（独立线程）\nonmessage = (e) => {\n  const result = performHeavyCalculation();\n  postMessage(result);\n};\n```\n\n（2）I/O密集型场景的优化\n\n+ 浏览器中的 JavaScript 主要处理 I/O 密集型任务（如网络请求、文件操作），单线程模型配合异步 I/O 机制（如事件循环）可高效处理这类场景。\n+ **事件循环（Event Loop）**：\n    - JavaScript 通过事件循环机制处理异步任务，将耗时操作放入任务队列，主线程空闲时再处理这些任务。\n\n\n\n### 事件循环的完整运行机制：\n#### 核心组件详解\n（1）调用栈（Call Stack）\n\n+ 本质：记录函数调用的数据结构（LIFO栈），先进后出，如下图所示：\n\n![调用栈callstack](images/callstack.webp)\n\n+ 特点：\n    - **合成线程**：每次函数调用都会创建新的栈帧（包含参数、局部变量等）\n    - 栈溢出：当递归深度超过最大调用栈大小（Chrome约1万层）\n\n```javascript\n// 栈溢出示例\nfunction stackOverflow() {\n  stackOverflow()\n}\nstackOverflow() // Uncaught RangeError: Maximum call stack size exceeded\n```\n\n\n\n（2）堆内存（Heap）\n\n+ 存储引用类型（对象、数组等）的内存区域\n+ 与栈的区别：\n    - 栈：自动分配固定大小内存（基础类型、指针）\n    - 堆：动态分配内存，需要垃圾回收\n\n（3）任务队列系统\n\n| **队列类型** | **触发方式** | **优先级** |\n| --- | --- | --- |\n| 微任务队列 | JS引擎直接管理 | 高 |\n| 宏任务队列 | 由浏览器宿主环境管理 | 低 |\n| 动画回调队列 | requestAnimationFrame | 特殊 |\n| 空闲回调队列 | requestIdleCallback | 最低 |\n\n\n#### 完整事件循环流程\n下图为主线程中事件循环的运行示例图：\n\n![主线程中的eventloop](images/主线程中的eventloop.png)\n\n<img src=\"/images/eventloop流程.png\" alt=\"eventloop流程\" height=\"auto\" style=\"width:40%; display:block;\">\n\n##### 宏任务【Macro-tasks】与微任务【micro-tasks】\n宏任务大概包括：\n\n+ script(整体代码)\n+ setTimeout\n+ setInterval\n+ setImmediate\n+ I/O（例如网络请求 `<font style=\"background-color:rgba(77, 208, 225, 0.08);\">ajax</font>`、文件读写）\n+ UI render\n+ `<font style=\"background-color:rgba(77, 208, 225, 0.08);\">setImmediate</font>` (Node.js环境特有)\n\n微任务大概包括：\n\n+ `<font style=\"background-color:rgba(77, 208, 225, 0.08);\">Promise.then()</font>`、`<font style=\"background-color:rgba(77, 208, 225, 0.08);\">Promise.catch()</font>`、`<font style=\"background-color:rgba(77, 208, 225, 0.08);\">Promise.finally()</font>`\n+ `<font style=\"background-color:rgba(77, 208, 225, 0.08);\">process.nextTick</font>` (Node.js环境特有)\n+ `<font style=\"background-color:rgba(77, 208, 225, 0.08);\">MutationObserver</font>` (h5新特性 用于监听DOM变化)\n\n##### EventLoop的执行顺序详解：\n1. **执行同步代码：** 当JavaScript代码开始执行时，会首先执行所有的同步代码。这些同步代码可以被看作是当前宏任务的一部分。在执行过程中，如果遇到异步任务（无论是宏任务还是微任务），就会将其对应的回调函数放入相应的任务队列中。\n2. **清空微任务队列：** 当所有同步代码执行完毕后，Event Loop并不会立即去执行宏任务队列中的任务。它会优先检查并清空**微任务队列**。这意味着，所有在当前宏任务执行期间产生的微任务，都会在下一个宏任务开始之前被执行完毕。\n3. **页面渲染（可选）：** 在微任务队列清空之后，如果浏览器判断有必要进行页面渲染（比如DOM结构发生了变化，或者需要更新UI），它就会进行一次页面渲染。这一步是可选的，浏览器会根据实际情况决定是否进行渲染。\n4. **执行下一个宏任务：** 页面渲染完成后，Event Loop会从**宏任务队列**中取出一个任务来执行。这个任务执行完毕后，又会重复步骤2，检查并清空微任务队列，然后再次进行页面渲染（如果需要），接着再从宏任务队列中取出下一个任务……如此循环往复，直到所有任务执行完毕。\n\n这个过程可以概括为：**一个宏任务执行完毕 -> 清空所有微任务 -> 页面渲染（如果需要） -> 执行下一个宏任务**。这个循环会一直持续下去，直到所有任务都执行完毕。\n\n\n\n### 代码实战：\n#### async/await在EventLoop中的表现：\n##### 概述：async/await是js中用于处理异步操作的语法糖，基于promise+generator构建\n+ async函数\n    - async函数隐式返回一个Promise对象。如果函数返回一个值，该值会被包装为Promise（通过`Promise.resolve`）；如果函数抛出异常，则返回的Promise状态为`rejected`。\n\n```javascript\nasync function foo(){\n  return 'hello world!'\n}\n\n// 等同于\nfunction foo() {\n  return Promise.resolve('hello world!')\n}\n```\n\n+ await表达式\n    - `await`只能在async函数内部使用。\n    - `await`后面可以跟一个Promise对象，它会暂停async函数的执行，等待Promise的状态变为`resolved`，然后返回结果值。\n    - 如果`await`后面是一个非Promise的值，它会被立即转换为一个已解决的Promise。\n    - 如果Promise被拒绝（rejected），`await`会抛出拒绝的原因（可以使用try/catch捕获）\n\n##### async函数在事件循环中造成的细微差别：\n<img src=\"/images/async和微任务.png\" alt=\"async和微任务\" height=\"auto\" style=\"width:60%; display:block;\">\n\n**重点：**\n\n**根据规范，async函数返回一个Promise，并且await会暂停函数的执行，等待Promise解决，然后继续执行函数，并将后续代码放入微任务队列。**\n\n**特别要注意的是：当async函数返回一个Promise时，会有额外的微任务产生（因为需要等待返回的Promise被解决，然后才能解决async函数自己的Promise）。**\n\n\n<details class=\"lake-collapse\"><summary id=\"uee28ecd3\"><span class=\"ne-text\">async async2()函数分析：</span></summary><p id=\"u6adc2781\" class=\"ne-p\"><span class=\"ne-text\">执行同步代码：</span></p><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u93ecd645\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 'script start'</span></li><li id=\"ub0b236ee\" data-lake-index-type=\"0\"><span class=\"ne-text\">定义async1和async2（不执行）</span></li><li id=\"u83f602f8\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用async1()</span></li><li id=\"u3b88aae8\" data-lake-index-type=\"0\"><span class=\"ne-text\">在async1中，调用async2()（因为await后面是async2()，所以先执行async2）</span></li></ul></ul><ol class=\"ne-ol\"><li id=\"u901c7dd1\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行async2：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u7be6e3e7\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 'async2 end'</span></li><li id=\"uf1064ee2\" data-lake-index-type=\"0\"><span class=\"ne-text\">然后执行 return Promise.resolve().then(...)<br /></span><span class=\"ne-text\">  这里，Promise.resolve()返回一个已解决的Promise，然后调用then方法，将then的回调（输出'async2 end1'）放入微任务队列。</span></li><li id=\"u13468c5f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"background-color: #CEF5F7\">注意：async2是一个async函数，它返回的Promise不是直接这个then返回的Promise，而是会额外包装一层。<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">根据ECMAScript规范，async函数内部return一个值x，相当于执行</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"background-color: #CEF5F7\">Promise.resolve(x)</span></code><span class=\"ne-text\" style=\"background-color: #CEF5F7\">，然后会等待x（如果x是Promise）解决，再解决async函数返回的Promise。但是，如果x是一个Promise，那么就会产生两个微任务：一个用于等待x解决，另一个用于解决async函数的Promise。<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">具体到async2：<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">async2中：return Promise.resolve().then(...)<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">这个then方法返回一个新的Promise（我们称为P1）。而async2函数会返回一个新的Promise（称为P2），P2的解决会等待P1的解决。所以，在P1解决后，才会解决P2，然后async1中的await才会继续。</span></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"u485bd34a\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续同步代码：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u29d7af0e\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用setTimeout，将回调放入宏任务队列（0毫秒后，但会在当前宏任务执行完后执行）</span></li><li id=\"ud7fba569\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行new Promise，输出 'Promise'，并立即resolve，将第一个then的回调（输出'promise1'）放入微任务队列</span></li><li id=\"u2c84e1e6\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 'script end'<br /></span><span class=\"ne-text\">此时，同步代码执行完毕。当前微任务队列中有两个任务（注意顺序）：</span></li><li id=\"u9f2acfbe\" data-lake-index-type=\"0\"><span class=\"ne-text\">第一个是async2中放入的：输出'async2 end1'（来自P1的then回调）</span></li><li id=\"u5048b8b9\" data-lake-index-type=\"0\"><span class=\"ne-text\">第二个是new Promise的then回调：输出'promise1'</span></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u1fcaa51b\" data-lake-index-type=\"0\"><span class=\"ne-text\">开始执行微任务队列：<br /></span><span class=\"ne-text\">第一个微任务：执行async2中then的回调<br /></span><span class=\"ne-text\">  输出 'async2 end1'<br /></span><span class=\"ne-text\">  这个回调执行完毕，P1被解决（值为undefined，因为没有return）<br /></span><span class=\"ne-text\"> </span><strong><span class=\"ne-text\"> </span></strong><span class=\"ne-text\" style=\"background-color: #CEF5F7\">这时，因为async2返回的P2在等待P1解决，所以会安排一个微任务来解决P2（这是规范要求的，当async函数返回一个Promise时，需要等待这个Promise解决，然后才能解决async函数自己的Promise。这个等待过程会产生一个微任务）。</span><span class=\"ne-text\"><br /></span><span class=\"ne-text\">第二个微任务：执行输出'promise1'<br /></span><span class=\"ne-text\">  输出 'promise1'<br /></span><span class=\"ne-text\">  由于这个then回调返回undefined，所以它返回的Promise立即解决，于是下一个then的回调（输出'promise2'）被放入微任务队列。<br /></span><span class=\"ne-text\">此时，微任务队列中新增了两个微任务（按顺序）：<br /></span><span class=\"ne-text\">微任务3：解决async2返回的P2（这个微任务会触发async1中await后面的代码放入微任务队列）<br /></span><span class=\"ne-text\">微任务4：输出'promise2'<br /></span><span class=\"ne-text\">注意：微任务3是在执行第一个微任务（输出'async2 end1'）后产生的，所以它排在微任务4（由第二个微任务产生）之前。<br /></span><span class=\"ne-text\">当前微任务队列：[微任务3, 微任务4]</span></li><li id=\"u213c16ff\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续执行微任务队列：<br /></span><span class=\"ne-text\">执行微任务3：解决async2返回的P2<br /></span><span class=\"ne-text\">此时，await async2()的Promise（即P2）被解决，然后await后面的代码（输出'async1 end'）被放入微任务队列。<br /></span><span class=\"ne-text\">执行微任务4：输出 'promise2'<br /></span><span class=\"ne-text\">此时，微任务队列中新增了一个微任务（输出'async1 end'）</span></li><li id=\"uae2fa8c4\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续执行微任务队列（新的一轮？不，微任务队列会一直执行直到清空，所以会继续）：<br /></span><span class=\"ne-text\">微任务5：输出 'async1 end'</span></li><li id=\"ub048ce21\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列清空，执行宏任务：<br /></span><span class=\"ne-text\">  输出 'setTimeout'</span></li></ol></details>\n###### 事件循环详细过程：\n\n{% tabs 页面内不重复的ID %}\n \n<!-- tab 左边流程 -->\n \n阶段1：同步代码执行（宏任务）\n同右\n微任务队列：[ 回调A (async2 end1), 回调B (promise1) ]\n阶段2：微任务执行（第一轮）\n1. 执行回调A：\n  ○ console.log('async2 end1') → 输出 \"async2 end1\"\n  ○ 解析 P2（async2 内部 Promise）\n  ○ await async2() 完成，将 async1 end 加入微任务队列（回调C）\n微任务队列更新：\n[ 回调B (promise1), 回调C (async1 end) ]\n1. 执行回调B：\n  ○ console.log('promise1') → 输出 \"promise1\"\n  ○ 返回 undefined，自动创建新解析的 Promise P4\n  ○ 将 promise2 回调加入微任务队列（回调C）\n微任务队列更新：\n[ 回调C (async1 end) , 回调D (promise2)]\n阶段3：微任务执行（第二轮）\n1. 执行回调C：\n  ○ console.log('async1 end') → 输出 \"async1 end\"\n2. 执行回调D：\n  ○ console.log('promise2') → 输出 \"promise2\"\n阶段4：宏任务执行\n1. 执行 setTimeout 回调：\n  ○ console.log('setTimeout') → 输出 \"setTimeout\"\n \n<!-- endtab -->\n<!-- tab 右边流程 -->\n \n阶段1：同步代码执行（宏任务）\n1. console.log('script start')\n→ 输出 \"script start\"\n2. 定义函数：\n  ○ 定义 async1 和 async2（不执行函数体）\n3. 调用 async1()：\n  ○ 进入 async1，遇到 await async2()\n  ○ 调用 async2()\n4. 执行 async2()：\n  ○ console.log('async2 end') → 输出 \"async2 end\"\n  ○ return Promise.resolve().then(...)\n创建 Promise P2 并将 .then 回调加入微任务队列（回调A）\n5. setTimeout：\n  ○ 将回调加入宏任务队列\n6. new Promise：\n  ○ console.log('Promise') → 输出 \"Promise\"\n  ○ resolve() 立即解析 Promise P3\n  ○ 将 .then 回调加入微任务队列（回调B）\n7. console.log('script end')\n→ 输出 \"script end\"\n微任务队列：[ 回调A (async2 end1), 回调B (promise1) ]\n阶段2：微任务执行（第一轮）\n1. 执行回调A：\n  ○ console.log('async2 end1') → 输出 \"async2 end1\"\n  ○ 解析 P2（async2 内部 Promise）\n  ○ 由于 async2 是 async 函数，需要额外微任务解析其返回的 Promise P1\n微任务队列更新：\n[ 回调B (promise1), 新任务 (解析P1) ]\n1. 执行回调B：\n  ○ console.log('promise1') → 输出 \"promise1\"\n  ○ 返回 undefined，自动创建新解析的 Promise P4\n  ○ 将 promise2 回调加入微任务队列（回调C）\n微任务队列更新：\n[ 解析P1, 回调C (promise2) ]\n阶段3：微任务执行（第二轮）\n1. 执行解析P1任务：\n  ○ 解析 async2 返回的 Promise P1\n  ○ 使 await async2() 完成，将 async1 end 加入微任务队列（回调D）\n微任务队列更新：\n[ 回调C (promise2), 回调D (async1 end) ]\n1. 执行回调C：\n  ○ console.log('promise2') → 输出 \"promise2\"\n2. 执行回调D：\n  ○ console.log('async1 end') → 输出 \"async1 end\"\n阶段4：宏任务执行\n1. 执行 setTimeout 回调：\n  ○ console.log('setTimeout') → 输出 \"setTimeout\"\n\n\n\n\n \n<!-- endtab -->\n \n{% endtabs %}\n\n\n  \n\n\n##### await表达式在事件循环中，参考[async和await的面试题](https://www.bilibili.com/video/BV1x29iYdEQy/?spm_id_from=333.337.search-card.all.click&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89)， 举例：\n```javascript\n  async function asy1(params) {\n      console.log(1);\n      await asy2();\n      console.log(2);\n    }\n\n  const asy2 = async () => {\n    await setTimeout(() => {\n      Promise.resolve().then(() => {\n        console.log(3);\n      });\n      console.log(4);\n    }, 0);\n  };\n\n  const asy3 = async () => {\n    Promise.resolve().then(() => {\n      console.log(6);\n    });\n  };\n\n  asy1();\n  console.log(7);\n  asy3();\n\n// 输出顺序如下：\n// 1\n// 7\n// 6\n// 2\n// 4\n// 3\n```\n\n###### 分析如下：\n<details class=\"lake-collapse\"><summary id=\"ua9d4e59b\"><span class=\"ne-text\">执行流程：</span></summary><ol class=\"ne-ol\"><li id=\"ua7bdc105\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">，进入</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">函数：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ubff5558e\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code></li><li id=\"u11d6bd6e\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2()</span></code></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"ub1b11355\" data-lake-index-type=\"0\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 中：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u4398c32c\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">setTimeout</span></code><span class=\"ne-text\">，将回调函数放入宏任务队列（将在下一个宏任务执行）。</span></li><li id=\"u5f055c33\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面是 </span><code class=\"ne-code\"><span class=\"ne-text\">setTimeout</span></code><span class=\"ne-text\"> 返回的数字，所以会生成一个立即解决的Promise，并将 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面的代码（这里没有代码，所以实际上是等待这个Promise解决，然后 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回）包装成微任务，放入微任务队列。</span></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u3a31576e\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续执行同步代码：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u6e2f88c4\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">7</span></code></li><li id=\"u2b84c779\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3()</span></code><span class=\"ne-text\">，在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\"> 中，</span><code class=\"ne-code\"><span class=\"ne-text\">Promise.resolve().then</span></code><span class=\"ne-text\"> 将回调（输出6）放入微任务队列。</span></li></ul></ul><ol start=\"4\" class=\"ne-ol\"><li id=\"u10e27d36\" data-lake-index-type=\"0\"><span class=\"ne-text\">同步代码执行完毕，开始执行微任务队列：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ucaa3f54f\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列中有两个微任务：</span></li></ul></ul><ol class=\"ne-list-wrap\"><ol class=\"ne-list-wrap\"><ol ne-level=\"2\" class=\"ne-ol\"><li id=\"u8a3a55ba\" data-lake-index-type=\"0\"><span class=\"ne-text\">由 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生的微任务（表示 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数可以继续执行，实际上就是让 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回，并解决 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 所等待的Promise）。</span></li><li id=\"u19404ecd\" data-lake-index-type=\"0\"><span class=\"ne-text\">由 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\"> 放入的微任务（输出6）。</span></li></ol></ol></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u8a4fffbd\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列按顺序执行：</span></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"u6d3cc76f\" data-lake-index-type=\"0\"><span class=\"ne-text\">首先执行第一个微任务（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">）：这个微任务的执行会解决</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">函数返回的Promise，从而让</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">函数中</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">后面的代码（输出2）可以继续，但是注意，这个继续并不是立即执行输出2，而是将输出2的代码作为一个新的微任务加入微任务队列（因为async函数中，</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">后面的代码总是被包装成微任务）。</span></li><li id=\"uab041688\" data-lake-index-type=\"0\"><span class=\"ne-text\">然后执行第二个微任务：输出 </span><code class=\"ne-code\"><span class=\"ne-text\">6</span></code><span class=\"ne-text\">。</span></li></ul></ul></ul><ol start=\"5\" class=\"ne-ol\"><li id=\"ucf226f8c\" data-lake-index-type=\"0\"><span class=\"ne-text\">此时微任务队列中又有了一个新的微任务（输出2），所以接下来执行这个微任务：输出 </span><code class=\"ne-code\"><span class=\"ne-text\">2</span></code><span class=\"ne-text\">。</span></li><li id=\"u6c503281\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列清空，然后执行宏任务队列中的定时器回调：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uccbe3d59\" data-lake-index-type=\"0\"><span class=\"ne-text\">在定时器回调中：</span></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"u31c6a5c4\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行 </span><code class=\"ne-code\"><span class=\"ne-text\">Promise.resolve().then</span></code><span class=\"ne-text\">，将输出3的回调放入微任务队列。</span></li><li id=\"u4f93746a\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">4</span></code><span class=\"ne-text\">。</span></li></ul></ul></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u30f2e9ee\" data-lake-index-type=\"0\"><span class=\"ne-text\">这个宏任务执行完毕，然后执行微任务队列：输出 </span><code class=\"ne-code\"><span class=\"ne-text\">3</span></code><span class=\"ne-text\">。</span></li></ul></ul><h3 id=\"GAz0l\"><span class=\"ne-text\">重点：</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生的微任务次数</span></h3><p id=\"ua93b7a29\" class=\"ne-p\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中：</span></p><ul class=\"ne-ul\"><li id=\"ua4ecaa40\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 一个非Promise值（数字）会产生一个微任务（用于继续执行async函数后面的代码，即使后面没有代码，也需要解决async函数返回的Promise）。<br /></span><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中：</span></li><li id=\"u15aad2bc\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await asy2()</span></code><span class=\"ne-text\">：</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 返回一个Promise，这个Promise的解决会在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数内部的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 完成时（即上面产生的微任务执行时）解决。然后，</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面的代码（输出2）会被放入微任务队列。<br /></span><span class=\"ne-text\">因此，整个流程中微任务队列的变化：</span></li></ul><ol class=\"ne-ol\"><li id=\"u67f1aaae\" data-lake-index-type=\"0\"><span class=\"ne-text\">同步代码执行完毕后，微任务队列有两个微任务：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uea94d940\" data-lake-index-type=\"0\"><span class=\"ne-text\">第一个是 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生的（标记为微任务A）：用于解决 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回的Promise。</span></li><li id=\"u0ac362e1\" data-lake-index-type=\"0\"><span class=\"ne-text\">第二个是 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\"> 放入的（微任务B）：输出6。</span></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"u161f7bd5\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务A：这会解决 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回的Promise，然后导致 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 完成，从而将 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面的代码（输出2）作为新的微任务（微任务C）加入队列。</span></li><li id=\"u35263207\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务B：输出6。</span></li><li id=\"u7a57f36d\" data-lake-index-type=\"0\"><span class=\"ne-text\">然后执行微任务C：输出2。<br /></span><span class=\"ne-text\">所以，</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 确实产生了一个微任务（微任务A），并且这个微任务的执行又导致了一个新的微任务（微任务C）产生。</span></li></ol><h3 id=\"OZ2IP\"><span class=\"ne-text\">结论</span></h3><p id=\"u030784a1\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生了微任务。整个代码中，微任务队列的执行顺序是：</span></p><ol class=\"ne-ol\"><li id=\"u270ebb63\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务A（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">）：解决</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">的Promise，触发</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">中的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">完成，将输出2加入微任务队列（微任务C）。</span></li><li id=\"ufa55c812\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务B（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\">）：输出6。</span></li><li id=\"u671bd9d5\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务C（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">完成）：输出2。<br /></span><span class=\"ne-text\">然后执行宏任务（定时器回调），在定时器回调中又产生了一个微任务（输出3），最后执行。</span></li></ol></details>\n###### 上面的例子稍微变形后：\n```javascript\nasync function asy1(params) {\n    console.log(1);\n    await asy2();\n    console.log(2);\n  }\n\nconst asy2 = async () => {\n  await (async () => {\n    await (() => {\n      console.log(3);\n    })();\n    console.log(4);\n  })();\n};\n\nconst asy3 = async () => {\n  Promise.resolve().then(() => {\n    console.log(6);\n  });\n};\n\nasy1();\nconsole.log(7);\nasy3();\n\n// 输出顺序如下：\n// 1\n// 3\n// 7\n// 4\n// 6\n// 2\n```\n\n<details class=\"lake-collapse\"><summary id=\"u058a4c63\"><span class=\"ne-text\">分析如下：</span></summary><ol class=\"ne-ol\"><li id=\"uc339dd7e\" data-lake-index-type=\"0\"><span class=\"ne-text\">声明asy1、asy2、asy3函数，不进入执行栈。</span></li><li id=\"u4182cade\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">，进入</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">函数：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uc8b547f5\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code></li><li id=\"uc54df11b\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2()</span></code></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u96ec74de\" data-lake-index-type=\"0\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 中：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ub8620ccd\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await (() =&gt; {console.log(3) })()</span></code><span class=\"ne-text\"> 即</span><code class=\"ne-code\"><span class=\"ne-text\">await console.log(3)</span></code><span class=\"ne-text\">最终会生成一个立即解决的Promise，即</span><code class=\"ne-code\"><span class=\"ne-text\">await Promise.resolve()</span></code><span class=\"ne-text\">记为P1，该Promise解决后，将</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(4);</span></code><span class=\"ne-text\">（回调A）推入微任务队列。</span></li><li id=\"u47e33dc8\" data-lake-index-type=\"0\"><span class=\"ne-text\">此时</span><code class=\"ne-code\"><span class=\"ne-text\">await (async () =&gt; {...)()</span></code><span class=\"ne-text\"> 返回的Promise，记为P2，需要等待内部的</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(4)</span></code><span class=\"ne-text\">执行后才完成，所以该Promise挂起，</span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">中暂停执行。</span></li></ul></ul><ol start=\"4\" class=\"ne-ol\"><li id=\"u5e47407d\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">console.log(7)</span></code><span class=\"ne-text\">执行，输出7。</span></li><li id=\"uaf22f070\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3()</span></code><span class=\"ne-text\">，将</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(6)</span></code><span class=\"ne-text\">（回调B）加入微任务队列中，此时微任务队列：[回调A（console.log(4)），回调B（console.log(6)）]</span></li><li id=\"ueb91d798\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务队列（阶段1）：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uef015d46\" data-lake-index-type=\"0\"><span class=\"ne-text\">回调A调用，输出4。P2完成，</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">将后续代码（没有）推入微任务队列，所以会产生一个微任务解析</span><code class=\"ne-code\"><span class=\"ne-text\">asy2()</span></code><span class=\"ne-text\">的完成（微任务C）。</span></li><li id=\"u2643c2d9\" data-lake-index-type=\"0\"><span class=\"ne-text\">回调B调用，输出6。此时微任务队列：[微任务C（asy2的完成）]</span></li></ul></ul><ol start=\"7\" class=\"ne-ol\"><li id=\"ue3844e51\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务队列（阶段2）：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uee079303\" data-lake-index-type=\"0\"><span class=\"ne-text\">回调C调用，</span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">中</span><code class=\"ne-code\"><span class=\"ne-text\">await asy2()</span></code><span class=\"ne-text\">完成，将后续代码（</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(2)</span></code><span class=\"ne-text\">回调D）推入微任务队列。</span></li><li id=\"u08fd80c5\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行回调D，输出2。</span></li></ul></ul><p id=\"u8e7806a1\" class=\"ne-p\"><br></p></details>\n","source":"_posts/关于eventloop.md","raw":"---\ntitle: 关于eventloop\ndate: 2023-10-08\ntags: [eventloop, js基础, async/await案例题]\ncategories: eventloop\n---\n\n一些参考：\n\n测试eventloop地址：[https://www.jsv9000.app](https://www.jsv9000.app)\n\n参考视频：[【事件循环】【前端】事件原理讲解](https://www.bilibili.com/video/BV1K4411D7Jb/?spm_id_from=333.337.search-card.all.click&vd_source=a1a75df55f32a09493aa84363d0e2aa0)\n\n## 浏览器的事件循环机制（EventLoop）\n概述：\n\n要真正理解事件循环，我们需要先了解浏览器的多进程架构：\n\n+ **浏览器主进程**：负责界面显示、用户交互\n+ **GPU进程**：处理图形渲染\n+ **网络进程**：处理网络请求\n+ **渲染进程**（核心）：每个标签页一个渲染进程，包含：\n    - **主线程**：<u>执行JS、解析HTML/CSS、布局、绘制（就是我们常说的JS线程）</u>\n    - **合成线程**：负责图层分割\n    - **光栅线程**：将图层转换为像素\n\n> <font style=\"background-color:rgba(77, 208, 225, 0.15);\">关键点：JS引擎（如V8）只是渲染进程的一部分，JS的\"单线程\"指的是主线程的单线程，浏览器整体是多线程的。</font>\n>\n\n\n\n关于浏览器渲染机制的笔记，可以查看：[浏览器渲染机制](https://www.yuque.com/u54400072/kgraay/gyclhvv7y5wogkf0)\n\n\n\n### JavaScript的单线程特性与异步机制\n#### JS为什么是单线程的？\nJavaScript被设计成单线程的，主要是为了避免DOM操作的复杂性。如果JavaScript是多线程的，那么当多个线程同时操作同一个DOM元素时，就会出现竞态条件（Race Condition），导致不可预测的结果。例如，一个线程要删除某个DOM元素，另一个线程要修改它，那么到底应该以哪个线程的操作为准呢？为了避免这种复杂性，JavaScript从诞生之初就被设计为单线程。\n\n#### 单线程带来的问题与解决方案\n（1）阻塞问题\n\n+ 单线程意味着所有任务需按顺序执行，若某个任务耗时过长（如复杂计算或网络请求），会阻塞后续代码执行，导致页面卡顿\n+ 解决方案：\n    - **异步编程模型**：通过回调函数、Promise、async/await 处理异步操作，避免阻塞主线程\n\n```javascript\n// 示例：使用 Promise 处理异步请求\nfetch('https://api.example.com/data')\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error(error));\n```\n\n    - **Web Worker**：将耗时任务交给后台线程处理，不阻塞主线程\n\n```javascript\n// 主线程\nconst worker = new Worker('worker.js');\nworker.postMessage('开始计算');\nworker.onmessage = (e) => {\n  console.log('计算结果:', e.data);\n};\n\n// worker.js（独立线程）\nonmessage = (e) => {\n  const result = performHeavyCalculation();\n  postMessage(result);\n};\n```\n\n（2）I/O密集型场景的优化\n\n+ 浏览器中的 JavaScript 主要处理 I/O 密集型任务（如网络请求、文件操作），单线程模型配合异步 I/O 机制（如事件循环）可高效处理这类场景。\n+ **事件循环（Event Loop）**：\n    - JavaScript 通过事件循环机制处理异步任务，将耗时操作放入任务队列，主线程空闲时再处理这些任务。\n\n\n\n### 事件循环的完整运行机制：\n#### 核心组件详解\n（1）调用栈（Call Stack）\n\n+ 本质：记录函数调用的数据结构（LIFO栈），先进后出，如下图所示：\n\n![调用栈callstack](images/callstack.webp)\n\n+ 特点：\n    - **合成线程**：每次函数调用都会创建新的栈帧（包含参数、局部变量等）\n    - 栈溢出：当递归深度超过最大调用栈大小（Chrome约1万层）\n\n```javascript\n// 栈溢出示例\nfunction stackOverflow() {\n  stackOverflow()\n}\nstackOverflow() // Uncaught RangeError: Maximum call stack size exceeded\n```\n\n\n\n（2）堆内存（Heap）\n\n+ 存储引用类型（对象、数组等）的内存区域\n+ 与栈的区别：\n    - 栈：自动分配固定大小内存（基础类型、指针）\n    - 堆：动态分配内存，需要垃圾回收\n\n（3）任务队列系统\n\n| **队列类型** | **触发方式** | **优先级** |\n| --- | --- | --- |\n| 微任务队列 | JS引擎直接管理 | 高 |\n| 宏任务队列 | 由浏览器宿主环境管理 | 低 |\n| 动画回调队列 | requestAnimationFrame | 特殊 |\n| 空闲回调队列 | requestIdleCallback | 最低 |\n\n\n#### 完整事件循环流程\n下图为主线程中事件循环的运行示例图：\n\n![主线程中的eventloop](images/主线程中的eventloop.png)\n\n<img src=\"/images/eventloop流程.png\" alt=\"eventloop流程\" height=\"auto\" style=\"width:40%; display:block;\">\n\n##### 宏任务【Macro-tasks】与微任务【micro-tasks】\n宏任务大概包括：\n\n+ script(整体代码)\n+ setTimeout\n+ setInterval\n+ setImmediate\n+ I/O（例如网络请求 `<font style=\"background-color:rgba(77, 208, 225, 0.08);\">ajax</font>`、文件读写）\n+ UI render\n+ `<font style=\"background-color:rgba(77, 208, 225, 0.08);\">setImmediate</font>` (Node.js环境特有)\n\n微任务大概包括：\n\n+ `<font style=\"background-color:rgba(77, 208, 225, 0.08);\">Promise.then()</font>`、`<font style=\"background-color:rgba(77, 208, 225, 0.08);\">Promise.catch()</font>`、`<font style=\"background-color:rgba(77, 208, 225, 0.08);\">Promise.finally()</font>`\n+ `<font style=\"background-color:rgba(77, 208, 225, 0.08);\">process.nextTick</font>` (Node.js环境特有)\n+ `<font style=\"background-color:rgba(77, 208, 225, 0.08);\">MutationObserver</font>` (h5新特性 用于监听DOM变化)\n\n##### EventLoop的执行顺序详解：\n1. **执行同步代码：** 当JavaScript代码开始执行时，会首先执行所有的同步代码。这些同步代码可以被看作是当前宏任务的一部分。在执行过程中，如果遇到异步任务（无论是宏任务还是微任务），就会将其对应的回调函数放入相应的任务队列中。\n2. **清空微任务队列：** 当所有同步代码执行完毕后，Event Loop并不会立即去执行宏任务队列中的任务。它会优先检查并清空**微任务队列**。这意味着，所有在当前宏任务执行期间产生的微任务，都会在下一个宏任务开始之前被执行完毕。\n3. **页面渲染（可选）：** 在微任务队列清空之后，如果浏览器判断有必要进行页面渲染（比如DOM结构发生了变化，或者需要更新UI），它就会进行一次页面渲染。这一步是可选的，浏览器会根据实际情况决定是否进行渲染。\n4. **执行下一个宏任务：** 页面渲染完成后，Event Loop会从**宏任务队列**中取出一个任务来执行。这个任务执行完毕后，又会重复步骤2，检查并清空微任务队列，然后再次进行页面渲染（如果需要），接着再从宏任务队列中取出下一个任务……如此循环往复，直到所有任务执行完毕。\n\n这个过程可以概括为：**一个宏任务执行完毕 -> 清空所有微任务 -> 页面渲染（如果需要） -> 执行下一个宏任务**。这个循环会一直持续下去，直到所有任务都执行完毕。\n\n\n\n### 代码实战：\n#### async/await在EventLoop中的表现：\n##### 概述：async/await是js中用于处理异步操作的语法糖，基于promise+generator构建\n+ async函数\n    - async函数隐式返回一个Promise对象。如果函数返回一个值，该值会被包装为Promise（通过`Promise.resolve`）；如果函数抛出异常，则返回的Promise状态为`rejected`。\n\n```javascript\nasync function foo(){\n  return 'hello world!'\n}\n\n// 等同于\nfunction foo() {\n  return Promise.resolve('hello world!')\n}\n```\n\n+ await表达式\n    - `await`只能在async函数内部使用。\n    - `await`后面可以跟一个Promise对象，它会暂停async函数的执行，等待Promise的状态变为`resolved`，然后返回结果值。\n    - 如果`await`后面是一个非Promise的值，它会被立即转换为一个已解决的Promise。\n    - 如果Promise被拒绝（rejected），`await`会抛出拒绝的原因（可以使用try/catch捕获）\n\n##### async函数在事件循环中造成的细微差别：\n<img src=\"/images/async和微任务.png\" alt=\"async和微任务\" height=\"auto\" style=\"width:60%; display:block;\">\n\n**重点：**\n\n**根据规范，async函数返回一个Promise，并且await会暂停函数的执行，等待Promise解决，然后继续执行函数，并将后续代码放入微任务队列。**\n\n**特别要注意的是：当async函数返回一个Promise时，会有额外的微任务产生（因为需要等待返回的Promise被解决，然后才能解决async函数自己的Promise）。**\n\n\n<details class=\"lake-collapse\"><summary id=\"uee28ecd3\"><span class=\"ne-text\">async async2()函数分析：</span></summary><p id=\"u6adc2781\" class=\"ne-p\"><span class=\"ne-text\">执行同步代码：</span></p><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u93ecd645\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 'script start'</span></li><li id=\"ub0b236ee\" data-lake-index-type=\"0\"><span class=\"ne-text\">定义async1和async2（不执行）</span></li><li id=\"u83f602f8\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用async1()</span></li><li id=\"u3b88aae8\" data-lake-index-type=\"0\"><span class=\"ne-text\">在async1中，调用async2()（因为await后面是async2()，所以先执行async2）</span></li></ul></ul><ol class=\"ne-ol\"><li id=\"u901c7dd1\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行async2：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u7be6e3e7\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 'async2 end'</span></li><li id=\"uf1064ee2\" data-lake-index-type=\"0\"><span class=\"ne-text\">然后执行 return Promise.resolve().then(...)<br /></span><span class=\"ne-text\">  这里，Promise.resolve()返回一个已解决的Promise，然后调用then方法，将then的回调（输出'async2 end1'）放入微任务队列。</span></li><li id=\"u13468c5f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"background-color: #CEF5F7\">注意：async2是一个async函数，它返回的Promise不是直接这个then返回的Promise，而是会额外包装一层。<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">根据ECMAScript规范，async函数内部return一个值x，相当于执行</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"background-color: #CEF5F7\">Promise.resolve(x)</span></code><span class=\"ne-text\" style=\"background-color: #CEF5F7\">，然后会等待x（如果x是Promise）解决，再解决async函数返回的Promise。但是，如果x是一个Promise，那么就会产生两个微任务：一个用于等待x解决，另一个用于解决async函数的Promise。<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">具体到async2：<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">async2中：return Promise.resolve().then(...)<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">这个then方法返回一个新的Promise（我们称为P1）。而async2函数会返回一个新的Promise（称为P2），P2的解决会等待P1的解决。所以，在P1解决后，才会解决P2，然后async1中的await才会继续。</span></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"u485bd34a\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续同步代码：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u29d7af0e\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用setTimeout，将回调放入宏任务队列（0毫秒后，但会在当前宏任务执行完后执行）</span></li><li id=\"ud7fba569\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行new Promise，输出 'Promise'，并立即resolve，将第一个then的回调（输出'promise1'）放入微任务队列</span></li><li id=\"u2c84e1e6\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 'script end'<br /></span><span class=\"ne-text\">此时，同步代码执行完毕。当前微任务队列中有两个任务（注意顺序）：</span></li><li id=\"u9f2acfbe\" data-lake-index-type=\"0\"><span class=\"ne-text\">第一个是async2中放入的：输出'async2 end1'（来自P1的then回调）</span></li><li id=\"u5048b8b9\" data-lake-index-type=\"0\"><span class=\"ne-text\">第二个是new Promise的then回调：输出'promise1'</span></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u1fcaa51b\" data-lake-index-type=\"0\"><span class=\"ne-text\">开始执行微任务队列：<br /></span><span class=\"ne-text\">第一个微任务：执行async2中then的回调<br /></span><span class=\"ne-text\">  输出 'async2 end1'<br /></span><span class=\"ne-text\">  这个回调执行完毕，P1被解决（值为undefined，因为没有return）<br /></span><span class=\"ne-text\"> </span><strong><span class=\"ne-text\"> </span></strong><span class=\"ne-text\" style=\"background-color: #CEF5F7\">这时，因为async2返回的P2在等待P1解决，所以会安排一个微任务来解决P2（这是规范要求的，当async函数返回一个Promise时，需要等待这个Promise解决，然后才能解决async函数自己的Promise。这个等待过程会产生一个微任务）。</span><span class=\"ne-text\"><br /></span><span class=\"ne-text\">第二个微任务：执行输出'promise1'<br /></span><span class=\"ne-text\">  输出 'promise1'<br /></span><span class=\"ne-text\">  由于这个then回调返回undefined，所以它返回的Promise立即解决，于是下一个then的回调（输出'promise2'）被放入微任务队列。<br /></span><span class=\"ne-text\">此时，微任务队列中新增了两个微任务（按顺序）：<br /></span><span class=\"ne-text\">微任务3：解决async2返回的P2（这个微任务会触发async1中await后面的代码放入微任务队列）<br /></span><span class=\"ne-text\">微任务4：输出'promise2'<br /></span><span class=\"ne-text\">注意：微任务3是在执行第一个微任务（输出'async2 end1'）后产生的，所以它排在微任务4（由第二个微任务产生）之前。<br /></span><span class=\"ne-text\">当前微任务队列：[微任务3, 微任务4]</span></li><li id=\"u213c16ff\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续执行微任务队列：<br /></span><span class=\"ne-text\">执行微任务3：解决async2返回的P2<br /></span><span class=\"ne-text\">此时，await async2()的Promise（即P2）被解决，然后await后面的代码（输出'async1 end'）被放入微任务队列。<br /></span><span class=\"ne-text\">执行微任务4：输出 'promise2'<br /></span><span class=\"ne-text\">此时，微任务队列中新增了一个微任务（输出'async1 end'）</span></li><li id=\"uae2fa8c4\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续执行微任务队列（新的一轮？不，微任务队列会一直执行直到清空，所以会继续）：<br /></span><span class=\"ne-text\">微任务5：输出 'async1 end'</span></li><li id=\"ub048ce21\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列清空，执行宏任务：<br /></span><span class=\"ne-text\">  输出 'setTimeout'</span></li></ol></details>\n###### 事件循环详细过程：\n\n{% tabs 页面内不重复的ID %}\n \n<!-- tab 左边流程 -->\n \n阶段1：同步代码执行（宏任务）\n同右\n微任务队列：[ 回调A (async2 end1), 回调B (promise1) ]\n阶段2：微任务执行（第一轮）\n1. 执行回调A：\n  ○ console.log('async2 end1') → 输出 \"async2 end1\"\n  ○ 解析 P2（async2 内部 Promise）\n  ○ await async2() 完成，将 async1 end 加入微任务队列（回调C）\n微任务队列更新：\n[ 回调B (promise1), 回调C (async1 end) ]\n1. 执行回调B：\n  ○ console.log('promise1') → 输出 \"promise1\"\n  ○ 返回 undefined，自动创建新解析的 Promise P4\n  ○ 将 promise2 回调加入微任务队列（回调C）\n微任务队列更新：\n[ 回调C (async1 end) , 回调D (promise2)]\n阶段3：微任务执行（第二轮）\n1. 执行回调C：\n  ○ console.log('async1 end') → 输出 \"async1 end\"\n2. 执行回调D：\n  ○ console.log('promise2') → 输出 \"promise2\"\n阶段4：宏任务执行\n1. 执行 setTimeout 回调：\n  ○ console.log('setTimeout') → 输出 \"setTimeout\"\n \n<!-- endtab -->\n<!-- tab 右边流程 -->\n \n阶段1：同步代码执行（宏任务）\n1. console.log('script start')\n→ 输出 \"script start\"\n2. 定义函数：\n  ○ 定义 async1 和 async2（不执行函数体）\n3. 调用 async1()：\n  ○ 进入 async1，遇到 await async2()\n  ○ 调用 async2()\n4. 执行 async2()：\n  ○ console.log('async2 end') → 输出 \"async2 end\"\n  ○ return Promise.resolve().then(...)\n创建 Promise P2 并将 .then 回调加入微任务队列（回调A）\n5. setTimeout：\n  ○ 将回调加入宏任务队列\n6. new Promise：\n  ○ console.log('Promise') → 输出 \"Promise\"\n  ○ resolve() 立即解析 Promise P3\n  ○ 将 .then 回调加入微任务队列（回调B）\n7. console.log('script end')\n→ 输出 \"script end\"\n微任务队列：[ 回调A (async2 end1), 回调B (promise1) ]\n阶段2：微任务执行（第一轮）\n1. 执行回调A：\n  ○ console.log('async2 end1') → 输出 \"async2 end1\"\n  ○ 解析 P2（async2 内部 Promise）\n  ○ 由于 async2 是 async 函数，需要额外微任务解析其返回的 Promise P1\n微任务队列更新：\n[ 回调B (promise1), 新任务 (解析P1) ]\n1. 执行回调B：\n  ○ console.log('promise1') → 输出 \"promise1\"\n  ○ 返回 undefined，自动创建新解析的 Promise P4\n  ○ 将 promise2 回调加入微任务队列（回调C）\n微任务队列更新：\n[ 解析P1, 回调C (promise2) ]\n阶段3：微任务执行（第二轮）\n1. 执行解析P1任务：\n  ○ 解析 async2 返回的 Promise P1\n  ○ 使 await async2() 完成，将 async1 end 加入微任务队列（回调D）\n微任务队列更新：\n[ 回调C (promise2), 回调D (async1 end) ]\n1. 执行回调C：\n  ○ console.log('promise2') → 输出 \"promise2\"\n2. 执行回调D：\n  ○ console.log('async1 end') → 输出 \"async1 end\"\n阶段4：宏任务执行\n1. 执行 setTimeout 回调：\n  ○ console.log('setTimeout') → 输出 \"setTimeout\"\n\n\n\n\n \n<!-- endtab -->\n \n{% endtabs %}\n\n\n  \n\n\n##### await表达式在事件循环中，参考[async和await的面试题](https://www.bilibili.com/video/BV1x29iYdEQy/?spm_id_from=333.337.search-card.all.click&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89)， 举例：\n```javascript\n  async function asy1(params) {\n      console.log(1);\n      await asy2();\n      console.log(2);\n    }\n\n  const asy2 = async () => {\n    await setTimeout(() => {\n      Promise.resolve().then(() => {\n        console.log(3);\n      });\n      console.log(4);\n    }, 0);\n  };\n\n  const asy3 = async () => {\n    Promise.resolve().then(() => {\n      console.log(6);\n    });\n  };\n\n  asy1();\n  console.log(7);\n  asy3();\n\n// 输出顺序如下：\n// 1\n// 7\n// 6\n// 2\n// 4\n// 3\n```\n\n###### 分析如下：\n<details class=\"lake-collapse\"><summary id=\"ua9d4e59b\"><span class=\"ne-text\">执行流程：</span></summary><ol class=\"ne-ol\"><li id=\"ua7bdc105\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">，进入</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">函数：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ubff5558e\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code></li><li id=\"u11d6bd6e\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2()</span></code></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"ub1b11355\" data-lake-index-type=\"0\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 中：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u4398c32c\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">setTimeout</span></code><span class=\"ne-text\">，将回调函数放入宏任务队列（将在下一个宏任务执行）。</span></li><li id=\"u5f055c33\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面是 </span><code class=\"ne-code\"><span class=\"ne-text\">setTimeout</span></code><span class=\"ne-text\"> 返回的数字，所以会生成一个立即解决的Promise，并将 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面的代码（这里没有代码，所以实际上是等待这个Promise解决，然后 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回）包装成微任务，放入微任务队列。</span></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u3a31576e\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续执行同步代码：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u6e2f88c4\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">7</span></code></li><li id=\"u2b84c779\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3()</span></code><span class=\"ne-text\">，在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\"> 中，</span><code class=\"ne-code\"><span class=\"ne-text\">Promise.resolve().then</span></code><span class=\"ne-text\"> 将回调（输出6）放入微任务队列。</span></li></ul></ul><ol start=\"4\" class=\"ne-ol\"><li id=\"u10e27d36\" data-lake-index-type=\"0\"><span class=\"ne-text\">同步代码执行完毕，开始执行微任务队列：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ucaa3f54f\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列中有两个微任务：</span></li></ul></ul><ol class=\"ne-list-wrap\"><ol class=\"ne-list-wrap\"><ol ne-level=\"2\" class=\"ne-ol\"><li id=\"u8a3a55ba\" data-lake-index-type=\"0\"><span class=\"ne-text\">由 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生的微任务（表示 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数可以继续执行，实际上就是让 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回，并解决 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 所等待的Promise）。</span></li><li id=\"u19404ecd\" data-lake-index-type=\"0\"><span class=\"ne-text\">由 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\"> 放入的微任务（输出6）。</span></li></ol></ol></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u8a4fffbd\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列按顺序执行：</span></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"u6d3cc76f\" data-lake-index-type=\"0\"><span class=\"ne-text\">首先执行第一个微任务（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">）：这个微任务的执行会解决</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">函数返回的Promise，从而让</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">函数中</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">后面的代码（输出2）可以继续，但是注意，这个继续并不是立即执行输出2，而是将输出2的代码作为一个新的微任务加入微任务队列（因为async函数中，</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">后面的代码总是被包装成微任务）。</span></li><li id=\"uab041688\" data-lake-index-type=\"0\"><span class=\"ne-text\">然后执行第二个微任务：输出 </span><code class=\"ne-code\"><span class=\"ne-text\">6</span></code><span class=\"ne-text\">。</span></li></ul></ul></ul><ol start=\"5\" class=\"ne-ol\"><li id=\"ucf226f8c\" data-lake-index-type=\"0\"><span class=\"ne-text\">此时微任务队列中又有了一个新的微任务（输出2），所以接下来执行这个微任务：输出 </span><code class=\"ne-code\"><span class=\"ne-text\">2</span></code><span class=\"ne-text\">。</span></li><li id=\"u6c503281\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列清空，然后执行宏任务队列中的定时器回调：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uccbe3d59\" data-lake-index-type=\"0\"><span class=\"ne-text\">在定时器回调中：</span></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"u31c6a5c4\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行 </span><code class=\"ne-code\"><span class=\"ne-text\">Promise.resolve().then</span></code><span class=\"ne-text\">，将输出3的回调放入微任务队列。</span></li><li id=\"u4f93746a\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">4</span></code><span class=\"ne-text\">。</span></li></ul></ul></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u30f2e9ee\" data-lake-index-type=\"0\"><span class=\"ne-text\">这个宏任务执行完毕，然后执行微任务队列：输出 </span><code class=\"ne-code\"><span class=\"ne-text\">3</span></code><span class=\"ne-text\">。</span></li></ul></ul><h3 id=\"GAz0l\"><span class=\"ne-text\">重点：</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生的微任务次数</span></h3><p id=\"ua93b7a29\" class=\"ne-p\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中：</span></p><ul class=\"ne-ul\"><li id=\"ua4ecaa40\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 一个非Promise值（数字）会产生一个微任务（用于继续执行async函数后面的代码，即使后面没有代码，也需要解决async函数返回的Promise）。<br /></span><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中：</span></li><li id=\"u15aad2bc\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await asy2()</span></code><span class=\"ne-text\">：</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 返回一个Promise，这个Promise的解决会在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数内部的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 完成时（即上面产生的微任务执行时）解决。然后，</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面的代码（输出2）会被放入微任务队列。<br /></span><span class=\"ne-text\">因此，整个流程中微任务队列的变化：</span></li></ul><ol class=\"ne-ol\"><li id=\"u67f1aaae\" data-lake-index-type=\"0\"><span class=\"ne-text\">同步代码执行完毕后，微任务队列有两个微任务：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uea94d940\" data-lake-index-type=\"0\"><span class=\"ne-text\">第一个是 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生的（标记为微任务A）：用于解决 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回的Promise。</span></li><li id=\"u0ac362e1\" data-lake-index-type=\"0\"><span class=\"ne-text\">第二个是 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\"> 放入的（微任务B）：输出6。</span></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"u161f7bd5\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务A：这会解决 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回的Promise，然后导致 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 完成，从而将 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面的代码（输出2）作为新的微任务（微任务C）加入队列。</span></li><li id=\"u35263207\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务B：输出6。</span></li><li id=\"u7a57f36d\" data-lake-index-type=\"0\"><span class=\"ne-text\">然后执行微任务C：输出2。<br /></span><span class=\"ne-text\">所以，</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 确实产生了一个微任务（微任务A），并且这个微任务的执行又导致了一个新的微任务（微任务C）产生。</span></li></ol><h3 id=\"OZ2IP\"><span class=\"ne-text\">结论</span></h3><p id=\"u030784a1\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生了微任务。整个代码中，微任务队列的执行顺序是：</span></p><ol class=\"ne-ol\"><li id=\"u270ebb63\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务A（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">）：解决</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">的Promise，触发</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">中的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">完成，将输出2加入微任务队列（微任务C）。</span></li><li id=\"ufa55c812\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务B（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\">）：输出6。</span></li><li id=\"u671bd9d5\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务C（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">完成）：输出2。<br /></span><span class=\"ne-text\">然后执行宏任务（定时器回调），在定时器回调中又产生了一个微任务（输出3），最后执行。</span></li></ol></details>\n###### 上面的例子稍微变形后：\n```javascript\nasync function asy1(params) {\n    console.log(1);\n    await asy2();\n    console.log(2);\n  }\n\nconst asy2 = async () => {\n  await (async () => {\n    await (() => {\n      console.log(3);\n    })();\n    console.log(4);\n  })();\n};\n\nconst asy3 = async () => {\n  Promise.resolve().then(() => {\n    console.log(6);\n  });\n};\n\nasy1();\nconsole.log(7);\nasy3();\n\n// 输出顺序如下：\n// 1\n// 3\n// 7\n// 4\n// 6\n// 2\n```\n\n<details class=\"lake-collapse\"><summary id=\"u058a4c63\"><span class=\"ne-text\">分析如下：</span></summary><ol class=\"ne-ol\"><li id=\"uc339dd7e\" data-lake-index-type=\"0\"><span class=\"ne-text\">声明asy1、asy2、asy3函数，不进入执行栈。</span></li><li id=\"u4182cade\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">，进入</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">函数：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uc8b547f5\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code></li><li id=\"uc54df11b\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2()</span></code></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u96ec74de\" data-lake-index-type=\"0\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 中：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ub8620ccd\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await (() =&gt; {console.log(3) })()</span></code><span class=\"ne-text\"> 即</span><code class=\"ne-code\"><span class=\"ne-text\">await console.log(3)</span></code><span class=\"ne-text\">最终会生成一个立即解决的Promise，即</span><code class=\"ne-code\"><span class=\"ne-text\">await Promise.resolve()</span></code><span class=\"ne-text\">记为P1，该Promise解决后，将</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(4);</span></code><span class=\"ne-text\">（回调A）推入微任务队列。</span></li><li id=\"u47e33dc8\" data-lake-index-type=\"0\"><span class=\"ne-text\">此时</span><code class=\"ne-code\"><span class=\"ne-text\">await (async () =&gt; {...)()</span></code><span class=\"ne-text\"> 返回的Promise，记为P2，需要等待内部的</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(4)</span></code><span class=\"ne-text\">执行后才完成，所以该Promise挂起，</span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">中暂停执行。</span></li></ul></ul><ol start=\"4\" class=\"ne-ol\"><li id=\"u5e47407d\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">console.log(7)</span></code><span class=\"ne-text\">执行，输出7。</span></li><li id=\"uaf22f070\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3()</span></code><span class=\"ne-text\">，将</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(6)</span></code><span class=\"ne-text\">（回调B）加入微任务队列中，此时微任务队列：[回调A（console.log(4)），回调B（console.log(6)）]</span></li><li id=\"ueb91d798\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务队列（阶段1）：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uef015d46\" data-lake-index-type=\"0\"><span class=\"ne-text\">回调A调用，输出4。P2完成，</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">将后续代码（没有）推入微任务队列，所以会产生一个微任务解析</span><code class=\"ne-code\"><span class=\"ne-text\">asy2()</span></code><span class=\"ne-text\">的完成（微任务C）。</span></li><li id=\"u2643c2d9\" data-lake-index-type=\"0\"><span class=\"ne-text\">回调B调用，输出6。此时微任务队列：[微任务C（asy2的完成）]</span></li></ul></ul><ol start=\"7\" class=\"ne-ol\"><li id=\"ue3844e51\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务队列（阶段2）：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uee079303\" data-lake-index-type=\"0\"><span class=\"ne-text\">回调C调用，</span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">中</span><code class=\"ne-code\"><span class=\"ne-text\">await asy2()</span></code><span class=\"ne-text\">完成，将后续代码（</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(2)</span></code><span class=\"ne-text\">回调D）推入微任务队列。</span></li><li id=\"u08fd80c5\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行回调D，输出2。</span></li></ul></ul><p id=\"u8e7806a1\" class=\"ne-p\"><br></p></details>\n","slug":"关于eventloop","published":1,"updated":"2025-09-14T15:30:54.900Z","_id":"cmfjthuof0000l95wai7x11xt","comments":1,"layout":"post","photos":[],"content":"<p>一些参考：</p>\n<p>测试eventloop地址：<a class=\"link\"   href=\"https://www.jsv9000.app/\" >https://www.jsv9000.app<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p>参考视频：<a class=\"link\"   href=\"https://www.bilibili.com/video/BV1K4411D7Jb/?spm_id_from=333.337.search-card.all.click&vd_source=a1a75df55f32a09493aa84363d0e2aa0\" >【事件循环】【前端】事件原理讲解<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<h2 id=\"浏览器的事件循环机制（EventLoop）\"><a href=\"#浏览器的事件循环机制（EventLoop）\" class=\"headerlink\" title=\"浏览器的事件循环机制（EventLoop）\"></a>浏览器的事件循环机制（EventLoop）</h2><p>概述：</p>\n<p>要真正理解事件循环，我们需要先了解浏览器的多进程架构：</p>\n<ul>\n<li><strong>浏览器主进程</strong>：负责界面显示、用户交互</li>\n<li><strong>GPU进程</strong>：处理图形渲染</li>\n<li><strong>网络进程</strong>：处理网络请求</li>\n<li><strong>渲染进程</strong>（核心）：每个标签页一个渲染进程，包含：<ul>\n<li><strong>主线程</strong>：<u>执行JS、解析HTML&#x2F;CSS、布局、绘制（就是我们常说的JS线程）</u></li>\n<li><strong>合成线程</strong>：负责图层分割</li>\n<li><strong>光栅线程</strong>：将图层转换为像素</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><font style=\"background-color:rgba(77, 208, 225, 0.15);\">关键点：JS引擎（如V8）只是渲染进程的一部分，JS的”单线程”指的是主线程的单线程，浏览器整体是多线程的。</font></p>\n</blockquote>\n<p>关于浏览器渲染机制的笔记，可以查看：<a class=\"link\"   href=\"https://www.yuque.com/u54400072/kgraay/gyclhvv7y5wogkf0\" >浏览器渲染机制<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<h3 id=\"JavaScript的单线程特性与异步机制\"><a href=\"#JavaScript的单线程特性与异步机制\" class=\"headerlink\" title=\"JavaScript的单线程特性与异步机制\"></a>JavaScript的单线程特性与异步机制</h3><h4 id=\"JS为什么是单线程的？\"><a href=\"#JS为什么是单线程的？\" class=\"headerlink\" title=\"JS为什么是单线程的？\"></a>JS为什么是单线程的？</h4><p>JavaScript被设计成单线程的，主要是为了避免DOM操作的复杂性。如果JavaScript是多线程的，那么当多个线程同时操作同一个DOM元素时，就会出现竞态条件（Race Condition），导致不可预测的结果。例如，一个线程要删除某个DOM元素，另一个线程要修改它，那么到底应该以哪个线程的操作为准呢？为了避免这种复杂性，JavaScript从诞生之初就被设计为单线程。</p>\n<h4 id=\"单线程带来的问题与解决方案\"><a href=\"#单线程带来的问题与解决方案\" class=\"headerlink\" title=\"单线程带来的问题与解决方案\"></a>单线程带来的问题与解决方案</h4><p>（1）阻塞问题</p>\n<ul>\n<li>单线程意味着所有任务需按顺序执行，若某个任务耗时过长（如复杂计算或网络请求），会阻塞后续代码执行，导致页面卡顿</li>\n<li>解决方案：<ul>\n<li><strong>异步编程模型</strong>：通过回调函数、Promise、async&#x2F;await 处理异步操作，避免阻塞主线程</li>\n</ul>\n</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例：使用 Promise 处理异步请求</span></span><br><span class=\"line\"><span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.<span class=\"title function_\">json</span>())</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data))</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(error));</span><br></pre></td></tr></table></figure></div>\n\n<pre><code>- **Web Worker**：将耗时任务交给后台线程处理，不阻塞主线程\n</code></pre>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主线程</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> worker = <span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(<span class=\"string\">&#x27;worker.js&#x27;</span>);</span><br><span class=\"line\">worker.<span class=\"title function_\">postMessage</span>(<span class=\"string\">&#x27;开始计算&#x27;</span>);</span><br><span class=\"line\">worker.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;计算结果:&#x27;</span>, e.<span class=\"property\">data</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// worker.js（独立线程）</span></span><br><span class=\"line\">onmessage = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"title function_\">performHeavyCalculation</span>();</span><br><span class=\"line\">  <span class=\"title function_\">postMessage</span>(result);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<p>（2）I&#x2F;O密集型场景的优化</p>\n<ul>\n<li>浏览器中的 JavaScript 主要处理 I&#x2F;O 密集型任务（如网络请求、文件操作），单线程模型配合异步 I&#x2F;O 机制（如事件循环）可高效处理这类场景。</li>\n<li><strong>事件循环（Event Loop）</strong>：<ul>\n<li>JavaScript 通过事件循环机制处理异步任务，将耗时操作放入任务队列，主线程空闲时再处理这些任务。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"事件循环的完整运行机制：\"><a href=\"#事件循环的完整运行机制：\" class=\"headerlink\" title=\"事件循环的完整运行机制：\"></a>事件循环的完整运行机制：</h3><h4 id=\"核心组件详解\"><a href=\"#核心组件详解\" class=\"headerlink\" title=\"核心组件详解\"></a>核心组件详解</h4><p>（1）调用栈（Call Stack）</p>\n<ul>\n<li>本质：记录函数调用的数据结构（LIFO栈），先进后出，如下图所示：</li>\n</ul>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/callstack.webp\"\n                      alt=\"调用栈callstack\"\n                ></p>\n<ul>\n<li>特点：<ul>\n<li><strong>合成线程</strong>：每次函数调用都会创建新的栈帧（包含参数、局部变量等）</li>\n<li>栈溢出：当递归深度超过最大调用栈大小（Chrome约1万层）</li>\n</ul>\n</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 栈溢出示例</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">stackOverflow</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">stackOverflow</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">stackOverflow</span>() <span class=\"comment\">// Uncaught RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>（2）堆内存（Heap）</p>\n<ul>\n<li>存储引用类型（对象、数组等）的内存区域</li>\n<li>与栈的区别：<ul>\n<li>栈：自动分配固定大小内存（基础类型、指针）</li>\n<li>堆：动态分配内存，需要垃圾回收</li>\n</ul>\n</li>\n</ul>\n<p>（3）任务队列系统</p>\n<table>\n<thead>\n<tr>\n<th><strong>队列类型</strong></th>\n<th><strong>触发方式</strong></th>\n<th><strong>优先级</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>微任务队列</td>\n<td>JS引擎直接管理</td>\n<td>高</td>\n</tr>\n<tr>\n<td>宏任务队列</td>\n<td>由浏览器宿主环境管理</td>\n<td>低</td>\n</tr>\n<tr>\n<td>动画回调队列</td>\n<td>requestAnimationFrame</td>\n<td>特殊</td>\n</tr>\n<tr>\n<td>空闲回调队列</td>\n<td>requestIdleCallback</td>\n<td>最低</td>\n</tr>\n</tbody></table>\n<h4 id=\"完整事件循环流程\"><a href=\"#完整事件循环流程\" class=\"headerlink\" title=\"完整事件循环流程\"></a>完整事件循环流程</h4><p>下图为主线程中事件循环的运行示例图：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84eventloop.png\"\n                      alt=\"主线程中的eventloop\"\n                ></p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/eventloop流程.png\"\n                      alt=\"eventloop流程\" height=\"auto\" style=\"width:40%; display:block;\"\n                >\n\n<h5 id=\"宏任务【Macro-tasks】与微任务【micro-tasks】\"><a href=\"#宏任务【Macro-tasks】与微任务【micro-tasks】\" class=\"headerlink\" title=\"宏任务【Macro-tasks】与微任务【micro-tasks】\"></a>宏任务【Macro-tasks】与微任务【micro-tasks】</h5><p>宏任务大概包括：</p>\n<ul>\n<li>script(整体代码)</li>\n<li>setTimeout</li>\n<li>setInterval</li>\n<li>setImmediate</li>\n<li>I&#x2F;O（例如网络请求 <code>&lt;font style=&quot;background-color:rgba(77, 208, 225, 0.08);&quot;&gt;ajax&lt;/font&gt;</code>、文件读写）</li>\n<li>UI render</li>\n<li><code>&lt;font style=&quot;background-color:rgba(77, 208, 225, 0.08);&quot;&gt;setImmediate&lt;/font&gt;</code> (Node.js环境特有)</li>\n</ul>\n<p>微任务大概包括：</p>\n<ul>\n<li><code>&lt;font style=&quot;background-color:rgba(77, 208, 225, 0.08);&quot;&gt;Promise.then()&lt;/font&gt;</code>、<code>&lt;font style=&quot;background-color:rgba(77, 208, 225, 0.08);&quot;&gt;Promise.catch()&lt;/font&gt;</code>、<code>&lt;font style=&quot;background-color:rgba(77, 208, 225, 0.08);&quot;&gt;Promise.finally()&lt;/font&gt;</code></li>\n<li><code>&lt;font style=&quot;background-color:rgba(77, 208, 225, 0.08);&quot;&gt;process.nextTick&lt;/font&gt;</code> (Node.js环境特有)</li>\n<li><code>&lt;font style=&quot;background-color:rgba(77, 208, 225, 0.08);&quot;&gt;MutationObserver&lt;/font&gt;</code> (h5新特性 用于监听DOM变化)</li>\n</ul>\n<h5 id=\"EventLoop的执行顺序详解：\"><a href=\"#EventLoop的执行顺序详解：\" class=\"headerlink\" title=\"EventLoop的执行顺序详解：\"></a>EventLoop的执行顺序详解：</h5><ol>\n<li><strong>执行同步代码：</strong> 当JavaScript代码开始执行时，会首先执行所有的同步代码。这些同步代码可以被看作是当前宏任务的一部分。在执行过程中，如果遇到异步任务（无论是宏任务还是微任务），就会将其对应的回调函数放入相应的任务队列中。</li>\n<li><strong>清空微任务队列：</strong> 当所有同步代码执行完毕后，Event Loop并不会立即去执行宏任务队列中的任务。它会优先检查并清空<strong>微任务队列</strong>。这意味着，所有在当前宏任务执行期间产生的微任务，都会在下一个宏任务开始之前被执行完毕。</li>\n<li><strong>页面渲染（可选）：</strong> 在微任务队列清空之后，如果浏览器判断有必要进行页面渲染（比如DOM结构发生了变化，或者需要更新UI），它就会进行一次页面渲染。这一步是可选的，浏览器会根据实际情况决定是否进行渲染。</li>\n<li><strong>执行下一个宏任务：</strong> 页面渲染完成后，Event Loop会从<strong>宏任务队列</strong>中取出一个任务来执行。这个任务执行完毕后，又会重复步骤2，检查并清空微任务队列，然后再次进行页面渲染（如果需要），接着再从宏任务队列中取出下一个任务……如此循环往复，直到所有任务执行完毕。</li>\n</ol>\n<p>这个过程可以概括为：<strong>一个宏任务执行完毕 -&gt; 清空所有微任务 -&gt; 页面渲染（如果需要） -&gt; 执行下一个宏任务</strong>。这个循环会一直持续下去，直到所有任务都执行完毕。</p>\n<h3 id=\"代码实战：\"><a href=\"#代码实战：\" class=\"headerlink\" title=\"代码实战：\"></a>代码实战：</h3><h4 id=\"async-await在EventLoop中的表现：\"><a href=\"#async-await在EventLoop中的表现：\" class=\"headerlink\" title=\"async&#x2F;await在EventLoop中的表现：\"></a>async&#x2F;await在EventLoop中的表现：</h4><h5 id=\"概述：async-await是js中用于处理异步操作的语法糖，基于promise-generator构建\"><a href=\"#概述：async-await是js中用于处理异步操作的语法糖，基于promise-generator构建\" class=\"headerlink\" title=\"概述：async&#x2F;await是js中用于处理异步操作的语法糖，基于promise+generator构建\"></a>概述：async&#x2F;await是js中用于处理异步操作的语法糖，基于promise+generator构建</h5><ul>\n<li>async函数<ul>\n<li>async函数隐式返回一个Promise对象。如果函数返回一个值，该值会被包装为Promise（通过<code>Promise.resolve</code>）；如果函数抛出异常，则返回的Promise状态为<code>rejected</code>。</li>\n</ul>\n</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello world!&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"string\">&#x27;hello world!&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>await表达式<ul>\n<li><code>await</code>只能在async函数内部使用。</li>\n<li><code>await</code>后面可以跟一个Promise对象，它会暂停async函数的执行，等待Promise的状态变为<code>resolved</code>，然后返回结果值。</li>\n<li>如果<code>await</code>后面是一个非Promise的值，它会被立即转换为一个已解决的Promise。</li>\n<li>如果Promise被拒绝（rejected），<code>await</code>会抛出拒绝的原因（可以使用try&#x2F;catch捕获）</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"async函数在事件循环中造成的细微差别：\"><a href=\"#async函数在事件循环中造成的细微差别：\" class=\"headerlink\" title=\"async函数在事件循环中造成的细微差别：\"></a>async函数在事件循环中造成的细微差别：</h5><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/async和微任务.png\"\n                      alt=\"async和微任务\" height=\"auto\" style=\"width:60%; display:block;\"\n                >\n\n<p><strong>重点：</strong></p>\n<p><strong>根据规范，async函数返回一个Promise，并且await会暂停函数的执行，等待Promise解决，然后继续执行函数，并将后续代码放入微任务队列。</strong></p>\n<p><strong>特别要注意的是：当async函数返回一个Promise时，会有额外的微任务产生（因为需要等待返回的Promise被解决，然后才能解决async函数自己的Promise）。</strong></p>\n<details class=\"lake-collapse\"><summary id=\"uee28ecd3\"><span class=\"ne-text\">async async2()函数分析：</span></summary><p id=\"u6adc2781\" class=\"ne-p\"><span class=\"ne-text\">执行同步代码：</span></p><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u93ecd645\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 'script start'</span></li><li id=\"ub0b236ee\" data-lake-index-type=\"0\"><span class=\"ne-text\">定义async1和async2（不执行）</span></li><li id=\"u83f602f8\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用async1()</span></li><li id=\"u3b88aae8\" data-lake-index-type=\"0\"><span class=\"ne-text\">在async1中，调用async2()（因为await后面是async2()，所以先执行async2）</span></li></ul></ul><ol class=\"ne-ol\"><li id=\"u901c7dd1\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行async2：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u7be6e3e7\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 'async2 end'</span></li><li id=\"uf1064ee2\" data-lake-index-type=\"0\"><span class=\"ne-text\">然后执行 return Promise.resolve().then(...)<br /></span><span class=\"ne-text\">  这里，Promise.resolve()返回一个已解决的Promise，然后调用then方法，将then的回调（输出'async2 end1'）放入微任务队列。</span></li><li id=\"u13468c5f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"background-color: #CEF5F7\">注意：async2是一个async函数，它返回的Promise不是直接这个then返回的Promise，而是会额外包装一层。<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">根据ECMAScript规范，async函数内部return一个值x，相当于执行</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"background-color: #CEF5F7\">Promise.resolve(x)</span></code><span class=\"ne-text\" style=\"background-color: #CEF5F7\">，然后会等待x（如果x是Promise）解决，再解决async函数返回的Promise。但是，如果x是一个Promise，那么就会产生两个微任务：一个用于等待x解决，另一个用于解决async函数的Promise。<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">具体到async2：<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">async2中：return Promise.resolve().then(...)<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">这个then方法返回一个新的Promise（我们称为P1）。而async2函数会返回一个新的Promise（称为P2），P2的解决会等待P1的解决。所以，在P1解决后，才会解决P2，然后async1中的await才会继续。</span></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"u485bd34a\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续同步代码：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u29d7af0e\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用setTimeout，将回调放入宏任务队列（0毫秒后，但会在当前宏任务执行完后执行）</span></li><li id=\"ud7fba569\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行new Promise，输出 'Promise'，并立即resolve，将第一个then的回调（输出'promise1'）放入微任务队列</span></li><li id=\"u2c84e1e6\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 'script end'<br /></span><span class=\"ne-text\">此时，同步代码执行完毕。当前微任务队列中有两个任务（注意顺序）：</span></li><li id=\"u9f2acfbe\" data-lake-index-type=\"0\"><span class=\"ne-text\">第一个是async2中放入的：输出'async2 end1'（来自P1的then回调）</span></li><li id=\"u5048b8b9\" data-lake-index-type=\"0\"><span class=\"ne-text\">第二个是new Promise的then回调：输出'promise1'</span></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u1fcaa51b\" data-lake-index-type=\"0\"><span class=\"ne-text\">开始执行微任务队列：<br /></span><span class=\"ne-text\">第一个微任务：执行async2中then的回调<br /></span><span class=\"ne-text\">  输出 'async2 end1'<br /></span><span class=\"ne-text\">  这个回调执行完毕，P1被解决（值为undefined，因为没有return）<br /></span><span class=\"ne-text\"> </span><strong><span class=\"ne-text\"> </span></strong><span class=\"ne-text\" style=\"background-color: #CEF5F7\">这时，因为async2返回的P2在等待P1解决，所以会安排一个微任务来解决P2（这是规范要求的，当async函数返回一个Promise时，需要等待这个Promise解决，然后才能解决async函数自己的Promise。这个等待过程会产生一个微任务）。</span><span class=\"ne-text\"><br /></span><span class=\"ne-text\">第二个微任务：执行输出'promise1'<br /></span><span class=\"ne-text\">  输出 'promise1'<br /></span><span class=\"ne-text\">  由于这个then回调返回undefined，所以它返回的Promise立即解决，于是下一个then的回调（输出'promise2'）被放入微任务队列。<br /></span><span class=\"ne-text\">此时，微任务队列中新增了两个微任务（按顺序）：<br /></span><span class=\"ne-text\">微任务3：解决async2返回的P2（这个微任务会触发async1中await后面的代码放入微任务队列）<br /></span><span class=\"ne-text\">微任务4：输出'promise2'<br /></span><span class=\"ne-text\">注意：微任务3是在执行第一个微任务（输出'async2 end1'）后产生的，所以它排在微任务4（由第二个微任务产生）之前。<br /></span><span class=\"ne-text\">当前微任务队列：[微任务3, 微任务4]</span></li><li id=\"u213c16ff\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续执行微任务队列：<br /></span><span class=\"ne-text\">执行微任务3：解决async2返回的P2<br /></span><span class=\"ne-text\">此时，await async2()的Promise（即P2）被解决，然后await后面的代码（输出'async1 end'）被放入微任务队列。<br /></span><span class=\"ne-text\">执行微任务4：输出 'promise2'<br /></span><span class=\"ne-text\">此时，微任务队列中新增了一个微任务（输出'async1 end'）</span></li><li id=\"uae2fa8c4\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续执行微任务队列（新的一轮？不，微任务队列会一直执行直到清空，所以会继续）：<br /></span><span class=\"ne-text\">微任务5：输出 'async1 end'</span></li><li id=\"ub048ce21\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列清空，执行宏任务：<br /></span><span class=\"ne-text\">  输出 'setTimeout'</span></li></ol></details>\n###### 事件循环详细过程：\n\n<div class=\"tabs\" id=\"tab-页面内不重复的id\"><ul class=\"nav-tabs\"><li class=\"tab active\"><a class=\"#页面内不重复的id-1\">左边流程</a></li><li class=\"tab\"><a class=\"#页面内不重复的id-2\">右边流程</a></li></ul><div class=\"tab-content\"><div class=\"tab-pane active\" id=\"页面内不重复的id-1\"><p>阶段1：同步代码执行（宏任务）<br>同右<br>微任务队列：[ 回调A (async2 end1), 回调B (promise1) ]<br>阶段2：微任务执行（第一轮）</p>\n<ol>\n<li>执行回调A：<br>  ○ console.log(‘async2 end1’) → 输出 “async2 end1”<br>  ○ 解析 P2（async2 内部 Promise）<br>  ○ await async2() 完成，将 async1 end 加入微任务队列（回调C）<br>微任务队列更新：<br>[ 回调B (promise1), 回调C (async1 end) ]</li>\n<li>执行回调B：<br>  ○ console.log(‘promise1’) → 输出 “promise1”<br>  ○ 返回 undefined，自动创建新解析的 Promise P4<br>  ○ 将 promise2 回调加入微任务队列（回调C）<br>微任务队列更新：<br>[ 回调C (async1 end) , 回调D (promise2)]<br>阶段3：微任务执行（第二轮）</li>\n<li>执行回调C：<br>  ○ console.log(‘async1 end’) → 输出 “async1 end”</li>\n<li>执行回调D：<br>  ○ console.log(‘promise2’) → 输出 “promise2”<br>阶段4：宏任务执行</li>\n<li>执行 setTimeout 回调：<br>  ○ console.log(‘setTimeout’) → 输出 “setTimeout”</li>\n</ol></div><div class=\"tab-pane\" id=\"页面内不重复的id-2\"><p>阶段1：同步代码执行（宏任务）</p>\n<ol>\n<li>console.log(‘script start’)<br>→ 输出 “script start”</li>\n<li>定义函数：<br>  ○ 定义 async1 和 async2（不执行函数体）</li>\n<li>调用 async1()：<br>  ○ 进入 async1，遇到 await async2()<br>  ○ 调用 async2()</li>\n<li>执行 async2()：<br>  ○ console.log(‘async2 end’) → 输出 “async2 end”<br>  ○ return Promise.resolve().then(…)<br>创建 Promise P2 并将 .then 回调加入微任务队列（回调A）</li>\n<li>setTimeout：<br>  ○ 将回调加入宏任务队列</li>\n<li>new Promise：<br>  ○ console.log(‘Promise’) → 输出 “Promise”<br>  ○ resolve() 立即解析 Promise P3<br>  ○ 将 .then 回调加入微任务队列（回调B）</li>\n<li>console.log(‘script end’)<br>→ 输出 “script end”<br>微任务队列：[ 回调A (async2 end1), 回调B (promise1) ]<br>阶段2：微任务执行（第一轮）</li>\n<li>执行回调A：<br>  ○ console.log(‘async2 end1’) → 输出 “async2 end1”<br>  ○ 解析 P2（async2 内部 Promise）<br>  ○ 由于 async2 是 async 函数，需要额外微任务解析其返回的 Promise P1<br>微任务队列更新：<br>[ 回调B (promise1), 新任务 (解析P1) ]</li>\n<li>执行回调B：<br>  ○ console.log(‘promise1’) → 输出 “promise1”<br>  ○ 返回 undefined，自动创建新解析的 Promise P4<br>  ○ 将 promise2 回调加入微任务队列（回调C）<br>微任务队列更新：<br>[ 解析P1, 回调C (promise2) ]<br>阶段3：微任务执行（第二轮）</li>\n<li>执行解析P1任务：<br>  ○ 解析 async2 返回的 Promise P1<br>  ○ 使 await async2() 完成，将 async1 end 加入微任务队列（回调D）<br>微任务队列更新：<br>[ 回调C (promise2), 回调D (async1 end) ]</li>\n<li>执行回调C：<br>  ○ console.log(‘promise2’) → 输出 “promise2”</li>\n<li>执行回调D：<br>  ○ console.log(‘async1 end’) → 输出 “async1 end”<br>阶段4：宏任务执行</li>\n<li>执行 setTimeout 回调：<br>  ○ console.log(‘setTimeout’) → 输出 “setTimeout”</li>\n</ol></div></div></div>\n\n\n<h5 id=\"await表达式在事件循环中，参考async和await的面试题，-举例：\"><a href=\"#await表达式在事件循环中，参考async和await的面试题，-举例：\" class=\"headerlink\" title=\"await表达式在事件循环中，参考async和await的面试题， 举例：\"></a>await表达式在事件循环中，参考<a class=\"link\"   href=\"https://www.bilibili.com/video/BV1x29iYdEQy/?spm_id_from=333.337.search-card.all.click&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89\" >async和await的面试题<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>， 举例：</h5><div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">asy1</span>(<span class=\"params\">params</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"keyword\">await</span> <span class=\"title function_\">asy2</span>();</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">asy2</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">asy3</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">asy1</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">  <span class=\"title function_\">asy3</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出顺序如下：</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 7</span></span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></div>\n\n<h6 id=\"分析如下：\"><a href=\"#分析如下：\" class=\"headerlink\" title=\"分析如下：\"></a>分析如下：</h6><details class=\"lake-collapse\"><summary id=\"ua9d4e59b\"><span class=\"ne-text\">执行流程：</span></summary><ol class=\"ne-ol\"><li id=\"ua7bdc105\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">，进入</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">函数：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ubff5558e\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code></li><li id=\"u11d6bd6e\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2()</span></code></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"ub1b11355\" data-lake-index-type=\"0\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 中：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u4398c32c\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">setTimeout</span></code><span class=\"ne-text\">，将回调函数放入宏任务队列（将在下一个宏任务执行）。</span></li><li id=\"u5f055c33\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面是 </span><code class=\"ne-code\"><span class=\"ne-text\">setTimeout</span></code><span class=\"ne-text\"> 返回的数字，所以会生成一个立即解决的Promise，并将 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面的代码（这里没有代码，所以实际上是等待这个Promise解决，然后 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回）包装成微任务，放入微任务队列。</span></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u3a31576e\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续执行同步代码：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u6e2f88c4\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">7</span></code></li><li id=\"u2b84c779\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3()</span></code><span class=\"ne-text\">，在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\"> 中，</span><code class=\"ne-code\"><span class=\"ne-text\">Promise.resolve().then</span></code><span class=\"ne-text\"> 将回调（输出6）放入微任务队列。</span></li></ul></ul><ol start=\"4\" class=\"ne-ol\"><li id=\"u10e27d36\" data-lake-index-type=\"0\"><span class=\"ne-text\">同步代码执行完毕，开始执行微任务队列：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ucaa3f54f\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列中有两个微任务：</span></li></ul></ul><ol class=\"ne-list-wrap\"><ol class=\"ne-list-wrap\"><ol ne-level=\"2\" class=\"ne-ol\"><li id=\"u8a3a55ba\" data-lake-index-type=\"0\"><span class=\"ne-text\">由 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生的微任务（表示 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数可以继续执行，实际上就是让 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回，并解决 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 所等待的Promise）。</span></li><li id=\"u19404ecd\" data-lake-index-type=\"0\"><span class=\"ne-text\">由 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\"> 放入的微任务（输出6）。</span></li></ol></ol></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u8a4fffbd\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列按顺序执行：</span></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"u6d3cc76f\" data-lake-index-type=\"0\"><span class=\"ne-text\">首先执行第一个微任务（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">）：这个微任务的执行会解决</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">函数返回的Promise，从而让</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">函数中</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">后面的代码（输出2）可以继续，但是注意，这个继续并不是立即执行输出2，而是将输出2的代码作为一个新的微任务加入微任务队列（因为async函数中，</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">后面的代码总是被包装成微任务）。</span></li><li id=\"uab041688\" data-lake-index-type=\"0\"><span class=\"ne-text\">然后执行第二个微任务：输出 </span><code class=\"ne-code\"><span class=\"ne-text\">6</span></code><span class=\"ne-text\">。</span></li></ul></ul></ul><ol start=\"5\" class=\"ne-ol\"><li id=\"ucf226f8c\" data-lake-index-type=\"0\"><span class=\"ne-text\">此时微任务队列中又有了一个新的微任务（输出2），所以接下来执行这个微任务：输出 </span><code class=\"ne-code\"><span class=\"ne-text\">2</span></code><span class=\"ne-text\">。</span></li><li id=\"u6c503281\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列清空，然后执行宏任务队列中的定时器回调：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uccbe3d59\" data-lake-index-type=\"0\"><span class=\"ne-text\">在定时器回调中：</span></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"u31c6a5c4\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行 </span><code class=\"ne-code\"><span class=\"ne-text\">Promise.resolve().then</span></code><span class=\"ne-text\">，将输出3的回调放入微任务队列。</span></li><li id=\"u4f93746a\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">4</span></code><span class=\"ne-text\">。</span></li></ul></ul></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u30f2e9ee\" data-lake-index-type=\"0\"><span class=\"ne-text\">这个宏任务执行完毕，然后执行微任务队列：输出 </span><code class=\"ne-code\"><span class=\"ne-text\">3</span></code><span class=\"ne-text\">。</span></li></ul></ul><h3 id=\"GAz0l\"><span class=\"ne-text\">重点：</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生的微任务次数</span></h3><p id=\"ua93b7a29\" class=\"ne-p\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中：</span></p><ul class=\"ne-ul\"><li id=\"ua4ecaa40\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 一个非Promise值（数字）会产生一个微任务（用于继续执行async函数后面的代码，即使后面没有代码，也需要解决async函数返回的Promise）。<br /></span><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中：</span></li><li id=\"u15aad2bc\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await asy2()</span></code><span class=\"ne-text\">：</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 返回一个Promise，这个Promise的解决会在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数内部的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 完成时（即上面产生的微任务执行时）解决。然后，</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面的代码（输出2）会被放入微任务队列。<br /></span><span class=\"ne-text\">因此，整个流程中微任务队列的变化：</span></li></ul><ol class=\"ne-ol\"><li id=\"u67f1aaae\" data-lake-index-type=\"0\"><span class=\"ne-text\">同步代码执行完毕后，微任务队列有两个微任务：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uea94d940\" data-lake-index-type=\"0\"><span class=\"ne-text\">第一个是 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生的（标记为微任务A）：用于解决 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回的Promise。</span></li><li id=\"u0ac362e1\" data-lake-index-type=\"0\"><span class=\"ne-text\">第二个是 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\"> 放入的（微任务B）：输出6。</span></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"u161f7bd5\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务A：这会解决 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回的Promise，然后导致 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 完成，从而将 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面的代码（输出2）作为新的微任务（微任务C）加入队列。</span></li><li id=\"u35263207\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务B：输出6。</span></li><li id=\"u7a57f36d\" data-lake-index-type=\"0\"><span class=\"ne-text\">然后执行微任务C：输出2。<br /></span><span class=\"ne-text\">所以，</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 确实产生了一个微任务（微任务A），并且这个微任务的执行又导致了一个新的微任务（微任务C）产生。</span></li></ol><h3 id=\"OZ2IP\"><span class=\"ne-text\">结论</span></h3><p id=\"u030784a1\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生了微任务。整个代码中，微任务队列的执行顺序是：</span></p><ol class=\"ne-ol\"><li id=\"u270ebb63\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务A（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">）：解决</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">的Promise，触发</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">中的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">完成，将输出2加入微任务队列（微任务C）。</span></li><li id=\"ufa55c812\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务B（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\">）：输出6。</span></li><li id=\"u671bd9d5\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务C（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">完成）：输出2。<br /></span><span class=\"ne-text\">然后执行宏任务（定时器回调），在定时器回调中又产生了一个微任务（输出3），最后执行。</span></li></ol></details>\n###### 上面的例子稍微变形后：\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">asy1</span>(<span class=\"params\">params</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">asy2</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">asy2</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title function_\">await</span> (<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">await</span> (<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125;)();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">asy3</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">asy1</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"title function_\">asy3</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出顺序如下：</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 7</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></div>\n\n<details class=\"lake-collapse\"><summary id=\"u058a4c63\"><span class=\"ne-text\">分析如下：</span></summary><ol class=\"ne-ol\"><li id=\"uc339dd7e\" data-lake-index-type=\"0\"><span class=\"ne-text\">声明asy1、asy2、asy3函数，不进入执行栈。</span></li><li id=\"u4182cade\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">，进入</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">函数：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uc8b547f5\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code></li><li id=\"uc54df11b\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2()</span></code></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u96ec74de\" data-lake-index-type=\"0\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 中：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ub8620ccd\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await (() =&gt; &#123;console.log(3) &#125;)()</span></code><span class=\"ne-text\"> 即</span><code class=\"ne-code\"><span class=\"ne-text\">await console.log(3)</span></code><span class=\"ne-text\">最终会生成一个立即解决的Promise，即</span><code class=\"ne-code\"><span class=\"ne-text\">await Promise.resolve()</span></code><span class=\"ne-text\">记为P1，该Promise解决后，将</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(4);</span></code><span class=\"ne-text\">（回调A）推入微任务队列。</span></li><li id=\"u47e33dc8\" data-lake-index-type=\"0\"><span class=\"ne-text\">此时</span><code class=\"ne-code\"><span class=\"ne-text\">await (async () =&gt; &#123;...)()</span></code><span class=\"ne-text\"> 返回的Promise，记为P2，需要等待内部的</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(4)</span></code><span class=\"ne-text\">执行后才完成，所以该Promise挂起，</span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">中暂停执行。</span></li></ul></ul><ol start=\"4\" class=\"ne-ol\"><li id=\"u5e47407d\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">console.log(7)</span></code><span class=\"ne-text\">执行，输出7。</span></li><li id=\"uaf22f070\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3()</span></code><span class=\"ne-text\">，将</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(6)</span></code><span class=\"ne-text\">（回调B）加入微任务队列中，此时微任务队列：[回调A（console.log(4)），回调B（console.log(6)）]</span></li><li id=\"ueb91d798\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务队列（阶段1）：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uef015d46\" data-lake-index-type=\"0\"><span class=\"ne-text\">回调A调用，输出4。P2完成，</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">将后续代码（没有）推入微任务队列，所以会产生一个微任务解析</span><code class=\"ne-code\"><span class=\"ne-text\">asy2()</span></code><span class=\"ne-text\">的完成（微任务C）。</span></li><li id=\"u2643c2d9\" data-lake-index-type=\"0\"><span class=\"ne-text\">回调B调用，输出6。此时微任务队列：[微任务C（asy2的完成）]</span></li></ul></ul><ol start=\"7\" class=\"ne-ol\"><li id=\"ue3844e51\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务队列（阶段2）：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uee079303\" data-lake-index-type=\"0\"><span class=\"ne-text\">回调C调用，</span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">中</span><code class=\"ne-code\"><span class=\"ne-text\">await asy2()</span></code><span class=\"ne-text\">完成，将后续代码（</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(2)</span></code><span class=\"ne-text\">回调D）推入微任务队列。</span></li><li id=\"u08fd80c5\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行回调D，输出2。</span></li></ul></ul><p id=\"u8e7806a1\" class=\"ne-p\"><br></p></details>\n","excerpt":"","more":"<p>一些参考：</p>\n<p>测试eventloop地址：<a class=\"link\"   href=\"https://www.jsv9000.app/\" >https://www.jsv9000.app<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p>参考视频：<a class=\"link\"   href=\"https://www.bilibili.com/video/BV1K4411D7Jb/?spm_id_from=333.337.search-card.all.click&vd_source=a1a75df55f32a09493aa84363d0e2aa0\" >【事件循环】【前端】事件原理讲解<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<h2 id=\"浏览器的事件循环机制（EventLoop）\"><a href=\"#浏览器的事件循环机制（EventLoop）\" class=\"headerlink\" title=\"浏览器的事件循环机制（EventLoop）\"></a>浏览器的事件循环机制（EventLoop）</h2><p>概述：</p>\n<p>要真正理解事件循环，我们需要先了解浏览器的多进程架构：</p>\n<ul>\n<li><strong>浏览器主进程</strong>：负责界面显示、用户交互</li>\n<li><strong>GPU进程</strong>：处理图形渲染</li>\n<li><strong>网络进程</strong>：处理网络请求</li>\n<li><strong>渲染进程</strong>（核心）：每个标签页一个渲染进程，包含：<ul>\n<li><strong>主线程</strong>：<u>执行JS、解析HTML&#x2F;CSS、布局、绘制（就是我们常说的JS线程）</u></li>\n<li><strong>合成线程</strong>：负责图层分割</li>\n<li><strong>光栅线程</strong>：将图层转换为像素</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><font style=\"background-color:rgba(77, 208, 225, 0.15);\">关键点：JS引擎（如V8）只是渲染进程的一部分，JS的”单线程”指的是主线程的单线程，浏览器整体是多线程的。</font></p>\n</blockquote>\n<p>关于浏览器渲染机制的笔记，可以查看：<a class=\"link\"   href=\"https://www.yuque.com/u54400072/kgraay/gyclhvv7y5wogkf0\" >浏览器渲染机制<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<h3 id=\"JavaScript的单线程特性与异步机制\"><a href=\"#JavaScript的单线程特性与异步机制\" class=\"headerlink\" title=\"JavaScript的单线程特性与异步机制\"></a>JavaScript的单线程特性与异步机制</h3><h4 id=\"JS为什么是单线程的？\"><a href=\"#JS为什么是单线程的？\" class=\"headerlink\" title=\"JS为什么是单线程的？\"></a>JS为什么是单线程的？</h4><p>JavaScript被设计成单线程的，主要是为了避免DOM操作的复杂性。如果JavaScript是多线程的，那么当多个线程同时操作同一个DOM元素时，就会出现竞态条件（Race Condition），导致不可预测的结果。例如，一个线程要删除某个DOM元素，另一个线程要修改它，那么到底应该以哪个线程的操作为准呢？为了避免这种复杂性，JavaScript从诞生之初就被设计为单线程。</p>\n<h4 id=\"单线程带来的问题与解决方案\"><a href=\"#单线程带来的问题与解决方案\" class=\"headerlink\" title=\"单线程带来的问题与解决方案\"></a>单线程带来的问题与解决方案</h4><p>（1）阻塞问题</p>\n<ul>\n<li>单线程意味着所有任务需按顺序执行，若某个任务耗时过长（如复杂计算或网络请求），会阻塞后续代码执行，导致页面卡顿</li>\n<li>解决方案：<ul>\n<li><strong>异步编程模型</strong>：通过回调函数、Promise、async&#x2F;await 处理异步操作，避免阻塞主线程</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例：使用 Promise 处理异步请求</span></span><br><span class=\"line\"><span class=\"title function_\">fetch</span>(<span class=\"string\">&#x27;https://api.example.com/data&#x27;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.<span class=\"title function_\">json</span>())</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data))</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(error));</span><br></pre></td></tr></table></figure>\n\n<pre><code>- **Web Worker**：将耗时任务交给后台线程处理，不阻塞主线程\n</code></pre>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主线程</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> worker = <span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(<span class=\"string\">&#x27;worker.js&#x27;</span>);</span><br><span class=\"line\">worker.<span class=\"title function_\">postMessage</span>(<span class=\"string\">&#x27;开始计算&#x27;</span>);</span><br><span class=\"line\">worker.<span class=\"property\">onmessage</span> = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;计算结果:&#x27;</span>, e.<span class=\"property\">data</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// worker.js（独立线程）</span></span><br><span class=\"line\">onmessage = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"title function_\">performHeavyCalculation</span>();</span><br><span class=\"line\">  <span class=\"title function_\">postMessage</span>(result);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>（2）I&#x2F;O密集型场景的优化</p>\n<ul>\n<li>浏览器中的 JavaScript 主要处理 I&#x2F;O 密集型任务（如网络请求、文件操作），单线程模型配合异步 I&#x2F;O 机制（如事件循环）可高效处理这类场景。</li>\n<li><strong>事件循环（Event Loop）</strong>：<ul>\n<li>JavaScript 通过事件循环机制处理异步任务，将耗时操作放入任务队列，主线程空闲时再处理这些任务。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"事件循环的完整运行机制：\"><a href=\"#事件循环的完整运行机制：\" class=\"headerlink\" title=\"事件循环的完整运行机制：\"></a>事件循环的完整运行机制：</h3><h4 id=\"核心组件详解\"><a href=\"#核心组件详解\" class=\"headerlink\" title=\"核心组件详解\"></a>核心组件详解</h4><p>（1）调用栈（Call Stack）</p>\n<ul>\n<li>本质：记录函数调用的数据结构（LIFO栈），先进后出，如下图所示：</li>\n</ul>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/callstack.webp\"\n                      alt=\"调用栈callstack\"\n                ></p>\n<ul>\n<li>特点：<ul>\n<li><strong>合成线程</strong>：每次函数调用都会创建新的栈帧（包含参数、局部变量等）</li>\n<li>栈溢出：当递归深度超过最大调用栈大小（Chrome约1万层）</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 栈溢出示例</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">stackOverflow</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"title function_\">stackOverflow</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">stackOverflow</span>() <span class=\"comment\">// Uncaught RangeError: Maximum call stack size exceeded</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>（2）堆内存（Heap）</p>\n<ul>\n<li>存储引用类型（对象、数组等）的内存区域</li>\n<li>与栈的区别：<ul>\n<li>栈：自动分配固定大小内存（基础类型、指针）</li>\n<li>堆：动态分配内存，需要垃圾回收</li>\n</ul>\n</li>\n</ul>\n<p>（3）任务队列系统</p>\n<table>\n<thead>\n<tr>\n<th><strong>队列类型</strong></th>\n<th><strong>触发方式</strong></th>\n<th><strong>优先级</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>微任务队列</td>\n<td>JS引擎直接管理</td>\n<td>高</td>\n</tr>\n<tr>\n<td>宏任务队列</td>\n<td>由浏览器宿主环境管理</td>\n<td>低</td>\n</tr>\n<tr>\n<td>动画回调队列</td>\n<td>requestAnimationFrame</td>\n<td>特殊</td>\n</tr>\n<tr>\n<td>空闲回调队列</td>\n<td>requestIdleCallback</td>\n<td>最低</td>\n</tr>\n</tbody></table>\n<h4 id=\"完整事件循环流程\"><a href=\"#完整事件循环流程\" class=\"headerlink\" title=\"完整事件循环流程\"></a>完整事件循环流程</h4><p>下图为主线程中事件循环的运行示例图：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84eventloop.png\"\n                      alt=\"主线程中的eventloop\"\n                ></p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/eventloop流程.png\"\n                      alt=\"eventloop流程\" height=\"auto\" style=\"width:40%; display:block;\"\n                >\n\n<h5 id=\"宏任务【Macro-tasks】与微任务【micro-tasks】\"><a href=\"#宏任务【Macro-tasks】与微任务【micro-tasks】\" class=\"headerlink\" title=\"宏任务【Macro-tasks】与微任务【micro-tasks】\"></a>宏任务【Macro-tasks】与微任务【micro-tasks】</h5><p>宏任务大概包括：</p>\n<ul>\n<li>script(整体代码)</li>\n<li>setTimeout</li>\n<li>setInterval</li>\n<li>setImmediate</li>\n<li>I&#x2F;O（例如网络请求 <code>&lt;font style=&quot;background-color:rgba(77, 208, 225, 0.08);&quot;&gt;ajax&lt;/font&gt;</code>、文件读写）</li>\n<li>UI render</li>\n<li><code>&lt;font style=&quot;background-color:rgba(77, 208, 225, 0.08);&quot;&gt;setImmediate&lt;/font&gt;</code> (Node.js环境特有)</li>\n</ul>\n<p>微任务大概包括：</p>\n<ul>\n<li><code>&lt;font style=&quot;background-color:rgba(77, 208, 225, 0.08);&quot;&gt;Promise.then()&lt;/font&gt;</code>、<code>&lt;font style=&quot;background-color:rgba(77, 208, 225, 0.08);&quot;&gt;Promise.catch()&lt;/font&gt;</code>、<code>&lt;font style=&quot;background-color:rgba(77, 208, 225, 0.08);&quot;&gt;Promise.finally()&lt;/font&gt;</code></li>\n<li><code>&lt;font style=&quot;background-color:rgba(77, 208, 225, 0.08);&quot;&gt;process.nextTick&lt;/font&gt;</code> (Node.js环境特有)</li>\n<li><code>&lt;font style=&quot;background-color:rgba(77, 208, 225, 0.08);&quot;&gt;MutationObserver&lt;/font&gt;</code> (h5新特性 用于监听DOM变化)</li>\n</ul>\n<h5 id=\"EventLoop的执行顺序详解：\"><a href=\"#EventLoop的执行顺序详解：\" class=\"headerlink\" title=\"EventLoop的执行顺序详解：\"></a>EventLoop的执行顺序详解：</h5><ol>\n<li><strong>执行同步代码：</strong> 当JavaScript代码开始执行时，会首先执行所有的同步代码。这些同步代码可以被看作是当前宏任务的一部分。在执行过程中，如果遇到异步任务（无论是宏任务还是微任务），就会将其对应的回调函数放入相应的任务队列中。</li>\n<li><strong>清空微任务队列：</strong> 当所有同步代码执行完毕后，Event Loop并不会立即去执行宏任务队列中的任务。它会优先检查并清空<strong>微任务队列</strong>。这意味着，所有在当前宏任务执行期间产生的微任务，都会在下一个宏任务开始之前被执行完毕。</li>\n<li><strong>页面渲染（可选）：</strong> 在微任务队列清空之后，如果浏览器判断有必要进行页面渲染（比如DOM结构发生了变化，或者需要更新UI），它就会进行一次页面渲染。这一步是可选的，浏览器会根据实际情况决定是否进行渲染。</li>\n<li><strong>执行下一个宏任务：</strong> 页面渲染完成后，Event Loop会从<strong>宏任务队列</strong>中取出一个任务来执行。这个任务执行完毕后，又会重复步骤2，检查并清空微任务队列，然后再次进行页面渲染（如果需要），接着再从宏任务队列中取出下一个任务……如此循环往复，直到所有任务执行完毕。</li>\n</ol>\n<p>这个过程可以概括为：<strong>一个宏任务执行完毕 -&gt; 清空所有微任务 -&gt; 页面渲染（如果需要） -&gt; 执行下一个宏任务</strong>。这个循环会一直持续下去，直到所有任务都执行完毕。</p>\n<h3 id=\"代码实战：\"><a href=\"#代码实战：\" class=\"headerlink\" title=\"代码实战：\"></a>代码实战：</h3><h4 id=\"async-await在EventLoop中的表现：\"><a href=\"#async-await在EventLoop中的表现：\" class=\"headerlink\" title=\"async&#x2F;await在EventLoop中的表现：\"></a>async&#x2F;await在EventLoop中的表现：</h4><h5 id=\"概述：async-await是js中用于处理异步操作的语法糖，基于promise-generator构建\"><a href=\"#概述：async-await是js中用于处理异步操作的语法糖，基于promise-generator构建\" class=\"headerlink\" title=\"概述：async&#x2F;await是js中用于处理异步操作的语法糖，基于promise+generator构建\"></a>概述：async&#x2F;await是js中用于处理异步操作的语法糖，基于promise+generator构建</h5><ul>\n<li>async函数<ul>\n<li>async函数隐式返回一个Promise对象。如果函数返回一个值，该值会被包装为Promise（通过<code>Promise.resolve</code>）；如果函数抛出异常，则返回的Promise状态为<code>rejected</code>。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello world!&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"string\">&#x27;hello world!&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>await表达式<ul>\n<li><code>await</code>只能在async函数内部使用。</li>\n<li><code>await</code>后面可以跟一个Promise对象，它会暂停async函数的执行，等待Promise的状态变为<code>resolved</code>，然后返回结果值。</li>\n<li>如果<code>await</code>后面是一个非Promise的值，它会被立即转换为一个已解决的Promise。</li>\n<li>如果Promise被拒绝（rejected），<code>await</code>会抛出拒绝的原因（可以使用try&#x2F;catch捕获）</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"async函数在事件循环中造成的细微差别：\"><a href=\"#async函数在事件循环中造成的细微差别：\" class=\"headerlink\" title=\"async函数在事件循环中造成的细微差别：\"></a>async函数在事件循环中造成的细微差别：</h5><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/images/async和微任务.png\"\n                      alt=\"async和微任务\" height=\"auto\" style=\"width:60%; display:block;\"\n                >\n\n<p><strong>重点：</strong></p>\n<p><strong>根据规范，async函数返回一个Promise，并且await会暂停函数的执行，等待Promise解决，然后继续执行函数，并将后续代码放入微任务队列。</strong></p>\n<p><strong>特别要注意的是：当async函数返回一个Promise时，会有额外的微任务产生（因为需要等待返回的Promise被解决，然后才能解决async函数自己的Promise）。</strong></p>\n<details class=\"lake-collapse\"><summary id=\"uee28ecd3\"><span class=\"ne-text\">async async2()函数分析：</span></summary><p id=\"u6adc2781\" class=\"ne-p\"><span class=\"ne-text\">执行同步代码：</span></p><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u93ecd645\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 'script start'</span></li><li id=\"ub0b236ee\" data-lake-index-type=\"0\"><span class=\"ne-text\">定义async1和async2（不执行）</span></li><li id=\"u83f602f8\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用async1()</span></li><li id=\"u3b88aae8\" data-lake-index-type=\"0\"><span class=\"ne-text\">在async1中，调用async2()（因为await后面是async2()，所以先执行async2）</span></li></ul></ul><ol class=\"ne-ol\"><li id=\"u901c7dd1\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行async2：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u7be6e3e7\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 'async2 end'</span></li><li id=\"uf1064ee2\" data-lake-index-type=\"0\"><span class=\"ne-text\">然后执行 return Promise.resolve().then(...)<br /></span><span class=\"ne-text\">  这里，Promise.resolve()返回一个已解决的Promise，然后调用then方法，将then的回调（输出'async2 end1'）放入微任务队列。</span></li><li id=\"u13468c5f\" data-lake-index-type=\"0\"><span class=\"ne-text\" style=\"background-color: #CEF5F7\">注意：async2是一个async函数，它返回的Promise不是直接这个then返回的Promise，而是会额外包装一层。<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">根据ECMAScript规范，async函数内部return一个值x，相当于执行</span><code class=\"ne-code\"><span class=\"ne-text\" style=\"background-color: #CEF5F7\">Promise.resolve(x)</span></code><span class=\"ne-text\" style=\"background-color: #CEF5F7\">，然后会等待x（如果x是Promise）解决，再解决async函数返回的Promise。但是，如果x是一个Promise，那么就会产生两个微任务：一个用于等待x解决，另一个用于解决async函数的Promise。<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">具体到async2：<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">async2中：return Promise.resolve().then(...)<br /></span><span class=\"ne-text\" style=\"background-color: #CEF5F7\">这个then方法返回一个新的Promise（我们称为P1）。而async2函数会返回一个新的Promise（称为P2），P2的解决会等待P1的解决。所以，在P1解决后，才会解决P2，然后async1中的await才会继续。</span></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"u485bd34a\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续同步代码：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u29d7af0e\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用setTimeout，将回调放入宏任务队列（0毫秒后，但会在当前宏任务执行完后执行）</span></li><li id=\"ud7fba569\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行new Promise，输出 'Promise'，并立即resolve，将第一个then的回调（输出'promise1'）放入微任务队列</span></li><li id=\"u2c84e1e6\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 'script end'<br /></span><span class=\"ne-text\">此时，同步代码执行完毕。当前微任务队列中有两个任务（注意顺序）：</span></li><li id=\"u9f2acfbe\" data-lake-index-type=\"0\"><span class=\"ne-text\">第一个是async2中放入的：输出'async2 end1'（来自P1的then回调）</span></li><li id=\"u5048b8b9\" data-lake-index-type=\"0\"><span class=\"ne-text\">第二个是new Promise的then回调：输出'promise1'</span></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u1fcaa51b\" data-lake-index-type=\"0\"><span class=\"ne-text\">开始执行微任务队列：<br /></span><span class=\"ne-text\">第一个微任务：执行async2中then的回调<br /></span><span class=\"ne-text\">  输出 'async2 end1'<br /></span><span class=\"ne-text\">  这个回调执行完毕，P1被解决（值为undefined，因为没有return）<br /></span><span class=\"ne-text\"> </span><strong><span class=\"ne-text\"> </span></strong><span class=\"ne-text\" style=\"background-color: #CEF5F7\">这时，因为async2返回的P2在等待P1解决，所以会安排一个微任务来解决P2（这是规范要求的，当async函数返回一个Promise时，需要等待这个Promise解决，然后才能解决async函数自己的Promise。这个等待过程会产生一个微任务）。</span><span class=\"ne-text\"><br /></span><span class=\"ne-text\">第二个微任务：执行输出'promise1'<br /></span><span class=\"ne-text\">  输出 'promise1'<br /></span><span class=\"ne-text\">  由于这个then回调返回undefined，所以它返回的Promise立即解决，于是下一个then的回调（输出'promise2'）被放入微任务队列。<br /></span><span class=\"ne-text\">此时，微任务队列中新增了两个微任务（按顺序）：<br /></span><span class=\"ne-text\">微任务3：解决async2返回的P2（这个微任务会触发async1中await后面的代码放入微任务队列）<br /></span><span class=\"ne-text\">微任务4：输出'promise2'<br /></span><span class=\"ne-text\">注意：微任务3是在执行第一个微任务（输出'async2 end1'）后产生的，所以它排在微任务4（由第二个微任务产生）之前。<br /></span><span class=\"ne-text\">当前微任务队列：[微任务3, 微任务4]</span></li><li id=\"u213c16ff\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续执行微任务队列：<br /></span><span class=\"ne-text\">执行微任务3：解决async2返回的P2<br /></span><span class=\"ne-text\">此时，await async2()的Promise（即P2）被解决，然后await后面的代码（输出'async1 end'）被放入微任务队列。<br /></span><span class=\"ne-text\">执行微任务4：输出 'promise2'<br /></span><span class=\"ne-text\">此时，微任务队列中新增了一个微任务（输出'async1 end'）</span></li><li id=\"uae2fa8c4\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续执行微任务队列（新的一轮？不，微任务队列会一直执行直到清空，所以会继续）：<br /></span><span class=\"ne-text\">微任务5：输出 'async1 end'</span></li><li id=\"ub048ce21\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列清空，执行宏任务：<br /></span><span class=\"ne-text\">  输出 'setTimeout'</span></li></ol></details>\n###### 事件循环详细过程：\n\n<div class=\"tabs\" id=\"tab-页面内不重复的id\"><ul class=\"nav-tabs\"><li class=\"tab active\"><a class=\"#页面内不重复的id-1\">左边流程</a></li><li class=\"tab\"><a class=\"#页面内不重复的id-2\">右边流程</a></li></ul><div class=\"tab-content\"><div class=\"tab-pane active\" id=\"页面内不重复的id-1\"><p>阶段1：同步代码执行（宏任务）<br>同右<br>微任务队列：[ 回调A (async2 end1), 回调B (promise1) ]<br>阶段2：微任务执行（第一轮）</p>\n<ol>\n<li>执行回调A：<br>  ○ console.log(‘async2 end1’) → 输出 “async2 end1”<br>  ○ 解析 P2（async2 内部 Promise）<br>  ○ await async2() 完成，将 async1 end 加入微任务队列（回调C）<br>微任务队列更新：<br>[ 回调B (promise1), 回调C (async1 end) ]</li>\n<li>执行回调B：<br>  ○ console.log(‘promise1’) → 输出 “promise1”<br>  ○ 返回 undefined，自动创建新解析的 Promise P4<br>  ○ 将 promise2 回调加入微任务队列（回调C）<br>微任务队列更新：<br>[ 回调C (async1 end) , 回调D (promise2)]<br>阶段3：微任务执行（第二轮）</li>\n<li>执行回调C：<br>  ○ console.log(‘async1 end’) → 输出 “async1 end”</li>\n<li>执行回调D：<br>  ○ console.log(‘promise2’) → 输出 “promise2”<br>阶段4：宏任务执行</li>\n<li>执行 setTimeout 回调：<br>  ○ console.log(‘setTimeout’) → 输出 “setTimeout”</li>\n</ol></div><div class=\"tab-pane\" id=\"页面内不重复的id-2\"><p>阶段1：同步代码执行（宏任务）</p>\n<ol>\n<li>console.log(‘script start’)<br>→ 输出 “script start”</li>\n<li>定义函数：<br>  ○ 定义 async1 和 async2（不执行函数体）</li>\n<li>调用 async1()：<br>  ○ 进入 async1，遇到 await async2()<br>  ○ 调用 async2()</li>\n<li>执行 async2()：<br>  ○ console.log(‘async2 end’) → 输出 “async2 end”<br>  ○ return Promise.resolve().then(…)<br>创建 Promise P2 并将 .then 回调加入微任务队列（回调A）</li>\n<li>setTimeout：<br>  ○ 将回调加入宏任务队列</li>\n<li>new Promise：<br>  ○ console.log(‘Promise’) → 输出 “Promise”<br>  ○ resolve() 立即解析 Promise P3<br>  ○ 将 .then 回调加入微任务队列（回调B）</li>\n<li>console.log(‘script end’)<br>→ 输出 “script end”<br>微任务队列：[ 回调A (async2 end1), 回调B (promise1) ]<br>阶段2：微任务执行（第一轮）</li>\n<li>执行回调A：<br>  ○ console.log(‘async2 end1’) → 输出 “async2 end1”<br>  ○ 解析 P2（async2 内部 Promise）<br>  ○ 由于 async2 是 async 函数，需要额外微任务解析其返回的 Promise P1<br>微任务队列更新：<br>[ 回调B (promise1), 新任务 (解析P1) ]</li>\n<li>执行回调B：<br>  ○ console.log(‘promise1’) → 输出 “promise1”<br>  ○ 返回 undefined，自动创建新解析的 Promise P4<br>  ○ 将 promise2 回调加入微任务队列（回调C）<br>微任务队列更新：<br>[ 解析P1, 回调C (promise2) ]<br>阶段3：微任务执行（第二轮）</li>\n<li>执行解析P1任务：<br>  ○ 解析 async2 返回的 Promise P1<br>  ○ 使 await async2() 完成，将 async1 end 加入微任务队列（回调D）<br>微任务队列更新：<br>[ 回调C (promise2), 回调D (async1 end) ]</li>\n<li>执行回调C：<br>  ○ console.log(‘promise2’) → 输出 “promise2”</li>\n<li>执行回调D：<br>  ○ console.log(‘async1 end’) → 输出 “async1 end”<br>阶段4：宏任务执行</li>\n<li>执行 setTimeout 回调：<br>  ○ console.log(‘setTimeout’) → 输出 “setTimeout”</li>\n</ol></div></div></div>\n\n\n<h5 id=\"await表达式在事件循环中，参考async和await的面试题，-举例：\"><a href=\"#await表达式在事件循环中，参考async和await的面试题，-举例：\" class=\"headerlink\" title=\"await表达式在事件循环中，参考async和await的面试题， 举例：\"></a>await表达式在事件循环中，参考<a class=\"link\"   href=\"https://www.bilibili.com/video/BV1x29iYdEQy/?spm_id_from=333.337.search-card.all.click&vd_source=a63e68ff2d1fc881d5dfb3ccab9ccf89\" >async和await的面试题<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>， 举例：</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">asy1</span>(<span class=\"params\">params</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"keyword\">await</span> <span class=\"title function_\">asy2</span>();</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">asy2</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">asy3</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">asy1</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\">  <span class=\"title function_\">asy3</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出顺序如下：</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 7</span></span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h6 id=\"分析如下：\"><a href=\"#分析如下：\" class=\"headerlink\" title=\"分析如下：\"></a>分析如下：</h6><details class=\"lake-collapse\"><summary id=\"ua9d4e59b\"><span class=\"ne-text\">执行流程：</span></summary><ol class=\"ne-ol\"><li id=\"ua7bdc105\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">，进入</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">函数：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ubff5558e\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code></li><li id=\"u11d6bd6e\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2()</span></code></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"ub1b11355\" data-lake-index-type=\"0\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 中：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u4398c32c\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">setTimeout</span></code><span class=\"ne-text\">，将回调函数放入宏任务队列（将在下一个宏任务执行）。</span></li><li id=\"u5f055c33\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面是 </span><code class=\"ne-code\"><span class=\"ne-text\">setTimeout</span></code><span class=\"ne-text\"> 返回的数字，所以会生成一个立即解决的Promise，并将 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面的代码（这里没有代码，所以实际上是等待这个Promise解决，然后 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回）包装成微任务，放入微任务队列。</span></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u3a31576e\" data-lake-index-type=\"0\"><span class=\"ne-text\">继续执行同步代码：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u6e2f88c4\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">7</span></code></li><li id=\"u2b84c779\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3()</span></code><span class=\"ne-text\">，在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\"> 中，</span><code class=\"ne-code\"><span class=\"ne-text\">Promise.resolve().then</span></code><span class=\"ne-text\"> 将回调（输出6）放入微任务队列。</span></li></ul></ul><ol start=\"4\" class=\"ne-ol\"><li id=\"u10e27d36\" data-lake-index-type=\"0\"><span class=\"ne-text\">同步代码执行完毕，开始执行微任务队列：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ucaa3f54f\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列中有两个微任务：</span></li></ul></ul><ol class=\"ne-list-wrap\"><ol class=\"ne-list-wrap\"><ol ne-level=\"2\" class=\"ne-ol\"><li id=\"u8a3a55ba\" data-lake-index-type=\"0\"><span class=\"ne-text\">由 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生的微任务（表示 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数可以继续执行，实际上就是让 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回，并解决 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 所等待的Promise）。</span></li><li id=\"u19404ecd\" data-lake-index-type=\"0\"><span class=\"ne-text\">由 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\"> 放入的微任务（输出6）。</span></li></ol></ol></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u8a4fffbd\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列按顺序执行：</span></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"u6d3cc76f\" data-lake-index-type=\"0\"><span class=\"ne-text\">首先执行第一个微任务（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">）：这个微任务的执行会解决</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">函数返回的Promise，从而让</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">函数中</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">后面的代码（输出2）可以继续，但是注意，这个继续并不是立即执行输出2，而是将输出2的代码作为一个新的微任务加入微任务队列（因为async函数中，</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">后面的代码总是被包装成微任务）。</span></li><li id=\"uab041688\" data-lake-index-type=\"0\"><span class=\"ne-text\">然后执行第二个微任务：输出 </span><code class=\"ne-code\"><span class=\"ne-text\">6</span></code><span class=\"ne-text\">。</span></li></ul></ul></ul><ol start=\"5\" class=\"ne-ol\"><li id=\"ucf226f8c\" data-lake-index-type=\"0\"><span class=\"ne-text\">此时微任务队列中又有了一个新的微任务（输出2），所以接下来执行这个微任务：输出 </span><code class=\"ne-code\"><span class=\"ne-text\">2</span></code><span class=\"ne-text\">。</span></li><li id=\"u6c503281\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务队列清空，然后执行宏任务队列中的定时器回调：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uccbe3d59\" data-lake-index-type=\"0\"><span class=\"ne-text\">在定时器回调中：</span></li></ul></ul><ul class=\"ne-list-wrap\"><ul class=\"ne-list-wrap\"><ul ne-level=\"2\" class=\"ne-ul\"><li id=\"u31c6a5c4\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行 </span><code class=\"ne-code\"><span class=\"ne-text\">Promise.resolve().then</span></code><span class=\"ne-text\">，将输出3的回调放入微任务队列。</span></li><li id=\"u4f93746a\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">4</span></code><span class=\"ne-text\">。</span></li></ul></ul></ul><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"u30f2e9ee\" data-lake-index-type=\"0\"><span class=\"ne-text\">这个宏任务执行完毕，然后执行微任务队列：输出 </span><code class=\"ne-code\"><span class=\"ne-text\">3</span></code><span class=\"ne-text\">。</span></li></ul></ul><h3 id=\"GAz0l\"><span class=\"ne-text\">重点：</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生的微任务次数</span></h3><p id=\"ua93b7a29\" class=\"ne-p\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中：</span></p><ul class=\"ne-ul\"><li id=\"ua4ecaa40\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 一个非Promise值（数字）会产生一个微任务（用于继续执行async函数后面的代码，即使后面没有代码，也需要解决async函数返回的Promise）。<br /></span><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中：</span></li><li id=\"u15aad2bc\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await asy2()</span></code><span class=\"ne-text\">：</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 返回一个Promise，这个Promise的解决会在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数内部的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 完成时（即上面产生的微任务执行时）解决。然后，</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面的代码（输出2）会被放入微任务队列。<br /></span><span class=\"ne-text\">因此，整个流程中微任务队列的变化：</span></li></ul><ol class=\"ne-ol\"><li id=\"u67f1aaae\" data-lake-index-type=\"0\"><span class=\"ne-text\">同步代码执行完毕后，微任务队列有两个微任务：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uea94d940\" data-lake-index-type=\"0\"><span class=\"ne-text\">第一个是 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生的（标记为微任务A）：用于解决 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回的Promise。</span></li><li id=\"u0ac362e1\" data-lake-index-type=\"0\"><span class=\"ne-text\">第二个是 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\"> 放入的（微任务B）：输出6。</span></li></ul></ul><ol start=\"2\" class=\"ne-ol\"><li id=\"u161f7bd5\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务A：这会解决 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数返回的Promise，然后导致 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 完成，从而将 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\"> 函数中 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 后面的代码（输出2）作为新的微任务（微任务C）加入队列。</span></li><li id=\"u35263207\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务B：输出6。</span></li><li id=\"u7a57f36d\" data-lake-index-type=\"0\"><span class=\"ne-text\">然后执行微任务C：输出2。<br /></span><span class=\"ne-text\">所以，</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 确实产生了一个微任务（微任务A），并且这个微任务的执行又导致了一个新的微任务（微任务C）产生。</span></li></ol><h3 id=\"OZ2IP\"><span class=\"ne-text\">结论</span></h3><p id=\"u030784a1\" class=\"ne-p\"><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 函数中的 </span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\"> 产生了微任务。整个代码中，微任务队列的执行顺序是：</span></p><ol class=\"ne-ol\"><li id=\"u270ebb63\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务A（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">）：解决</span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\">的Promise，触发</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">中的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">完成，将输出2加入微任务队列（微任务C）。</span></li><li id=\"ufa55c812\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务B（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy3</span></code><span class=\"ne-text\">）：输出6。</span></li><li id=\"u671bd9d5\" data-lake-index-type=\"0\"><span class=\"ne-text\">微任务C（来自</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">的</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">完成）：输出2。<br /></span><span class=\"ne-text\">然后执行宏任务（定时器回调），在定时器回调中又产生了一个微任务（输出3），最后执行。</span></li></ol></details>\n###### 上面的例子稍微变形后：\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">asy1</span>(<span class=\"params\">params</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">asy2</span>();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">asy2</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title function_\">await</span> (<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">await</span> (<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125;)();</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">  &#125;)();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">asy3</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">6</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">asy1</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">7</span>);</span><br><span class=\"line\"><span class=\"title function_\">asy3</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出顺序如下：</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 7</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<details class=\"lake-collapse\"><summary id=\"u058a4c63\"><span class=\"ne-text\">分析如下：</span></summary><ol class=\"ne-ol\"><li id=\"uc339dd7e\" data-lake-index-type=\"0\"><span class=\"ne-text\">声明asy1、asy2、asy3函数，不进入执行栈。</span></li><li id=\"u4182cade\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">，进入</span><code class=\"ne-code\"><span class=\"ne-text\">asy1</span></code><span class=\"ne-text\">函数：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uc8b547f5\" data-lake-index-type=\"0\"><span class=\"ne-text\">输出 </span><code class=\"ne-code\"><span class=\"ne-text\">1</span></code></li><li id=\"uc54df11b\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2()</span></code></li></ul></ul><ol start=\"3\" class=\"ne-ol\"><li id=\"u96ec74de\" data-lake-index-type=\"0\"><span class=\"ne-text\">在 </span><code class=\"ne-code\"><span class=\"ne-text\">asy2</span></code><span class=\"ne-text\"> 中：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"ub8620ccd\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">await (() =&gt; &#123;console.log(3) &#125;)()</span></code><span class=\"ne-text\"> 即</span><code class=\"ne-code\"><span class=\"ne-text\">await console.log(3)</span></code><span class=\"ne-text\">最终会生成一个立即解决的Promise，即</span><code class=\"ne-code\"><span class=\"ne-text\">await Promise.resolve()</span></code><span class=\"ne-text\">记为P1，该Promise解决后，将</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(4);</span></code><span class=\"ne-text\">（回调A）推入微任务队列。</span></li><li id=\"u47e33dc8\" data-lake-index-type=\"0\"><span class=\"ne-text\">此时</span><code class=\"ne-code\"><span class=\"ne-text\">await (async () =&gt; &#123;...)()</span></code><span class=\"ne-text\"> 返回的Promise，记为P2，需要等待内部的</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(4)</span></code><span class=\"ne-text\">执行后才完成，所以该Promise挂起，</span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">中暂停执行。</span></li></ul></ul><ol start=\"4\" class=\"ne-ol\"><li id=\"u5e47407d\" data-lake-index-type=\"0\"><code class=\"ne-code\"><span class=\"ne-text\">console.log(7)</span></code><span class=\"ne-text\">执行，输出7。</span></li><li id=\"uaf22f070\" data-lake-index-type=\"0\"><span class=\"ne-text\">调用 </span><code class=\"ne-code\"><span class=\"ne-text\">asy3()</span></code><span class=\"ne-text\">，将</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(6)</span></code><span class=\"ne-text\">（回调B）加入微任务队列中，此时微任务队列：[回调A（console.log(4)），回调B（console.log(6)）]</span></li><li id=\"ueb91d798\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务队列（阶段1）：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uef015d46\" data-lake-index-type=\"0\"><span class=\"ne-text\">回调A调用，输出4。P2完成，</span><code class=\"ne-code\"><span class=\"ne-text\">await</span></code><span class=\"ne-text\">将后续代码（没有）推入微任务队列，所以会产生一个微任务解析</span><code class=\"ne-code\"><span class=\"ne-text\">asy2()</span></code><span class=\"ne-text\">的完成（微任务C）。</span></li><li id=\"u2643c2d9\" data-lake-index-type=\"0\"><span class=\"ne-text\">回调B调用，输出6。此时微任务队列：[微任务C（asy2的完成）]</span></li></ul></ul><ol start=\"7\" class=\"ne-ol\"><li id=\"ue3844e51\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行微任务队列（阶段2）：</span></li></ol><ul class=\"ne-list-wrap\"><ul ne-level=\"1\" class=\"ne-ul\"><li id=\"uee079303\" data-lake-index-type=\"0\"><span class=\"ne-text\">回调C调用，</span><code class=\"ne-code\"><span class=\"ne-text\">asy1()</span></code><span class=\"ne-text\">中</span><code class=\"ne-code\"><span class=\"ne-text\">await asy2()</span></code><span class=\"ne-text\">完成，将后续代码（</span><code class=\"ne-code\"><span class=\"ne-text\">console.log(2)</span></code><span class=\"ne-text\">回调D）推入微任务队列。</span></li><li id=\"u08fd80c5\" data-lake-index-type=\"0\"><span class=\"ne-text\">执行回调D，输出2。</span></li></ul></ul><p id=\"u8e7806a1\" class=\"ne-p\"><br></p></details>\n","_processedHighlight":true},{"title":"浏览器缓存","date":"2022-06-19T16:00:00.000Z","_content":"\n[彻底理解浏览器的缓存机制](https://juejin.cn/post/6992843117963509791)\n\n![](https://cdn.nlark.com/yuque/0/2025/png/55999631/1755589578525-8055f9ba-206c-4b98-aebc-9aba6ae8fb88.png)\n\n![](https://cdn.nlark.com/yuque/0/2025/png/55999631/1755590016572-f4b6b29f-6dde-4ec4-b140-3149eff86624.png)\n\n![](https://cdn.nlark.com/yuque/0/2025/png/55999631/1755590062901-ec083943-aa2a-424e-abf2-5d28c36374d6.png)\n\n![](https://cdn.nlark.com/yuque/0/2025/png/55999631/1756038023485-e7d42dd0-7ee6-4647-96ca-b15b446f2136.png)\n\n![](https://cdn.nlark.com/yuque/0/2025/png/55999631/1756038064153-fbf144fc-cc5f-4f4e-b830-a8f54288e655.png)\n\n\n\n","source":"_posts/浏览器缓存.md","raw":"---\ntitle: 浏览器缓存\ndate: 2022-06-20\ntags: [浏览器缓存, js基础]\ncategories: 浏览器缓存\n---\n\n[彻底理解浏览器的缓存机制](https://juejin.cn/post/6992843117963509791)\n\n![](https://cdn.nlark.com/yuque/0/2025/png/55999631/1755589578525-8055f9ba-206c-4b98-aebc-9aba6ae8fb88.png)\n\n![](https://cdn.nlark.com/yuque/0/2025/png/55999631/1755590016572-f4b6b29f-6dde-4ec4-b140-3149eff86624.png)\n\n![](https://cdn.nlark.com/yuque/0/2025/png/55999631/1755590062901-ec083943-aa2a-424e-abf2-5d28c36374d6.png)\n\n![](https://cdn.nlark.com/yuque/0/2025/png/55999631/1756038023485-e7d42dd0-7ee6-4647-96ca-b15b446f2136.png)\n\n![](https://cdn.nlark.com/yuque/0/2025/png/55999631/1756038064153-fbf144fc-cc5f-4f4e-b830-a8f54288e655.png)\n\n\n\n","slug":"浏览器缓存","published":1,"updated":"2025-09-14T15:33:30.267Z","_id":"cmfjusoet000pl95w3wom7tzm","comments":1,"layout":"post","photos":[],"content":"<p><a class=\"link\"   href=\"https://juejin.cn/post/6992843117963509791\" >彻底理解浏览器的缓存机制<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/png/55999631/1755589578525-8055f9ba-206c-4b98-aebc-9aba6ae8fb88.png\"\n                     \n                ></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/png/55999631/1755590016572-f4b6b29f-6dde-4ec4-b140-3149eff86624.png\"\n                     \n                ></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/png/55999631/1755590062901-ec083943-aa2a-424e-abf2-5d28c36374d6.png\"\n                     \n                ></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/png/55999631/1756038023485-e7d42dd0-7ee6-4647-96ca-b15b446f2136.png\"\n                     \n                ></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/png/55999631/1756038064153-fbf144fc-cc5f-4f4e-b830-a8f54288e655.png\"\n                     \n                ></p>\n","excerpt":"","more":"<p><a class=\"link\"   href=\"https://juejin.cn/post/6992843117963509791\" >彻底理解浏览器的缓存机制<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/png/55999631/1755589578525-8055f9ba-206c-4b98-aebc-9aba6ae8fb88.png\"\n                     \n                ></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/png/55999631/1755590016572-f4b6b29f-6dde-4ec4-b140-3149eff86624.png\"\n                     \n                ></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/png/55999631/1755590062901-ec083943-aa2a-424e-abf2-5d28c36374d6.png\"\n                     \n                ></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/png/55999631/1756038023485-e7d42dd0-7ee6-4647-96ca-b15b446f2136.png\"\n                     \n                ></p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/png/55999631/1756038064153-fbf144fc-cc5f-4f4e-b830-a8f54288e655.png\"\n                     \n                ></p>\n","_processedHighlight":true}],"PostAsset":[],"PostCategory":[{"post_id":"cmfjktvt00000tx5w8wom0bev","category_id":"cmfjktvt50001tx5w3zva8wch","_id":"cmfjktvt70004tx5w10m3hf09"},{"post_id":"cmfjkpz9g0000ma5wfkkshevh","category_id":"cmfjkx02r0000y35w563tb1n6","_id":"cmfjkx02t0003y35wbmejcfhu"},{"post_id":"cmfjk7nik0000d65w4wct3bto","category_id":"cmfjlykvk0000h65whul24ryt","_id":"cmfjlykvp0003h65wcsyr2eef"},{"post_id":"cmfjrcmnz0000175wdmfi64tf","category_id":"cmfjrcmo50001175weacmd6b8","_id":"cmfjrcmo80004175w0nss4a0i"},{"post_id":"cmfjspu9a000kn05w1bl5hjaq","category_id":"cmfjspu9c000ln05wbww681ga","_id":"cmfjspu9d000nn05wct8q0npz"},{"post_id":"cmfjszzkf000on05w5jpf77d0","category_id":"cmfjszzkg000pn05wbkrh0wpq","_id":"cmfjszzkh000sn05wh8ut778h"},{"post_id":"cmfjrl1il0000n05w96kz3gzm","category_id":"cmfjscemt0009n05w1zithvcn","_id":"cmfjtlsnv000dl95we6na5krl"},{"post_id":"cmfjthuof0000l95wai7x11xt","category_id":"cmfjtowun000il95wdtmud2ou","_id":"cmfjtowuo000ml95w16vz0cx7"},{"post_id":"cmfjusoet000pl95w3wom7tzm","category_id":"cmfjuuf46000ul95weq4r2bo5","_id":"cmfjuuf47000xl95w331885jl"}],"PostTag":[{"post_id":"cmfjktvt00000tx5w8wom0bev","tag_id":"cmfjktvt60002tx5wezongbu3","_id":"cmfjktvt80006tx5wb64m73k0"},{"post_id":"cmfjktvt00000tx5w8wom0bev","tag_id":"cmfjktvt70003tx5wf5mihu0d","_id":"cmfjktvt80007tx5wacu11ze1"},{"post_id":"cmfjktvt00000tx5w8wom0bev","tag_id":"cmfjktvt70005tx5wclga6jlz","_id":"cmfjktvt80008tx5wbw2c40fg"},{"post_id":"cmfjkpz9g0000ma5wfkkshevh","tag_id":"cmfjkx02s0001y35wg3vj9tc5","_id":"cmfjkx02u0006y35w7mia5gcw"},{"post_id":"cmfjkpz9g0000ma5wfkkshevh","tag_id":"cmfjkx02t0002y35wfkq4b4r2","_id":"cmfjkx02u0007y35wf101b8we"},{"post_id":"cmfjkpz9g0000ma5wfkkshevh","tag_id":"cmfjkx02t0004y35wb7o3c9jb","_id":"cmfjkx02u0008y35wbptd2ofd"},{"post_id":"cmfjkpz9g0000ma5wfkkshevh","tag_id":"cmfjkx02u0005y35w011ketrh","_id":"cmfjkx02u0009y35w3giv22mi"},{"post_id":"cmfjk7nik0000d65w4wct3bto","tag_id":"cmfjlykvn0001h65w4wic4945","_id":"cmfjlykvp0004h65w58qcc58o"},{"post_id":"cmfjk7nik0000d65w4wct3bto","tag_id":"cmfjlykvo0002h65wbbenfmqt","_id":"cmfjlykvp0005h65w1y822ho3"},{"post_id":"cmfjk7nik0000d65w4wct3bto","tag_id":"cmfjmxuij0002of5w0xio62kr","_id":"cmfjmxuik0003of5wcuev1ttx"},{"post_id":"cmfjrcmnz0000175wdmfi64tf","tag_id":"cmfjrcmo70002175wcfc44c56","_id":"cmfjrcmo80003175wh0hagr67"},{"post_id":"cmfjspu9a000kn05w1bl5hjaq","tag_id":"cmfjmxuij0002of5w0xio62kr","_id":"cmfjspu9c000mn05whv01hhrg"},{"post_id":"cmfjszzkf000on05w5jpf77d0","tag_id":"cmfjszzkh000qn05wda1neg3i","_id":"cmfjszzkh000rn05wg6iybx44"},{"post_id":"cmfjszzkf000on05w5jpf77d0","tag_id":"cmfjtja4b0003l95wcqdq9qkv","_id":"cmfjtjfun0007l95wgrzddgwf"},{"post_id":"cmfjrl1il0000n05w96kz3gzm","tag_id":"cmfjrnhj80002n05wdxlf86vt","_id":"cmfjtlsnv000bl95wf457dtiy"},{"post_id":"cmfjrl1il0000n05w96kz3gzm","tag_id":"cmfjrnhj80003n05w7dtbcx5t","_id":"cmfjtlsnv000cl95wfb019ko5"},{"post_id":"cmfjrl1il0000n05w96kz3gzm","tag_id":"cmfjrnhj90005n05w0xobgnqi","_id":"cmfjtlsnv000el95wa3aqgro9"},{"post_id":"cmfjrl1il0000n05w96kz3gzm","tag_id":"cmfjscemu000an05w6ped0f09","_id":"cmfjtlsnw000fl95wc1pj3bvu"},{"post_id":"cmfjrl1il0000n05w96kz3gzm","tag_id":"cmfjsn47k000gn05w1gjmcgv4","_id":"cmfjtlsnw000gl95w6kz12sbp"},{"post_id":"cmfjrl1il0000n05w96kz3gzm","tag_id":"cmfjsn47l000hn05w3p4l0ald","_id":"cmfjtlsnw000hl95w2xgi3k69"},{"post_id":"cmfjthuof0000l95wai7x11xt","tag_id":"cmfjtowun000jl95w7gu98081","_id":"cmfjtowuo000kl95w1c781q7n"},{"post_id":"cmfjthuof0000l95wai7x11xt","tag_id":"cmfjtja4b0003l95wcqdq9qkv","_id":"cmfjtowuo000ll95wdfemfd0j"},{"post_id":"cmfjthuof0000l95wai7x11xt","tag_id":"cmfjur3sd000nl95wa4gj5t7y","_id":"cmfjur3sh000ol95w9z9y4jok"},{"post_id":"cmfjusoet000pl95w3wom7tzm","tag_id":"cmfjtja4b0003l95wcqdq9qkv","_id":"cmfjutq5r000rl95wgmgjdmun"},{"post_id":"cmfjusoet000pl95w3wom7tzm","tag_id":"cmfjuuf47000vl95w2nzecx1m","_id":"cmfjuuf47000wl95w6qmw6paj"}],"Tag":[{"name":"部署","_id":"cmfjktvt60002tx5wezongbu3"},{"name":"前端","_id":"cmfjktvt70003tx5wf5mihu0d"},{"name":"CI/CD","_id":"cmfjktvt70005tx5wclga6jlz"},{"name":"微前端","_id":"cmfjkx02s0001y35wg3vj9tc5"},{"name":"qiankun","_id":"cmfjkx02t0002y35wfkq4b4r2"},{"name":"single-spa","_id":"cmfjkx02t0004y35wb7o3c9jb"},{"name":"Module Federation","_id":"cmfjkx02u0005y35w011ketrh"},{"name":"Nuxt","_id":"cmfjlykvn0001h65w4wic4945"},{"name":"服务端渲染","_id":"cmfjlykvo0002h65wbbenfmqt"},{"name":"vue","_id":"cmfjmwrxe0000of5wcixkcbzy"},{"name":"Vue","_id":"cmfjmxuij0002of5w0xio62kr"},{"name":"SSR渲染","_id":"cmfjrcmo70002175wcfc44c56"},{"name":"Webpack","_id":"cmfjrnhj80002n05wdxlf86vt"},{"name":"loader","_id":"cmfjrnhj80003n05w7dtbcx5t"},{"name":"plugin","_id":"cmfjrnhj90005n05w0xobgnqi"},{"name":"打包构建工具","_id":"cmfjscemu000an05w6ped0f09"},{"name":"副作用函数","_id":"cmfjsn47k000gn05w1gjmcgv4"},{"name":"静态分析","_id":"cmfjsn47l000hn05w3p4l0ald"},{"name":"浏览器渲染机制","_id":"cmfjszzkh000qn05wda1neg3i"},{"name":"关于eventloop","_id":"cmfjtja4b0002l95w3f3u2dml"},{"name":"js基础","_id":"cmfjtja4b0003l95wcqdq9qkv"},{"name":"eventloop","_id":"cmfjtowun000jl95w7gu98081"},{"name":"async/await案例题","_id":"cmfjur3sd000nl95wa4gj5t7y"},{"name":"浏览器缓存","_id":"cmfjuuf47000vl95w2nzecx1m"}]}}