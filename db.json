{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/assets/hbe.style.css","path":"assets/hbe.style.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/assets/odometer-theme-minimal.css","path":"assets/odometer-theme-minimal.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/tailwind.source.css","path":"css/tailwind.source.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/all.min.css","path":"fontawesome/all.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/brands.min.css","path":"fontawesome/brands.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/duotone.min.css","path":"fontawesome/duotone.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/fontawesome.min.css","path":"fontawesome/fontawesome.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/light.min.css","path":"fontawesome/light.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/regular.min.css","path":"fontawesome/regular.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/sharp-solid.min.css","path":"fontawesome/sharp-solid.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/solid.min.css","path":"fontawesome/solid.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/svg-with-js.min.css","path":"fontawesome/svg-with-js.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/thin.min.css","path":"fontawesome/thin.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-font-face.min.css","path":"fontawesome/v4-font-face.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-shims.min.css","path":"fontawesome/v4-shims.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v5-font-face.min.css","path":"fontawesome/v5-font-face.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/bookmark-placeholder.svg","path":"images/bookmark-placeholder.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-avatar.svg","path":"images/redefine-avatar.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/loading.svg","path":"images/loading.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-favicon.svg","path":"images/redefine-favicon.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.svg","path":"images/redefine-logo.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.webp","path":"images/redefine-logo.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-og.webp","path":"images/redefine-og.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-dark.webp","path":"images/wallhaven-wqery6-dark.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-light.webp","path":"images/wallhaven-wqery6-light.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build.js","path":"js/build.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.ttf","path":"webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.ttf","path":"webfonts/fa-duotone-900.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.woff2","path":"webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.woff2","path":"webfonts/fa-duotone-900.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.ttf","path":"webfonts/fa-light-300.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.woff2","path":"webfonts/fa-light-300.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.ttf","path":"webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.woff2","path":"webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.ttf","path":"webfonts/fa-sharp-solid-900.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.woff2","path":"webfonts/fa-sharp-solid-900.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.ttf","path":"webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.woff2","path":"webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.ttf","path":"webfonts/fa-thin-100.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.woff2","path":"webfonts/fa-thin-100.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.ttf","path":"webfonts/fa-v4compatibility.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.woff2","path":"webfonts/fa-v4compatibility.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/build/tailwind.css","path":"css/build/tailwind.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/animated.styl","path":"css/common/animated.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/colors.styl","path":"css/common/colors.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/basic.styl","path":"css/common/basic.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/markdown.styl","path":"css/common/markdown.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/redefine-theme.styl","path":"css/common/redefine-theme.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/theme.styl","path":"css/common/theme.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/variables.styl","path":"css/common/variables.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/animations.styl","path":"css/layout/animations.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/archive-content.styl","path":"css/layout/archive-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/bookmarks.styl","path":"css/layout/bookmarks.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-content.styl","path":"css/layout/category-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-list.styl","path":"css/layout/category-list.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/article-content.styl","path":"css/layout/article-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-content.styl","path":"css/layout/home-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-sidebar.styl","path":"css/layout/home-sidebar.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/tag-content.styl","path":"css/layout/tag-content.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/page.styl","path":"css/layout/page.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.eot","path":"fonts/Chillax/Chillax-Variable.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff","path":"fonts/Chillax/Chillax-Variable.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.ttf","path":"fonts/Chillax/Chillax-Variable.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff2","path":"fonts/Chillax/Chillax-Variable.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/chillax.css","path":"fonts/Chillax/chillax.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.ttf","path":"fonts/Geist/GeistVF.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.woff2","path":"fonts/Geist/GeistVF.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.woff","path":"fonts/Geist/GeistVF.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/geist.css","path":"fonts/Geist/geist.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.ttf","path":"fonts/GeistMono/GeistMonoVF.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.woff","path":"fonts/GeistMono/GeistMonoVF.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.woff2","path":"fonts/GeistMono/GeistMonoVF.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/geist-mono.css","path":"fonts/GeistMono/geist-mono.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/main.js","path":"js/build/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/main.js.map","path":"js/build/main.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/utils.js.map","path":"js/build/utils.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/utils.js","path":"js/build/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/bookmarkNav.js","path":"js/layouts/bookmarkNav.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/essays.js","path":"js/layouts/essays.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/categoryList.js","path":"js/layouts/categoryList.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/lazyload.js","path":"js/layouts/lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/navbarShrink.js","path":"js/layouts/navbarShrink.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/toc.js","path":"js/layouts/toc.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js","path":"js/libs/APlayer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js.map","path":"js/libs/APlayer.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js","path":"js/libs/Swup.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js.map","path":"js/libs/Swup.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js","path":"js/libs/SwupPreloadPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js.map","path":"js/libs/SwupPreloadPlugin.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScriptsPlugin.min.js","path":"js/libs/SwupScriptsPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js","path":"js/libs/SwupScrollPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupProgressPlugin.min.js","path":"js/libs/SwupProgressPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js.map","path":"js/libs/SwupScrollPlugin.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Typed.min.js","path":"js/libs/Typed.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupSlideTheme.min.js","path":"js/libs/SwupSlideTheme.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/anime.min.js","path":"js/libs/anime.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js","path":"js/libs/mermaid.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js.map","path":"js/libs/mermaid.min.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/moment-with-locales.min.js","path":"js/libs/moment-with-locales.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/minimasonry.min.js","path":"js/libs/minimasonry.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/moment.min.js","path":"js/libs/moment.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/odometer.min.js","path":"js/libs/odometer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/pjax.min.js","path":"js/libs/pjax.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs","path":"js/libs/waline.mjs","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs.map","path":"js/libs/waline.mjs.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/pangu.min.js","path":"js/libs/pangu.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/aplayer.js","path":"js/plugins/aplayer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/hbe.js","path":"js/plugins/hbe.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/masonry.js","path":"js/plugins/masonry.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/mermaid.js","path":"js/plugins/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/tabs.js","path":"js/plugins/tabs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/typed.js","path":"js/plugins/typed.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/pangu.js","path":"js/plugins/pangu.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/codeBlock.js","path":"js/tools/codeBlock.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/imageViewer.js","path":"js/tools/imageViewer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/lightDarkSwitch.js","path":"js/tools/lightDarkSwitch.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/localSearch.js","path":"js/tools/localSearch.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/scrollTopBottom.js","path":"js/tools/scrollTopBottom.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/tocToggle.js","path":"js/tools/tocToggle.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/runtime.js","path":"js/tools/runtime.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-block.styl","path":"css/common/codeblock/code-block.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-theme.styl","path":"css/common/codeblock/code-theme.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/highlight.styl","path":"css/common/codeblock/highlight.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/bookmarkNav.js","path":"js/build/layouts/bookmarkNav.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/bookmarkNav.js.map","path":"js/build/layouts/bookmarkNav.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/categoryList.js","path":"js/build/layouts/categoryList.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/categoryList.js.map","path":"js/build/layouts/categoryList.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/essays.js","path":"js/build/layouts/essays.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/essays.js.map","path":"js/build/layouts/essays.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/lazyload.js","path":"js/build/layouts/lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/lazyload.js.map","path":"js/build/layouts/lazyload.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/navbarShrink.js","path":"js/build/layouts/navbarShrink.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/navbarShrink.js.map","path":"js/build/layouts/navbarShrink.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/toc.js","path":"js/build/layouts/toc.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/toc.js.map","path":"js/build/layouts/toc.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/APlayer.min.js","path":"js/build/libs/APlayer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/Swup.min.js","path":"js/build/libs/Swup.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupPreloadPlugin.min.js","path":"js/build/libs/SwupPreloadPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupProgressPlugin.min.js","path":"js/build/libs/SwupProgressPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupScriptsPlugin.min.js","path":"js/build/libs/SwupScriptsPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupScrollPlugin.min.js","path":"js/build/libs/SwupScrollPlugin.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupSlideTheme.min.js","path":"js/build/libs/SwupSlideTheme.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/Typed.min.js","path":"js/build/libs/Typed.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/anime.min.js","path":"js/build/libs/anime.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/mermaid.min.js","path":"js/build/libs/mermaid.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/minimasonry.min.js","path":"js/build/libs/minimasonry.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/moment-with-locales.min.js","path":"js/build/libs/moment-with-locales.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/moment.min.js","path":"js/build/libs/moment.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/odometer.min.js","path":"js/build/libs/odometer.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/pangu.min.js","path":"js/build/libs/pangu.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/pjax.min.js","path":"js/build/libs/pjax.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/codeBlock.js","path":"js/build/tools/codeBlock.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/codeBlock.js.map","path":"js/build/tools/codeBlock.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/imageViewer.js","path":"js/build/tools/imageViewer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/imageViewer.js.map","path":"js/build/tools/imageViewer.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/lightDarkSwitch.js","path":"js/build/tools/lightDarkSwitch.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/lightDarkSwitch.js.map","path":"js/build/tools/lightDarkSwitch.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/localSearch.js","path":"js/build/tools/localSearch.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/localSearch.js.map","path":"js/build/tools/localSearch.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/runtime.js","path":"js/build/tools/runtime.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/runtime.js.map","path":"js/build/tools/runtime.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/scrollTopBottom.js","path":"js/build/tools/scrollTopBottom.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/scrollTopBottom.js.map","path":"js/build/tools/scrollTopBottom.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/tocToggle.js","path":"js/build/tools/tocToggle.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/tocToggle.js.map","path":"js/build/tools/tocToggle.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/aplayer.js","path":"js/build/plugins/aplayer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/aplayer.js.map","path":"js/build/plugins/aplayer.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/hbe.js","path":"js/build/plugins/hbe.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/hbe.js.map","path":"js/build/plugins/hbe.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/masonry.js","path":"js/build/plugins/masonry.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/masonry.js.map","path":"js/build/plugins/masonry.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/mermaid.js","path":"js/build/plugins/mermaid.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/mermaid.js.map","path":"js/build/plugins/mermaid.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/pangu.js","path":"js/build/plugins/pangu.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/pangu.js.map","path":"js/build/plugins/pangu.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/tabs.js","path":"js/build/plugins/tabs.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/tabs.js.map","path":"js/build/plugins/tabs.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/typed.js","path":"js/build/plugins/typed.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/typed.js.map","path":"js/build/plugins/typed.js.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/a11y-dark.styl","path":"css/common/codeblock/hljs-themes/dark/a11y-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/agate.styl","path":"css/common/codeblock/hljs-themes/dark/agate.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/atom-one-dark.styl","path":"css/common/codeblock/hljs-themes/dark/atom-one-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/github-dark.styl","path":"css/common/codeblock/hljs-themes/dark/github-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/monokai-sublime.styl","path":"css/common/codeblock/hljs-themes/dark/monokai-sublime.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/night-owl.styl","path":"css/common/codeblock/hljs-themes/dark/night-owl.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/nord.styl","path":"css/common/codeblock/hljs-themes/dark/nord.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/tokyo-night-dark.styl","path":"css/common/codeblock/hljs-themes/dark/tokyo-night-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/vs2015.styl","path":"css/common/codeblock/hljs-themes/dark/vs2015.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/atom-one-light.styl","path":"css/common/codeblock/hljs-themes/light/atom-one-light.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/default.styl","path":"css/common/codeblock/hljs-themes/light/default.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/github.styl","path":"css/common/codeblock/hljs-themes/light/github.styl","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1757842258599},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"a93d7b3990e45bc7247eecf01888f71674887a63","modified":1757842276618},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"6497b70356271fd6f9f1dc862353be844c457a53","modified":1757842276596},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"06889bee30e4c39479467021da434d3a6a0990fc","modified":1757842276595},{"_id":"node_modules/hexo-theme-landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1757842276619},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1757842276620},{"_id":"node_modules/hexo-theme-landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1757842276620},{"_id":"node_modules/hexo-theme-landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1757842276621},{"_id":"node_modules/hexo-theme-landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1757842276621},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1757842276432},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1757842276621},{"_id":"node_modules/hexo-theme-landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1757842276622},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1757842276622},{"_id":"node_modules/hexo-theme-landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1757842276622},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1757842276623},{"_id":"node_modules/hexo-theme-landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1757842276623},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1757842276623},{"_id":"node_modules/hexo-theme-landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1757842276624},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1757842276624},{"_id":"node_modules/hexo-theme-landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1757842276625},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1757842276625},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1757842276626},{"_id":"node_modules/hexo-theme-landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1757842276626},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1757842276626},{"_id":"node_modules/hexo-theme-landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1757842276626},{"_id":"node_modules/hexo-theme-landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1757842276627},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1757842276627},{"_id":"node_modules/hexo-theme-landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1757842276628},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1757842276628},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1757842276628},{"_id":"node_modules/hexo-theme-landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1757842276629},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1757842276629},{"_id":"node_modules/hexo-theme-landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1757842276630},{"_id":"node_modules/hexo-theme-landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1757842276630},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1757842276630},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1757842276631},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1757842276631},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"57281fc3812c877ec2d8e89ec87ede57b9789d4c","modified":1757842276558},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1757842276558},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1757842276561},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1757842276539},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1757842276584},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1757842276526},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1757842276560},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1757842276565},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"1b89d0caba03a66a43d9c290a5e94fa438a89210","modified":1757842276488},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"0039146b8ccbdf9b9f8bee58fc6c238f0e9921fc","modified":1757842276499},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1757842276496},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1757842276545},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1757842276542},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"0e94f5722d4c44d3cc91be2f4fd30b9ab503b868","modified":1757842276554},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1757842276562},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"e9d4678e14be5e3cd5e34d783e5af6d6626092f5","modified":1757842276531},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1757842276562},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1757842276559},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1757842276564},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1757842276566},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1757842276600},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"ca28281423ae57d76b6c1eb91cd845fd4e518bd6","modified":1757842276601},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"e55a1d92954ed20f6887f92dc727bb995a010a43","modified":1757842276618},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"6a5033d189554c9a6d42e2ef7952ae5c9742648e","modified":1757842276556},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1757842276594},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1757842276537},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1757842276514},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1757842276463},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1757842276536},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1757842276563},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1757842276567},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1757842276610},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1757842276612},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1757842276602},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"f608400a08cf137ab15ec1f44bac551950afe879","modified":1757842276603},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1757842276604},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1757842276606},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"268d2989acb06e2ddd06cc36a6918c6cd865476b","modified":1757842276611},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"9cc3b2927d814f2f6e8e188f9d3657b94f4c6ef3","modified":1757842276611},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1757842276612},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1757842276613},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1757842276614},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1757842276617},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1757842276541},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1757842276560},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1757842276543},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1757842276546},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1757842276594},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1757842276589},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1757842276583},{"_id":"public/2025/09/14/hello-world/index.html","hash":"7805ffd9f331b13f0809de74fdb0899d242fad7a","modified":1757843626261},{"_id":"public/archives/index.html","hash":"637660aa1f4914e67c14a1de7a5b25b2752e390a","modified":1757843626261},{"_id":"public/archives/2025/index.html","hash":"3851464fbbd3af13a3d7aa16ee99a07491276c57","modified":1757843626261},{"_id":"public/archives/2025/09/index.html","hash":"8a874516b413bb1395d1de9275da11471ceb1b1e","modified":1757843626261},{"_id":"public/index.html","hash":"3fa5028fe9536bf3db3bd31f7a99e6d33a5be2b2","modified":1757843626261},{"_id":"public/css/style.css","hash":"ecc329be740a220cc188ff49b02da4847cb7ee5e","modified":1757843626261},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1757843626261},{"_id":"public/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1757843626261},{"_id":"public/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1757843626261},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1757843626261},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1757843626261},{"_id":"source/.DS_Store","hash":"adfa739b4ae961f20ba8e899cc1c5acd49cc34a7","modified":1757846100240},{"_id":"source/_posts/.DS_Store","hash":"eec998a0ac601ec94830faab66fb08f6d73a1d40","modified":1757847101056},{"_id":"source/_posts/Nuxt.js.md","hash":"a138d6cf5fb3efbfda443a88707bb134d62eb6d2","modified":1757849087457},{"_id":"source/_posts/微前端.md","hash":"6fa6723e741f135aa83c09502187019f5ce5baad","modified":1757848896278},{"_id":"source/_posts/前端部署详解.md","hash":"1f8f05d9e0b5fa9dac2cbc6b6388818318698898","modified":1757849115083},{"_id":"node_modules/hexo-theme-redefine/.coderabbit.yaml","hash":"ba28a5250f22db9a8eb9cd1ee282285eddd848a8","modified":1757848811479},{"_id":"node_modules/hexo-theme-redefine/DONATION.md","hash":"08e105bad07d733efb98543a034f930c569f5c2f","modified":1757848808973},{"_id":"node_modules/hexo-theme-redefine/README_zh-CN.md","hash":"1456215db749caca6f2dab3d70b9182a7d0c69c8","modified":1757848808973},{"_id":"node_modules/hexo-theme-redefine/README.md","hash":"6f47fb08c3a3353f6735e064be117f33d1e66540","modified":1757848808973},{"_id":"node_modules/hexo-theme-redefine/CONTRIBUTING.md","hash":"c6ef834f602b7ae02e2863a2a857e0ce8d392f15","modified":1757848808973},{"_id":"node_modules/hexo-theme-redefine/CODE_OF_CONDUCT.md","hash":"61a6276ef54989b7a1325f3ecb3183a4dfdf50cb","modified":1757848808973},{"_id":"node_modules/hexo-theme-redefine/README_zh-TW.md","hash":"5ac48e225ad90bdc0265f496e4c4ffb251b74a89","modified":1757848808973},{"_id":"node_modules/hexo-theme-redefine/package.json","hash":"d1c68a3b597d971dc31812430706307364214a67","modified":1757848807254},{"_id":"node_modules/hexo-theme-redefine/_config.yml","hash":"9cc3ea9bf18474dc2ed140631a737f9fac2a22fe","modified":1757848811481},{"_id":"node_modules/hexo-theme-redefine/LICENSE","hash":"1de7bacb4fbbd7b6d391a69abfe174c2509ec303","modified":1757848806017},{"_id":"node_modules/hexo-theme-redefine/languages/en.yml","hash":"4cc09fff6895fd864044d7c11f8638ab92d98453","modified":1757848811484},{"_id":"node_modules/hexo-theme-redefine/languages/es.yml","hash":"b244609cd9349791883b28cad0fb05a26c1cd0fe","modified":1757848811487},{"_id":"node_modules/hexo-theme-redefine/languages/fr.yml","hash":"a249af0bd206f10ce78b186b8f0ef6c483ddfcad","modified":1757848811487},{"_id":"node_modules/hexo-theme-redefine/vercel.json","hash":"357c1fd2678f8ae4a9a852a1a6888c8eca774551","modified":1757848807254},{"_id":"node_modules/hexo-theme-redefine/.husky/pre-commit","hash":"843996b47615c2f8c1037db9183de3006166ac1d","modified":1757848806019},{"_id":"node_modules/hexo-theme-redefine/scripts/config-export.js","hash":"b10185069cd3f3fd7873982e259e402d5f146a58","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/scripts/data-handle.js","hash":"c72188b7dd0596d618ecbd3deb1b49ef257014df","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/languages/zh-TW.yml","hash":"16b4abceec032d5e66cd6431b35900740d4d8e3b","modified":1757848811492},{"_id":"node_modules/hexo-theme-redefine/languages/zh-CN.yml","hash":"67d93982759d79f38afadeef871c80b08c21c7ca","modified":1757848811490},{"_id":"node_modules/hexo-theme-redefine/languages/ja.yml","hash":"6da103d89685ddf6da4c367efd699c6fc1a15f84","modified":1757848811488},{"_id":"node_modules/hexo-theme-redefine/layout/index.ejs","hash":"f5fee4e079a9c2c23059ebde4cd89ec723e310c6","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/layout.ejs","hash":"ecf818cd11e363c1a33e7105ac415d8c192c1f73","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/archive.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1757848806359},{"_id":"node_modules/hexo-theme-redefine/layout/404.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1757848806359},{"_id":"node_modules/hexo-theme-redefine/layout/page.ejs","hash":"3dc83dae73b48b3e6ae65bdaf6106ec711c88ecd","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/bug-english.yml","hash":"bf91936a78a2e444dbaf916755f502cc0abe7be3","modified":1757848811484},{"_id":"node_modules/hexo-theme-redefine/layout/category.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1757848806361},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/bug-chinese.yml","hash":"73df1f0aabb527a9e3c131d0f0eda0db8b7a1f3b","modified":1757848811484},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/enhancement-english.yml","hash":"d072e75c10673fb70be74f89dff8b1bae6df0c8f","modified":1757848811487},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/enhancement-chinese.yml","hash":"1ea9f2b52f53e5d1525bb22709bcf37da5a6da01","modified":1757848811486},{"_id":"node_modules/hexo-theme-redefine/layout/tag.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/aliyun-cdn-publish.yml","hash":"18975c5422509b0fb7c3b6ddd788eac65802781a","modified":1757848811483},{"_id":"node_modules/hexo-theme-redefine/layout/tags.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/production-deployment.yml","hash":"78ed9a5458cd8aa21edd0a03789575089f922364","modified":1757848811490},{"_id":"node_modules/hexo-theme-redefine/layout/post.ejs","hash":"f5fee4e079a9c2c23059ebde4cd89ec723e310c6","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/preview-deployment.yml","hash":"25068f67bb279c374e578a568d1e600d41e197f9","modified":1757848811489},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/npm-publish.yml","hash":"3379098cb32de9ee4f6e69eb91505a4d3a2f37e6","modified":1757848811488},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/build-and-commit.yml","hash":"6cb6834cd753e38dadb25c6492347ddd247935ea","modified":1757848811484},{"_id":"node_modules/hexo-theme-redefine/scripts/events/404.js","hash":"a444a2ef3af3e2dc9ebc0b92d76a323dc02c6023","modified":1757848806421},{"_id":"node_modules/hexo-theme-redefine/scripts/events/welcome.js","hash":"7b1e16ef62edfc63ab06b390867aad0ede9589fb","modified":1757848807254},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/delete-mask-handle.js","hash":"088e205976a09c8ee7afec6445847ed4b3aef71f","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/link-handle.js","hash":"d168d78034c5fa5a75978f47185b50fd79ba54cf","modified":1757848806452},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/encrypt.js","hash":"bf6b90842991a25af590af76f10d7164ea34abcb","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/img-handle.js","hash":"b396fe7b6cbc331f2952aa7561f96c1f250d8c52","modified":1757848806446},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/lazyload-handle.js","hash":"f8ae44311e6463e887c07a41910ebade8766bac2","modified":1757848806446},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/table-handle.js","hash":"c500c45cd9221788df1f31939c5399eabb62ebb5","modified":1757848807247},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/meta-helpers.js","hash":"5484677eb8064880019642f139e4a29f21cab495","modified":1757848807072},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/theme-helpers.js","hash":"028b3d18816011dc8e4efa9f4d8cf0e033a72942","modified":1757848807247},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/stylus-handle.js","hash":"8a8bf069ce096bd7b42952c8e50c3c89758cbc13","modified":1757848807233},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/page-helpers.js","hash":"beaeb760eaa92bb63272d21d0d99ab64b78980e8","modified":1757848807229},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/stale-issues.yml","hash":"4ae03f0bd4aaf5ccaa08205af07218d406e921da","modified":1757848811490},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/recommendation-helpers.js","hash":"f704100a3571a4a5da18cc3b1adbcf53c29e779d","modified":1757848807232},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/btn.js","hash":"19b57d6cc01b73e5d6a01330d6baefb8d05872ae","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/waline-helpers.js","hash":"c1c53e269c9d24642152dcced99f85b6a1baaec9","modified":1757848807254},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/btns.js","hash":"c3de03c07a24062781cafd741bcc4c6631c662be","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/note-large.js","hash":"09df0058cd22f1fbfcfcce687938d7ec33f194ad","modified":1757848807228},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/note.js","hash":"85115ba4e08022048bede81fd92570e536cc24a3","modified":1757848807228},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/tabs.js","hash":"74e3b0cdd009206f7b78b04dcb96eccd86e7a996","modified":1757848807247},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/folding.js","hash":"01d03fdf4a071c9e92cc2239356004e06458b834","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/source/css/style.styl","hash":"0d78bda29a5b0446074ed724f4f9fe772d4b15cc","modified":1757848809215},{"_id":"node_modules/hexo-theme-redefine/source/assets/hbe.style.css","hash":"29be8fc47be885e9954e310cbc68dfadd3b4cee6","modified":1757848806264},{"_id":"node_modules/hexo-theme-redefine/source/assets/odometer-theme-minimal.css","hash":"793c31feb38e241a5ff6ecc5e65e61751507d728","modified":1757848806264},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/brands.min.css","hash":"5119c35bbd273d2ea2501997827f6d644da93164","modified":1757848806197},{"_id":"node_modules/hexo-theme-redefine/source/css/tailwind.source.css","hash":"b109b7e9decb8978bb6f010727d0779dbc9a3a9b","modified":1757848806349},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/regular.min.css","hash":"d27c4fed54dacff688010e51f611d950dd6e0aca","modified":1757848806264},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/solid.min.css","hash":"e727feabedb171fb0b398151870d7739ef4e2432","modified":1757848806264},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/sharp-solid.min.css","hash":"7d1a13c6b8178b29f5bcb1a639a1998fc9de16c4","modified":1757848806264},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/light.min.css","hash":"18a176eb2486db4e938e568083fa578b641ccc83","modified":1757848806264},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/thin.min.css","hash":"3d46be31379b07ffb24d69c6c915725eaa2e89e9","modified":1757848806349},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-font-face.min.css","hash":"0be987628c8b485b39f064da41c90f15c0596c1f","modified":1757848806349},{"_id":"node_modules/hexo-theme-redefine/source/images/bookmark-placeholder.svg","hash":"255a1236bab60d2871da31e4f0db947b44931df6","modified":1757848809217},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/svg-with-js.min.css","hash":"f4c08e37c4d44b3ed7a3f377d1cb5d7fca4d04bc","modified":1757848806264},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v5-font-face.min.css","hash":"260ea7a5e0b89963a5dcf2600a4decdf0f408f3f","modified":1757848806359},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-avatar.svg","hash":"d0d20061bda08894a82d7691b660be7c6aaa0608","modified":1757848809218},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-shims.min.css","hash":"96f037860b8e9b59af8e47571ea98791616dbfd8","modified":1757848806358},{"_id":"node_modules/hexo-theme-redefine/source/images/loading.svg","hash":"938c2a41c8ba18e37ed659e481696e40a4c8f3a4","modified":1757848809217},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-favicon.svg","hash":"420f930a1df64a3c4391ff80326a8a2d7d5a6418","modified":1757848809218},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.svg","hash":"472776b6f013aad44706fee6c94201c96ee83932","modified":1757848809218},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-og.webp","hash":"44fb793383da185808ed682d7dd916e10eb65b4d","modified":1757848810073},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.webp","hash":"0a07e3fb6d9125dee44798c8c110187b16fb42a9","modified":1757848810059},{"_id":"node_modules/hexo-theme-redefine/source/js/build.js","hash":"61eb4760cefeffa79550f3f7387e701d554a0709","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/source/js/main.js","hash":"cee5f0dcb5b1f0f7f952e24d31cce2bd785b29cc","modified":1757848806453},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-dark.webp","hash":"d0066e0b025ae748448a3d6a96165d45a55d2f22","modified":1757848810103},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-light.webp","hash":"d25389973d0359b78f1e9c74a850ef425690ba40","modified":1757848810120},{"_id":"node_modules/hexo-theme-redefine/source/js/utils.js","hash":"4452f6e2d0b46f2b2574b3ac5236d2fc80d59435","modified":1757848807254},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.ttf","hash":"b54531dd09c5089eb93b12ce8f90ff521855ff8a","modified":1757848809956},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.woff2","hash":"d02b1adc81fd5bec023e25a7770779b99d6dd742","modified":1757848811463},{"_id":"node_modules/hexo-theme-redefine/layout/pages/page-template.ejs","hash":"75a41b963a4ed3fcae846163bc674d8d185a27a9","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/layout/components/scripts.ejs","hash":"373cbbf8fe0a39fc3de14579e0b3ae20cb429998","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/lib/hbe.default.js","hash":"fee2c92011ef007121b992193bbab0f3b196d873","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/layout/components/swup.ejs","hash":"ac0263cdb945ad99876a246db43801213b45b309","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/layout/utils/side-tools.ejs","hash":"42f0c677c3ee74fedfd5ca40d1b64c490c3cb3d7","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/layout/utils/local-search.ejs","hash":"06ad51a60648100fcf8a750c471a48bd1c9b31b8","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/utils/image-viewer.ejs","hash":"2f31d56e7ed88dadeacffa5af69931461f4fb4f9","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/source/css/common/animated.styl","hash":"1d5a026f3a023031772fdca7d7359bbe7a28548a","modified":1757848809202},{"_id":"node_modules/hexo-theme-redefine/layout/utils/paginator.ejs","hash":"cb0a8fca60575195f65510c1a52a7145c819de14","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/layout/utils/posts-list.ejs","hash":"80dd9ff9b135b582c32c5506d237db71fa742be5","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/source/css/common/basic.styl","hash":"27884d570ce220cf93063c72f117486db365dc68","modified":1757848809207},{"_id":"node_modules/hexo-theme-redefine/source/css/common/colors.styl","hash":"e4a5336757de7b04c01d8c2a2b4bb1de885c6ae0","modified":1757848809209},{"_id":"node_modules/hexo-theme-redefine/source/css/build/tailwind.css","hash":"3986e2bb4666d70908d0c47a23d3eafc7b34040d","modified":1757848806266},{"_id":"node_modules/hexo-theme-redefine/source/css/common/theme.styl","hash":"0c5eedb57874c91babdb603b1daef35d70a7c150","modified":1757848809215},{"_id":"node_modules/hexo-theme-redefine/source/css/common/redefine-theme.styl","hash":"068b95881387ee2b70ba94a6489ee21171f26bf3","modified":1757848809214},{"_id":"node_modules/hexo-theme-redefine/source/css/common/markdown.styl","hash":"62853721fb71613f6574adf9fac9b627a273fe23","modified":1757848809211},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/animations.styl","hash":"2c48fec80bd56164bff297727d06ab5c343b3b41","modified":1757848809202},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/bookmarks.styl","hash":"a89f96f73d9f1d51e455b53bbcf13d003d672d33","modified":1757848809207},{"_id":"node_modules/hexo-theme-redefine/source/css/common/variables.styl","hash":"961f936e6d08372bdc1e9379e7d1288410e4a319","modified":1757848809216},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-list.styl","hash":"aaccab4fb21e25086323e7e418e7fea945f551be","modified":1757848809208},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/archive-content.styl","hash":"4e329547447c716c986e0b4a4f54afc59fc6b486","modified":1757848809205},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-content.styl","hash":"1221a4e0fa2ab5c49e886e0a5bb6dc1d23d969e8","modified":1757848809208},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/tag-content.styl","hash":"3d08edcfbd866627f5681c368d5c61270ba2f682","modified":1757848809215},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/article-content.styl","hash":"94771695782abe5e723918a1319a953fbd2031e0","modified":1757848809205},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-content.styl","hash":"65a5184a667966f5c5387662de77da512faa4e0e","modified":1757848809210},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-sidebar.styl","hash":"daad28f2c004f7afe335080d67e977660829d63e","modified":1757848809211},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/page.styl","hash":"ffc2622357f1556a95fc8f138b7e8ac27b0bba2c","modified":1757848809214},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff","hash":"fc0e791429c274c4c9312d810e7ae9503cab34ab","modified":1757848810125},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff2","hash":"fc5d99b40db9deca7d151f9bd16b96ff160828b7","modified":1757848810197},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/chillax.css","hash":"210179f53c6bce91a12ca6db9129184cc1549c36","modified":1757848806197},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.woff2","hash":"772998a8569a6caa04927d876fbe9e0fb859658b","modified":1757848811478},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/geist.css","hash":"17f37a09d6192f06b2190f8319114238b0a2ec8c","modified":1757848806263},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/geist-mono.css","hash":"b89d5af7e04df579c8ad62c0ea445ff7d16eec11","modified":1757848806263},{"_id":"node_modules/hexo-theme-redefine/source/js/build/main.js.map","hash":"b089351e96e8f99395ac9b44aea257364a475dca","modified":1757848807258},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.woff2","hash":"11e9a061ce255fc4cc45ac3eeb8cab09a49f5ccc","modified":1757848811476},{"_id":"node_modules/hexo-theme-redefine/source/js/build/utils.js.map","hash":"fb09747f1b82adaa7f1078d02fc1a03cfa2b3e12","modified":1757848808968},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/bookmarkNav.js","hash":"3155ed3e6e2aa2e32dbd9e4e06b863e63c2a9b9d","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/source/js/build/main.js","hash":"2fcd1ce192bb34997c2e962d9c98a389573969ac","modified":1757848806453},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/lazyload.js","hash":"c06323d68bbdebbb685db5010e7655b8ed0caf42","modified":1757848806452},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/toc.js","hash":"7a768982f6cb1f40552cce063d5743fe862db762","modified":1757848807248},{"_id":"node_modules/hexo-theme-redefine/source/js/build/utils.js","hash":"f9d03c2029e59c347facb0b6e76296b9c3c83c62","modified":1757848807253},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/essays.js","hash":"df82365c7287710dd876e452f8ef4e1d87b8c09e","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/categoryList.js","hash":"eb1af2cd0726f56ff7861222ea543315fe295a17","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/navbarShrink.js","hash":"3e80bf9ef719b2ddb2d1c4b67eb169d2ef52dbb8","modified":1757848807228},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1757848806443},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScriptsPlugin.min.js","hash":"b17f3434035f1339d6f9cd5c8a055d2a1b6602e9","modified":1757848807246},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js","hash":"cc054d34e74a1feecfae75064f6a4d6107607396","modified":1757848807233},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js.map","hash":"40513fec1323b601667876a97a9ef8a0c88bff63","modified":1757848808968},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupSlideTheme.min.js","hash":"e9d143780e879d958164b1356b7f918ec25e838a","modified":1757848807247},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js","hash":"d911512891ecbe1935203bcd3d93427ad75e45c8","modified":1757848807234},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js","hash":"6c3afca9bb98f79d14516c093f27e3e50a3fd82e","modified":1757848807246},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupProgressPlugin.min.js","hash":"fd30fe1c43072017f67bbaac18b962a5ac218711","modified":1757848807245},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Typed.min.js","hash":"e8ce2b674a637b0c0396a3106c1aedf10186249c","modified":1757848807252},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js.map","hash":"63cf04ba556b256379e103ef7d3ba12d629449a4","modified":1757848808968},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1757848806422},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/odometer.min.js","hash":"fe5beb60997c84ab2f91b54535c4221443cdd21f","modified":1757848807229},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/moment.min.js","hash":"20bd76acf8e950e5cf7243f60e1192705dacca7d","modified":1757848807226},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/minimasonry.min.js","hash":"9681cc509cb8aa733d36aad032e6e8acdb33c08c","modified":1757848807073},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/pjax.min.js","hash":"3d796e5be9cdd4067c94e190ea2482d7fdb4856c","modified":1757848807232},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/aplayer.js","hash":"f2818445cfbdbf936f136c3d0f983583c581d77e","modified":1757848806422},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/pangu.min.js","hash":"ebc25ecdbf464407c5886f024d13f1f6da51ec85","modified":1757848807230},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/tabs.js","hash":"964ec5c25a8d78763ba2ba9bfbd5b1b49ed05381","modified":1757848807247},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/hbe.js","hash":"f7bd9258359dc8f70c6faec3f4fe22a1852d9bf1","modified":1757848806446},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/masonry.js","hash":"92734a30a21f8b16f20aa75208f6c082890275fb","modified":1757848806453},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/typed.js","hash":"f46f636a32e7569a9ff8b8b301bf860e598bd4fe","modified":1757848807250},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/mermaid.js","hash":"303254d382869ed618025fcb328426bd10314583","modified":1757848806453},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/pangu.js","hash":"25af6a33c9176a00f21f45cf5cfad0eb7d473841","modified":1757848807229},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/codeBlock.js","hash":"344e6c83e6ffda22f6e5bc724d603066b49a7d8b","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/localSearch.js","hash":"f6e59f65c676457198c2cf5d78bd06052499ee38","modified":1757848806453},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/imageViewer.js","hash":"33c4e4a28cf66be0cb3f181acae082a5a5404a89","modified":1757848806446},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/tocToggle.js","hash":"c2224ff0370fcf109e94194613b9480a3913c82d","modified":1757848807249},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/scrollTopBottom.js","hash":"9e54fa4310bb98ea5ba61780a9ef56d05d475203","modified":1757848807233},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/lightDarkSwitch.js","hash":"97b7e68f871dc218fceca77b85ac051c7c6306af","modified":1757848806452},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/runtime.js","hash":"eb0374b6f033f7ac25f49b1b079aa163e14b0fcd","modified":1757848807233},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/twikoo.ejs","hash":"49d230c1a732e0f3504a57dfd169738156ed22ba","modified":1757848806374},{"_id":"node_modules/hexo-theme-redefine/layout/components/header/head.ejs","hash":"81f4be0a8b07a4773423f4b8c23b4a36aa8ec34c","modified":1757848806370},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/waline.ejs","hash":"c24dce20a3924adf56753144f17adc1a6fc51190","modified":1757848806374},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/comment.ejs","hash":"98c2db06626a82f24886cd8b77118014ef8aa6e2","modified":1757848806361},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/giscus.ejs","hash":"afa08ddc80ae3f1c57d9b85d2625f11751801540","modified":1757848806362},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/gitalk.ejs","hash":"f94607c4bb12f5c2325e674e25a428dae742e99e","modified":1757848806362},{"_id":"node_modules/hexo-theme-redefine/layout/components/footer/footer.ejs","hash":"acb56ecba5c231f5c8c6701de6d54e3d654948a2","modified":1757848806361},{"_id":"node_modules/hexo-theme-redefine/layout/components/header/preloader.ejs","hash":"a450ba1381dd43d348a3f538bb17ffbd1d332cad","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/layout/components/plugins/aplayer.ejs","hash":"2d34a3583ac0b2b08b6ae035e8d3f97c51db070c","modified":1757848806359},{"_id":"node_modules/hexo-theme-redefine/layout/components/sidebar/author.ejs","hash":"422aed0f3f67529c1ea87ee43f8f680ffc531b45","modified":1757848806360},{"_id":"node_modules/hexo-theme-redefine/layout/components/header/navbar.ejs","hash":"9eb814d67d5d66fb39523c147ad56c10348b70f4","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/layout/components/header/progress-bar.ejs","hash":"e552f0f5e6ab6398ab42eef1788f7c0dcb8f4c18","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/layout/components/sidebar/statistics.ejs","hash":"4329363d232de541e1cb8f24eb59c1a8bacc9b9c","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/layout/pages/category/categories.ejs","hash":"fe6e11590c28cc8462a04580868aa6b8b472a9d1","modified":1757848806361},{"_id":"node_modules/hexo-theme-redefine/layout/pages/archive/archive.ejs","hash":"11fb21fe971157a1a6053ecbd6de9ffbe8ba88a8","modified":1757848806360},{"_id":"node_modules/hexo-theme-redefine/layout/pages/category/category-detail.ejs","hash":"ee99263b6761e9865b06d427597435e69b40dda9","modified":1757848806361},{"_id":"node_modules/hexo-theme-redefine/layout/pages/bookmarks/bookmarks.ejs","hash":"6a52f8f6bd5b0d5e8f9af07124a265fd58b2bdff","modified":1757848806361},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-background.ejs","hash":"dd120259ab091b8087d0194ea2291676556efad8","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/components/sidebar/avatar.ejs","hash":"47cd8318471493c82f5e5983550145d4fd0a2ddc","modified":1757848806360},{"_id":"node_modules/hexo-theme-redefine/layout/pages/friends/friends-link.ejs","hash":"c4a8555880ab546a9bc829386c4fc2b43cdcece2","modified":1757848806362},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-banner.ejs","hash":"b64ba5bb654950e3c430f7429b5f60993e0f6fa0","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-sidebar.ejs","hash":"8df645c6e1878187909d749639ecce6edc0ee72c","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-article.ejs","hash":"b54a0df26341fa5f26a6e1eedb91cd11014d50c5","modified":1757848806370},{"_id":"node_modules/hexo-theme-redefine/layout/pages/masonry/masonry.ejs","hash":"c45f6faf5ccd4db3bd5533eacb6333744a480e27","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/pages/notfound/notfound.ejs","hash":"5e90d8519d19a31234de10a33983b8d70aed94a2","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/layout/pages/shuoshuo/essays.ejs","hash":"0a27aebeba9a9aa56b705b4c84bc24d1874ddb18","modified":1757848806361},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/article-content.ejs","hash":"65bc4194754a0473931014f53d997447e613a530","modified":1757848806360},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-content.ejs","hash":"6985ec3528866f90ce882564556c30c151050061","modified":1757848806371},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/toc.ejs","hash":"c3bd7f4632ded1b59a2479028070fa2b292d8c5e","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/article-copyright.ejs","hash":"8e97d76ded33d1e334c376451e2f3d5fd177a958","modified":1757848806360},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/article-info.ejs","hash":"f42db25cc0f4e3bbce5b8602365025dd37d643d0","modified":1757848806360},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/post-tools.ejs","hash":"5336e36394250d2f25d26432262061c752b1868a","modified":1757848806372},{"_id":"node_modules/hexo-theme-redefine/layout/pages/tag/tag-detail.ejs","hash":"8864356337a301a123e85fb3aec6f3d9b1f2197c","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/layout/pages/tag/tags.ejs","hash":"ff59878833eb2a72fda7c78690a36a9c0c522c76","modified":1757848806373},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-theme.styl","hash":"79d13151f771a7a967fbf18eab955354466335a8","modified":1757848809208},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/highlight.styl","hash":"35cfa277f1f2ea3c3876e50ac56c7401e1b8a4c7","modified":1757848809210},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-block.styl","hash":"e6a793c6b2c54549db8226fcb13ee3c4b3a1c45d","modified":1757848809208},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/aplayer.styl","hash":"5d9b58f0d5226ef2a2a67502577539115ae29942","modified":1757848809203},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/buttons.styl","hash":"32be9cf72f19b588b6e0db6b6e23146293b64268","modified":1757848809207},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/folding.styl","hash":"b5e5c2407eb83ae4b3ee4ed73490dcd41edef705","modified":1757848809209},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/notes.styl","hash":"37b2a4a0669414c74498ed0ecae873c90b15fe6e","modified":1757848809213},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/404.styl","hash":"16215f6fe664d1ddc5744a626405bc774dc30f70","modified":1757848809200},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/tabs.styl","hash":"fb5f2f223f7d4ed86d3693fdc0977362f456212e","modified":1757848809215},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/archive-list.styl","hash":"d57516e1723b807d38cb7955a9a1422dd03ac820","modified":1757848809205},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/article-meta-info.styl","hash":"141ae2639ac760ced89887cce139adbc76c18cea","modified":1757848809206},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/footer.styl","hash":"0dc8796e312215e45e1daf566a495c00480b68e3","modified":1757848809209},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/home-banner.styl","hash":"9f0fb6bd26e73bf07c556a3c1f552997234cb81c","modified":1757848809210},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/image-viewer.styl","hash":"6c8eeb7a96cae110cd9a684a3a5076148b8154d8","modified":1757848809211},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/article-copyright-info.styl","hash":"12fad2f674e8a7ad009cabecf4e98b65d5ed8b1e","modified":1757848809205},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/local-search.styl","hash":"45e7580258bc2d85cc12313abcc24cba9e531e00","modified":1757848809211},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/post-tools.styl","hash":"d602c2fe191d2c639f7cd8c4d0ee618f8c80f5c1","modified":1757848809214},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/paginator.styl","hash":"53421b731f3d7ed34a3a4c87405e06ae3d6519e0","modified":1757848809214},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/page-template.styl","hash":"e2e1826427e1fc5f88d4c31ddd508818a0b0d87d","modified":1757848809213},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/progress-bar.styl","hash":"d3715280d9b62d89ccd1b79ab5e5f030669f4d88","modified":1757848809214},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/side-tools.styl","hash":"995982b8c228f7386d352042f64587d06663716e","modified":1757848809214},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/bookmarkNav.js","hash":"a92d80fb49180a2700e069451c3ee9fde3f7cde0","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/toc.styl","hash":"13949981a5afa2b0483da1836af5999d992961f9","modified":1757848809216},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/categoryList.js","hash":"cd8e7825b6dce79cac97e6047f9a80f0fb893213","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/tagcloud.styl","hash":"cb12c8ef44b5e597eb971d3341919fe9569da709","modified":1757848809215},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/bookmarkNav.js.map","hash":"ba215231cccf6495570205bf974a83142592a22b","modified":1757848807256},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/categoryList.js.map","hash":"fb9f8f83a1d0510eaa510fe58891de555d4839a8","modified":1757848807256},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/essays.js.map","hash":"60c58a3fc229cd497ad782e6f2b642e6be600e4c","modified":1757848807256},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/navbar.styl","hash":"b95efbade2b4cfd8000fd8238bdbd3de522b319e","modified":1757848809212},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/essays.js","hash":"fbd5599508c60dc20fa90a9f37db27770e3773d5","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/lazyload.js.map","hash":"d365d984dfa37411397b36c69e24e4d5d0b32bee","modified":1757848807257},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/lazyload.js","hash":"eacb006bd852a3c9881438b75d45e72d87914ad7","modified":1757848806446},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/navbarShrink.js.map","hash":"275dbb4ded89c2d2d805edbbf678475139bcc442","modified":1757848808967},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/navbarShrink.js","hash":"181c0c7e45f0c3a099d272b7c531559cd0d4fdbf","modified":1757848807228},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/toc.js","hash":"892929c5bb2293804f4c5f911dd901969f08ef67","modified":1757848807248},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/toc.js.map","hash":"9a413e8dbc2ff2a6fc21eb2899e59d5af75942a3","modified":1757848808968},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupScriptsPlugin.min.js","hash":"b17f3434035f1339d6f9cd5c8a055d2a1b6602e9","modified":1757848807245},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/Swup.min.js","hash":"cc054d34e74a1feecfae75064f6a4d6107607396","modified":1757848807233},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1757848806432},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupScrollPlugin.min.js","hash":"6c3afca9bb98f79d14516c093f27e3e50a3fd82e","modified":1757848807246},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupPreloadPlugin.min.js","hash":"d911512891ecbe1935203bcd3d93427ad75e45c8","modified":1757848807234},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupSlideTheme.min.js","hash":"e9d143780e879d958164b1356b7f918ec25e838a","modified":1757848807247},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupProgressPlugin.min.js","hash":"fd30fe1c43072017f67bbaac18b962a5ac218711","modified":1757848807242},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/Typed.min.js","hash":"e8ce2b674a637b0c0396a3106c1aedf10186249c","modified":1757848807251},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1757848806421},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/odometer.min.js","hash":"fe5beb60997c84ab2f91b54535c4221443cdd21f","modified":1757848807229},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/minimasonry.min.js","hash":"9681cc509cb8aa733d36aad032e6e8acdb33c08c","modified":1757848807073},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/pjax.min.js","hash":"3d796e5be9cdd4067c94e190ea2482d7fdb4856c","modified":1757848807231},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/pangu.min.js","hash":"ebc25ecdbf464407c5886f024d13f1f6da51ec85","modified":1757848807230},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/codeBlock.js","hash":"8aa8e62cdc3891c9c608c1f52866aeab8cef0457","modified":1757848806444},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/imageViewer.js","hash":"310f06d38245235e1a65a5a7f1a6f673647faa6f","modified":1757848806446},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/moment.min.js","hash":"20bd76acf8e950e5cf7243f60e1192705dacca7d","modified":1757848807206},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/imageViewer.js.map","hash":"6bf89edc74bc48b0e6f616d1ac0b0bb52df09353","modified":1757848807257},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/lightDarkSwitch.js","hash":"dee772cad8a9ab42d54b6ea99599534524c47f18","modified":1757848806452},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/lightDarkSwitch.js.map","hash":"0fd195af186727b3b6f8a7d29035f35f7375e5a1","modified":1757848807257},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/codeBlock.js.map","hash":"fe609e1f8c1d028eca5e131b6a98cd71547be39c","modified":1757848807256},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/runtime.js","hash":"99d9fbc2022a12dd7f9bab4f88384f563f3f51e8","modified":1757848807232},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/localSearch.js","hash":"4ddb3808f9216b848a14e66c813ae883d0f883b1","modified":1757848806452},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/runtime.js.map","hash":"43ed778e985cbf71e7d62c5960da98a431ad43e3","modified":1757848808967},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/localSearch.js.map","hash":"86630e1b406ad10fe0450ccc49fbf07154fab9e5","modified":1757848807257},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/tocToggle.js.map","hash":"6fd262220a32c784f194d21c7e514f21122bde2f","modified":1757848808968},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/scrollTopBottom.js.map","hash":"76a041bbbd0d49426322c4fc1ee05bf327ffb7bd","modified":1757848808967},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/scrollTopBottom.js","hash":"037720022f64622f244682c176c5f0ab8f1efb54","modified":1757848807233},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/hbe.js","hash":"383a946a2be735bc30c0bb331bbee335fe5b6942","modified":1757848806445},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/tocToggle.js","hash":"978bc1a31f8026ac9522198bca3c892ebf3551bc","modified":1757848807249},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/aplayer.js.map","hash":"daefe65fb99e2f7699f3fd25ec90b7f38469da5d","modified":1757848807254},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/aplayer.js","hash":"bef8536cb25306f78f80c1744c07544a46dac970","modified":1757848806422},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/masonry.js.map","hash":"b2d93754a64f84ef67528d320de69561fc763525","modified":1757848807258},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/mermaid.js.map","hash":"5a8b4e15316517af607d3c12cf4a6e3447cfec22","modified":1757848807258},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/masonry.js","hash":"b5b44a6d4b74beea1938334b3558bd3d1caec07a","modified":1757848806453},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/pangu.js.map","hash":"27d5318b81541274c3026e4892ee43ba2c410951","modified":1757848808967},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/pangu.js","hash":"e96959eb39ca702242aca08c75f2230aa1bda7e4","modified":1757848807229},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/tabs.js","hash":"b14b70e316e3151d591f03cbaf3c70c11ae5aad5","modified":1757848807247},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/mermaid.js","hash":"2deee4201b637c54c1be0e1b686a97050fb37cce","modified":1757848806453},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/tabs.js.map","hash":"218abee3893ecdee6f6c633b9fd13520a4eefabf","modified":1757848808968},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/typed.js","hash":"d8999de0b92fe1e1c9061040d6e95a9b607caa23","modified":1757848807250},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/hbe.js.map","hash":"53deed7e9b802b964ff90d3303f957238f2b1421","modified":1757848807256},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/gitalk.styl","hash":"85f26189ec6dee13a0a743687e7b5391f170c33f","modified":1757848809210},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/twikoo.styl","hash":"448cbc045bcffa2d666094b81dd99eb980676fff","modified":1757848809216},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/typed.js.map","hash":"4840c94f7639cee4615916ce2cabd172a565a71c","modified":1757848808968},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/a11y-dark.styl","hash":"457e0df301f4dc1cc96371e65173b94bec0161fe","modified":1757848809201},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/agate.styl","hash":"a33ce49622c788e5d8bba32573e0b701e4cb7ead","modified":1757848809202},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/comment.styl","hash":"71529ec72f356c78f75a752e5400c1197aa5ea96","modified":1757848809209},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/atom-one-dark.styl","hash":"8802725310cf86c4a179d874072188f31d10b224","modified":1757848809206},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/monokai-sublime.styl","hash":"803773d8c6dd5ecf957596ca57584a6618f373ac","modified":1757848809211},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/night-owl.styl","hash":"07c331a0c45051e93d24e10688425f1e30f0e99f","modified":1757848809212},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/waline.styl","hash":"0663e8e50eff65afb4dbcbc7c4758d8acdd1d368","modified":1757848809217},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/tokyo-night-dark.styl","hash":"2ae8e43a87b18bb899ac9c802d3774232160b8e7","modified":1757848809216},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/vs2015.styl","hash":"c54d91bf767efe0671c4dfbe874fac678cfde117","modified":1757848809216},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/atom-one-light.styl","hash":"99de67d507bd6ffed5993097a6ce2be6422480b1","modified":1757848809207},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/nord.styl","hash":"9b88c9e8bca2b8995fdc71519c01a9c80121161c","modified":1757848809212},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/default.styl","hash":"c2b8d16ba4dffdd3bae4db4f817bc18cdd7c1d60","modified":1757848809209},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/github.styl","hash":"a2a15ed938b319c369569845bf35d00c6624d136","modified":1757848809210},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/github-dark.styl","hash":"fab5f7f62407b66f8b5f2837b178ef5b09a4badc","modified":1757848809210},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.woff2","hash":"a358912d781e6249a8d291e4ce9ebd0a9ab9452e","modified":1757848810230},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.woff","hash":"d06c767b3837999a8b98426e4eb16ca0a8080880","modified":1757848810167},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.ttf","hash":"9a531509e4e768e9102d11f5d7d293e3f04d9c64","modified":1757848810056},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.woff","hash":"fd8c986a8767d59a36e2d194299466720c916ee2","modified":1757848810148},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.ttf","hash":"d72ec9d729305fc24f38e1ba69174e93b700cd69","modified":1757848810003},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js.map","hash":"f74755d9318a86939791027767f631472b876207","modified":1757848808967},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/fontawesome.min.css","hash":"44e6d666b45a6875e4fce11159876129e7a1cceb","modified":1757848806262},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.ttf","hash":"ba9322d66c19f635e15e458cc39fcb509818332f","modified":1757848809240},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.eot","hash":"50a4e2ab17155fe7449e0ee488a6242180f3b256","modified":1757848806416},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.ttf","hash":"01aafadc0ca4ace59127a5594a8f534e83b84879","modified":1757848809223},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1757848807256},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs","hash":"bb3d9180d8c3aae39bd9aacd2bdde1aef9363da7","modified":1757848809198},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.woff2","hash":"74d0af1108ab8157993ca03cef80e89e35e2408d","modified":1757848810869},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/duotone.min.css","hash":"0becc4b085bd9d377a8ff4b5160f8e19c8ec27a0","modified":1757848806233},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.woff2","hash":"e73d164db2aff2c91d18c07da03e8db9d0c5dfd4","modified":1757848810998},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/moment-with-locales.min.js","hash":"dd1c67b36c800c00b7901f17af6200b26f2bb42c","modified":1757848807197},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/moment-with-locales.min.js","hash":"dd1c67b36c800c00b7901f17af6200b26f2bb42c","modified":1757848807106},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.woff2","hash":"2cc24434345b80a844a6bda1139539fe41e4df53","modified":1757848810394},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.woff2","hash":"def760895375328ccdcf62b2b9b9001a21947acd","modified":1757848810557},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.woff2","hash":"486fed640153de1de84f460834c73daef060ed20","modified":1757848810733},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/all.min.css","hash":"630bf0e29410ec27622f65d1270c6bc435cdff21","modified":1757848806195},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.woff2","hash":"e0a4482c20f6b67784df54965539a317a3bd681b","modified":1757848811462},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.ttf","hash":"0d710cd7bd1b7ff574e88bb812de82babe45e415","modified":1757848809688},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.ttf","hash":"40b536c3667547db70ee9ca6f3c94fbc33e0cab7","modified":1757848809758},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.ttf","hash":"cdec068700dc440530e5bbeff7e8bb33a01b4132","modified":1757848809679},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.ttf","hash":"cc5d9f4f994c82e23f58cdde1eec8792d81633c7","modified":1757848809581},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.ttf","hash":"c1fee6e6986b14533ce022afada5fbe10c0f6562","modified":1757848809955},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.ttf","hash":"e0313a772ea710cb5ea4bd08f5dedb0a0025f8ca","modified":1757848809252},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs.map","hash":"9ffe1d8eacf5adc4ffbfa12e6294161d4b528734","modified":1757848808972},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js","hash":"22eeb45e4dfff78a42bc8dad60d3a8ff64968a9d","modified":1757848807071},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/mermaid.min.js","hash":"22eeb45e4dfff78a42bc8dad60d3a8ff64968a9d","modified":1757848806761},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js.map","hash":"2e1a632f0588c4370188887d79a10ff8b38a49b5","modified":1757848808966}],"Category":[{"name":"前端","_id":"cmfjktvt50001tx5w3zva8wch"},{"name":"微前端","_id":"cmfjkx02r0000y35w563tb1n6"},{"name":"Nuxt","_id":"cmfjlykvk0000h65whul24ryt"}],"Data":[],"Page":[],"Post":[{"title":"微前端","date":"2025-08-14T16:00:00.000Z","_content":"\n## Nuxt.js的ssr服务端渲染原理\nNuxt.js 的 SSR（服务端渲染）原理是一个非常核心且有趣的话题。它并不是简单的“在服务器上跑 Vue”，而是一套完整的、精心设计的架构。\n\n简单来说，它的核心原理是：**“首屏在服务器提前渲染成 HTML，之后在客户端‘激活’为 SPA”。**\n\n下面我们分步拆解这个过程的原理、优势和关键实现。\n\n---\n\n### 一、核心目标：解决什么問題？\n1. **SEO（搜索引擎优化）**：传统 SPA（单页应用）返回的是一个空的 HTML 壳，内容由 JavaScript 动态填充。搜索引擎爬虫可能无法等待和执行 JS，导致无法收录内容。SSR 直接返回渲染好的完整 HTML，利于爬虫抓取。\n2. **更快的内容到达时间**：用户浏览器无需等待所有 JavaScript 下载和执行完毕才能看到内容。服务器直接返回了渲染好的 HTML，首屏内容可以立即展示，感知性能极大提升。\n\n### 二、Nuxt.js SSR 的核心工作流程\nNuxt.js 的 SSR 过程可以清晰地分为两个阶段：**服务端渲染**和**客户端激活**。下图展示了从用户请求到页面可交互的完整生命周期：\n\n![画板](https://cdn.nlark.com/yuque/0/2025/jpeg/55999631/1757522658867-d1d335f5-5c7f-443b-bdc8-3a1621a987cb.jpeg)\n\n#### 第一阶段：服务端渲染（Server-Side）\n这个过程发生在 **Nuxt 服务器**（一个 Node.js 服务器）上。\n\n1. **接收请求**：用户浏览器请求一个 URL，请求到达 Nuxt 服务器。\n2. **创建应用实例**：Nuxt 服务器为这次请求**创建一个全新的 Vue 应用实例、Router 和 Store**。这是关键，确保了每个请求的隔离性。\n3. **路由匹配**：根据请求的 URL，Nuxt Router 确定要渲染哪个页面组件（如 `pages/about.vue`）。\n4. **数据预取**：Nuxt 会调用页面组件中定义的**异步数据获取方法**（如 `asyncData`、`useAsyncData`、`useFetch`）。**这些方法会在服务端执行**。\n    - 服务器会等待这些异步操作完成，再去渲染组件。这确保了渲染出的 HTML 是包含数据的。\n5. **渲染 HTML**：\n    - 将获取到的数据**注入到 Vuex Store 或组件状态**中。\n    - 调用 Vue 的 `vue-server-renderer`（Vue 2）或 `@vue/server-renderer`（Vue 3）的 `renderToString()` 函数。\n    - 这个函数会运行 Vue 组件，但它**不是在浏览器中创建真实 DOM，而是在内存中生成一个完整的 HTML 字符串**。\n6. **构建最终文档**：Nuxt 将这个 HTML 字符串插入到HTML模板（`app.html`）中。同时，**将预取的数据序列化后内联到 HTML 中**（通常是在一个 `<script>` 标签里，如 `window.__NUXT__ = {...}`），这个过程称为 **状态脱水**。\n7. **响应**：将这个完整的、包含数据和内容的 HTML 文档发送给客户端。\n\n#### 第二阶段：客户端激活（Client-Side Hydration）\n这个过程发生在**用户浏览器**上。\n\n1. **静态内容展示**：浏览器收到服务器返回的 HTML 后，**无需等待任何 JavaScript，就能立即解析和显示页面内容**。这是首屏速度快的根本原因。\n2. **加载资源**：浏览器开始加载页面中引用的 JavaScript 和 CSS 资源（Nuxt 打包好的客户端 bundle）。\n3. **Vue 接管（Hydration -“混合”）**：这是最精妙的一步。\n    - 客户端的 Vue 应用也会被创建和初始化。\n    - Vue 不会像传统 SPA 那样清空 DOM 再重新渲染。相反，它会**将虚拟 DOM 与服务器渲染好的现有静态 HTML 结构进行“混合”**。\n    - 它会将事件监听器、Vue 的响应式系统等“激活”到这些静态元素上，使其变成一个完全交互式的 Vue 应用。\n4. **变为 SPA**：激活完成后，应用就切换到了正常的 SPA 模式。后续的页面导航不会再向服务器请求完整的 HTML，而是由客户端 Router 管理，只获取必要的数据，实现无刷新跳转。\n\n---\n\n### 三、Nuxt.js 实现 SSR 的关键技术点\n1. **双入口构建（Dual Entry Points）**：\n    - Nuxt 使用 Webpack/Vite 分别打包**两个版本**的代码：\n        * **服务端 Bundle**：用于 `renderToString`，它知道如何在 Node.js 环境中渲染组件。\n        * **客户端 Bundle**：用于在浏览器中“激活”静态页面并处理后续交互。\n    - 这是通过 `webpack` 的 `target: 'node'` 和 `target: 'web'` 分别配置实现的。\n2. **数据预取与状态同步**：\n    - 服务端获取的数据必须**安全地传递到客户端**，否则客户端 Vue 在初始化时没有数据，会导致虚拟 DOM 与服务器渲染的 HTML 不匹配，激活失败。\n    - Nuxt 通过 `window.__NUXT__` 对象将数据从服务器“脱水”到客户端“补水”，保证两端状态一致。\n3. **生命周期**：\n    - 在 SSR 过程中，**只有**** **`**beforeCreate**`** ****和**** **`**created**`** ****这两个生命周期钩子会在服务端执行**。\n    - `mounted`、`beforeMount` 等只在客户端执行。因此，**在**** **`**created**`** ****中操作**** **`**window**`** ****或 DOM 会报错**。\n\n---\n\n### 四、Universal Mode (同构渲染)\nNuxt.js 的 SSR 通常被称为 **“Universal”应用**或**“同构”应用**。\n\n+ **同构代码**：同一份 Vue 组件代码（`.vue` 文件）既可以在**服务器**上运行（用于首屏生成 HTML），也可以在**客户端**运行（用于激活和后续交互）。\n+ **优势**：开发者只需写一套代码，Nuxt 负责处理双端的构建和渲染协调，开发体验非常流畅。\n\n### 总结\nNuxt.js 的 SSR 原理可以概括为：\n\n1. **服务端**：为每个请求即时创建 Vue 应用，预先获取数据，渲染出包含内容的 HTML 字符串，并将数据状态一同返回。\n2. **客户端**：快速展示静态内容，然后加载 JS，由 Vue 将静态页面“激活”为可交互的 SPA，最后接管所有后续导航。\n\n它完美地结合了**传统服务端渲染首屏快、SEO 好**的优势和**单页应用用户体验流畅、交互丰富**的优势，是现代 Web 应用开发的绝佳选择。\n\n## nuxt中调后端接口怎么做，要注意什么？\n在 Nuxt.js 中调用后端接口是其核心功能之一，但根据你使用的 API 风格（Composition API 或 Options API）和渲染模式（SSR 或 SPA），做法和注意事项有所不同。\n\n下面将为你提供全面的指南，包括方法、最佳实践和常见陷阱。\n\n---\n\n### 一、如何调用后端接口？\nNuxt 3 推荐使用 Composition API，并提供了强大的组合式函数。\n\n#### 1. 使用 `useFetch` / `useAsyncData` (Composition API - 首选)\n这是 Nuxt 3 中最现代、最推荐的方式，它完美处理了服务端和客户端的数据获取。\n\n**基本用法 (**`**useFetch**`**)：**  \n`useFetch` 是专门为获取数据而设计的语法糖。\n\n```vue\n<script setup>\n// 直接在模板中使用，无需 .value\nconst { data: posts, pending, error, refresh } = useFetch('/api/posts')\n\n// 或者指定完整 URL（注意配置代理或 CORS）\nconst { data: users } = useFetch('https://api.example.com/users', {\n  // 可选项：在客户端才获取数据（代替 onMounted + ref）\n  // lazy: true,\n  // server: false\n})\n</script>\n\n<template>\n  <div v-if=\"pending\">Loading...</div>\n  <div v-else-if=\"error\">Error: {{ error.message }}</div>\n  <ul v-else>\n    <li v-for=\"post in posts\" :key=\"post.id\">{{ post.title }}</li>\n  </ul>\n  <button @click=\"refresh\">Refresh</button>\n</template>\n```\n\n**高级用法 (**`**useAsyncData**`** + **`**$fetch**`**)：**  \n当你需要更复杂的逻辑时（如多个请求、数据处理），使用 `useAsyncData`。\n\n```vue\n<script setup>\nconst { data: combinedData, refresh } = useAsyncData('unique-key', async () => {\n  // 这里可以写任何复杂的异步逻辑\n  const [posts, users] = await Promise.all([\n    $fetch('/api/posts'),\n    $fetch('/api/users')\n  ])\n  \n  // 对数据进行转换\n  return {\n    posts: posts.map(post => ({ ...post, title: post.title.toUpperCase() })),\n    users\n  }\n})\n</script>\n```\n\n#### 2. 使用 `$fetch` 直接调用\nNuxt 3 内置了基于 [ofetch](https://github.com/unjs/ofetch) 的 `$fetch` 工具，可以在任何地方使用（如事件处理函数中）。\n\n```vue\n<script setup>\nconst handleSubmit = async () => {\n  try {\n    const response = await $fetch('/api/submit', {\n      method: 'POST',\n      body: { name: 'John Doe' }\n    })\n    console.log('Success:', response)\n  } catch (error) {\n    console.error('Error:', error)\n  }\n}\n</script>\n```\n\n#### 3. 使用 `useLazyFetch` / `useLazyAsyncData`\n它们是 `useFetch` 和 `useAsyncData` 的变体，`lazy: true` 是默认行为。**不会阻塞导航**，适用于非关键数据。\n\n```vue\n<script setup>\n// 不会阻塞路由导航，你需要自己处理 data 为 null 的情况\nconst { data: nonCriticalData } = useLazyFetch('/api/non-critical-data')\n</script>\n\n<template>\n  <div v-if=\"data\">\n    <!-- 渲染数据 -->\n  </div>\n</template>\n```\n\n### 二、最重要的注意事项\n#### 1. 服务端渲染 (SSR) vs 客户端渲染 (CSR) 行为\n这是 **最核心、最容易出错** 的点！\n\n+ **默认行为**：`useFetch` 和 `useAsyncData` **会在服务端执行**。这意味着：\n    - **好处**：返回的 HTML 直接包含数据，利于 SEO 和首屏加载。\n    - **陷阱**：**不能在它们内部或**** **`**created**`** ****生命周期中使用浏览器API**（如 `window`, `document`, `localStorage`）。\n+ **如何控制**：\n\n```javascript\n// 选项 1: 强制只在客户端执行\nconst { data } = useFetch('/api/data', { server: false })\n\n// 选项 2: 使用 useLazyFetch (默认不会阻塞导航，且在客户端执行)\nconst { data } = useLazyFetch('/api/data')\n\n// 选项 3: 在 onMounted 钩子中用 $fetch\nimport { onMounted } from 'vue'\nconst data = ref(null)\nonMounted(async () => {\n  data.value = await $fetch('/api/data')\n})\n```\n\n#### 2. 处理 CORS (跨域资源共享)\n如果你调用的接口不在同一个域下，会遇到 CORS 问题。\n\n+ **开发环境**：在 `nuxt.config.ts` 中配置代理是最佳实践。\n\n```typescript\n// nuxt.config.ts\nexport default defineNuxtConfig({\n  // ... 其他配置\n  nitro: {\n    routeRules: {\n      '/api/**': { proxy: 'https://api.example.com/**' }, // 代理 API 请求\n    },\n  },\n  // 或者使用旧的 devServer 配置 (v3.0+ 推荐使用 nitro)\n  // devServer: {\n  //   proxy: {\n  //     '/api': 'https://api.example.com'\n  //   }\n  // }\n})\n```\n\n+ 然后你在代码中请求 `/api/users`，开发服务器会将其代理到 `https://api.example.com/api/users`，避免 CORS。\n+ **生产环境**：\n    - **最佳方案**：配置你的**反向代理**（如 Nginx）来处理跨域请求。\n    - **备选方案**：确保后端 API 正确配置了 CORS 头 (`Access-Control-Allow-Origin` 等)。\n\n#### 3. 认证和令牌 (Authentication)\n如何安全地传递身份验证信息（如 JWT Token）。\n\n+ **使用请求拦截器**：利用 `ofetch` 的自动全局拦截器。\n+ 如何安全地传递身份验证信息（如 JWT Token）。\n\n```typescript\n// plugins/api.ts\nexport default defineNuxtPlugin(() => {\n  const { token } = useAuth() // 假设你有一个获取 token 的 composable\n\n  // 全局拦截 $fetch 请求\n  globalThis.$fetch = $fetch.create({\n    onRequest({ request, options }) {\n      // 添加认证头\n      if (token.value) {\n        options.headers = {\n          ...options.headers,\n          Authorization: `Bearer ${token.value}`\n        }\n      }\n    },\n    onRequestError({ error }) {\n      console.error('Request error:', error)\n    },\n    onResponseError({ response }) {\n      // 统一处理 401 未授权错误\n      if (response.status === 401) {\n        // 跳转到登录页\n        navigateTo('/login')\n      }\n    }\n  })\n})\n```\n\n#### 4. 错误处理\n永远不要假设请求一定会成功。\n\n+ **使用 try-catch**：\n\n```javascript\ntry {\n  const data = await $fetch('/api/endpoint')\n} catch (error) {\n  // Nuxt 3 的 $fetch 会自动抛出错误\n  console.error('API call failed:', error)\n  // 在这里显示用户友好的错误信息\n}\n```\n\n+ **使用 **`**useFetch**`** 的状态**：\n\n```vue\n<script setup>\nconst { data, error } = useFetch('/api/endpoint')\n</script>\n\n<template>\n  <div v-if=\"error\">\n    Failed to load data: {{ error.message }}\n    <button @click=\"refresh\">Try Again</button>\n  </div>\n</template>\n```\n\n#### 5. 性能优化：避免重复请求\n+ **Key 的妙用**：`useAsyncData` 和 `useFetch` 会**自动去重**具有相同 key 的请求。确保为唯一的数据集提供唯一的 key。\n\n```javascript\n// 如果两个组件使用相同的 key，只会发出一个请求\nconst { data } = useAsyncData('user-profile', () => $fetch('/api/profile'))\n```\n\n+ **缓存**：`$fetch` 默认不会缓存 HTTP 缓存。如果你需要利用 HTTP 缓存，可以在 headers 中设置，或者使用更高级的缓存策略。\n\n---\n\n### 三、最佳实践总结\n1. **首选**** **`**useFetch**`**/**`**useAsyncData**`：用于在组件中获取数据，它们能智能处理 SSR 和 hydration。\n2. **明确数据获取时机**：想清楚你需要的数**据是应该在服务端获取（SEO 关键）还是客户端获取（用户相关）**，并用 `server: false` 或 `useLazyFetch` 控制。\n3. **开发环境用代理解决 CORS**：在 `nuxt.config.ts` 中配置代理，避免跨域问题。\n4. **统一处理认证和错误**：通过插件创建配置好的 `$fetch` 实例，全局处理 token 和错误。\n5. **善待你的 API**：合理使用 key 去重，避免重复请求；考虑分页、限流和缓存。\n\n遵循这些指南，你就能在 Nuxt 应用中高效、可靠地与后端 API 进行交互。\n\n## 开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\n**你这个问题问得非常好，直击要害！你的理解完全正确。**\n\n是的，你的推理是精准的：\n\n+ **服务端（Node.js）发起的请求**：没有跨域概念。跨域是**浏览器**强加的安全策略。Node.js 发请求就像你用 `curl` 或 Postman 一样，可以去任何地方，不存在 CORS 问题。\n+ **客户端（浏览器）发起的请求**：受跨域限制。浏览器会拦截违反同源策略的请求。\n\n**因此，“开发环境配置代理” 主要就是为了解决 —— 在客户端发起请求时遇到的跨域问题。**\n\n---\n\n### 为什么开发环境会有客户端请求？\n在 Nuxt 3 的 SSR 模式下，一个页面渲染通常涉及**两次**数据获取：\n\n1. **第一次（服务端请求 - 无 CORS）**：\n    - 当用户直接访问页面 URL 时，请求会先到达你的 Nuxt 服务器。\n    - Nuxt 服务器执行 `useFetch` 或 `useAsyncData`，**在服务器环境**（Node.js）中向后端 API 发起请求。\n    - 此时是 **服务器对服务器** 的通信，没有浏览器参与，所以**没有 CORS 问题**。\n    - 服务器拿到数据后，渲染出包含内容的 HTML 并返回给浏览器。\n2. **第二次（客户端请求 - 有 CORS 风险）**：\n    - 浏览器收到 HTML 并展示后，会加载 Nuxt 的客户端 JS Bundle。\n    - Vue 开始 **“激活” (Hydration)** 过程。\n    - 在这个过程中，`useFetch` 和 `useAsyncData` 的代码会在**客户端浏览器环境**中再次运行，以确保数据状态一致。\n    - 如果它们的 URL 是**绝对路径**（如 `https://api.example.com/data`），那么这次请求就是由**浏览器**直接发起的，就会触发 CORS 检查。\n    - 如果后端 API 没有正确配置 CORS 头，浏览器就会拦截这次请求，导致错误。\n\n此外，还有几种常见的**纯客户端请求**场景：\n\n+ 用户交互（如点击按钮）触发的 `$fetch` 请求。\n+ 在 `onMounted` 钩子中发起的请求。\n+ 使用 `useLazyFetch`（它默认在客户端执行）。\n\n### 总结与最佳实践\n| 场景 | 请求发起方 | 是否有 CORS 问题？ | 解决方案 |\n| --- | --- | --- | --- |\n| **SSR 首屏渲染** | Nuxt Server (Node.js) | **否** | 无需额外配置。但需确保服务器能访问到 API（网络连通性）。 |\n| **CSR Hydration/交互** | 浏览器 | **是** | **配置开发服务器代理**（如下方代码）。这是最推荐的方法。 |\n| **生产环境** | 浏览器 | **是** | **配置生产级反向代理**（如 Nginx），或确保后端 API 正确设置 CORS 头。 |\n\n\n## nuxt中的$fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\n非常好的问题！这是理解 Nuxt 3 数据获取的关键。它们的执行环境行为是核心区别。\n\n简单直接的答案是：**不，**`**$fetch**`** ****可以在服务端和客户端调用。而**** **`**useFetch**`** ****和**** **`**useAsyncData**`** ****的行为是智能的，默认在服务端执行。**\n\n下面我们来详细拆解这三者的区别。\n\n---\n\n### 一、`$fetch`：双环境通用的请求工具\n`$fetch` 是 Nuxt 3 基于 [ofetch](https://github.com/unjs/ofetch) 提供的全局工具函数。它本身**没有环境限制**，你在哪里调用它，它就在哪个环境执行。\n\n+ **在服务端（Node.js）调用**：它就像一个普通的 Node.js HTTP 客户端（比如 `axios`），直接向后端发起请求，**没有跨域概念**。\n+ **在客户端（浏览器）调用**：它的行为类似于原生的 `fetch()`，但功能更强大（自动处理 JSON、更好的错误处理等），并且**受浏览器跨域策略限制**。\n\n**示例：**\n\n```javascript\n// 1. 在组件 setup 中直接调用 - 根据渲染环境决定\n// 如果在服务端渲染，它在服务端执行；如果在客户端激活或导航，它在客户端执行。\nconst data = await $fetch('/api/items');\n\n// 2. 在明确的服务端环境调用 - 只在服务端执行\n// 例如：在 API 路由、服务器中间件或 plugin 中\nexport default defineEventHandler(async (event) => {\n  const data = await $fetch('https://external-api.com/data'); // 在服务器上运行\n  return { data };\n});\n\n// 3. 在明确的客户端环境调用 - 只在客户端执行\n// 例如：在事件处理函数或 onMounted 中\nconst handleClick = async () => {\n  const data = await $fetch('/api/items'); // 在浏览器中运行，受 CORS 限制\n};\n```\n\n`**$fetch**`** ****的陷阱**：如果你在组件顶层直接使用 `$fetch`（没有包裹在 `useAsyncData` 或 `useFetch` 中），并且该组件在服务端渲染，那么请求会在服务端执行。但当客户端激活（Hydration）时，**同样的**** **`**$fetch**`** ****代码又会在客户端再执行一次**，造成重复请求。\n\n---\n\n### 二、`useAsyncData` & `useFetch`：智能的双环境数据获取器\n这两个组合函数是 Nuxt 数据获取的“智能大脑”。它们的关键特性是：**“在服务端预取数据，并自动将数据序列化到客户端，避免重复请求”**。\n\n#### 核心行为：\n1. **默认在服务端执行**：在 SSR 模式下，当页面首次加载时，它们会在 Nuxt 服务器内部执行，获取数据并直接将数据嵌入到最终返回的 HTML 中。\n2. **在客户端激活**：当 Vue 在客户端“激活”静态页面时，`useAsyncData` 和 `useFetch` 会识别到数据已经存在于从服务器传递过来的 payload 中，因此**不会在客户端再次发起请求**，而是直接使用已有的数据。\n3. **后续导航**：当你在客户端通过导航跳转到另一个也使用了这些函数的页面时，它们会在**客户端**执行。\n\n#### 如何控制执行环境？\n它们提供了一个 `server` 选项让你精确控制：\n\n```javascript\n// 默认：true - 在服务端执行（SSR 首屏）\nconst { data } = useFetch('/api/items');\n\n// 强制在客户端执行（CSR）\n// 适合：用户相关的数据、不需要 SEO 的数据、访问浏览器 API 的数据\nconst { data } = useFetch('/api/user-data', {\n  server: false\n});\n\n// useAsyncData 用法相同\nconst { data } = useAsyncData('user-key', () => $fetch('/api/user'), {\n  server: false\n});\n```\n\n### 三、三者的对比总结\n为了更直观地理解，下面的流程图展示了不同调用方式在 Nuxt 应用生命周期中的执行时机和数据流向：\n\n这个图清晰地展示了：\n\n1. `**useFetch**`**/**`**useAsyncData**` 是贯穿服务端和客户端的“智能通道”，保证了数据的高效同步和无重复请求。\n2. **直接使用**** **`**$fetch**` 在组件顶层会导致重复请求，是需要避免的反模式。\n3. **在事件中使用的**** **`**$fetch**` 是纯客户端行为。\n\n### 最佳实践与选择指南\n| 场景 | 推荐使用的工具 | 原因 |\n| --- | --- | --- |\n| **获取页面组件所需数据** | `**useFetch**`<br/>** ****或**** **`**useAsyncData**` | 自动处理 SSR/CSR，避免重复请求，数据序列化到客户端。 |\n| **在事件处理、**`**onMounted**`<br/>** ****中获取数据** | `**$fetch**` | 明确需要在客户端触发的请求。 |\n| **在 API 路由或服务器中间件中** | `**$fetch**` | 明确的服务端环境，无需 `useAsyncData`<br/> 的额外功能。 |\n| **需要复杂的数据获取逻辑** | `**useAsyncData**`<br/>** ****+**** **`**$fetch**` | `useAsyncData`<br/> 提供状态管理，内部函数可使用 `$fetch`<br/> 进行复杂操作。 |\n| **简单的 URL 请求** | `**useFetch**` | 最简洁的写法。 |\n\n\n**一句话总结：**\n\n+ **用**** **`**useFetch**`**/**`**useAsyncData**` 来获取**组件初始化时所需的数据**，让 Nuxt 智能决定执行环境。\n+ **用**** **`**$fetch**` 在**明确的客户端交互**或**明确的服务端环境**中主动发起请求。\n\n遵循这个原则，你就能高效且正确地在 Nuxt 应用中处理数据获取。\n\n## 激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\n这些问题触及了 Nuxt.js SSR 的核心魔法。好消息是，**这个过程绝大部分是自动化的，开发者几乎不需要手动干预**。Nuxt 和 Vue 底层已经为你处理好了一切。\n\n下面我来逐一解答你的问题，你会看到 Nuxt 的设计是多么巧妙。\n\n---\n\n### 一、激活客户端需要开发手动调用什么 API 吗？\n**答：完全不需要。这是 Vue 和 Nuxt 自动完成的。**\n\n这个过程称为 **Hydration（混合）**。它的流程是：\n\n1. **自动执行**：当浏览器加载完 Nuxt 发送过来的 HTML 和客户端 JavaScript 包后，Vue 会自动启动。\n2. **自动匹配**：Vue 会将它的虚拟 DOM 与服务器渲染好的、已经存在的静态 HTML 结构进行对比和匹配。\n3. **自动“激活”**：Vue 不会重新创建 DOM 元素，而是会将事件监听器、响应式数据系统等“附加”到这些现有的 DOM 元素上，使静态页面瞬间变为一个完全交互式的 Vue 应用。\n\n**作为开发者，你唯一要做的就是：**\n\n+ 确保你的代码是**同构的**（即同一份代码既能在 Node.js 环境运行，也能在浏览器环境运行）。\n+ 避免在 `created` 或 `setup` 等生命周期中使用浏览器特有的 API（如 `window`, `document`），或者使用 `onMounted`（仅在客户端执行）来包裹它们。\n\n**你不用写任何像**** **`**app.hydrate()**`** ****这样的代码，一切都是开箱即用、自动发生的。**\n\n---\n\n### 二、服务端异步获取的数据注入到 HTML 这一步开发需要做什么？\n**答：你只需要使用正确的 API（**`**useAsyncData**`** ****或**** **`**useFetch**`**），Nuxt 就会自动完成注入。**\n\n这个“注入”过程在 Nuxt 中被称为 **State Serialization（状态序列化）** 或 ** dehydration（脱水）**。\n\n**你的工作（非常简单）：**\n\n1. **使用 **`**useAsyncData**`** 或 **`**useFetch**`：在你的页面组件中，用它们来获取数据。\n\n```vue\n<script setup>\n  // pages/posts.vue\n  const { data: posts } = await useFetch('/api/posts')\n</script>\n```\n\n2. **Nuxt 自动完成后续所有事情**：\n    - Nuxt 在服务端执行完 `useFetch` 后，会**自动**将 `posts` 数据序列化为 JSON 字符串。\n    - 将这个 JSON 字符串**自动嵌入**到最终 HTML 的 `<head>` 部分的一个 `<script>` 标签中。\n    - 这个标签的内容通常是 `window.__NUXT__ = { ... }`，其中就包含了所有页面的预取数据。\n\n**你不需要手动操作 DOM 去注入数据，Nuxt 的渲染引擎为你包办了一切。**\n\n---\n\n### 三、到客户端时如何获取数据呢？\n**答：客户端 Vue 应用会自动从**** **`**window.__NUXT__**`** ****中提取并复用数据，无需再次请求。**\n\n这个过程是 **State Deserialization（状态反序列化）** 或 **rehydration（补水）**。\n\n**它的自动流程如下：**\n\n1. **数据随 HTML 到达浏览器**：HTML 中的 `<script>window.__NUXT__ = {...}</script>` 会先被执行，将数据挂载到全局对象上。\n2. **客户端 Vue 应用启动**：客户端的 JavaScript 包加载完毕后，Vue 和 Nuxt 开始初始化。\n3. **自动提取数据**：当客户端的 `useFetch('/api/posts')` 代码执行时，它不会真正去发起网络请求，而是会**先自动去**** **`**window.__NUXT__**`** ****对象里查找**，看是否存在服务端已经为它准备好的数据。\n4. **直接复用数据**：如果找到了，它就直接使用这份数据，完全跳过网络请求。这样就保证了客户端和服务端的数据状态**绝对一致**，这也是 Hydration 能成功的前提。\n\n**你可以通过 **`**useNuxtData**`** 这个工具函数来验证和访问这些被缓存的数据：**\n\n```vue\n<script setup>\n// 在客户端，你可以这样访问之前服务端获取的、被缓存的数据\nconst { data: posts } = useNuxtData('posts') // 使用 useFetch 时自动生成的 key\n\n// 这不会导致第二次请求，它只是从客户端缓存中读取\nconsole.log(posts.value)\n</script>\n```\n\n## 服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\n**你这个问题问得非常非常关键，切中了SSR安全的核心！你的直觉完全正确。**\n\n**绝对不应该将任何敏感信息（如用户凭证、Token、个人身份信息PII等）内联到HTML的**** **`**<script>**`** ****标签中，并通过**** **`**window.__NUXT__**`** ****暴露给客户端。**\n\n这样做会带来严重的安全风险：\n\n1. **数据泄露**：任何能打开浏览器开发者工具的人，都可以直接看到 `window.__NUXT__` 里的全部内容。\n2. **XSS攻击加剧**：如果你的应用存在XSS（跨站脚本）漏洞，攻击者可以更容易地编写脚本窃取 `window.__NUXT__` 中的所有数据，而不必费力去窃取多个API请求的返回结果。\n3. **缓存风险**：HTML页面可能会被CDN、代理服务器或浏览器缓存。如果其中包含了用户敏感信息，就意味着这些信息也可能被缓存并泄露给其他用户。\n\n---\n\n### 那么，如何处理需要认证的敏感数据？\n正确的做法是将敏感数据与非敏感数据**分离**，并遵循“**按需索取**”和“**最小化暴露**”的原则。以下是几种安全策略：\n\n#### 策略一：敏感数据绝不预取，仅在客户端获取\n这是最常用、最安全的策略。用户登录状态、个人资料等高度敏感的数据，**不应该**在服务端的 `useFetch`/`useAsyncData` 中获取。\n\n```vue\n<script setup>\n// 1. 非敏感、SEO需要的数据：在服务端预取（安全）\nconst { data: publicPosts } = await useFetch('/api/public-posts')\n\n// 2. 敏感的用户数据：不在服务端预取，只在客户端获取\nconst user = ref(null)\nconst token = useCookie('auth-token') // Token应存放在HttpOnly Cookie中\n\n// 在客户端挂载后，再安全地获取用户数据\nonMounted(async () => {\n  if (token.value) {\n    // 此请求在客户端发起，携带Cookie中的token\n    user.value = await $fetch('/api/me', {\n      headers: {\n        // 通常Token会自动通过Cookie发送，无需手动设置，这里演示逻辑\n        Authorization: `Bearer ${token.value}`\n      }\n    })\n  }\n})\n</script>\n\n<template>\n  <!-- 公开数据直接渲染 -->\n  <div v-for=\"post in publicPosts\" :key=\"post.id\">{{ post.title }}</div>\n  \n  <!-- 用户数据，等客户端获取后再显示 -->\n  <div v-if=\"user\">Welcome, {{ user.name }}</div>\n</template>\n```\n\n#### 策略二：使用 `useState` 进行状态管理，区分服务端与客户端状态\n你可以利用 `useState` 的灵活性来管理不同环境的状态。\n\n```vue\n<script setup>\n// 创建一个响应式状态，服务端先初始化为 null\nconst secretData = useState('secret-data', () => null)\n\n// 在客户端再获取真实数据\nonMounted(async () => {\n  if (!secretData.value) { // 避免在服务端执行\n    secretData.value = await $fetch('/api/secret-data')\n  }\n})\n</script>\n```\n\n#### 策略三：API 设计分离 - 提供公开和私密端点\n从后端设计上就进行分离：\n\n+ `/api/public/data`：返回不敏感的数据，可以安全地在服务端渲染。\n+ `/api/private/user-data`：返回敏感数据，必须认证且在客户端获取。\n\n---\n\n### Nuxt 如何安全地处理认证？\n认证的最佳实践是使用 **HttpOnly Cookies** 来传输令牌（Token），而不是通过 `window.__NUXT__` 或 JS 可读的 Cookie。\n\n1. **登录流程**：\n    - 用户提交登录表单，客户端 `$fetch` 发送到 `/api/auth/login`。\n    - **后端**验证成功后，设置一个 **HttpOnly、Secure、SameSite=Strict** 的 Cookie（包含认证Token）。这个 Cookie 对 JavaScript 不可见，极大地增强了安全性。\n    - 前端只需知道登录成功，无需接触 Token 本身。\n2. **获取用户数据**：\n    - 在客户端，调用 `$fetch('/api/me')`。\n    - 浏览器会**自动**在请求中带上 HttpOnly Cookie。\n    - 后端验证 Cookie 中的 Token 有效性后，返回对应用户的数据。\n3. **服务端渲染中的认证**：\n    - 如果服务端需要根据用户状态渲染不同内容（例如“您好，用户名”），可以通过**服务器中间件**或 **API 路由**来处理。\n    - 服务端可以读取请求中的 Cookie，去后端验证用户身份，然后决定返回什么数据。但这个验证过程发生在后端，结果信息需要是**非敏感**的（例如只返回 `username`，而不是返回 `token` 或 `email`）。\n\n```vue\n<script setup>\n// 服务端可以安全地读取Cookie并获取非敏感的用户显示信息\nconst { data: userInfo } = await useFetch('/api/user-display-info')\n// 这个 `/api/user-display-info` 接口在后端会验证Cookie，\n// 但只返回 { name: 'John' } 这样的非敏感信息用于界面显示。\n</script>\n```\n\n### 总结\n1. **核心原则**：**绝不将敏感数据内联到 HTML 中**。`window.__NUXT__` 应该是“公开的”或“非敏感的”。\n2. **数据分离**：将数据分为“公开”和“私密”两类。公开数据用 `useFetch` 服务端预取；私密数据在客户端用 `$fetch` 按需获取。\n3. **认证最佳实践**：使用 **HttpOnly Cookies** 来安全地传输认证凭证，而不是将其暴露给客户端 JavaScript 或 `window` 对象。\n4. **信任后端**：敏感的权限检查和数据处理逻辑应该始终放在后端 API 中。前端（包括SSR服务端）只负责展示非敏感的结果。\n\n你的安全意识非常到位，遵循这些原则可以让你构建出既高效又安全的 Nuxt.js 应用。\n\n## 除此之外，服务端渲染还有什么不能实现的呢？canvas？\n说得非常对！**Canvas** 是一个绝佳的例子，它完美地揭示了服务端渲染（SSR）的“盲区”。\n\nSSR 的核心是**生成静态的 HTML 和 CSS 字符串**。因此，任何**动态的、依赖于浏览器 JavaScript 运行时环境**的功能，在纯 SSR 阶段都无法实现或功能不全。\n\n除了 Canvas，还有很多类似的限制。我们可以将它们分为几大类：\n\n---\n\n### 一、浏览器特有的 API 和全局对象\n这是最直接的一类。在 Node.js 服务器环境中，根本没有 `window`, `document`, `navigator` 等对象。\n\n| API/功能 | 原因 | 解决方案 |\n| --- | --- | --- |\n| `**window**`**、**`**document**` | Node.js 中不存在。 | 使用 `onMounted`钩子或 `clientOnly`组件确保只在客户端访问。 |\n| `**alert**`**、**`**confirm**`**、**`**prompt**` | 浏览器交互对话框。 | 逻辑移至客户端，或使用基于组件的替代品（如模态框）。 |\n| **Canvas (**`**<canvas>**`**) / WebGL** | 需要浏览器渲染上下文来绘图和操作像素。 | **只能在客户端初始化和使用**。SSR 只能渲染一个空画布。 |\n| **地理位置 (**`**navigator.geolocation**`**)** | 需要用户的浏览器授权和设备硬件支持。 | 仅在客户端通过 `onMounted`或用户交互触发。 |\n| **本地存储 (**`**localStorage**`**, **`**sessionStorage**`**, **`**IndexedDB**`**)** | 是浏览器的持久化存储机制。 | 在 `onMounted`中访问，或使用 `useLocalStorage`等组合式函数（内部做了客户端检查）。 |\n| **媒体设备 (**`**navigator.mediaDevices**`**)** | 需要访问麦克风、摄像头等硬件。 | 完全的用户客户端行为。 |\n\n\n---\n\n### 二、依赖浏览器渲染或布局的功能\n这类功能需要知道元素的真实尺寸和位置，而这些信息在纯字符串的 SSR 阶段是无法获得的。\n\n| 功能 | 原因 | 解决方案 |\n| --- | --- | --- |\n| **元素尺寸/位置** (如 `element.offsetWidth`<br/>, `getBoundingClientRect()`<br/>) | SSR 只有 HTML 字符串，没有真实的布局和渲染。 | 在 `onMounted`<br/> 后使用，或使用 Vue 的 `nextTick`<br/> 确保 DOM 已更新。 |\n| **基于尺寸的渲染** (如图表库 ECharts、D3.js) | 需要挂载到真实 DOM 元素并获取其宽高才能渲染。 | 在 `onMounted`<br/> 中初始化图表实例。 |\n| **动画 (CSS 动画除外)** | 许多 JS 动画库需要操作 DOM 样式。 | 使用 `onMounted`<br/> 启动动画，或使用 CSS 动画（SSR 支持）。 |\n\n\n---\n\n### 三、用户交互和状态\nSSR 输出的是一个“快照”，无法预知用户未来的行为。\n\n| 功能 | 原因 | 解决方案 |\n| --- | --- | --- |\n| **用户输入** (表单输入、焦点状态) | SSR 无法预知用户会输入什么。 | SSR 可以渲染表单结构，但交互和值绑定必须在客户端完成。 |\n| **鼠标事件、键盘事件** | 纯静态环境，无用户交互。 | 完全由客户端 JavaScript 处理。 |\n| **浏览器标签页可见性** (`document.visibilityState`) | 依赖于用户当前的浏览器状态。 | 纯客户端逻辑。 |\n\n\n---\n\n### 四、第三方库\n许多强大的第三方库在设计时就是为浏览器而生的。\n\n| 库类型 | 问题 | 解决方案 |\n| --- | --- | --- |\n| **地图库** (如 Leaflet, Google Maps) | 需要挂载到 DOM 并初始化地图渲染上下文。 | 使用 `onMounted`<br/> 初始化，或使用 Nuxt 模块（如 `nuxt-leaflet`<br/>）。 |\n| **可视化库** (如 D3, Three.js) | 严重依赖 Canvas、WebGL 或 SVG 操作。 | **只能在客户端运行**。 |\n| **分析/广告库** (如 Google Analytics) | 依赖 `window`<br/> 对象和浏览器环境来跟踪用户。 | 使用 Nuxt 插件（`client: true`<br/> 选项）或直接在 `onMounted`<br/> 中加载。 |\n\n\n---\n\n### 如何安全地处理这些限制？Nuxt 提供的解决方案\nNuxt 提供了一系列模式来优雅地解决这些问题：\n\n#### 1. `onMounted` 钩子 (最常用)\n确保代码只在客户端执行。\n\n```vue\n<script setup>\nimport { onMounted } from 'vue'\n\nconst canvas = ref(null)\n\nonMounted(() => {\n  // 现在可以安全地访问 DOM 和浏览器 API 了\n  const ctx = canvas.value.getContext('2d')\n  ctx.fillStyle = 'green'\n  ctx.fillRect(10, 10, 150, 100)\n})\n</script>\n\n<template>\n  <!-- SSR 会渲染一个空画布 -->\n  <canvas ref=\"canvas\" width=\"200\" height=\"200\"></canvas>\n</template>\n```\n\n#### 2. 条件渲染与 `<ClientOnly>` 组件\n防止不支持 SSR 的组件在服务器端渲染时出错。\n\n```vue\n<template>\n  <!-- 默认插槽只在客户端渲染 -->\n  <ClientOnly>\n    <MyChartThatUsesWindow />\n    <!-- 可以设置回退内容，在SSR阶段显示 -->\n    <template #fallback>\n      <div>Loading chart...</div>\n    </template>\n  </ClientOnly>\n</template>\n```\n\n#### 3. 使用 `process.client` 标志进行运行时检查\n```vue\n<script setup>\nif (process.client) {\n  // 此代码块只在客户端打包时包含，并在客户端执行\n  console.log('I am on the client!', window.innerWidth)\n}\n</script>\n```\n\n#### 4. 为第三方库创建客户端插件\n```javascript\n// plugins/analytics.client.js - 注意 .client 后缀\nexport default defineNuxtPlugin(() => {\n  // 这个插件只会在客户端运行\n  window.dataLayer = window.dataLayer || []\n  function gtag(){ dataLayer.push(arguments) }\n  gtag('js', new Date())\n  gtag('config', 'GA_MEASUREMENT_ID')\n})\n```\n\n### 总结\n服务端渲染 (SSR) 的本质是**静态化**，它擅长的是：\n\n+ **生成初始 HTML 内容**\n+ **提供更好的 SEO**\n+ **提升首屏加载性能**\n\n而**动态交互**和**浏览器依赖**永远是 SSR 的盲区，必须交给客户端处理。\n\n**因此，一个成熟的 Nuxt 应用是两者结合的“混合体”：**\n\n1. **服务端**：生成静态结构和首屏内容。\n2. **客户端**：“激活”页面，接管所有交互，并加载那些依赖浏览器环境的动态功能。\n\n你的工作就是清晰地界定哪些逻辑属于服务端，哪些属于客户端，并使用 Nuxt 提供的模式（`onMounted`, `<ClientOnly>`, `.client` 插件）将它们优雅地结合起来。\n\n## nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\n这是一个非常好的问题，它触及了 Nuxt 全栈架构的核心优势。\n\n**简单而直接的答案是：不会。在客户端激活后，向同源的 Nuxt 中间件或 API 路由发起请求，绝对不会产生跨域问题。**\n\n这是因为你发起请求的目标和你的页面来源是**完全同源的**。\n\n---\n\n### 为什么不会跨域？—— 同源策略详解\n让我们回顾一下“同源策略”：当协议、域名、端口都相同时，即为同源，浏览器允许请求。\n\n假设你的 Nuxt 应用部署在：  \n`https://www.my-app.com`\n\n1. **你的页面来源**：  \n浏览器中显示的地址是：`https://www.my-app.com/some-page`\n2. **你请求的目标**：  \n你在代码中发起的请求是：\n\n```javascript\n// 使用相对路径，目标自动补全为：https://www.my-app.com/api/hello\nawait $fetch('/api/hello');\n\n// 或者使用 useFetch（同样基于相对路径）\nconst { data } = useFetch('/api/auth/user');\n```\n\n3. **对比**：\n    - **协议**：都是 `https`\n    - **域名**：都是 `www.my-app.com`\n    - **端口**：都是 `443` (HTTPS 默认端口)\n\n**结论**：**完全同源**，浏览器欣然放行，没有任何跨域限制。\n\n---\n\n### Nuxt 如何处理这些请求？—— 请求生命周期\n理解这个过程能让你更清楚为什么这是安全的：\n\n如图所示，无论是开发还是生产环境，**你的 API 请求和前端页面都由同一个主机处理**。它们处于同一个“生态系统”内，通信是内部的、安全的，不存在跨域问题。\n\n---\n\n### 什么情况下会有跨域问题？\n只有当你的**页面来源**和**请求目标**不同源时，才会触发跨域。例如：\n\n| 你的页面在 | 你请求的目标 | 是否跨域 | 原因 |\n| --- | --- | --- | --- |\n| `https://www.my-app.com` | `https://www.my-app.com/api/hello` | **否** | 同源 |\n| `https://www.my-app.com` | `https://api.my-app.com` | **是** | 子域名不同 (`www` vs `api`) |\n| `http://localhost:3000` | `https://api.third-party.com` | **是** | 完全不同的域名 |\n| `https://www.my-app.com` | `http://www.my-app.com/api/hello` | **是** | 协议不同 (`https`vs `http`) |\n\n\n**对于最后一种情况（生产环境前后端分离），解决方案是：**\n\n1. **后端配置 CORS**：在你的 `api.my-app.com` 服务器上设置 `Access-Control-Allow-Origin: https://www.my-app.com` 响应头。\n2. **使用反向代理**：配置你的生产服务器（如 Nginx），将对 `/api/` 的请求代理到 `api.my-app.com`，让浏览器始终觉得是在请求同源地址。这是更推荐的做法。\n\n### 总结\n+ **在 Nuxt 应用中，请求自身的 API 路由 (**`**/api/xxx**`**) 或服务器中间件是绝对同源的，没有跨域问题。**\n+ 这是 Nuxt 全栈框架的巨大优势之一，它简化了开发，让你无需在开发阶段为 CORS 烦恼。\n+ 跨域问题只会在你请求**外部第三方 API** 且对方未正确配置 CORS 时出现。\n+ 如果你的生产环境是前后端完全分离的（不同域），那么需要在生产环境的**后端配置 CORS** 或通过**反向代理**来解决。\n\n所以，请放心地在你的 Nuxt 应用内部调用 API，这是最安全、最正确的做法。\n\n## 那如果对后端接口(另一台服务器上)的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\n**你的这个思路非常棒，完全正确！** 这正是构建现代 Web 应用的一种核心架构模式，被称为 **“BFF（Backend For Frontend）模式”** 或 **“API 网关模式”**。\n\n你的推理链条是：\n\n1. **所有客户端请求**都只发往**同源**的 Nuxt 服务器（`/api/proxy`）。\n2. Nuxt 服务器上的**中间件**接收到请求后，**代为转发**给真正的后端服务器。\n3. 由于服务器之间通信（Nuxt Server -> Your Backend Server）**没有跨域限制**，所以问题迎刃而解。\n\n这个方案**在理论上是完全可行且非常优雅的**，它确实可以让你**完全摆脱 CORS 的困扰**。\n\n---\n\n### 这种架构的详细工作流程\n如图所示，浏览器始终只与 `my-nuxt-app.com` 通信，完美符合同源策略。\n\n---\n\n### 优缺点分析：这是否是“万能药”？\n虽然这个方案能根治跨域，但它也引入了一些新的考虑因素：\n\n#### 优点 ✅\n1. **彻底解决 CORS**：前端开发者完全无需再关心跨域配置，开发体验极其流畅。\n2. **隐藏后端架构**：真正的后端地址、端口、API 结构对客户端完全隐藏，更安全。\n3. **协议转换**：可以轻松地在 Nuxt 中处理 HTTPS -> HTTP 的请求（服务器间通信允许）。\n4. **数据处理与聚合**：你可以在 Nuxt 中间件中对多个后端服务的返回值进行聚合、过滤、转换，为前端提供最合适的数据结构，减少前端请求次数。\n\n#### 缺点与需要考虑的因素 ⚠️\n1. **额外的网络跳转**：所有请求都多经过一环（浏览器 -> Nuxt -> 真实后端），**会增加微小的延迟**。对于延迟敏感的应用需要优化。\n2. **单点压力与故障点**：Nuxt 服务器现在成为了所有 API 流量的入口。如果它宕机，所有请求都会失败。需要保证其高可用性。\n3. **复杂性转移**：虽然前端变简单了，但 Nuxt 层（BFF 层）的逻辑变复杂了。你需要在这里编写转发、错误处理、认证等逻辑。\n4. **认证问题**：如果后端 API 需要认证，你需要决定如何传递认证信息。\n    - **方案A（推荐）**：浏览器将认证 Token 发给 Nuxt，Nuxt 再原样转发给后端。\n    - **方案B**：Nuxt 服务器自己持有访问后端的凭证，替用户与后端通信。但这需要非常小心地管理权限。\n\n---\n\n### 如何实现？\n在 Nuxt 中，你通常使用 **API 路由** 或 **服务器中间件** 来实现，而不是普通的中间件，因为它们专门处理服务器逻辑。\n\n**示例：在 **`**server/api/proxy/[...].ts**`** 中创建一个捕获所有路由的 API**\n\n```typescript\n// server/api/proxy/[...].ts\nexport default defineEventHandler(async (event) => {\n  // 1. 获取请求路径和方法\n  const path = getRouterParam(event, 'path') // 获取 ... 通配符参数\n  const method = getMethod(event)\n  const body = method === 'GET' ? undefined : await readBody(event)\n\n  // 2. 定义你的真实后端基础 URL（应从环境变量读取！）\n  const baseURL = 'https://your-real-backend.com/api'\n  const targetURL = `${baseURL}/${path}`\n\n  // 3. 可选：处理认证（例如，将前端传来的 token 转发给后端）\n  const headers = {}\n  const authHeader = getHeader(event, 'authorization')\n  if (authHeader) {\n    headers['Authorization'] = authHeader\n  }\n\n  // 4. 代理请求到真实后端\n  try {\n    const response = await $fetch.raw(targetURL, {\n      method,\n      body,\n      headers,\n      // 重要：转发查询参数 (?foo=bar)\n      query: getQuery(event),\n    })\n\n    // 5. 可选：根据需要设置响应头\n    setHeaders(event, response.headers)\n\n    // 6. 返回后端响应的数据\n    return response._data\n  } catch (error) {\n    // 7. 错误处理，将后端错误返回给前端\n    throw createError({\n      statusCode: error.statusCode || 500,\n      statusMessage: error.statusMessage || 'Internal Server Error',\n    })\n  }\n})\n```\n\n这样，前端所有发往 `/api/proxy/items`、`/api/proxy/user/profile` 的请求，都会被这个 handler 捕获，并转发到 `https://your-real-backend.com/api/items` 和 `https://your-real-backend.com/api/user/profile`。\n\n### 结论\n**是的，你的想法是完全正确且高效的。通过让 Nuxt 服务器作为所有后端请求的代理，你可以一劳永逸地解决跨域问题，无需在开发或生产环境配置任何 CORS 或代理规则。**\n\n这不仅是解决跨域的手段，更是一种先进的**架构设计选择**（BFF）。它特别适用于：\n\n+ 中大型前后端分离项目。\n+ 需要集成多个后端微服务的复杂前端。\n+ 希望简化前端开发流程，将复杂性集中到 BFF 层的团队。\n\n你只需要评估其带来的**额外延迟**和**单点压力**是否在你的应用可接受范围内即可。对于绝大多数应用来说，这个方案的利远大于弊。\n\n","source":"_posts/Nuxt.js.md","raw":"---\ntitle: 微前端\ndate: 2025-08-15\ntags: [Nuxt, 服务端渲染]\ncategories: Nuxt\n---\n\n## Nuxt.js的ssr服务端渲染原理\nNuxt.js 的 SSR（服务端渲染）原理是一个非常核心且有趣的话题。它并不是简单的“在服务器上跑 Vue”，而是一套完整的、精心设计的架构。\n\n简单来说，它的核心原理是：**“首屏在服务器提前渲染成 HTML，之后在客户端‘激活’为 SPA”。**\n\n下面我们分步拆解这个过程的原理、优势和关键实现。\n\n---\n\n### 一、核心目标：解决什么問題？\n1. **SEO（搜索引擎优化）**：传统 SPA（单页应用）返回的是一个空的 HTML 壳，内容由 JavaScript 动态填充。搜索引擎爬虫可能无法等待和执行 JS，导致无法收录内容。SSR 直接返回渲染好的完整 HTML，利于爬虫抓取。\n2. **更快的内容到达时间**：用户浏览器无需等待所有 JavaScript 下载和执行完毕才能看到内容。服务器直接返回了渲染好的 HTML，首屏内容可以立即展示，感知性能极大提升。\n\n### 二、Nuxt.js SSR 的核心工作流程\nNuxt.js 的 SSR 过程可以清晰地分为两个阶段：**服务端渲染**和**客户端激活**。下图展示了从用户请求到页面可交互的完整生命周期：\n\n![画板](https://cdn.nlark.com/yuque/0/2025/jpeg/55999631/1757522658867-d1d335f5-5c7f-443b-bdc8-3a1621a987cb.jpeg)\n\n#### 第一阶段：服务端渲染（Server-Side）\n这个过程发生在 **Nuxt 服务器**（一个 Node.js 服务器）上。\n\n1. **接收请求**：用户浏览器请求一个 URL，请求到达 Nuxt 服务器。\n2. **创建应用实例**：Nuxt 服务器为这次请求**创建一个全新的 Vue 应用实例、Router 和 Store**。这是关键，确保了每个请求的隔离性。\n3. **路由匹配**：根据请求的 URL，Nuxt Router 确定要渲染哪个页面组件（如 `pages/about.vue`）。\n4. **数据预取**：Nuxt 会调用页面组件中定义的**异步数据获取方法**（如 `asyncData`、`useAsyncData`、`useFetch`）。**这些方法会在服务端执行**。\n    - 服务器会等待这些异步操作完成，再去渲染组件。这确保了渲染出的 HTML 是包含数据的。\n5. **渲染 HTML**：\n    - 将获取到的数据**注入到 Vuex Store 或组件状态**中。\n    - 调用 Vue 的 `vue-server-renderer`（Vue 2）或 `@vue/server-renderer`（Vue 3）的 `renderToString()` 函数。\n    - 这个函数会运行 Vue 组件，但它**不是在浏览器中创建真实 DOM，而是在内存中生成一个完整的 HTML 字符串**。\n6. **构建最终文档**：Nuxt 将这个 HTML 字符串插入到HTML模板（`app.html`）中。同时，**将预取的数据序列化后内联到 HTML 中**（通常是在一个 `<script>` 标签里，如 `window.__NUXT__ = {...}`），这个过程称为 **状态脱水**。\n7. **响应**：将这个完整的、包含数据和内容的 HTML 文档发送给客户端。\n\n#### 第二阶段：客户端激活（Client-Side Hydration）\n这个过程发生在**用户浏览器**上。\n\n1. **静态内容展示**：浏览器收到服务器返回的 HTML 后，**无需等待任何 JavaScript，就能立即解析和显示页面内容**。这是首屏速度快的根本原因。\n2. **加载资源**：浏览器开始加载页面中引用的 JavaScript 和 CSS 资源（Nuxt 打包好的客户端 bundle）。\n3. **Vue 接管（Hydration -“混合”）**：这是最精妙的一步。\n    - 客户端的 Vue 应用也会被创建和初始化。\n    - Vue 不会像传统 SPA 那样清空 DOM 再重新渲染。相反，它会**将虚拟 DOM 与服务器渲染好的现有静态 HTML 结构进行“混合”**。\n    - 它会将事件监听器、Vue 的响应式系统等“激活”到这些静态元素上，使其变成一个完全交互式的 Vue 应用。\n4. **变为 SPA**：激活完成后，应用就切换到了正常的 SPA 模式。后续的页面导航不会再向服务器请求完整的 HTML，而是由客户端 Router 管理，只获取必要的数据，实现无刷新跳转。\n\n---\n\n### 三、Nuxt.js 实现 SSR 的关键技术点\n1. **双入口构建（Dual Entry Points）**：\n    - Nuxt 使用 Webpack/Vite 分别打包**两个版本**的代码：\n        * **服务端 Bundle**：用于 `renderToString`，它知道如何在 Node.js 环境中渲染组件。\n        * **客户端 Bundle**：用于在浏览器中“激活”静态页面并处理后续交互。\n    - 这是通过 `webpack` 的 `target: 'node'` 和 `target: 'web'` 分别配置实现的。\n2. **数据预取与状态同步**：\n    - 服务端获取的数据必须**安全地传递到客户端**，否则客户端 Vue 在初始化时没有数据，会导致虚拟 DOM 与服务器渲染的 HTML 不匹配，激活失败。\n    - Nuxt 通过 `window.__NUXT__` 对象将数据从服务器“脱水”到客户端“补水”，保证两端状态一致。\n3. **生命周期**：\n    - 在 SSR 过程中，**只有**** **`**beforeCreate**`** ****和**** **`**created**`** ****这两个生命周期钩子会在服务端执行**。\n    - `mounted`、`beforeMount` 等只在客户端执行。因此，**在**** **`**created**`** ****中操作**** **`**window**`** ****或 DOM 会报错**。\n\n---\n\n### 四、Universal Mode (同构渲染)\nNuxt.js 的 SSR 通常被称为 **“Universal”应用**或**“同构”应用**。\n\n+ **同构代码**：同一份 Vue 组件代码（`.vue` 文件）既可以在**服务器**上运行（用于首屏生成 HTML），也可以在**客户端**运行（用于激活和后续交互）。\n+ **优势**：开发者只需写一套代码，Nuxt 负责处理双端的构建和渲染协调，开发体验非常流畅。\n\n### 总结\nNuxt.js 的 SSR 原理可以概括为：\n\n1. **服务端**：为每个请求即时创建 Vue 应用，预先获取数据，渲染出包含内容的 HTML 字符串，并将数据状态一同返回。\n2. **客户端**：快速展示静态内容，然后加载 JS，由 Vue 将静态页面“激活”为可交互的 SPA，最后接管所有后续导航。\n\n它完美地结合了**传统服务端渲染首屏快、SEO 好**的优势和**单页应用用户体验流畅、交互丰富**的优势，是现代 Web 应用开发的绝佳选择。\n\n## nuxt中调后端接口怎么做，要注意什么？\n在 Nuxt.js 中调用后端接口是其核心功能之一，但根据你使用的 API 风格（Composition API 或 Options API）和渲染模式（SSR 或 SPA），做法和注意事项有所不同。\n\n下面将为你提供全面的指南，包括方法、最佳实践和常见陷阱。\n\n---\n\n### 一、如何调用后端接口？\nNuxt 3 推荐使用 Composition API，并提供了强大的组合式函数。\n\n#### 1. 使用 `useFetch` / `useAsyncData` (Composition API - 首选)\n这是 Nuxt 3 中最现代、最推荐的方式，它完美处理了服务端和客户端的数据获取。\n\n**基本用法 (**`**useFetch**`**)：**  \n`useFetch` 是专门为获取数据而设计的语法糖。\n\n```vue\n<script setup>\n// 直接在模板中使用，无需 .value\nconst { data: posts, pending, error, refresh } = useFetch('/api/posts')\n\n// 或者指定完整 URL（注意配置代理或 CORS）\nconst { data: users } = useFetch('https://api.example.com/users', {\n  // 可选项：在客户端才获取数据（代替 onMounted + ref）\n  // lazy: true,\n  // server: false\n})\n</script>\n\n<template>\n  <div v-if=\"pending\">Loading...</div>\n  <div v-else-if=\"error\">Error: {{ error.message }}</div>\n  <ul v-else>\n    <li v-for=\"post in posts\" :key=\"post.id\">{{ post.title }}</li>\n  </ul>\n  <button @click=\"refresh\">Refresh</button>\n</template>\n```\n\n**高级用法 (**`**useAsyncData**`** + **`**$fetch**`**)：**  \n当你需要更复杂的逻辑时（如多个请求、数据处理），使用 `useAsyncData`。\n\n```vue\n<script setup>\nconst { data: combinedData, refresh } = useAsyncData('unique-key', async () => {\n  // 这里可以写任何复杂的异步逻辑\n  const [posts, users] = await Promise.all([\n    $fetch('/api/posts'),\n    $fetch('/api/users')\n  ])\n  \n  // 对数据进行转换\n  return {\n    posts: posts.map(post => ({ ...post, title: post.title.toUpperCase() })),\n    users\n  }\n})\n</script>\n```\n\n#### 2. 使用 `$fetch` 直接调用\nNuxt 3 内置了基于 [ofetch](https://github.com/unjs/ofetch) 的 `$fetch` 工具，可以在任何地方使用（如事件处理函数中）。\n\n```vue\n<script setup>\nconst handleSubmit = async () => {\n  try {\n    const response = await $fetch('/api/submit', {\n      method: 'POST',\n      body: { name: 'John Doe' }\n    })\n    console.log('Success:', response)\n  } catch (error) {\n    console.error('Error:', error)\n  }\n}\n</script>\n```\n\n#### 3. 使用 `useLazyFetch` / `useLazyAsyncData`\n它们是 `useFetch` 和 `useAsyncData` 的变体，`lazy: true` 是默认行为。**不会阻塞导航**，适用于非关键数据。\n\n```vue\n<script setup>\n// 不会阻塞路由导航，你需要自己处理 data 为 null 的情况\nconst { data: nonCriticalData } = useLazyFetch('/api/non-critical-data')\n</script>\n\n<template>\n  <div v-if=\"data\">\n    <!-- 渲染数据 -->\n  </div>\n</template>\n```\n\n### 二、最重要的注意事项\n#### 1. 服务端渲染 (SSR) vs 客户端渲染 (CSR) 行为\n这是 **最核心、最容易出错** 的点！\n\n+ **默认行为**：`useFetch` 和 `useAsyncData` **会在服务端执行**。这意味着：\n    - **好处**：返回的 HTML 直接包含数据，利于 SEO 和首屏加载。\n    - **陷阱**：**不能在它们内部或**** **`**created**`** ****生命周期中使用浏览器API**（如 `window`, `document`, `localStorage`）。\n+ **如何控制**：\n\n```javascript\n// 选项 1: 强制只在客户端执行\nconst { data } = useFetch('/api/data', { server: false })\n\n// 选项 2: 使用 useLazyFetch (默认不会阻塞导航，且在客户端执行)\nconst { data } = useLazyFetch('/api/data')\n\n// 选项 3: 在 onMounted 钩子中用 $fetch\nimport { onMounted } from 'vue'\nconst data = ref(null)\nonMounted(async () => {\n  data.value = await $fetch('/api/data')\n})\n```\n\n#### 2. 处理 CORS (跨域资源共享)\n如果你调用的接口不在同一个域下，会遇到 CORS 问题。\n\n+ **开发环境**：在 `nuxt.config.ts` 中配置代理是最佳实践。\n\n```typescript\n// nuxt.config.ts\nexport default defineNuxtConfig({\n  // ... 其他配置\n  nitro: {\n    routeRules: {\n      '/api/**': { proxy: 'https://api.example.com/**' }, // 代理 API 请求\n    },\n  },\n  // 或者使用旧的 devServer 配置 (v3.0+ 推荐使用 nitro)\n  // devServer: {\n  //   proxy: {\n  //     '/api': 'https://api.example.com'\n  //   }\n  // }\n})\n```\n\n+ 然后你在代码中请求 `/api/users`，开发服务器会将其代理到 `https://api.example.com/api/users`，避免 CORS。\n+ **生产环境**：\n    - **最佳方案**：配置你的**反向代理**（如 Nginx）来处理跨域请求。\n    - **备选方案**：确保后端 API 正确配置了 CORS 头 (`Access-Control-Allow-Origin` 等)。\n\n#### 3. 认证和令牌 (Authentication)\n如何安全地传递身份验证信息（如 JWT Token）。\n\n+ **使用请求拦截器**：利用 `ofetch` 的自动全局拦截器。\n+ 如何安全地传递身份验证信息（如 JWT Token）。\n\n```typescript\n// plugins/api.ts\nexport default defineNuxtPlugin(() => {\n  const { token } = useAuth() // 假设你有一个获取 token 的 composable\n\n  // 全局拦截 $fetch 请求\n  globalThis.$fetch = $fetch.create({\n    onRequest({ request, options }) {\n      // 添加认证头\n      if (token.value) {\n        options.headers = {\n          ...options.headers,\n          Authorization: `Bearer ${token.value}`\n        }\n      }\n    },\n    onRequestError({ error }) {\n      console.error('Request error:', error)\n    },\n    onResponseError({ response }) {\n      // 统一处理 401 未授权错误\n      if (response.status === 401) {\n        // 跳转到登录页\n        navigateTo('/login')\n      }\n    }\n  })\n})\n```\n\n#### 4. 错误处理\n永远不要假设请求一定会成功。\n\n+ **使用 try-catch**：\n\n```javascript\ntry {\n  const data = await $fetch('/api/endpoint')\n} catch (error) {\n  // Nuxt 3 的 $fetch 会自动抛出错误\n  console.error('API call failed:', error)\n  // 在这里显示用户友好的错误信息\n}\n```\n\n+ **使用 **`**useFetch**`** 的状态**：\n\n```vue\n<script setup>\nconst { data, error } = useFetch('/api/endpoint')\n</script>\n\n<template>\n  <div v-if=\"error\">\n    Failed to load data: {{ error.message }}\n    <button @click=\"refresh\">Try Again</button>\n  </div>\n</template>\n```\n\n#### 5. 性能优化：避免重复请求\n+ **Key 的妙用**：`useAsyncData` 和 `useFetch` 会**自动去重**具有相同 key 的请求。确保为唯一的数据集提供唯一的 key。\n\n```javascript\n// 如果两个组件使用相同的 key，只会发出一个请求\nconst { data } = useAsyncData('user-profile', () => $fetch('/api/profile'))\n```\n\n+ **缓存**：`$fetch` 默认不会缓存 HTTP 缓存。如果你需要利用 HTTP 缓存，可以在 headers 中设置，或者使用更高级的缓存策略。\n\n---\n\n### 三、最佳实践总结\n1. **首选**** **`**useFetch**`**/**`**useAsyncData**`：用于在组件中获取数据，它们能智能处理 SSR 和 hydration。\n2. **明确数据获取时机**：想清楚你需要的数**据是应该在服务端获取（SEO 关键）还是客户端获取（用户相关）**，并用 `server: false` 或 `useLazyFetch` 控制。\n3. **开发环境用代理解决 CORS**：在 `nuxt.config.ts` 中配置代理，避免跨域问题。\n4. **统一处理认证和错误**：通过插件创建配置好的 `$fetch` 实例，全局处理 token 和错误。\n5. **善待你的 API**：合理使用 key 去重，避免重复请求；考虑分页、限流和缓存。\n\n遵循这些指南，你就能在 Nuxt 应用中高效、可靠地与后端 API 进行交互。\n\n## 开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\n**你这个问题问得非常好，直击要害！你的理解完全正确。**\n\n是的，你的推理是精准的：\n\n+ **服务端（Node.js）发起的请求**：没有跨域概念。跨域是**浏览器**强加的安全策略。Node.js 发请求就像你用 `curl` 或 Postman 一样，可以去任何地方，不存在 CORS 问题。\n+ **客户端（浏览器）发起的请求**：受跨域限制。浏览器会拦截违反同源策略的请求。\n\n**因此，“开发环境配置代理” 主要就是为了解决 —— 在客户端发起请求时遇到的跨域问题。**\n\n---\n\n### 为什么开发环境会有客户端请求？\n在 Nuxt 3 的 SSR 模式下，一个页面渲染通常涉及**两次**数据获取：\n\n1. **第一次（服务端请求 - 无 CORS）**：\n    - 当用户直接访问页面 URL 时，请求会先到达你的 Nuxt 服务器。\n    - Nuxt 服务器执行 `useFetch` 或 `useAsyncData`，**在服务器环境**（Node.js）中向后端 API 发起请求。\n    - 此时是 **服务器对服务器** 的通信，没有浏览器参与，所以**没有 CORS 问题**。\n    - 服务器拿到数据后，渲染出包含内容的 HTML 并返回给浏览器。\n2. **第二次（客户端请求 - 有 CORS 风险）**：\n    - 浏览器收到 HTML 并展示后，会加载 Nuxt 的客户端 JS Bundle。\n    - Vue 开始 **“激活” (Hydration)** 过程。\n    - 在这个过程中，`useFetch` 和 `useAsyncData` 的代码会在**客户端浏览器环境**中再次运行，以确保数据状态一致。\n    - 如果它们的 URL 是**绝对路径**（如 `https://api.example.com/data`），那么这次请求就是由**浏览器**直接发起的，就会触发 CORS 检查。\n    - 如果后端 API 没有正确配置 CORS 头，浏览器就会拦截这次请求，导致错误。\n\n此外，还有几种常见的**纯客户端请求**场景：\n\n+ 用户交互（如点击按钮）触发的 `$fetch` 请求。\n+ 在 `onMounted` 钩子中发起的请求。\n+ 使用 `useLazyFetch`（它默认在客户端执行）。\n\n### 总结与最佳实践\n| 场景 | 请求发起方 | 是否有 CORS 问题？ | 解决方案 |\n| --- | --- | --- | --- |\n| **SSR 首屏渲染** | Nuxt Server (Node.js) | **否** | 无需额外配置。但需确保服务器能访问到 API（网络连通性）。 |\n| **CSR Hydration/交互** | 浏览器 | **是** | **配置开发服务器代理**（如下方代码）。这是最推荐的方法。 |\n| **生产环境** | 浏览器 | **是** | **配置生产级反向代理**（如 Nginx），或确保后端 API 正确设置 CORS 头。 |\n\n\n## nuxt中的$fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\n非常好的问题！这是理解 Nuxt 3 数据获取的关键。它们的执行环境行为是核心区别。\n\n简单直接的答案是：**不，**`**$fetch**`** ****可以在服务端和客户端调用。而**** **`**useFetch**`** ****和**** **`**useAsyncData**`** ****的行为是智能的，默认在服务端执行。**\n\n下面我们来详细拆解这三者的区别。\n\n---\n\n### 一、`$fetch`：双环境通用的请求工具\n`$fetch` 是 Nuxt 3 基于 [ofetch](https://github.com/unjs/ofetch) 提供的全局工具函数。它本身**没有环境限制**，你在哪里调用它，它就在哪个环境执行。\n\n+ **在服务端（Node.js）调用**：它就像一个普通的 Node.js HTTP 客户端（比如 `axios`），直接向后端发起请求，**没有跨域概念**。\n+ **在客户端（浏览器）调用**：它的行为类似于原生的 `fetch()`，但功能更强大（自动处理 JSON、更好的错误处理等），并且**受浏览器跨域策略限制**。\n\n**示例：**\n\n```javascript\n// 1. 在组件 setup 中直接调用 - 根据渲染环境决定\n// 如果在服务端渲染，它在服务端执行；如果在客户端激活或导航，它在客户端执行。\nconst data = await $fetch('/api/items');\n\n// 2. 在明确的服务端环境调用 - 只在服务端执行\n// 例如：在 API 路由、服务器中间件或 plugin 中\nexport default defineEventHandler(async (event) => {\n  const data = await $fetch('https://external-api.com/data'); // 在服务器上运行\n  return { data };\n});\n\n// 3. 在明确的客户端环境调用 - 只在客户端执行\n// 例如：在事件处理函数或 onMounted 中\nconst handleClick = async () => {\n  const data = await $fetch('/api/items'); // 在浏览器中运行，受 CORS 限制\n};\n```\n\n`**$fetch**`** ****的陷阱**：如果你在组件顶层直接使用 `$fetch`（没有包裹在 `useAsyncData` 或 `useFetch` 中），并且该组件在服务端渲染，那么请求会在服务端执行。但当客户端激活（Hydration）时，**同样的**** **`**$fetch**`** ****代码又会在客户端再执行一次**，造成重复请求。\n\n---\n\n### 二、`useAsyncData` & `useFetch`：智能的双环境数据获取器\n这两个组合函数是 Nuxt 数据获取的“智能大脑”。它们的关键特性是：**“在服务端预取数据，并自动将数据序列化到客户端，避免重复请求”**。\n\n#### 核心行为：\n1. **默认在服务端执行**：在 SSR 模式下，当页面首次加载时，它们会在 Nuxt 服务器内部执行，获取数据并直接将数据嵌入到最终返回的 HTML 中。\n2. **在客户端激活**：当 Vue 在客户端“激活”静态页面时，`useAsyncData` 和 `useFetch` 会识别到数据已经存在于从服务器传递过来的 payload 中，因此**不会在客户端再次发起请求**，而是直接使用已有的数据。\n3. **后续导航**：当你在客户端通过导航跳转到另一个也使用了这些函数的页面时，它们会在**客户端**执行。\n\n#### 如何控制执行环境？\n它们提供了一个 `server` 选项让你精确控制：\n\n```javascript\n// 默认：true - 在服务端执行（SSR 首屏）\nconst { data } = useFetch('/api/items');\n\n// 强制在客户端执行（CSR）\n// 适合：用户相关的数据、不需要 SEO 的数据、访问浏览器 API 的数据\nconst { data } = useFetch('/api/user-data', {\n  server: false\n});\n\n// useAsyncData 用法相同\nconst { data } = useAsyncData('user-key', () => $fetch('/api/user'), {\n  server: false\n});\n```\n\n### 三、三者的对比总结\n为了更直观地理解，下面的流程图展示了不同调用方式在 Nuxt 应用生命周期中的执行时机和数据流向：\n\n这个图清晰地展示了：\n\n1. `**useFetch**`**/**`**useAsyncData**` 是贯穿服务端和客户端的“智能通道”，保证了数据的高效同步和无重复请求。\n2. **直接使用**** **`**$fetch**` 在组件顶层会导致重复请求，是需要避免的反模式。\n3. **在事件中使用的**** **`**$fetch**` 是纯客户端行为。\n\n### 最佳实践与选择指南\n| 场景 | 推荐使用的工具 | 原因 |\n| --- | --- | --- |\n| **获取页面组件所需数据** | `**useFetch**`<br/>** ****或**** **`**useAsyncData**` | 自动处理 SSR/CSR，避免重复请求，数据序列化到客户端。 |\n| **在事件处理、**`**onMounted**`<br/>** ****中获取数据** | `**$fetch**` | 明确需要在客户端触发的请求。 |\n| **在 API 路由或服务器中间件中** | `**$fetch**` | 明确的服务端环境，无需 `useAsyncData`<br/> 的额外功能。 |\n| **需要复杂的数据获取逻辑** | `**useAsyncData**`<br/>** ****+**** **`**$fetch**` | `useAsyncData`<br/> 提供状态管理，内部函数可使用 `$fetch`<br/> 进行复杂操作。 |\n| **简单的 URL 请求** | `**useFetch**` | 最简洁的写法。 |\n\n\n**一句话总结：**\n\n+ **用**** **`**useFetch**`**/**`**useAsyncData**` 来获取**组件初始化时所需的数据**，让 Nuxt 智能决定执行环境。\n+ **用**** **`**$fetch**` 在**明确的客户端交互**或**明确的服务端环境**中主动发起请求。\n\n遵循这个原则，你就能高效且正确地在 Nuxt 应用中处理数据获取。\n\n## 激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\n这些问题触及了 Nuxt.js SSR 的核心魔法。好消息是，**这个过程绝大部分是自动化的，开发者几乎不需要手动干预**。Nuxt 和 Vue 底层已经为你处理好了一切。\n\n下面我来逐一解答你的问题，你会看到 Nuxt 的设计是多么巧妙。\n\n---\n\n### 一、激活客户端需要开发手动调用什么 API 吗？\n**答：完全不需要。这是 Vue 和 Nuxt 自动完成的。**\n\n这个过程称为 **Hydration（混合）**。它的流程是：\n\n1. **自动执行**：当浏览器加载完 Nuxt 发送过来的 HTML 和客户端 JavaScript 包后，Vue 会自动启动。\n2. **自动匹配**：Vue 会将它的虚拟 DOM 与服务器渲染好的、已经存在的静态 HTML 结构进行对比和匹配。\n3. **自动“激活”**：Vue 不会重新创建 DOM 元素，而是会将事件监听器、响应式数据系统等“附加”到这些现有的 DOM 元素上，使静态页面瞬间变为一个完全交互式的 Vue 应用。\n\n**作为开发者，你唯一要做的就是：**\n\n+ 确保你的代码是**同构的**（即同一份代码既能在 Node.js 环境运行，也能在浏览器环境运行）。\n+ 避免在 `created` 或 `setup` 等生命周期中使用浏览器特有的 API（如 `window`, `document`），或者使用 `onMounted`（仅在客户端执行）来包裹它们。\n\n**你不用写任何像**** **`**app.hydrate()**`** ****这样的代码，一切都是开箱即用、自动发生的。**\n\n---\n\n### 二、服务端异步获取的数据注入到 HTML 这一步开发需要做什么？\n**答：你只需要使用正确的 API（**`**useAsyncData**`** ****或**** **`**useFetch**`**），Nuxt 就会自动完成注入。**\n\n这个“注入”过程在 Nuxt 中被称为 **State Serialization（状态序列化）** 或 ** dehydration（脱水）**。\n\n**你的工作（非常简单）：**\n\n1. **使用 **`**useAsyncData**`** 或 **`**useFetch**`：在你的页面组件中，用它们来获取数据。\n\n```vue\n<script setup>\n  // pages/posts.vue\n  const { data: posts } = await useFetch('/api/posts')\n</script>\n```\n\n2. **Nuxt 自动完成后续所有事情**：\n    - Nuxt 在服务端执行完 `useFetch` 后，会**自动**将 `posts` 数据序列化为 JSON 字符串。\n    - 将这个 JSON 字符串**自动嵌入**到最终 HTML 的 `<head>` 部分的一个 `<script>` 标签中。\n    - 这个标签的内容通常是 `window.__NUXT__ = { ... }`，其中就包含了所有页面的预取数据。\n\n**你不需要手动操作 DOM 去注入数据，Nuxt 的渲染引擎为你包办了一切。**\n\n---\n\n### 三、到客户端时如何获取数据呢？\n**答：客户端 Vue 应用会自动从**** **`**window.__NUXT__**`** ****中提取并复用数据，无需再次请求。**\n\n这个过程是 **State Deserialization（状态反序列化）** 或 **rehydration（补水）**。\n\n**它的自动流程如下：**\n\n1. **数据随 HTML 到达浏览器**：HTML 中的 `<script>window.__NUXT__ = {...}</script>` 会先被执行，将数据挂载到全局对象上。\n2. **客户端 Vue 应用启动**：客户端的 JavaScript 包加载完毕后，Vue 和 Nuxt 开始初始化。\n3. **自动提取数据**：当客户端的 `useFetch('/api/posts')` 代码执行时，它不会真正去发起网络请求，而是会**先自动去**** **`**window.__NUXT__**`** ****对象里查找**，看是否存在服务端已经为它准备好的数据。\n4. **直接复用数据**：如果找到了，它就直接使用这份数据，完全跳过网络请求。这样就保证了客户端和服务端的数据状态**绝对一致**，这也是 Hydration 能成功的前提。\n\n**你可以通过 **`**useNuxtData**`** 这个工具函数来验证和访问这些被缓存的数据：**\n\n```vue\n<script setup>\n// 在客户端，你可以这样访问之前服务端获取的、被缓存的数据\nconst { data: posts } = useNuxtData('posts') // 使用 useFetch 时自动生成的 key\n\n// 这不会导致第二次请求，它只是从客户端缓存中读取\nconsole.log(posts.value)\n</script>\n```\n\n## 服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\n**你这个问题问得非常非常关键，切中了SSR安全的核心！你的直觉完全正确。**\n\n**绝对不应该将任何敏感信息（如用户凭证、Token、个人身份信息PII等）内联到HTML的**** **`**<script>**`** ****标签中，并通过**** **`**window.__NUXT__**`** ****暴露给客户端。**\n\n这样做会带来严重的安全风险：\n\n1. **数据泄露**：任何能打开浏览器开发者工具的人，都可以直接看到 `window.__NUXT__` 里的全部内容。\n2. **XSS攻击加剧**：如果你的应用存在XSS（跨站脚本）漏洞，攻击者可以更容易地编写脚本窃取 `window.__NUXT__` 中的所有数据，而不必费力去窃取多个API请求的返回结果。\n3. **缓存风险**：HTML页面可能会被CDN、代理服务器或浏览器缓存。如果其中包含了用户敏感信息，就意味着这些信息也可能被缓存并泄露给其他用户。\n\n---\n\n### 那么，如何处理需要认证的敏感数据？\n正确的做法是将敏感数据与非敏感数据**分离**，并遵循“**按需索取**”和“**最小化暴露**”的原则。以下是几种安全策略：\n\n#### 策略一：敏感数据绝不预取，仅在客户端获取\n这是最常用、最安全的策略。用户登录状态、个人资料等高度敏感的数据，**不应该**在服务端的 `useFetch`/`useAsyncData` 中获取。\n\n```vue\n<script setup>\n// 1. 非敏感、SEO需要的数据：在服务端预取（安全）\nconst { data: publicPosts } = await useFetch('/api/public-posts')\n\n// 2. 敏感的用户数据：不在服务端预取，只在客户端获取\nconst user = ref(null)\nconst token = useCookie('auth-token') // Token应存放在HttpOnly Cookie中\n\n// 在客户端挂载后，再安全地获取用户数据\nonMounted(async () => {\n  if (token.value) {\n    // 此请求在客户端发起，携带Cookie中的token\n    user.value = await $fetch('/api/me', {\n      headers: {\n        // 通常Token会自动通过Cookie发送，无需手动设置，这里演示逻辑\n        Authorization: `Bearer ${token.value}`\n      }\n    })\n  }\n})\n</script>\n\n<template>\n  <!-- 公开数据直接渲染 -->\n  <div v-for=\"post in publicPosts\" :key=\"post.id\">{{ post.title }}</div>\n  \n  <!-- 用户数据，等客户端获取后再显示 -->\n  <div v-if=\"user\">Welcome, {{ user.name }}</div>\n</template>\n```\n\n#### 策略二：使用 `useState` 进行状态管理，区分服务端与客户端状态\n你可以利用 `useState` 的灵活性来管理不同环境的状态。\n\n```vue\n<script setup>\n// 创建一个响应式状态，服务端先初始化为 null\nconst secretData = useState('secret-data', () => null)\n\n// 在客户端再获取真实数据\nonMounted(async () => {\n  if (!secretData.value) { // 避免在服务端执行\n    secretData.value = await $fetch('/api/secret-data')\n  }\n})\n</script>\n```\n\n#### 策略三：API 设计分离 - 提供公开和私密端点\n从后端设计上就进行分离：\n\n+ `/api/public/data`：返回不敏感的数据，可以安全地在服务端渲染。\n+ `/api/private/user-data`：返回敏感数据，必须认证且在客户端获取。\n\n---\n\n### Nuxt 如何安全地处理认证？\n认证的最佳实践是使用 **HttpOnly Cookies** 来传输令牌（Token），而不是通过 `window.__NUXT__` 或 JS 可读的 Cookie。\n\n1. **登录流程**：\n    - 用户提交登录表单，客户端 `$fetch` 发送到 `/api/auth/login`。\n    - **后端**验证成功后，设置一个 **HttpOnly、Secure、SameSite=Strict** 的 Cookie（包含认证Token）。这个 Cookie 对 JavaScript 不可见，极大地增强了安全性。\n    - 前端只需知道登录成功，无需接触 Token 本身。\n2. **获取用户数据**：\n    - 在客户端，调用 `$fetch('/api/me')`。\n    - 浏览器会**自动**在请求中带上 HttpOnly Cookie。\n    - 后端验证 Cookie 中的 Token 有效性后，返回对应用户的数据。\n3. **服务端渲染中的认证**：\n    - 如果服务端需要根据用户状态渲染不同内容（例如“您好，用户名”），可以通过**服务器中间件**或 **API 路由**来处理。\n    - 服务端可以读取请求中的 Cookie，去后端验证用户身份，然后决定返回什么数据。但这个验证过程发生在后端，结果信息需要是**非敏感**的（例如只返回 `username`，而不是返回 `token` 或 `email`）。\n\n```vue\n<script setup>\n// 服务端可以安全地读取Cookie并获取非敏感的用户显示信息\nconst { data: userInfo } = await useFetch('/api/user-display-info')\n// 这个 `/api/user-display-info` 接口在后端会验证Cookie，\n// 但只返回 { name: 'John' } 这样的非敏感信息用于界面显示。\n</script>\n```\n\n### 总结\n1. **核心原则**：**绝不将敏感数据内联到 HTML 中**。`window.__NUXT__` 应该是“公开的”或“非敏感的”。\n2. **数据分离**：将数据分为“公开”和“私密”两类。公开数据用 `useFetch` 服务端预取；私密数据在客户端用 `$fetch` 按需获取。\n3. **认证最佳实践**：使用 **HttpOnly Cookies** 来安全地传输认证凭证，而不是将其暴露给客户端 JavaScript 或 `window` 对象。\n4. **信任后端**：敏感的权限检查和数据处理逻辑应该始终放在后端 API 中。前端（包括SSR服务端）只负责展示非敏感的结果。\n\n你的安全意识非常到位，遵循这些原则可以让你构建出既高效又安全的 Nuxt.js 应用。\n\n## 除此之外，服务端渲染还有什么不能实现的呢？canvas？\n说得非常对！**Canvas** 是一个绝佳的例子，它完美地揭示了服务端渲染（SSR）的“盲区”。\n\nSSR 的核心是**生成静态的 HTML 和 CSS 字符串**。因此，任何**动态的、依赖于浏览器 JavaScript 运行时环境**的功能，在纯 SSR 阶段都无法实现或功能不全。\n\n除了 Canvas，还有很多类似的限制。我们可以将它们分为几大类：\n\n---\n\n### 一、浏览器特有的 API 和全局对象\n这是最直接的一类。在 Node.js 服务器环境中，根本没有 `window`, `document`, `navigator` 等对象。\n\n| API/功能 | 原因 | 解决方案 |\n| --- | --- | --- |\n| `**window**`**、**`**document**` | Node.js 中不存在。 | 使用 `onMounted`钩子或 `clientOnly`组件确保只在客户端访问。 |\n| `**alert**`**、**`**confirm**`**、**`**prompt**` | 浏览器交互对话框。 | 逻辑移至客户端，或使用基于组件的替代品（如模态框）。 |\n| **Canvas (**`**<canvas>**`**) / WebGL** | 需要浏览器渲染上下文来绘图和操作像素。 | **只能在客户端初始化和使用**。SSR 只能渲染一个空画布。 |\n| **地理位置 (**`**navigator.geolocation**`**)** | 需要用户的浏览器授权和设备硬件支持。 | 仅在客户端通过 `onMounted`或用户交互触发。 |\n| **本地存储 (**`**localStorage**`**, **`**sessionStorage**`**, **`**IndexedDB**`**)** | 是浏览器的持久化存储机制。 | 在 `onMounted`中访问，或使用 `useLocalStorage`等组合式函数（内部做了客户端检查）。 |\n| **媒体设备 (**`**navigator.mediaDevices**`**)** | 需要访问麦克风、摄像头等硬件。 | 完全的用户客户端行为。 |\n\n\n---\n\n### 二、依赖浏览器渲染或布局的功能\n这类功能需要知道元素的真实尺寸和位置，而这些信息在纯字符串的 SSR 阶段是无法获得的。\n\n| 功能 | 原因 | 解决方案 |\n| --- | --- | --- |\n| **元素尺寸/位置** (如 `element.offsetWidth`<br/>, `getBoundingClientRect()`<br/>) | SSR 只有 HTML 字符串，没有真实的布局和渲染。 | 在 `onMounted`<br/> 后使用，或使用 Vue 的 `nextTick`<br/> 确保 DOM 已更新。 |\n| **基于尺寸的渲染** (如图表库 ECharts、D3.js) | 需要挂载到真实 DOM 元素并获取其宽高才能渲染。 | 在 `onMounted`<br/> 中初始化图表实例。 |\n| **动画 (CSS 动画除外)** | 许多 JS 动画库需要操作 DOM 样式。 | 使用 `onMounted`<br/> 启动动画，或使用 CSS 动画（SSR 支持）。 |\n\n\n---\n\n### 三、用户交互和状态\nSSR 输出的是一个“快照”，无法预知用户未来的行为。\n\n| 功能 | 原因 | 解决方案 |\n| --- | --- | --- |\n| **用户输入** (表单输入、焦点状态) | SSR 无法预知用户会输入什么。 | SSR 可以渲染表单结构，但交互和值绑定必须在客户端完成。 |\n| **鼠标事件、键盘事件** | 纯静态环境，无用户交互。 | 完全由客户端 JavaScript 处理。 |\n| **浏览器标签页可见性** (`document.visibilityState`) | 依赖于用户当前的浏览器状态。 | 纯客户端逻辑。 |\n\n\n---\n\n### 四、第三方库\n许多强大的第三方库在设计时就是为浏览器而生的。\n\n| 库类型 | 问题 | 解决方案 |\n| --- | --- | --- |\n| **地图库** (如 Leaflet, Google Maps) | 需要挂载到 DOM 并初始化地图渲染上下文。 | 使用 `onMounted`<br/> 初始化，或使用 Nuxt 模块（如 `nuxt-leaflet`<br/>）。 |\n| **可视化库** (如 D3, Three.js) | 严重依赖 Canvas、WebGL 或 SVG 操作。 | **只能在客户端运行**。 |\n| **分析/广告库** (如 Google Analytics) | 依赖 `window`<br/> 对象和浏览器环境来跟踪用户。 | 使用 Nuxt 插件（`client: true`<br/> 选项）或直接在 `onMounted`<br/> 中加载。 |\n\n\n---\n\n### 如何安全地处理这些限制？Nuxt 提供的解决方案\nNuxt 提供了一系列模式来优雅地解决这些问题：\n\n#### 1. `onMounted` 钩子 (最常用)\n确保代码只在客户端执行。\n\n```vue\n<script setup>\nimport { onMounted } from 'vue'\n\nconst canvas = ref(null)\n\nonMounted(() => {\n  // 现在可以安全地访问 DOM 和浏览器 API 了\n  const ctx = canvas.value.getContext('2d')\n  ctx.fillStyle = 'green'\n  ctx.fillRect(10, 10, 150, 100)\n})\n</script>\n\n<template>\n  <!-- SSR 会渲染一个空画布 -->\n  <canvas ref=\"canvas\" width=\"200\" height=\"200\"></canvas>\n</template>\n```\n\n#### 2. 条件渲染与 `<ClientOnly>` 组件\n防止不支持 SSR 的组件在服务器端渲染时出错。\n\n```vue\n<template>\n  <!-- 默认插槽只在客户端渲染 -->\n  <ClientOnly>\n    <MyChartThatUsesWindow />\n    <!-- 可以设置回退内容，在SSR阶段显示 -->\n    <template #fallback>\n      <div>Loading chart...</div>\n    </template>\n  </ClientOnly>\n</template>\n```\n\n#### 3. 使用 `process.client` 标志进行运行时检查\n```vue\n<script setup>\nif (process.client) {\n  // 此代码块只在客户端打包时包含，并在客户端执行\n  console.log('I am on the client!', window.innerWidth)\n}\n</script>\n```\n\n#### 4. 为第三方库创建客户端插件\n```javascript\n// plugins/analytics.client.js - 注意 .client 后缀\nexport default defineNuxtPlugin(() => {\n  // 这个插件只会在客户端运行\n  window.dataLayer = window.dataLayer || []\n  function gtag(){ dataLayer.push(arguments) }\n  gtag('js', new Date())\n  gtag('config', 'GA_MEASUREMENT_ID')\n})\n```\n\n### 总结\n服务端渲染 (SSR) 的本质是**静态化**，它擅长的是：\n\n+ **生成初始 HTML 内容**\n+ **提供更好的 SEO**\n+ **提升首屏加载性能**\n\n而**动态交互**和**浏览器依赖**永远是 SSR 的盲区，必须交给客户端处理。\n\n**因此，一个成熟的 Nuxt 应用是两者结合的“混合体”：**\n\n1. **服务端**：生成静态结构和首屏内容。\n2. **客户端**：“激活”页面，接管所有交互，并加载那些依赖浏览器环境的动态功能。\n\n你的工作就是清晰地界定哪些逻辑属于服务端，哪些属于客户端，并使用 Nuxt 提供的模式（`onMounted`, `<ClientOnly>`, `.client` 插件）将它们优雅地结合起来。\n\n## nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\n这是一个非常好的问题，它触及了 Nuxt 全栈架构的核心优势。\n\n**简单而直接的答案是：不会。在客户端激活后，向同源的 Nuxt 中间件或 API 路由发起请求，绝对不会产生跨域问题。**\n\n这是因为你发起请求的目标和你的页面来源是**完全同源的**。\n\n---\n\n### 为什么不会跨域？—— 同源策略详解\n让我们回顾一下“同源策略”：当协议、域名、端口都相同时，即为同源，浏览器允许请求。\n\n假设你的 Nuxt 应用部署在：  \n`https://www.my-app.com`\n\n1. **你的页面来源**：  \n浏览器中显示的地址是：`https://www.my-app.com/some-page`\n2. **你请求的目标**：  \n你在代码中发起的请求是：\n\n```javascript\n// 使用相对路径，目标自动补全为：https://www.my-app.com/api/hello\nawait $fetch('/api/hello');\n\n// 或者使用 useFetch（同样基于相对路径）\nconst { data } = useFetch('/api/auth/user');\n```\n\n3. **对比**：\n    - **协议**：都是 `https`\n    - **域名**：都是 `www.my-app.com`\n    - **端口**：都是 `443` (HTTPS 默认端口)\n\n**结论**：**完全同源**，浏览器欣然放行，没有任何跨域限制。\n\n---\n\n### Nuxt 如何处理这些请求？—— 请求生命周期\n理解这个过程能让你更清楚为什么这是安全的：\n\n如图所示，无论是开发还是生产环境，**你的 API 请求和前端页面都由同一个主机处理**。它们处于同一个“生态系统”内，通信是内部的、安全的，不存在跨域问题。\n\n---\n\n### 什么情况下会有跨域问题？\n只有当你的**页面来源**和**请求目标**不同源时，才会触发跨域。例如：\n\n| 你的页面在 | 你请求的目标 | 是否跨域 | 原因 |\n| --- | --- | --- | --- |\n| `https://www.my-app.com` | `https://www.my-app.com/api/hello` | **否** | 同源 |\n| `https://www.my-app.com` | `https://api.my-app.com` | **是** | 子域名不同 (`www` vs `api`) |\n| `http://localhost:3000` | `https://api.third-party.com` | **是** | 完全不同的域名 |\n| `https://www.my-app.com` | `http://www.my-app.com/api/hello` | **是** | 协议不同 (`https`vs `http`) |\n\n\n**对于最后一种情况（生产环境前后端分离），解决方案是：**\n\n1. **后端配置 CORS**：在你的 `api.my-app.com` 服务器上设置 `Access-Control-Allow-Origin: https://www.my-app.com` 响应头。\n2. **使用反向代理**：配置你的生产服务器（如 Nginx），将对 `/api/` 的请求代理到 `api.my-app.com`，让浏览器始终觉得是在请求同源地址。这是更推荐的做法。\n\n### 总结\n+ **在 Nuxt 应用中，请求自身的 API 路由 (**`**/api/xxx**`**) 或服务器中间件是绝对同源的，没有跨域问题。**\n+ 这是 Nuxt 全栈框架的巨大优势之一，它简化了开发，让你无需在开发阶段为 CORS 烦恼。\n+ 跨域问题只会在你请求**外部第三方 API** 且对方未正确配置 CORS 时出现。\n+ 如果你的生产环境是前后端完全分离的（不同域），那么需要在生产环境的**后端配置 CORS** 或通过**反向代理**来解决。\n\n所以，请放心地在你的 Nuxt 应用内部调用 API，这是最安全、最正确的做法。\n\n## 那如果对后端接口(另一台服务器上)的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\n**你的这个思路非常棒，完全正确！** 这正是构建现代 Web 应用的一种核心架构模式，被称为 **“BFF（Backend For Frontend）模式”** 或 **“API 网关模式”**。\n\n你的推理链条是：\n\n1. **所有客户端请求**都只发往**同源**的 Nuxt 服务器（`/api/proxy`）。\n2. Nuxt 服务器上的**中间件**接收到请求后，**代为转发**给真正的后端服务器。\n3. 由于服务器之间通信（Nuxt Server -> Your Backend Server）**没有跨域限制**，所以问题迎刃而解。\n\n这个方案**在理论上是完全可行且非常优雅的**，它确实可以让你**完全摆脱 CORS 的困扰**。\n\n---\n\n### 这种架构的详细工作流程\n如图所示，浏览器始终只与 `my-nuxt-app.com` 通信，完美符合同源策略。\n\n---\n\n### 优缺点分析：这是否是“万能药”？\n虽然这个方案能根治跨域，但它也引入了一些新的考虑因素：\n\n#### 优点 ✅\n1. **彻底解决 CORS**：前端开发者完全无需再关心跨域配置，开发体验极其流畅。\n2. **隐藏后端架构**：真正的后端地址、端口、API 结构对客户端完全隐藏，更安全。\n3. **协议转换**：可以轻松地在 Nuxt 中处理 HTTPS -> HTTP 的请求（服务器间通信允许）。\n4. **数据处理与聚合**：你可以在 Nuxt 中间件中对多个后端服务的返回值进行聚合、过滤、转换，为前端提供最合适的数据结构，减少前端请求次数。\n\n#### 缺点与需要考虑的因素 ⚠️\n1. **额外的网络跳转**：所有请求都多经过一环（浏览器 -> Nuxt -> 真实后端），**会增加微小的延迟**。对于延迟敏感的应用需要优化。\n2. **单点压力与故障点**：Nuxt 服务器现在成为了所有 API 流量的入口。如果它宕机，所有请求都会失败。需要保证其高可用性。\n3. **复杂性转移**：虽然前端变简单了，但 Nuxt 层（BFF 层）的逻辑变复杂了。你需要在这里编写转发、错误处理、认证等逻辑。\n4. **认证问题**：如果后端 API 需要认证，你需要决定如何传递认证信息。\n    - **方案A（推荐）**：浏览器将认证 Token 发给 Nuxt，Nuxt 再原样转发给后端。\n    - **方案B**：Nuxt 服务器自己持有访问后端的凭证，替用户与后端通信。但这需要非常小心地管理权限。\n\n---\n\n### 如何实现？\n在 Nuxt 中，你通常使用 **API 路由** 或 **服务器中间件** 来实现，而不是普通的中间件，因为它们专门处理服务器逻辑。\n\n**示例：在 **`**server/api/proxy/[...].ts**`** 中创建一个捕获所有路由的 API**\n\n```typescript\n// server/api/proxy/[...].ts\nexport default defineEventHandler(async (event) => {\n  // 1. 获取请求路径和方法\n  const path = getRouterParam(event, 'path') // 获取 ... 通配符参数\n  const method = getMethod(event)\n  const body = method === 'GET' ? undefined : await readBody(event)\n\n  // 2. 定义你的真实后端基础 URL（应从环境变量读取！）\n  const baseURL = 'https://your-real-backend.com/api'\n  const targetURL = `${baseURL}/${path}`\n\n  // 3. 可选：处理认证（例如，将前端传来的 token 转发给后端）\n  const headers = {}\n  const authHeader = getHeader(event, 'authorization')\n  if (authHeader) {\n    headers['Authorization'] = authHeader\n  }\n\n  // 4. 代理请求到真实后端\n  try {\n    const response = await $fetch.raw(targetURL, {\n      method,\n      body,\n      headers,\n      // 重要：转发查询参数 (?foo=bar)\n      query: getQuery(event),\n    })\n\n    // 5. 可选：根据需要设置响应头\n    setHeaders(event, response.headers)\n\n    // 6. 返回后端响应的数据\n    return response._data\n  } catch (error) {\n    // 7. 错误处理，将后端错误返回给前端\n    throw createError({\n      statusCode: error.statusCode || 500,\n      statusMessage: error.statusMessage || 'Internal Server Error',\n    })\n  }\n})\n```\n\n这样，前端所有发往 `/api/proxy/items`、`/api/proxy/user/profile` 的请求，都会被这个 handler 捕获，并转发到 `https://your-real-backend.com/api/items` 和 `https://your-real-backend.com/api/user/profile`。\n\n### 结论\n**是的，你的想法是完全正确且高效的。通过让 Nuxt 服务器作为所有后端请求的代理，你可以一劳永逸地解决跨域问题，无需在开发或生产环境配置任何 CORS 或代理规则。**\n\n这不仅是解决跨域的手段，更是一种先进的**架构设计选择**（BFF）。它特别适用于：\n\n+ 中大型前后端分离项目。\n+ 需要集成多个后端微服务的复杂前端。\n+ 希望简化前端开发流程，将复杂性集中到 BFF 层的团队。\n\n你只需要评估其带来的**额外延迟**和**单点压力**是否在你的应用可接受范围内即可。对于绝大多数应用来说，这个方案的利远大于弊。\n\n","slug":"Nuxt.js","published":1,"updated":"2025-09-14T11:24:47.457Z","_id":"cmfjk7nik0000d65w4wct3bto","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"Nuxt-js的ssr服务端渲染原理\"><a href=\"#Nuxt-js的ssr服务端渲染原理\" class=\"headerlink\" title=\"Nuxt.js的ssr服务端渲染原理\"></a>Nuxt.js的ssr服务端渲染原理</h2><p>Nuxt.js 的 SSR（服务端渲染）原理是一个非常核心且有趣的话题。它并不是简单的“在服务器上跑 Vue”，而是一套完整的、精心设计的架构。</p>\n<p>简单来说，它的核心原理是：<strong>“首屏在服务器提前渲染成 HTML，之后在客户端‘激活’为 SPA”。</strong></p>\n<p>下面我们分步拆解这个过程的原理、优势和关键实现。</p>\n<hr>\n<h3 id=\"一、核心目标：解决什么問題？\"><a href=\"#一、核心目标：解决什么問題？\" class=\"headerlink\" title=\"一、核心目标：解决什么問題？\"></a>一、核心目标：解决什么問題？</h3><ol>\n<li><strong>SEO（搜索引擎优化）</strong>：传统 SPA（单页应用）返回的是一个空的 HTML 壳，内容由 JavaScript 动态填充。搜索引擎爬虫可能无法等待和执行 JS，导致无法收录内容。SSR 直接返回渲染好的完整 HTML，利于爬虫抓取。</li>\n<li><strong>更快的内容到达时间</strong>：用户浏览器无需等待所有 JavaScript 下载和执行完毕才能看到内容。服务器直接返回了渲染好的 HTML，首屏内容可以立即展示，感知性能极大提升。</li>\n</ol>\n<h3 id=\"二、Nuxt-js-SSR-的核心工作流程\"><a href=\"#二、Nuxt-js-SSR-的核心工作流程\" class=\"headerlink\" title=\"二、Nuxt.js SSR 的核心工作流程\"></a>二、Nuxt.js SSR 的核心工作流程</h3><p>Nuxt.js 的 SSR 过程可以清晰地分为两个阶段：<strong>服务端渲染</strong>和<strong>客户端激活</strong>。下图展示了从用户请求到页面可交互的完整生命周期：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/jpeg/55999631/1757522658867-d1d335f5-5c7f-443b-bdc8-3a1621a987cb.jpeg\"\n                      alt=\"画板\"\n                ></p>\n<h4 id=\"第一阶段：服务端渲染（Server-Side）\"><a href=\"#第一阶段：服务端渲染（Server-Side）\" class=\"headerlink\" title=\"第一阶段：服务端渲染（Server-Side）\"></a>第一阶段：服务端渲染（Server-Side）</h4><p>这个过程发生在 <strong>Nuxt 服务器</strong>（一个 Node.js 服务器）上。</p>\n<ol>\n<li><strong>接收请求</strong>：用户浏览器请求一个 URL，请求到达 Nuxt 服务器。</li>\n<li><strong>创建应用实例</strong>：Nuxt 服务器为这次请求<strong>创建一个全新的 Vue 应用实例、Router 和 Store</strong>。这是关键，确保了每个请求的隔离性。</li>\n<li><strong>路由匹配</strong>：根据请求的 URL，Nuxt Router 确定要渲染哪个页面组件（如 <code>pages/about.vue</code>）。</li>\n<li><strong>数据预取</strong>：Nuxt 会调用页面组件中定义的<strong>异步数据获取方法</strong>（如 <code>asyncData</code>、<code>useAsyncData</code>、<code>useFetch</code>）。<strong>这些方法会在服务端执行</strong>。<ul>\n<li>服务器会等待这些异步操作完成，再去渲染组件。这确保了渲染出的 HTML 是包含数据的。</li>\n</ul>\n</li>\n<li><strong>渲染 HTML</strong>：<ul>\n<li>将获取到的数据<strong>注入到 Vuex Store 或组件状态</strong>中。</li>\n<li>调用 Vue 的 <code>vue-server-renderer</code>（Vue 2）或 <code>@vue/server-renderer</code>（Vue 3）的 <code>renderToString()</code> 函数。</li>\n<li>这个函数会运行 Vue 组件，但它<strong>不是在浏览器中创建真实 DOM，而是在内存中生成一个完整的 HTML 字符串</strong>。</li>\n</ul>\n</li>\n<li><strong>构建最终文档</strong>：Nuxt 将这个 HTML 字符串插入到HTML模板（<code>app.html</code>）中。同时，<strong>将预取的数据序列化后内联到 HTML 中</strong>（通常是在一个 <code>&lt;script&gt;</code> 标签里，如 <code>window.__NUXT__ = &#123;...&#125;</code>），这个过程称为 <strong>状态脱水</strong>。</li>\n<li><strong>响应</strong>：将这个完整的、包含数据和内容的 HTML 文档发送给客户端。</li>\n</ol>\n<h4 id=\"第二阶段：客户端激活（Client-Side-Hydration）\"><a href=\"#第二阶段：客户端激活（Client-Side-Hydration）\" class=\"headerlink\" title=\"第二阶段：客户端激活（Client-Side Hydration）\"></a>第二阶段：客户端激活（Client-Side Hydration）</h4><p>这个过程发生在<strong>用户浏览器</strong>上。</p>\n<ol>\n<li><strong>静态内容展示</strong>：浏览器收到服务器返回的 HTML 后，<strong>无需等待任何 JavaScript，就能立即解析和显示页面内容</strong>。这是首屏速度快的根本原因。</li>\n<li><strong>加载资源</strong>：浏览器开始加载页面中引用的 JavaScript 和 CSS 资源（Nuxt 打包好的客户端 bundle）。</li>\n<li><strong>Vue 接管（Hydration -“混合”）</strong>：这是最精妙的一步。<ul>\n<li>客户端的 Vue 应用也会被创建和初始化。</li>\n<li>Vue 不会像传统 SPA 那样清空 DOM 再重新渲染。相反，它会<strong>将虚拟 DOM 与服务器渲染好的现有静态 HTML 结构进行“混合”</strong>。</li>\n<li>它会将事件监听器、Vue 的响应式系统等“激活”到这些静态元素上，使其变成一个完全交互式的 Vue 应用。</li>\n</ul>\n</li>\n<li><strong>变为 SPA</strong>：激活完成后，应用就切换到了正常的 SPA 模式。后续的页面导航不会再向服务器请求完整的 HTML，而是由客户端 Router 管理，只获取必要的数据，实现无刷新跳转。</li>\n</ol>\n<hr>\n<h3 id=\"三、Nuxt-js-实现-SSR-的关键技术点\"><a href=\"#三、Nuxt-js-实现-SSR-的关键技术点\" class=\"headerlink\" title=\"三、Nuxt.js 实现 SSR 的关键技术点\"></a>三、Nuxt.js 实现 SSR 的关键技术点</h3><ol>\n<li><strong>双入口构建（Dual Entry Points）</strong>：<ul>\n<li>Nuxt 使用 Webpack&#x2F;Vite 分别打包<strong>两个版本</strong>的代码：<ul>\n<li><strong>服务端 Bundle</strong>：用于 <code>renderToString</code>，它知道如何在 Node.js 环境中渲染组件。</li>\n<li><strong>客户端 Bundle</strong>：用于在浏览器中“激活”静态页面并处理后续交互。</li>\n</ul>\n</li>\n<li>这是通过 <code>webpack</code> 的 <code>target: &#39;node&#39;</code> 和 <code>target: &#39;web&#39;</code> 分别配置实现的。</li>\n</ul>\n</li>\n<li><strong>数据预取与状态同步</strong>：<ul>\n<li>服务端获取的数据必须<strong>安全地传递到客户端</strong>，否则客户端 Vue 在初始化时没有数据，会导致虚拟 DOM 与服务器渲染的 HTML 不匹配，激活失败。</li>\n<li>Nuxt 通过 <code>window.__NUXT__</code> 对象将数据从服务器“脱水”到客户端“补水”，保证两端状态一致。</li>\n</ul>\n</li>\n<li><strong>生命周期</strong>：<ul>\n<li>在 SSR 过程中，<strong>只有</strong>** <strong><code>**beforeCreate**</code></strong> <strong><strong>和</strong></strong> <strong><code>**created**</code></strong> **<strong>这两个生命周期钩子会在服务端执行</strong>。</li>\n<li><code>mounted</code>、<code>beforeMount</code> 等只在客户端执行。因此，<strong>在</strong>** <strong><code>**created**</code></strong> <strong><strong>中操作</strong></strong> <strong><code>**window**</code></strong> **<strong>或 DOM 会报错</strong>。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"四、Universal-Mode-同构渲染\"><a href=\"#四、Universal-Mode-同构渲染\" class=\"headerlink\" title=\"四、Universal Mode (同构渲染)\"></a>四、Universal Mode (同构渲染)</h3><p>Nuxt.js 的 SSR 通常被称为 <strong>“Universal”应用</strong>或**“同构”应用**。</p>\n<ul>\n<li><strong>同构代码</strong>：同一份 Vue 组件代码（<code>.vue</code> 文件）既可以在<strong>服务器</strong>上运行（用于首屏生成 HTML），也可以在<strong>客户端</strong>运行（用于激活和后续交互）。</li>\n<li><strong>优势</strong>：开发者只需写一套代码，Nuxt 负责处理双端的构建和渲染协调，开发体验非常流畅。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Nuxt.js 的 SSR 原理可以概括为：</p>\n<ol>\n<li><strong>服务端</strong>：为每个请求即时创建 Vue 应用，预先获取数据，渲染出包含内容的 HTML 字符串，并将数据状态一同返回。</li>\n<li><strong>客户端</strong>：快速展示静态内容，然后加载 JS，由 Vue 将静态页面“激活”为可交互的 SPA，最后接管所有后续导航。</li>\n</ol>\n<p>它完美地结合了<strong>传统服务端渲染首屏快、SEO 好</strong>的优势和<strong>单页应用用户体验流畅、交互丰富</strong>的优势，是现代 Web 应用开发的绝佳选择。</p>\n<h2 id=\"nuxt中调后端接口怎么做，要注意什么？\"><a href=\"#nuxt中调后端接口怎么做，要注意什么？\" class=\"headerlink\" title=\"nuxt中调后端接口怎么做，要注意什么？\"></a>nuxt中调后端接口怎么做，要注意什么？</h2><p>在 Nuxt.js 中调用后端接口是其核心功能之一，但根据你使用的 API 风格（Composition API 或 Options API）和渲染模式（SSR 或 SPA），做法和注意事项有所不同。</p>\n<p>下面将为你提供全面的指南，包括方法、最佳实践和常见陷阱。</p>\n<hr>\n<h3 id=\"一、如何调用后端接口？\"><a href=\"#一、如何调用后端接口？\" class=\"headerlink\" title=\"一、如何调用后端接口？\"></a>一、如何调用后端接口？</h3><p>Nuxt 3 推荐使用 Composition API，并提供了强大的组合式函数。</p>\n<h4 id=\"1-使用-useFetch-useAsyncData-Composition-API-首选\"><a href=\"#1-使用-useFetch-useAsyncData-Composition-API-首选\" class=\"headerlink\" title=\"1. 使用 useFetch &#x2F; useAsyncData (Composition API - 首选)\"></a>1. 使用 <code>useFetch</code> &#x2F; <code>useAsyncData</code> (Composition API - 首选)</h4><p>这是 Nuxt 3 中最现代、最推荐的方式，它完美处理了服务端和客户端的数据获取。</p>\n<p><strong>基本用法 (</strong><code>**useFetch**</code><strong>)：</strong><br><code>useFetch</code> 是专门为获取数据而设计的语法糖。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 直接在模板中使用，无需 .value</span><br><span class=\"line\">const &#123; data: posts, pending, error, refresh &#125; = useFetch(&#x27;/api/posts&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者指定完整 URL（注意配置代理或 CORS）</span><br><span class=\"line\">const &#123; data: users &#125; = useFetch(&#x27;https://api.example.com/users&#x27;, &#123;</span><br><span class=\"line\">  // 可选项：在客户端才获取数据（代替 onMounted + ref）</span><br><span class=\"line\">  // lazy: true,</span><br><span class=\"line\">  // server: false</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;pending&quot;&gt;Loading...&lt;/div&gt;</span><br><span class=\"line\">  &lt;div v-else-if=&quot;error&quot;&gt;Error: &#123;&#123; error.message &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">  &lt;ul v-else&gt;</span><br><span class=\"line\">    &lt;li v-for=&quot;post in posts&quot; :key=&quot;post.id&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/li&gt;</span><br><span class=\"line\">  &lt;/ul&gt;</span><br><span class=\"line\">  &lt;button @click=&quot;refresh&quot;&gt;Refresh&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>高级用法 (</strong><code>**useAsyncData**</code>** + <strong><code>**$fetch**</code></strong>)：**<br>当你需要更复杂的逻辑时（如多个请求、数据处理），使用 <code>useAsyncData</code>。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">const &#123; data: combinedData, refresh &#125; = useAsyncData(&#x27;unique-key&#x27;, async () =&gt; &#123;</span><br><span class=\"line\">  // 这里可以写任何复杂的异步逻辑</span><br><span class=\"line\">  const [posts, users] = await Promise.all([</span><br><span class=\"line\">    $fetch(&#x27;/api/posts&#x27;),</span><br><span class=\"line\">    $fetch(&#x27;/api/users&#x27;)</span><br><span class=\"line\">  ])</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 对数据进行转换</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    posts: posts.map(post =&gt; (&#123; ...post, title: post.title.toUpperCase() &#125;)),</span><br><span class=\"line\">    users</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"2-使用-fetch-直接调用\"><a href=\"#2-使用-fetch-直接调用\" class=\"headerlink\" title=\"2. 使用 $fetch 直接调用\"></a>2. 使用 <code>$fetch</code> 直接调用</h4><p>Nuxt 3 内置了基于 <a class=\"link\"   href=\"https://github.com/unjs/ofetch\" >ofetch<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 的 <code>$fetch</code> 工具，可以在任何地方使用（如事件处理函数中）。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">const handleSubmit = async () =&gt; &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    const response = await $fetch(&#x27;/api/submit&#x27;, &#123;</span><br><span class=\"line\">      method: &#x27;POST&#x27;,</span><br><span class=\"line\">      body: &#123; name: &#x27;John Doe&#x27; &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    console.log(&#x27;Success:&#x27;, response)</span><br><span class=\"line\">  &#125; catch (error) &#123;</span><br><span class=\"line\">    console.error(&#x27;Error:&#x27;, error)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"3-使用-useLazyFetch-useLazyAsyncData\"><a href=\"#3-使用-useLazyFetch-useLazyAsyncData\" class=\"headerlink\" title=\"3. 使用 useLazyFetch &#x2F; useLazyAsyncData\"></a>3. 使用 <code>useLazyFetch</code> &#x2F; <code>useLazyAsyncData</code></h4><p>它们是 <code>useFetch</code> 和 <code>useAsyncData</code> 的变体，<code>lazy: true</code> 是默认行为。<strong>不会阻塞导航</strong>，适用于非关键数据。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 不会阻塞路由导航，你需要自己处理 data 为 null 的情况</span><br><span class=\"line\">const &#123; data: nonCriticalData &#125; = useLazyFetch(&#x27;/api/non-critical-data&#x27;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;data&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 渲染数据 --&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"二、最重要的注意事项\"><a href=\"#二、最重要的注意事项\" class=\"headerlink\" title=\"二、最重要的注意事项\"></a>二、最重要的注意事项</h3><h4 id=\"1-服务端渲染-SSR-vs-客户端渲染-CSR-行为\"><a href=\"#1-服务端渲染-SSR-vs-客户端渲染-CSR-行为\" class=\"headerlink\" title=\"1. 服务端渲染 (SSR) vs 客户端渲染 (CSR) 行为\"></a>1. 服务端渲染 (SSR) vs 客户端渲染 (CSR) 行为</h4><p>这是 <strong>最核心、最容易出错</strong> 的点！</p>\n<ul>\n<li><strong>默认行为</strong>：<code>useFetch</code> 和 <code>useAsyncData</code> <strong>会在服务端执行</strong>。这意味着：<ul>\n<li><strong>好处</strong>：返回的 HTML 直接包含数据，利于 SEO 和首屏加载。</li>\n<li><strong>陷阱</strong>：<strong>不能在它们内部或</strong>** <strong><code>**created**</code></strong> **<strong>生命周期中使用浏览器API</strong>（如 <code>window</code>, <code>document</code>, <code>localStorage</code>）。</li>\n</ul>\n</li>\n<li><strong>如何控制</strong>：</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 选项 1: 强制只在客户端执行</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/data&#x27;</span>, &#123; <span class=\"attr\">server</span>: <span class=\"literal\">false</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 选项 2: 使用 useLazyFetch (默认不会阻塞导航，且在客户端执行)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useLazyFetch</span>(<span class=\"string\">&#x27;/api/data&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 选项 3: 在 onMounted 钩子中用 $fetch</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = <span class=\"title function_\">ref</span>(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"title function_\">onMounted</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  data.<span class=\"property\">value</span> = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/data&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"2-处理-CORS-跨域资源共享\"><a href=\"#2-处理-CORS-跨域资源共享\" class=\"headerlink\" title=\"2. 处理 CORS (跨域资源共享)\"></a>2. 处理 CORS (跨域资源共享)</h4><p>如果你调用的接口不在同一个域下，会遇到 CORS 问题。</p>\n<ul>\n<li><strong>开发环境</strong>：在 <code>nuxt.config.ts</code> 中配置代理是最佳实践。</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// nuxt.config.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineNuxtConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 其他配置</span></span><br><span class=\"line\">  <span class=\"attr\">nitro</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">routeRules</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;/api/**&#x27;</span>: &#123; <span class=\"attr\">proxy</span>: <span class=\"string\">&#x27;https://api.example.com/**&#x27;</span> &#125;, <span class=\"comment\">// 代理 API 请求</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 或者使用旧的 devServer 配置 (v3.0+ 推荐使用 nitro)</span></span><br><span class=\"line\">  <span class=\"comment\">// devServer: &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   proxy: &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//     &#x27;/api&#x27;: &#x27;https://api.example.com&#x27;</span></span><br><span class=\"line\">  <span class=\"comment\">//   &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>然后你在代码中请求 <code>/api/users</code>，开发服务器会将其代理到 <code>https://api.example.com/api/users</code>，避免 CORS。</li>\n<li><strong>生产环境</strong>：<ul>\n<li><strong>最佳方案</strong>：配置你的<strong>反向代理</strong>（如 Nginx）来处理跨域请求。</li>\n<li><strong>备选方案</strong>：确保后端 API 正确配置了 CORS 头 (<code>Access-Control-Allow-Origin</code> 等)。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-认证和令牌-Authentication\"><a href=\"#3-认证和令牌-Authentication\" class=\"headerlink\" title=\"3. 认证和令牌 (Authentication)\"></a>3. 认证和令牌 (Authentication)</h4><p>如何安全地传递身份验证信息（如 JWT Token）。</p>\n<ul>\n<li><strong>使用请求拦截器</strong>：利用 <code>ofetch</code> 的自动全局拦截器。</li>\n<li>如何安全地传递身份验证信息（如 JWT Token）。</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// plugins/api.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineNuxtPlugin</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; token &#125; = <span class=\"title function_\">useAuth</span>() <span class=\"comment\">// 假设你有一个获取 token 的 composable</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 全局拦截 $fetch 请求</span></span><br><span class=\"line\">  globalThis.<span class=\"property\">$fetch</span> = $fetch.<span class=\"title function_\">create</span>(&#123;</span><br><span class=\"line\">    <span class=\"title function_\">onRequest</span>(<span class=\"params\">&#123; request, options &#125;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 添加认证头</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (token.<span class=\"property\">value</span>) &#123;</span><br><span class=\"line\">        options.<span class=\"property\">headers</span> = &#123;</span><br><span class=\"line\">          ...options.<span class=\"property\">headers</span>,</span><br><span class=\"line\">          <span class=\"title class_\">Authorization</span>: <span class=\"string\">`Bearer <span class=\"subst\">$&#123;token.value&#125;</span>`</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">onRequestError</span>(<span class=\"params\">&#123; error &#125;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;Request error:&#x27;</span>, error)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">onResponseError</span>(<span class=\"params\">&#123; response &#125;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 统一处理 401 未授权错误</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (response.<span class=\"property\">status</span> === <span class=\"number\">401</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 跳转到登录页</span></span><br><span class=\"line\">        <span class=\"title function_\">navigateTo</span>(<span class=\"string\">&#x27;/login&#x27;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"4-错误处理\"><a href=\"#4-错误处理\" class=\"headerlink\" title=\"4. 错误处理\"></a>4. 错误处理</h4><p>永远不要假设请求一定会成功。</p>\n<ul>\n<li><strong>使用 try-catch</strong>：</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/endpoint&#x27;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Nuxt 3 的 $fetch 会自动抛出错误</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;API call failed:&#x27;</span>, error)</span><br><span class=\"line\">  <span class=\"comment\">// 在这里显示用户友好的错误信息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><strong>使用 <strong><code>**useFetch**</code></strong> 的状态</strong>：</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">const &#123; data, error &#125; = useFetch(&#x27;/api/endpoint&#x27;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;error&quot;&gt;</span><br><span class=\"line\">    Failed to load data: &#123;&#123; error.message &#125;&#125;</span><br><span class=\"line\">    &lt;button @click=&quot;refresh&quot;&gt;Try Again&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"5-性能优化：避免重复请求\"><a href=\"#5-性能优化：避免重复请求\" class=\"headerlink\" title=\"5. 性能优化：避免重复请求\"></a>5. 性能优化：避免重复请求</h4><ul>\n<li><strong>Key 的妙用</strong>：<code>useAsyncData</code> 和 <code>useFetch</code> 会<strong>自动去重</strong>具有相同 key 的请求。确保为唯一的数据集提供唯一的 key。</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果两个组件使用相同的 key，只会发出一个请求</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useAsyncData</span>(<span class=\"string\">&#x27;user-profile&#x27;</span>, <span class=\"function\">() =&gt;</span> $fetch(<span class=\"string\">&#x27;/api/profile&#x27;</span>))</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><strong>缓存</strong>：<code>$fetch</code> 默认不会缓存 HTTP 缓存。如果你需要利用 HTTP 缓存，可以在 headers 中设置，或者使用更高级的缓存策略。</li>\n</ul>\n<hr>\n<h3 id=\"三、最佳实践总结\"><a href=\"#三、最佳实践总结\" class=\"headerlink\" title=\"三、最佳实践总结\"></a>三、最佳实践总结</h3><ol>\n<li><strong>首选</strong>** <strong><code>**useFetch**</code></strong>&#x2F;**<code>**useAsyncData**</code>：用于在组件中获取数据，它们能智能处理 SSR 和 hydration。</li>\n<li><strong>明确数据获取时机</strong>：想清楚你需要的数<strong>据是应该在服务端获取（SEO 关键）还是客户端获取（用户相关）</strong>，并用 <code>server: false</code> 或 <code>useLazyFetch</code> 控制。</li>\n<li><strong>开发环境用代理解决 CORS</strong>：在 <code>nuxt.config.ts</code> 中配置代理，避免跨域问题。</li>\n<li><strong>统一处理认证和错误</strong>：通过插件创建配置好的 <code>$fetch</code> 实例，全局处理 token 和错误。</li>\n<li><strong>善待你的 API</strong>：合理使用 key 去重，避免重复请求；考虑分页、限流和缓存。</li>\n</ol>\n<p>遵循这些指南，你就能在 Nuxt 应用中高效、可靠地与后端 API 进行交互。</p>\n<h2 id=\"开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\"><a href=\"#开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\" class=\"headerlink\" title=\"开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\"></a>开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？</h2><p><strong>你这个问题问得非常好，直击要害！你的理解完全正确。</strong></p>\n<p>是的，你的推理是精准的：</p>\n<ul>\n<li><strong>服务端（Node.js）发起的请求</strong>：没有跨域概念。跨域是<strong>浏览器</strong>强加的安全策略。Node.js 发请求就像你用 <code>curl</code> 或 Postman 一样，可以去任何地方，不存在 CORS 问题。</li>\n<li><strong>客户端（浏览器）发起的请求</strong>：受跨域限制。浏览器会拦截违反同源策略的请求。</li>\n</ul>\n<p><strong>因此，“开发环境配置代理” 主要就是为了解决 —— 在客户端发起请求时遇到的跨域问题。</strong></p>\n<hr>\n<h3 id=\"为什么开发环境会有客户端请求？\"><a href=\"#为什么开发环境会有客户端请求？\" class=\"headerlink\" title=\"为什么开发环境会有客户端请求？\"></a>为什么开发环境会有客户端请求？</h3><p>在 Nuxt 3 的 SSR 模式下，一个页面渲染通常涉及<strong>两次</strong>数据获取：</p>\n<ol>\n<li><strong>第一次（服务端请求 - 无 CORS）</strong>：<ul>\n<li>当用户直接访问页面 URL 时，请求会先到达你的 Nuxt 服务器。</li>\n<li>Nuxt 服务器执行 <code>useFetch</code> 或 <code>useAsyncData</code>，<strong>在服务器环境</strong>（Node.js）中向后端 API 发起请求。</li>\n<li>此时是 <strong>服务器对服务器</strong> 的通信，没有浏览器参与，所以<strong>没有 CORS 问题</strong>。</li>\n<li>服务器拿到数据后，渲染出包含内容的 HTML 并返回给浏览器。</li>\n</ul>\n</li>\n<li><strong>第二次（客户端请求 - 有 CORS 风险）</strong>：<ul>\n<li>浏览器收到 HTML 并展示后，会加载 Nuxt 的客户端 JS Bundle。</li>\n<li>Vue 开始 <strong>“激活” (Hydration)</strong> 过程。</li>\n<li>在这个过程中，<code>useFetch</code> 和 <code>useAsyncData</code> 的代码会在<strong>客户端浏览器环境</strong>中再次运行，以确保数据状态一致。</li>\n<li>如果它们的 URL 是<strong>绝对路径</strong>（如 <code>https://api.example.com/data</code>），那么这次请求就是由<strong>浏览器</strong>直接发起的，就会触发 CORS 检查。</li>\n<li>如果后端 API 没有正确配置 CORS 头，浏览器就会拦截这次请求，导致错误。</li>\n</ul>\n</li>\n</ol>\n<p>此外，还有几种常见的<strong>纯客户端请求</strong>场景：</p>\n<ul>\n<li>用户交互（如点击按钮）触发的 <code>$fetch</code> 请求。</li>\n<li>在 <code>onMounted</code> 钩子中发起的请求。</li>\n<li>使用 <code>useLazyFetch</code>（它默认在客户端执行）。</li>\n</ul>\n<h3 id=\"总结与最佳实践\"><a href=\"#总结与最佳实践\" class=\"headerlink\" title=\"总结与最佳实践\"></a>总结与最佳实践</h3><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>请求发起方</th>\n<th>是否有 CORS 问题？</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>SSR 首屏渲染</strong></td>\n<td>Nuxt Server (Node.js)</td>\n<td><strong>否</strong></td>\n<td>无需额外配置。但需确保服务器能访问到 API（网络连通性）。</td>\n</tr>\n<tr>\n<td><strong>CSR Hydration&#x2F;交互</strong></td>\n<td>浏览器</td>\n<td><strong>是</strong></td>\n<td><strong>配置开发服务器代理</strong>（如下方代码）。这是最推荐的方法。</td>\n</tr>\n<tr>\n<td><strong>生产环境</strong></td>\n<td>浏览器</td>\n<td><strong>是</strong></td>\n<td><strong>配置生产级反向代理</strong>（如 Nginx），或确保后端 API 正确设置 CORS 头。</td>\n</tr>\n</tbody></table>\n<h2 id=\"nuxt中的-fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\"><a href=\"#nuxt中的-fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\" class=\"headerlink\" title=\"nuxt中的$fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\"></a>nuxt中的$fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？</h2><p>非常好的问题！这是理解 Nuxt 3 数据获取的关键。它们的执行环境行为是核心区别。</p>\n<p>简单直接的答案是：<strong>不，</strong><code>**$fetch**</code>** <strong><strong>可以在服务端和客户端调用。而</strong></strong> <strong><code>**useFetch**</code></strong> <strong><strong>和</strong></strong> <strong><code>**useAsyncData**</code></strong> **<strong>的行为是智能的，默认在服务端执行。</strong></p>\n<p>下面我们来详细拆解这三者的区别。</p>\n<hr>\n<h3 id=\"一、-fetch：双环境通用的请求工具\"><a href=\"#一、-fetch：双环境通用的请求工具\" class=\"headerlink\" title=\"一、$fetch：双环境通用的请求工具\"></a>一、<code>$fetch</code>：双环境通用的请求工具</h3><p><code>$fetch</code> 是 Nuxt 3 基于 <a class=\"link\"   href=\"https://github.com/unjs/ofetch\" >ofetch<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 提供的全局工具函数。它本身<strong>没有环境限制</strong>，你在哪里调用它，它就在哪个环境执行。</p>\n<ul>\n<li><strong>在服务端（Node.js）调用</strong>：它就像一个普通的 Node.js HTTP 客户端（比如 <code>axios</code>），直接向后端发起请求，<strong>没有跨域概念</strong>。</li>\n<li><strong>在客户端（浏览器）调用</strong>：它的行为类似于原生的 <code>fetch()</code>，但功能更强大（自动处理 JSON、更好的错误处理等），并且<strong>受浏览器跨域策略限制</strong>。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 在组件 setup 中直接调用 - 根据渲染环境决定</span></span><br><span class=\"line\"><span class=\"comment\">// 如果在服务端渲染，它在服务端执行；如果在客户端激活或导航，它在客户端执行。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/items&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在明确的服务端环境调用 - 只在服务端执行</span></span><br><span class=\"line\"><span class=\"comment\">// 例如：在 API 路由、服务器中间件或 plugin 中</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineEventHandler</span>(<span class=\"title function_\">async</span> (event) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;https://external-api.com/data&#x27;</span>); <span class=\"comment\">// 在服务器上运行</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; data &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 在明确的客户端环境调用 - 只在客户端执行</span></span><br><span class=\"line\"><span class=\"comment\">// 例如：在事件处理函数或 onMounted 中</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handleClick</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/items&#x27;</span>); <span class=\"comment\">// 在浏览器中运行，受 CORS 限制</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<p><code>**$fetch**</code>** <strong><strong>的陷阱</strong>：如果你在组件顶层直接使用 <code>$fetch</code>（没有包裹在 <code>useAsyncData</code> 或 <code>useFetch</code> 中），并且该组件在服务端渲染，那么请求会在服务端执行。但当客户端激活（Hydration）时，<strong>同样的</strong></strong> <strong><code>**$fetch**</code></strong> **<strong>代码又会在客户端再执行一次</strong>，造成重复请求。</p>\n<hr>\n<h3 id=\"二、useAsyncData-useFetch：智能的双环境数据获取器\"><a href=\"#二、useAsyncData-useFetch：智能的双环境数据获取器\" class=\"headerlink\" title=\"二、useAsyncData &amp; useFetch：智能的双环境数据获取器\"></a>二、<code>useAsyncData</code> &amp; <code>useFetch</code>：智能的双环境数据获取器</h3><p>这两个组合函数是 Nuxt 数据获取的“智能大脑”。它们的关键特性是：<strong>“在服务端预取数据，并自动将数据序列化到客户端，避免重复请求”</strong>。</p>\n<h4 id=\"核心行为：\"><a href=\"#核心行为：\" class=\"headerlink\" title=\"核心行为：\"></a>核心行为：</h4><ol>\n<li><strong>默认在服务端执行</strong>：在 SSR 模式下，当页面首次加载时，它们会在 Nuxt 服务器内部执行，获取数据并直接将数据嵌入到最终返回的 HTML 中。</li>\n<li><strong>在客户端激活</strong>：当 Vue 在客户端“激活”静态页面时，<code>useAsyncData</code> 和 <code>useFetch</code> 会识别到数据已经存在于从服务器传递过来的 payload 中，因此<strong>不会在客户端再次发起请求</strong>，而是直接使用已有的数据。</li>\n<li><strong>后续导航</strong>：当你在客户端通过导航跳转到另一个也使用了这些函数的页面时，它们会在<strong>客户端</strong>执行。</li>\n</ol>\n<h4 id=\"如何控制执行环境？\"><a href=\"#如何控制执行环境？\" class=\"headerlink\" title=\"如何控制执行环境？\"></a>如何控制执行环境？</h4><p>它们提供了一个 <code>server</code> 选项让你精确控制：</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认：true - 在服务端执行（SSR 首屏）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/items&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 强制在客户端执行（CSR）</span></span><br><span class=\"line\"><span class=\"comment\">// 适合：用户相关的数据、不需要 SEO 的数据、访问浏览器 API 的数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/user-data&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">server</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// useAsyncData 用法相同</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useAsyncData</span>(<span class=\"string\">&#x27;user-key&#x27;</span>, <span class=\"function\">() =&gt;</span> $fetch(<span class=\"string\">&#x27;/api/user&#x27;</span>), &#123;</span><br><span class=\"line\">  <span class=\"attr\">server</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"三、三者的对比总结\"><a href=\"#三、三者的对比总结\" class=\"headerlink\" title=\"三、三者的对比总结\"></a>三、三者的对比总结</h3><p>为了更直观地理解，下面的流程图展示了不同调用方式在 Nuxt 应用生命周期中的执行时机和数据流向：</p>\n<p>这个图清晰地展示了：</p>\n<ol>\n<li><code>**useFetch**</code><strong>&#x2F;</strong><code>**useAsyncData**</code> 是贯穿服务端和客户端的“智能通道”，保证了数据的高效同步和无重复请求。</li>\n<li><strong>直接使用</strong>** **<code>**$fetch**</code> 在组件顶层会导致重复请求，是需要避免的反模式。</li>\n<li><strong>在事件中使用的</strong>** **<code>**$fetch**</code> 是纯客户端行为。</li>\n</ol>\n<h3 id=\"最佳实践与选择指南\"><a href=\"#最佳实践与选择指南\" class=\"headerlink\" title=\"最佳实践与选择指南\"></a>最佳实践与选择指南</h3><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐使用的工具</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>获取页面组件所需数据</strong></td>\n<td><code>**useFetch**</code><br/>** <strong><strong>或</strong></strong> **<code>**useAsyncData**</code></td>\n<td>自动处理 SSR&#x2F;CSR，避免重复请求，数据序列化到客户端。</td>\n</tr>\n<tr>\n<td><strong>在事件处理、</strong><code>**onMounted**</code><br/>** **<strong>中获取数据</strong></td>\n<td><code>**$fetch**</code></td>\n<td>明确需要在客户端触发的请求。</td>\n</tr>\n<tr>\n<td><strong>在 API 路由或服务器中间件中</strong></td>\n<td><code>**$fetch**</code></td>\n<td>明确的服务端环境，无需 <code>useAsyncData</code><br/> 的额外功能。</td>\n</tr>\n<tr>\n<td><strong>需要复杂的数据获取逻辑</strong></td>\n<td><code>**useAsyncData**</code><br/>** <strong><strong>+</strong></strong> **<code>**$fetch**</code></td>\n<td><code>useAsyncData</code><br/> 提供状态管理，内部函数可使用 <code>$fetch</code><br/> 进行复杂操作。</td>\n</tr>\n<tr>\n<td><strong>简单的 URL 请求</strong></td>\n<td><code>**useFetch**</code></td>\n<td>最简洁的写法。</td>\n</tr>\n</tbody></table>\n<p><strong>一句话总结：</strong></p>\n<ul>\n<li><strong>用</strong>** <strong><code>**useFetch**</code></strong>&#x2F;<strong><code>**useAsyncData**</code> 来获取</strong>组件初始化时所需的数据**，让 Nuxt 智能决定执行环境。</li>\n<li><strong>用</strong>** <strong><code>**$fetch**</code> 在</strong>明确的客户端交互<strong>或</strong>明确的服务端环境**中主动发起请求。</li>\n</ul>\n<p>遵循这个原则，你就能高效且正确地在 Nuxt 应用中处理数据获取。</p>\n<h2 id=\"激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\"><a href=\"#激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\" class=\"headerlink\" title=\"激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\"></a>激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？</h2><p>这些问题触及了 Nuxt.js SSR 的核心魔法。好消息是，<strong>这个过程绝大部分是自动化的，开发者几乎不需要手动干预</strong>。Nuxt 和 Vue 底层已经为你处理好了一切。</p>\n<p>下面我来逐一解答你的问题，你会看到 Nuxt 的设计是多么巧妙。</p>\n<hr>\n<h3 id=\"一、激活客户端需要开发手动调用什么-API-吗？\"><a href=\"#一、激活客户端需要开发手动调用什么-API-吗？\" class=\"headerlink\" title=\"一、激活客户端需要开发手动调用什么 API 吗？\"></a>一、激活客户端需要开发手动调用什么 API 吗？</h3><p><strong>答：完全不需要。这是 Vue 和 Nuxt 自动完成的。</strong></p>\n<p>这个过程称为 <strong>Hydration（混合）</strong>。它的流程是：</p>\n<ol>\n<li><strong>自动执行</strong>：当浏览器加载完 Nuxt 发送过来的 HTML 和客户端 JavaScript 包后，Vue 会自动启动。</li>\n<li><strong>自动匹配</strong>：Vue 会将它的虚拟 DOM 与服务器渲染好的、已经存在的静态 HTML 结构进行对比和匹配。</li>\n<li><strong>自动“激活”</strong>：Vue 不会重新创建 DOM 元素，而是会将事件监听器、响应式数据系统等“附加”到这些现有的 DOM 元素上，使静态页面瞬间变为一个完全交互式的 Vue 应用。</li>\n</ol>\n<p><strong>作为开发者，你唯一要做的就是：</strong></p>\n<ul>\n<li>确保你的代码是<strong>同构的</strong>（即同一份代码既能在 Node.js 环境运行，也能在浏览器环境运行）。</li>\n<li>避免在 <code>created</code> 或 <code>setup</code> 等生命周期中使用浏览器特有的 API（如 <code>window</code>, <code>document</code>），或者使用 <code>onMounted</code>（仅在客户端执行）来包裹它们。</li>\n</ul>\n<p><strong>你不用写任何像</strong>** <strong><code>**app.hydrate()**</code></strong> **<strong>这样的代码，一切都是开箱即用、自动发生的。</strong></p>\n<hr>\n<h3 id=\"二、服务端异步获取的数据注入到-HTML-这一步开发需要做什么？\"><a href=\"#二、服务端异步获取的数据注入到-HTML-这一步开发需要做什么？\" class=\"headerlink\" title=\"二、服务端异步获取的数据注入到 HTML 这一步开发需要做什么？\"></a>二、服务端异步获取的数据注入到 HTML 这一步开发需要做什么？</h3><p><strong>答：你只需要使用正确的 API（</strong><code>**useAsyncData**</code>** <strong><strong>或</strong></strong> <strong><code>**useFetch**</code></strong>），Nuxt 就会自动完成注入。**</p>\n<p>这个“注入”过程在 Nuxt 中被称为 <strong>State Serialization（状态序列化）</strong> 或 ** dehydration（脱水）**。</p>\n<p><strong>你的工作（非常简单）：</strong></p>\n<ol>\n<li>**使用 <strong><code>**useAsyncData**</code></strong> 或 **<code>**useFetch**</code>：在你的页面组件中，用它们来获取数据。</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">  // pages/posts.vue</span><br><span class=\"line\">  const &#123; data: posts &#125; = await useFetch(&#x27;/api/posts&#x27;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li><strong>Nuxt 自动完成后续所有事情</strong>：<ul>\n<li>Nuxt 在服务端执行完 <code>useFetch</code> 后，会<strong>自动</strong>将 <code>posts</code> 数据序列化为 JSON 字符串。</li>\n<li>将这个 JSON 字符串<strong>自动嵌入</strong>到最终 HTML 的 <code>&lt;head&gt;</code> 部分的一个 <code>&lt;script&gt;</code> 标签中。</li>\n<li>这个标签的内容通常是 <code>window.__NUXT__ = &#123; ... &#125;</code>，其中就包含了所有页面的预取数据。</li>\n</ul>\n</li>\n</ol>\n<p><strong>你不需要手动操作 DOM 去注入数据，Nuxt 的渲染引擎为你包办了一切。</strong></p>\n<hr>\n<h3 id=\"三、到客户端时如何获取数据呢？\"><a href=\"#三、到客户端时如何获取数据呢？\" class=\"headerlink\" title=\"三、到客户端时如何获取数据呢？\"></a>三、到客户端时如何获取数据呢？</h3><p><strong>答：客户端 Vue 应用会自动从</strong>** <strong><code>**window.__NUXT__**</code></strong> **<strong>中提取并复用数据，无需再次请求。</strong></p>\n<p>这个过程是 <strong>State Deserialization（状态反序列化）</strong> 或 <strong>rehydration（补水）</strong>。</p>\n<p><strong>它的自动流程如下：</strong></p>\n<ol>\n<li><strong>数据随 HTML 到达浏览器</strong>：HTML 中的 <code>&lt;script&gt;window.__NUXT__ = &#123;...&#125;&lt;/script&gt;</code> 会先被执行，将数据挂载到全局对象上。</li>\n<li><strong>客户端 Vue 应用启动</strong>：客户端的 JavaScript 包加载完毕后，Vue 和 Nuxt 开始初始化。</li>\n<li><strong>自动提取数据</strong>：当客户端的 <code>useFetch(&#39;/api/posts&#39;)</code> 代码执行时，它不会真正去发起网络请求，而是会<strong>先自动去</strong>** <strong><code>**window.__NUXT__**</code></strong> **<strong>对象里查找</strong>，看是否存在服务端已经为它准备好的数据。</li>\n<li><strong>直接复用数据</strong>：如果找到了，它就直接使用这份数据，完全跳过网络请求。这样就保证了客户端和服务端的数据状态<strong>绝对一致</strong>，这也是 Hydration 能成功的前提。</li>\n</ol>\n<p><strong>你可以通过 <strong><code>**useNuxtData**</code></strong> 这个工具函数来验证和访问这些被缓存的数据：</strong></p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 在客户端，你可以这样访问之前服务端获取的、被缓存的数据</span><br><span class=\"line\">const &#123; data: posts &#125; = useNuxtData(&#x27;posts&#x27;) // 使用 useFetch 时自动生成的 key</span><br><span class=\"line\"></span><br><span class=\"line\">// 这不会导致第二次请求，它只是从客户端缓存中读取</span><br><span class=\"line\">console.log(posts.value)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\"><a href=\"#服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\" class=\"headerlink\" title=\"服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\"></a>服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？</h2><p><strong>你这个问题问得非常非常关键，切中了SSR安全的核心！你的直觉完全正确。</strong></p>\n<p><strong>绝对不应该将任何敏感信息（如用户凭证、Token、个人身份信息PII等）内联到HTML的</strong>** <strong><code>**&lt;script&gt;**</code></strong> <strong><strong>标签中，并通过</strong></strong> <strong><code>**window.__NUXT__**</code></strong> **<strong>暴露给客户端。</strong></p>\n<p>这样做会带来严重的安全风险：</p>\n<ol>\n<li><strong>数据泄露</strong>：任何能打开浏览器开发者工具的人，都可以直接看到 <code>window.__NUXT__</code> 里的全部内容。</li>\n<li><strong>XSS攻击加剧</strong>：如果你的应用存在XSS（跨站脚本）漏洞，攻击者可以更容易地编写脚本窃取 <code>window.__NUXT__</code> 中的所有数据，而不必费力去窃取多个API请求的返回结果。</li>\n<li><strong>缓存风险</strong>：HTML页面可能会被CDN、代理服务器或浏览器缓存。如果其中包含了用户敏感信息，就意味着这些信息也可能被缓存并泄露给其他用户。</li>\n</ol>\n<hr>\n<h3 id=\"那么，如何处理需要认证的敏感数据？\"><a href=\"#那么，如何处理需要认证的敏感数据？\" class=\"headerlink\" title=\"那么，如何处理需要认证的敏感数据？\"></a>那么，如何处理需要认证的敏感数据？</h3><p>正确的做法是将敏感数据与非敏感数据<strong>分离</strong>，并遵循“<strong>按需索取</strong>”和“<strong>最小化暴露</strong>”的原则。以下是几种安全策略：</p>\n<h4 id=\"策略一：敏感数据绝不预取，仅在客户端获取\"><a href=\"#策略一：敏感数据绝不预取，仅在客户端获取\" class=\"headerlink\" title=\"策略一：敏感数据绝不预取，仅在客户端获取\"></a>策略一：敏感数据绝不预取，仅在客户端获取</h4><p>这是最常用、最安全的策略。用户登录状态、个人资料等高度敏感的数据，<strong>不应该</strong>在服务端的 <code>useFetch</code>&#x2F;<code>useAsyncData</code> 中获取。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 1. 非敏感、SEO需要的数据：在服务端预取（安全）</span><br><span class=\"line\">const &#123; data: publicPosts &#125; = await useFetch(&#x27;/api/public-posts&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. 敏感的用户数据：不在服务端预取，只在客户端获取</span><br><span class=\"line\">const user = ref(null)</span><br><span class=\"line\">const token = useCookie(&#x27;auth-token&#x27;) // Token应存放在HttpOnly Cookie中</span><br><span class=\"line\"></span><br><span class=\"line\">// 在客户端挂载后，再安全地获取用户数据</span><br><span class=\"line\">onMounted(async () =&gt; &#123;</span><br><span class=\"line\">  if (token.value) &#123;</span><br><span class=\"line\">    // 此请求在客户端发起，携带Cookie中的token</span><br><span class=\"line\">    user.value = await $fetch(&#x27;/api/me&#x27;, &#123;</span><br><span class=\"line\">      headers: &#123;</span><br><span class=\"line\">        // 通常Token会自动通过Cookie发送，无需手动设置，这里演示逻辑</span><br><span class=\"line\">        Authorization: `Bearer $&#123;token.value&#125;`</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;!-- 公开数据直接渲染 --&gt;</span><br><span class=\"line\">  &lt;div v-for=&quot;post in publicPosts&quot; :key=&quot;post.id&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;!-- 用户数据，等客户端获取后再显示 --&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;user&quot;&gt;Welcome, &#123;&#123; user.name &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"策略二：使用-useState-进行状态管理，区分服务端与客户端状态\"><a href=\"#策略二：使用-useState-进行状态管理，区分服务端与客户端状态\" class=\"headerlink\" title=\"策略二：使用 useState 进行状态管理，区分服务端与客户端状态\"></a>策略二：使用 <code>useState</code> 进行状态管理，区分服务端与客户端状态</h4><p>你可以利用 <code>useState</code> 的灵活性来管理不同环境的状态。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 创建一个响应式状态，服务端先初始化为 null</span><br><span class=\"line\">const secretData = useState(&#x27;secret-data&#x27;, () =&gt; null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 在客户端再获取真实数据</span><br><span class=\"line\">onMounted(async () =&gt; &#123;</span><br><span class=\"line\">  if (!secretData.value) &#123; // 避免在服务端执行</span><br><span class=\"line\">    secretData.value = await $fetch(&#x27;/api/secret-data&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"策略三：API-设计分离-提供公开和私密端点\"><a href=\"#策略三：API-设计分离-提供公开和私密端点\" class=\"headerlink\" title=\"策略三：API 设计分离 - 提供公开和私密端点\"></a>策略三：API 设计分离 - 提供公开和私密端点</h4><p>从后端设计上就进行分离：</p>\n<ul>\n<li><code>/api/public/data</code>：返回不敏感的数据，可以安全地在服务端渲染。</li>\n<li><code>/api/private/user-data</code>：返回敏感数据，必须认证且在客户端获取。</li>\n</ul>\n<hr>\n<h3 id=\"Nuxt-如何安全地处理认证？\"><a href=\"#Nuxt-如何安全地处理认证？\" class=\"headerlink\" title=\"Nuxt 如何安全地处理认证？\"></a>Nuxt 如何安全地处理认证？</h3><p>认证的最佳实践是使用 <strong>HttpOnly Cookies</strong> 来传输令牌（Token），而不是通过 <code>window.__NUXT__</code> 或 JS 可读的 Cookie。</p>\n<ol>\n<li><strong>登录流程</strong>：<ul>\n<li>用户提交登录表单，客户端 <code>$fetch</code> 发送到 <code>/api/auth/login</code>。</li>\n<li><strong>后端</strong>验证成功后，设置一个 <strong>HttpOnly、Secure、SameSite&#x3D;Strict</strong> 的 Cookie（包含认证Token）。这个 Cookie 对 JavaScript 不可见，极大地增强了安全性。</li>\n<li>前端只需知道登录成功，无需接触 Token 本身。</li>\n</ul>\n</li>\n<li><strong>获取用户数据</strong>：<ul>\n<li>在客户端，调用 <code>$fetch(&#39;/api/me&#39;)</code>。</li>\n<li>浏览器会<strong>自动</strong>在请求中带上 HttpOnly Cookie。</li>\n<li>后端验证 Cookie 中的 Token 有效性后，返回对应用户的数据。</li>\n</ul>\n</li>\n<li><strong>服务端渲染中的认证</strong>：<ul>\n<li>如果服务端需要根据用户状态渲染不同内容（例如“您好，用户名”），可以通过<strong>服务器中间件</strong>或 <strong>API 路由</strong>来处理。</li>\n<li>服务端可以读取请求中的 Cookie，去后端验证用户身份，然后决定返回什么数据。但这个验证过程发生在后端，结果信息需要是<strong>非敏感</strong>的（例如只返回 <code>username</code>，而不是返回 <code>token</code> 或 <code>email</code>）。</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 服务端可以安全地读取Cookie并获取非敏感的用户显示信息</span><br><span class=\"line\">const &#123; data: userInfo &#125; = await useFetch(&#x27;/api/user-display-info&#x27;)</span><br><span class=\"line\">// 这个 `/api/user-display-info` 接口在后端会验证Cookie，</span><br><span class=\"line\">// 但只返回 &#123; name: &#x27;John&#x27; &#125; 这样的非敏感信息用于界面显示。</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><strong>核心原则</strong>：<strong>绝不将敏感数据内联到 HTML 中</strong>。<code>window.__NUXT__</code> 应该是“公开的”或“非敏感的”。</li>\n<li><strong>数据分离</strong>：将数据分为“公开”和“私密”两类。公开数据用 <code>useFetch</code> 服务端预取；私密数据在客户端用 <code>$fetch</code> 按需获取。</li>\n<li><strong>认证最佳实践</strong>：使用 <strong>HttpOnly Cookies</strong> 来安全地传输认证凭证，而不是将其暴露给客户端 JavaScript 或 <code>window</code> 对象。</li>\n<li><strong>信任后端</strong>：敏感的权限检查和数据处理逻辑应该始终放在后端 API 中。前端（包括SSR服务端）只负责展示非敏感的结果。</li>\n</ol>\n<p>你的安全意识非常到位，遵循这些原则可以让你构建出既高效又安全的 Nuxt.js 应用。</p>\n<h2 id=\"除此之外，服务端渲染还有什么不能实现的呢？canvas？\"><a href=\"#除此之外，服务端渲染还有什么不能实现的呢？canvas？\" class=\"headerlink\" title=\"除此之外，服务端渲染还有什么不能实现的呢？canvas？\"></a>除此之外，服务端渲染还有什么不能实现的呢？canvas？</h2><p>说得非常对！<strong>Canvas</strong> 是一个绝佳的例子，它完美地揭示了服务端渲染（SSR）的“盲区”。</p>\n<p>SSR 的核心是<strong>生成静态的 HTML 和 CSS 字符串</strong>。因此，任何<strong>动态的、依赖于浏览器 JavaScript 运行时环境</strong>的功能，在纯 SSR 阶段都无法实现或功能不全。</p>\n<p>除了 Canvas，还有很多类似的限制。我们可以将它们分为几大类：</p>\n<hr>\n<h3 id=\"一、浏览器特有的-API-和全局对象\"><a href=\"#一、浏览器特有的-API-和全局对象\" class=\"headerlink\" title=\"一、浏览器特有的 API 和全局对象\"></a>一、浏览器特有的 API 和全局对象</h3><p>这是最直接的一类。在 Node.js 服务器环境中，根本没有 <code>window</code>, <code>document</code>, <code>navigator</code> 等对象。</p>\n<table>\n<thead>\n<tr>\n<th>API&#x2F;功能</th>\n<th>原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>**window**</code><strong>、</strong><code>**document**</code></td>\n<td>Node.js 中不存在。</td>\n<td>使用 <code>onMounted</code>钩子或 <code>clientOnly</code>组件确保只在客户端访问。</td>\n</tr>\n<tr>\n<td><code>**alert**</code><strong>、</strong><code>**confirm**</code><strong>、</strong><code>**prompt**</code></td>\n<td>浏览器交互对话框。</td>\n<td>逻辑移至客户端，或使用基于组件的替代品（如模态框）。</td>\n</tr>\n<tr>\n<td><strong>Canvas (</strong><code>**&lt;canvas&gt;**</code><strong>) &#x2F; WebGL</strong></td>\n<td>需要浏览器渲染上下文来绘图和操作像素。</td>\n<td><strong>只能在客户端初始化和使用</strong>。SSR 只能渲染一个空画布。</td>\n</tr>\n<tr>\n<td><strong>地理位置 (</strong><code>**navigator.geolocation**</code><strong>)</strong></td>\n<td>需要用户的浏览器授权和设备硬件支持。</td>\n<td>仅在客户端通过 <code>onMounted</code>或用户交互触发。</td>\n</tr>\n<tr>\n<td><strong>本地存储 (</strong><code>**localStorage**</code><strong>, <strong><code>**sessionStorage**</code></strong>, <strong><code>**IndexedDB**</code></strong>)</strong></td>\n<td>是浏览器的持久化存储机制。</td>\n<td>在 <code>onMounted</code>中访问，或使用 <code>useLocalStorage</code>等组合式函数（内部做了客户端检查）。</td>\n</tr>\n<tr>\n<td><strong>媒体设备 (</strong><code>**navigator.mediaDevices**</code><strong>)</strong></td>\n<td>需要访问麦克风、摄像头等硬件。</td>\n<td>完全的用户客户端行为。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"二、依赖浏览器渲染或布局的功能\"><a href=\"#二、依赖浏览器渲染或布局的功能\" class=\"headerlink\" title=\"二、依赖浏览器渲染或布局的功能\"></a>二、依赖浏览器渲染或布局的功能</h3><p>这类功能需要知道元素的真实尺寸和位置，而这些信息在纯字符串的 SSR 阶段是无法获得的。</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>元素尺寸&#x2F;位置</strong> (如 <code>element.offsetWidth</code><br/>, <code>getBoundingClientRect()</code><br/>)</td>\n<td>SSR 只有 HTML 字符串，没有真实的布局和渲染。</td>\n<td>在 <code>onMounted</code><br/> 后使用，或使用 Vue 的 <code>nextTick</code><br/> 确保 DOM 已更新。</td>\n</tr>\n<tr>\n<td><strong>基于尺寸的渲染</strong> (如图表库 ECharts、D3.js)</td>\n<td>需要挂载到真实 DOM 元素并获取其宽高才能渲染。</td>\n<td>在 <code>onMounted</code><br/> 中初始化图表实例。</td>\n</tr>\n<tr>\n<td><strong>动画 (CSS 动画除外)</strong></td>\n<td>许多 JS 动画库需要操作 DOM 样式。</td>\n<td>使用 <code>onMounted</code><br/> 启动动画，或使用 CSS 动画（SSR 支持）。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"三、用户交互和状态\"><a href=\"#三、用户交互和状态\" class=\"headerlink\" title=\"三、用户交互和状态\"></a>三、用户交互和状态</h3><p>SSR 输出的是一个“快照”，无法预知用户未来的行为。</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>用户输入</strong> (表单输入、焦点状态)</td>\n<td>SSR 无法预知用户会输入什么。</td>\n<td>SSR 可以渲染表单结构，但交互和值绑定必须在客户端完成。</td>\n</tr>\n<tr>\n<td><strong>鼠标事件、键盘事件</strong></td>\n<td>纯静态环境，无用户交互。</td>\n<td>完全由客户端 JavaScript 处理。</td>\n</tr>\n<tr>\n<td><strong>浏览器标签页可见性</strong> (<code>document.visibilityState</code>)</td>\n<td>依赖于用户当前的浏览器状态。</td>\n<td>纯客户端逻辑。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"四、第三方库\"><a href=\"#四、第三方库\" class=\"headerlink\" title=\"四、第三方库\"></a>四、第三方库</h3><p>许多强大的第三方库在设计时就是为浏览器而生的。</p>\n<table>\n<thead>\n<tr>\n<th>库类型</th>\n<th>问题</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>地图库</strong> (如 Leaflet, Google Maps)</td>\n<td>需要挂载到 DOM 并初始化地图渲染上下文。</td>\n<td>使用 <code>onMounted</code><br/> 初始化，或使用 Nuxt 模块（如 <code>nuxt-leaflet</code><br/>）。</td>\n</tr>\n<tr>\n<td><strong>可视化库</strong> (如 D3, Three.js)</td>\n<td>严重依赖 Canvas、WebGL 或 SVG 操作。</td>\n<td><strong>只能在客户端运行</strong>。</td>\n</tr>\n<tr>\n<td><strong>分析&#x2F;广告库</strong> (如 Google Analytics)</td>\n<td>依赖 <code>window</code><br/> 对象和浏览器环境来跟踪用户。</td>\n<td>使用 Nuxt 插件（<code>client: true</code><br/> 选项）或直接在 <code>onMounted</code><br/> 中加载。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"如何安全地处理这些限制？Nuxt-提供的解决方案\"><a href=\"#如何安全地处理这些限制？Nuxt-提供的解决方案\" class=\"headerlink\" title=\"如何安全地处理这些限制？Nuxt 提供的解决方案\"></a>如何安全地处理这些限制？Nuxt 提供的解决方案</h3><p>Nuxt 提供了一系列模式来优雅地解决这些问题：</p>\n<h4 id=\"1-onMounted-钩子-最常用\"><a href=\"#1-onMounted-钩子-最常用\" class=\"headerlink\" title=\"1. onMounted 钩子 (最常用)\"></a>1. <code>onMounted</code> 钩子 (最常用)</h4><p>确保代码只在客户端执行。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">import &#123; onMounted &#125; from &#x27;vue&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const canvas = ref(null)</span><br><span class=\"line\"></span><br><span class=\"line\">onMounted(() =&gt; &#123;</span><br><span class=\"line\">  // 现在可以安全地访问 DOM 和浏览器 API 了</span><br><span class=\"line\">  const ctx = canvas.value.getContext(&#x27;2d&#x27;)</span><br><span class=\"line\">  ctx.fillStyle = &#x27;green&#x27;</span><br><span class=\"line\">  ctx.fillRect(10, 10, 150, 100)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;!-- SSR 会渲染一个空画布 --&gt;</span><br><span class=\"line\">  &lt;canvas ref=&quot;canvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"2-条件渲染与-组件\"><a href=\"#2-条件渲染与-组件\" class=\"headerlink\" title=\"2. 条件渲染与 &lt;ClientOnly&gt; 组件\"></a>2. 条件渲染与 <code>&lt;ClientOnly&gt;</code> 组件</h4><p>防止不支持 SSR 的组件在服务器端渲染时出错。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;!-- 默认插槽只在客户端渲染 --&gt;</span><br><span class=\"line\">  &lt;ClientOnly&gt;</span><br><span class=\"line\">    &lt;MyChartThatUsesWindow /&gt;</span><br><span class=\"line\">    &lt;!-- 可以设置回退内容，在SSR阶段显示 --&gt;</span><br><span class=\"line\">    &lt;template #fallback&gt;</span><br><span class=\"line\">      &lt;div&gt;Loading chart...&lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">  &lt;/ClientOnly&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"3-使用-process-client-标志进行运行时检查\"><a href=\"#3-使用-process-client-标志进行运行时检查\" class=\"headerlink\" title=\"3. 使用 process.client 标志进行运行时检查\"></a>3. 使用 <code>process.client</code> 标志进行运行时检查</h4><div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">if (process.client) &#123;</span><br><span class=\"line\">  // 此代码块只在客户端打包时包含，并在客户端执行</span><br><span class=\"line\">  console.log(&#x27;I am on the client!&#x27;, window.innerWidth)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"4-为第三方库创建客户端插件\"><a href=\"#4-为第三方库创建客户端插件\" class=\"headerlink\" title=\"4. 为第三方库创建客户端插件\"></a>4. 为第三方库创建客户端插件</h4><div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// plugins/analytics.client.js - 注意 .client 后缀</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineNuxtPlugin</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这个插件只会在客户端运行</span></span><br><span class=\"line\">  <span class=\"variable language_\">window</span>.<span class=\"property\">dataLayer</span> = <span class=\"variable language_\">window</span>.<span class=\"property\">dataLayer</span> || []</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">gtag</span>(<span class=\"params\"></span>)&#123; dataLayer.<span class=\"title function_\">push</span>(<span class=\"variable language_\">arguments</span>) &#125;</span><br><span class=\"line\">  <span class=\"title function_\">gtag</span>(<span class=\"string\">&#x27;js&#x27;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>())</span><br><span class=\"line\">  <span class=\"title function_\">gtag</span>(<span class=\"string\">&#x27;config&#x27;</span>, <span class=\"string\">&#x27;GA_MEASUREMENT_ID&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>服务端渲染 (SSR) 的本质是<strong>静态化</strong>，它擅长的是：</p>\n<ul>\n<li><strong>生成初始 HTML 内容</strong></li>\n<li><strong>提供更好的 SEO</strong></li>\n<li><strong>提升首屏加载性能</strong></li>\n</ul>\n<p>而<strong>动态交互</strong>和<strong>浏览器依赖</strong>永远是 SSR 的盲区，必须交给客户端处理。</p>\n<p><strong>因此，一个成熟的 Nuxt 应用是两者结合的“混合体”：</strong></p>\n<ol>\n<li><strong>服务端</strong>：生成静态结构和首屏内容。</li>\n<li><strong>客户端</strong>：“激活”页面，接管所有交互，并加载那些依赖浏览器环境的动态功能。</li>\n</ol>\n<p>你的工作就是清晰地界定哪些逻辑属于服务端，哪些属于客户端，并使用 Nuxt 提供的模式（<code>onMounted</code>, <code>&lt;ClientOnly&gt;</code>, <code>.client</code> 插件）将它们优雅地结合起来。</p>\n<h2 id=\"nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\"><a href=\"#nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\" class=\"headerlink\" title=\"nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\"></a>nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？</h2><p>这是一个非常好的问题，它触及了 Nuxt 全栈架构的核心优势。</p>\n<p><strong>简单而直接的答案是：不会。在客户端激活后，向同源的 Nuxt 中间件或 API 路由发起请求，绝对不会产生跨域问题。</strong></p>\n<p>这是因为你发起请求的目标和你的页面来源是<strong>完全同源的</strong>。</p>\n<hr>\n<h3 id=\"为什么不会跨域？——-同源策略详解\"><a href=\"#为什么不会跨域？——-同源策略详解\" class=\"headerlink\" title=\"为什么不会跨域？—— 同源策略详解\"></a>为什么不会跨域？—— 同源策略详解</h3><p>让我们回顾一下“同源策略”：当协议、域名、端口都相同时，即为同源，浏览器允许请求。</p>\n<p>假设你的 Nuxt 应用部署在：<br><code>https://www.my-app.com</code></p>\n<ol>\n<li><strong>你的页面来源</strong>：<br>浏览器中显示的地址是：<code>https://www.my-app.com/some-page</code></li>\n<li><strong>你请求的目标</strong>：<br>你在代码中发起的请求是：</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用相对路径，目标自动补全为：https://www.my-app.com/api/hello</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/hello&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用 useFetch（同样基于相对路径）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/auth/user&#x27;</span>);</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"3\">\n<li><strong>对比</strong>：<ul>\n<li><strong>协议</strong>：都是 <code>https</code></li>\n<li><strong>域名</strong>：都是 <code>www.my-app.com</code></li>\n<li><strong>端口</strong>：都是 <code>443</code> (HTTPS 默认端口)</li>\n</ul>\n</li>\n</ol>\n<p><strong>结论</strong>：<strong>完全同源</strong>，浏览器欣然放行，没有任何跨域限制。</p>\n<hr>\n<h3 id=\"Nuxt-如何处理这些请求？——-请求生命周期\"><a href=\"#Nuxt-如何处理这些请求？——-请求生命周期\" class=\"headerlink\" title=\"Nuxt 如何处理这些请求？—— 请求生命周期\"></a>Nuxt 如何处理这些请求？—— 请求生命周期</h3><p>理解这个过程能让你更清楚为什么这是安全的：</p>\n<p>如图所示，无论是开发还是生产环境，<strong>你的 API 请求和前端页面都由同一个主机处理</strong>。它们处于同一个“生态系统”内，通信是内部的、安全的，不存在跨域问题。</p>\n<hr>\n<h3 id=\"什么情况下会有跨域问题？\"><a href=\"#什么情况下会有跨域问题？\" class=\"headerlink\" title=\"什么情况下会有跨域问题？\"></a>什么情况下会有跨域问题？</h3><p>只有当你的<strong>页面来源</strong>和<strong>请求目标</strong>不同源时，才会触发跨域。例如：</p>\n<table>\n<thead>\n<tr>\n<th>你的页面在</th>\n<th>你请求的目标</th>\n<th>是否跨域</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>https://www.my-app.com</code></td>\n<td><code>https://www.my-app.com/api/hello</code></td>\n<td><strong>否</strong></td>\n<td>同源</td>\n</tr>\n<tr>\n<td><code>https://www.my-app.com</code></td>\n<td><code>https://api.my-app.com</code></td>\n<td><strong>是</strong></td>\n<td>子域名不同 (<code>www</code> vs <code>api</code>)</td>\n</tr>\n<tr>\n<td><code>http://localhost:3000</code></td>\n<td><code>https://api.third-party.com</code></td>\n<td><strong>是</strong></td>\n<td>完全不同的域名</td>\n</tr>\n<tr>\n<td><code>https://www.my-app.com</code></td>\n<td><code>http://www.my-app.com/api/hello</code></td>\n<td><strong>是</strong></td>\n<td>协议不同 (<code>https</code>vs <code>http</code>)</td>\n</tr>\n</tbody></table>\n<p><strong>对于最后一种情况（生产环境前后端分离），解决方案是：</strong></p>\n<ol>\n<li><strong>后端配置 CORS</strong>：在你的 <code>api.my-app.com</code> 服务器上设置 <code>Access-Control-Allow-Origin: https://www.my-app.com</code> 响应头。</li>\n<li><strong>使用反向代理</strong>：配置你的生产服务器（如 Nginx），将对 <code>/api/</code> 的请求代理到 <code>api.my-app.com</code>，让浏览器始终觉得是在请求同源地址。这是更推荐的做法。</li>\n</ol>\n<h3 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>在 Nuxt 应用中，请求自身的 API 路由 (</strong><code>**/api/xxx**</code><strong>) 或服务器中间件是绝对同源的，没有跨域问题。</strong></li>\n<li>这是 Nuxt 全栈框架的巨大优势之一，它简化了开发，让你无需在开发阶段为 CORS 烦恼。</li>\n<li>跨域问题只会在你请求<strong>外部第三方 API</strong> 且对方未正确配置 CORS 时出现。</li>\n<li>如果你的生产环境是前后端完全分离的（不同域），那么需要在生产环境的<strong>后端配置 CORS</strong> 或通过<strong>反向代理</strong>来解决。</li>\n</ul>\n<p>所以，请放心地在你的 Nuxt 应用内部调用 API，这是最安全、最正确的做法。</p>\n<h2 id=\"那如果对后端接口-另一台服务器上-的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\"><a href=\"#那如果对后端接口-另一台服务器上-的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\" class=\"headerlink\" title=\"那如果对后端接口(另一台服务器上)的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\"></a>那如果对后端接口(另一台服务器上)的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？</h2><p><strong>你的这个思路非常棒，完全正确！</strong> 这正是构建现代 Web 应用的一种核心架构模式，被称为 <strong>“BFF（Backend For Frontend）模式”</strong> 或 <strong>“API 网关模式”</strong>。</p>\n<p>你的推理链条是：</p>\n<ol>\n<li><strong>所有客户端请求</strong>都只发往<strong>同源</strong>的 Nuxt 服务器（<code>/api/proxy</code>）。</li>\n<li>Nuxt 服务器上的<strong>中间件</strong>接收到请求后，<strong>代为转发</strong>给真正的后端服务器。</li>\n<li>由于服务器之间通信（Nuxt Server -&gt; Your Backend Server）<strong>没有跨域限制</strong>，所以问题迎刃而解。</li>\n</ol>\n<p>这个方案<strong>在理论上是完全可行且非常优雅的</strong>，它确实可以让你<strong>完全摆脱 CORS 的困扰</strong>。</p>\n<hr>\n<h3 id=\"这种架构的详细工作流程\"><a href=\"#这种架构的详细工作流程\" class=\"headerlink\" title=\"这种架构的详细工作流程\"></a>这种架构的详细工作流程</h3><p>如图所示，浏览器始终只与 <code>my-nuxt-app.com</code> 通信，完美符合同源策略。</p>\n<hr>\n<h3 id=\"优缺点分析：这是否是“万能药”？\"><a href=\"#优缺点分析：这是否是“万能药”？\" class=\"headerlink\" title=\"优缺点分析：这是否是“万能药”？\"></a>优缺点分析：这是否是“万能药”？</h3><p>虽然这个方案能根治跨域，但它也引入了一些新的考虑因素：</p>\n<h4 id=\"优点-✅\"><a href=\"#优点-✅\" class=\"headerlink\" title=\"优点 ✅\"></a>优点 ✅</h4><ol>\n<li><strong>彻底解决 CORS</strong>：前端开发者完全无需再关心跨域配置，开发体验极其流畅。</li>\n<li><strong>隐藏后端架构</strong>：真正的后端地址、端口、API 结构对客户端完全隐藏，更安全。</li>\n<li><strong>协议转换</strong>：可以轻松地在 Nuxt 中处理 HTTPS -&gt; HTTP 的请求（服务器间通信允许）。</li>\n<li><strong>数据处理与聚合</strong>：你可以在 Nuxt 中间件中对多个后端服务的返回值进行聚合、过滤、转换，为前端提供最合适的数据结构，减少前端请求次数。</li>\n</ol>\n<h4 id=\"缺点与需要考虑的因素-⚠️\"><a href=\"#缺点与需要考虑的因素-⚠️\" class=\"headerlink\" title=\"缺点与需要考虑的因素 ⚠️\"></a>缺点与需要考虑的因素 ⚠️</h4><ol>\n<li><strong>额外的网络跳转</strong>：所有请求都多经过一环（浏览器 -&gt; Nuxt -&gt; 真实后端），<strong>会增加微小的延迟</strong>。对于延迟敏感的应用需要优化。</li>\n<li><strong>单点压力与故障点</strong>：Nuxt 服务器现在成为了所有 API 流量的入口。如果它宕机，所有请求都会失败。需要保证其高可用性。</li>\n<li><strong>复杂性转移</strong>：虽然前端变简单了，但 Nuxt 层（BFF 层）的逻辑变复杂了。你需要在这里编写转发、错误处理、认证等逻辑。</li>\n<li><strong>认证问题</strong>：如果后端 API 需要认证，你需要决定如何传递认证信息。<ul>\n<li><strong>方案A（推荐）</strong>：浏览器将认证 Token 发给 Nuxt，Nuxt 再原样转发给后端。</li>\n<li><strong>方案B</strong>：Nuxt 服务器自己持有访问后端的凭证，替用户与后端通信。但这需要非常小心地管理权限。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"如何实现？\"><a href=\"#如何实现？\" class=\"headerlink\" title=\"如何实现？\"></a>如何实现？</h3><p>在 Nuxt 中，你通常使用 <strong>API 路由</strong> 或 <strong>服务器中间件</strong> 来实现，而不是普通的中间件，因为它们专门处理服务器逻辑。</p>\n<p><strong>示例：在 <strong><code>**server/api/proxy/[...].ts**</code></strong> 中创建一个捕获所有路由的 API</strong></p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server/api/proxy/[...].ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineEventHandler</span>(<span class=\"title function_\">async</span> (event) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 获取请求路径和方法</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = <span class=\"title function_\">getRouterParam</span>(event, <span class=\"string\">&#x27;path&#x27;</span>) <span class=\"comment\">// 获取 ... 通配符参数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> method = <span class=\"title function_\">getMethod</span>(event)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> body = method === <span class=\"string\">&#x27;GET&#x27;</span> ? <span class=\"literal\">undefined</span> : <span class=\"keyword\">await</span> <span class=\"title function_\">readBody</span>(event)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 定义你的真实后端基础 URL（应从环境变量读取！）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> baseURL = <span class=\"string\">&#x27;https://your-real-backend.com/api&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> targetURL = <span class=\"string\">`<span class=\"subst\">$&#123;baseURL&#125;</span>/<span class=\"subst\">$&#123;path&#125;</span>`</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 可选：处理认证（例如，将前端传来的 token 转发给后端）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> headers = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> authHeader = <span class=\"title function_\">getHeader</span>(event, <span class=\"string\">&#x27;authorization&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (authHeader) &#123;</span><br><span class=\"line\">    headers[<span class=\"string\">&#x27;Authorization&#x27;</span>] = authHeader</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 4. 代理请求到真实后端</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> $fetch.<span class=\"title function_\">raw</span>(targetURL, &#123;</span><br><span class=\"line\">      method,</span><br><span class=\"line\">      body,</span><br><span class=\"line\">      headers,</span><br><span class=\"line\">      <span class=\"comment\">// 重要：转发查询参数 (?foo=bar)</span></span><br><span class=\"line\">      <span class=\"attr\">query</span>: <span class=\"title function_\">getQuery</span>(event),</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 5. 可选：根据需要设置响应头</span></span><br><span class=\"line\">    <span class=\"title function_\">setHeaders</span>(event, response.<span class=\"property\">headers</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 6. 返回后端响应的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.<span class=\"property\">_data</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 7. 错误处理，将后端错误返回给前端</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"title function_\">createError</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">statusCode</span>: error.<span class=\"property\">statusCode</span> || <span class=\"number\">500</span>,</span><br><span class=\"line\">      <span class=\"attr\">statusMessage</span>: error.<span class=\"property\">statusMessage</span> || <span class=\"string\">&#x27;Internal Server Error&#x27;</span>,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n\n<p>这样，前端所有发往 <code>/api/proxy/items</code>、<code>/api/proxy/user/profile</code> 的请求，都会被这个 handler 捕获，并转发到 <code>https://your-real-backend.com/api/items</code> 和 <code>https://your-real-backend.com/api/user/profile</code>。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p><strong>是的，你的想法是完全正确且高效的。通过让 Nuxt 服务器作为所有后端请求的代理，你可以一劳永逸地解决跨域问题，无需在开发或生产环境配置任何 CORS 或代理规则。</strong></p>\n<p>这不仅是解决跨域的手段，更是一种先进的<strong>架构设计选择</strong>（BFF）。它特别适用于：</p>\n<ul>\n<li>中大型前后端分离项目。</li>\n<li>需要集成多个后端微服务的复杂前端。</li>\n<li>希望简化前端开发流程，将复杂性集中到 BFF 层的团队。</li>\n</ul>\n<p>你只需要评估其带来的<strong>额外延迟</strong>和<strong>单点压力</strong>是否在你的应用可接受范围内即可。对于绝大多数应用来说，这个方案的利远大于弊。</p>\n","excerpt":"","more":"<h2 id=\"Nuxt-js的ssr服务端渲染原理\"><a href=\"#Nuxt-js的ssr服务端渲染原理\" class=\"headerlink\" title=\"Nuxt.js的ssr服务端渲染原理\"></a>Nuxt.js的ssr服务端渲染原理</h2><p>Nuxt.js 的 SSR（服务端渲染）原理是一个非常核心且有趣的话题。它并不是简单的“在服务器上跑 Vue”，而是一套完整的、精心设计的架构。</p>\n<p>简单来说，它的核心原理是：<strong>“首屏在服务器提前渲染成 HTML，之后在客户端‘激活’为 SPA”。</strong></p>\n<p>下面我们分步拆解这个过程的原理、优势和关键实现。</p>\n<hr>\n<h3 id=\"一、核心目标：解决什么問題？\"><a href=\"#一、核心目标：解决什么問題？\" class=\"headerlink\" title=\"一、核心目标：解决什么問題？\"></a>一、核心目标：解决什么問題？</h3><ol>\n<li><strong>SEO（搜索引擎优化）</strong>：传统 SPA（单页应用）返回的是一个空的 HTML 壳，内容由 JavaScript 动态填充。搜索引擎爬虫可能无法等待和执行 JS，导致无法收录内容。SSR 直接返回渲染好的完整 HTML，利于爬虫抓取。</li>\n<li><strong>更快的内容到达时间</strong>：用户浏览器无需等待所有 JavaScript 下载和执行完毕才能看到内容。服务器直接返回了渲染好的 HTML，首屏内容可以立即展示，感知性能极大提升。</li>\n</ol>\n<h3 id=\"二、Nuxt-js-SSR-的核心工作流程\"><a href=\"#二、Nuxt-js-SSR-的核心工作流程\" class=\"headerlink\" title=\"二、Nuxt.js SSR 的核心工作流程\"></a>二、Nuxt.js SSR 的核心工作流程</h3><p>Nuxt.js 的 SSR 过程可以清晰地分为两个阶段：<strong>服务端渲染</strong>和<strong>客户端激活</strong>。下图展示了从用户请求到页面可交互的完整生命周期：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/jpeg/55999631/1757522658867-d1d335f5-5c7f-443b-bdc8-3a1621a987cb.jpeg\"\n                      alt=\"画板\"\n                ></p>\n<h4 id=\"第一阶段：服务端渲染（Server-Side）\"><a href=\"#第一阶段：服务端渲染（Server-Side）\" class=\"headerlink\" title=\"第一阶段：服务端渲染（Server-Side）\"></a>第一阶段：服务端渲染（Server-Side）</h4><p>这个过程发生在 <strong>Nuxt 服务器</strong>（一个 Node.js 服务器）上。</p>\n<ol>\n<li><strong>接收请求</strong>：用户浏览器请求一个 URL，请求到达 Nuxt 服务器。</li>\n<li><strong>创建应用实例</strong>：Nuxt 服务器为这次请求<strong>创建一个全新的 Vue 应用实例、Router 和 Store</strong>。这是关键，确保了每个请求的隔离性。</li>\n<li><strong>路由匹配</strong>：根据请求的 URL，Nuxt Router 确定要渲染哪个页面组件（如 <code>pages/about.vue</code>）。</li>\n<li><strong>数据预取</strong>：Nuxt 会调用页面组件中定义的<strong>异步数据获取方法</strong>（如 <code>asyncData</code>、<code>useAsyncData</code>、<code>useFetch</code>）。<strong>这些方法会在服务端执行</strong>。<ul>\n<li>服务器会等待这些异步操作完成，再去渲染组件。这确保了渲染出的 HTML 是包含数据的。</li>\n</ul>\n</li>\n<li><strong>渲染 HTML</strong>：<ul>\n<li>将获取到的数据<strong>注入到 Vuex Store 或组件状态</strong>中。</li>\n<li>调用 Vue 的 <code>vue-server-renderer</code>（Vue 2）或 <code>@vue/server-renderer</code>（Vue 3）的 <code>renderToString()</code> 函数。</li>\n<li>这个函数会运行 Vue 组件，但它<strong>不是在浏览器中创建真实 DOM，而是在内存中生成一个完整的 HTML 字符串</strong>。</li>\n</ul>\n</li>\n<li><strong>构建最终文档</strong>：Nuxt 将这个 HTML 字符串插入到HTML模板（<code>app.html</code>）中。同时，<strong>将预取的数据序列化后内联到 HTML 中</strong>（通常是在一个 <code>&lt;script&gt;</code> 标签里，如 <code>window.__NUXT__ = &#123;...&#125;</code>），这个过程称为 <strong>状态脱水</strong>。</li>\n<li><strong>响应</strong>：将这个完整的、包含数据和内容的 HTML 文档发送给客户端。</li>\n</ol>\n<h4 id=\"第二阶段：客户端激活（Client-Side-Hydration）\"><a href=\"#第二阶段：客户端激活（Client-Side-Hydration）\" class=\"headerlink\" title=\"第二阶段：客户端激活（Client-Side Hydration）\"></a>第二阶段：客户端激活（Client-Side Hydration）</h4><p>这个过程发生在<strong>用户浏览器</strong>上。</p>\n<ol>\n<li><strong>静态内容展示</strong>：浏览器收到服务器返回的 HTML 后，<strong>无需等待任何 JavaScript，就能立即解析和显示页面内容</strong>。这是首屏速度快的根本原因。</li>\n<li><strong>加载资源</strong>：浏览器开始加载页面中引用的 JavaScript 和 CSS 资源（Nuxt 打包好的客户端 bundle）。</li>\n<li><strong>Vue 接管（Hydration -“混合”）</strong>：这是最精妙的一步。<ul>\n<li>客户端的 Vue 应用也会被创建和初始化。</li>\n<li>Vue 不会像传统 SPA 那样清空 DOM 再重新渲染。相反，它会<strong>将虚拟 DOM 与服务器渲染好的现有静态 HTML 结构进行“混合”</strong>。</li>\n<li>它会将事件监听器、Vue 的响应式系统等“激活”到这些静态元素上，使其变成一个完全交互式的 Vue 应用。</li>\n</ul>\n</li>\n<li><strong>变为 SPA</strong>：激活完成后，应用就切换到了正常的 SPA 模式。后续的页面导航不会再向服务器请求完整的 HTML，而是由客户端 Router 管理，只获取必要的数据，实现无刷新跳转。</li>\n</ol>\n<hr>\n<h3 id=\"三、Nuxt-js-实现-SSR-的关键技术点\"><a href=\"#三、Nuxt-js-实现-SSR-的关键技术点\" class=\"headerlink\" title=\"三、Nuxt.js 实现 SSR 的关键技术点\"></a>三、Nuxt.js 实现 SSR 的关键技术点</h3><ol>\n<li><strong>双入口构建（Dual Entry Points）</strong>：<ul>\n<li>Nuxt 使用 Webpack&#x2F;Vite 分别打包<strong>两个版本</strong>的代码：<ul>\n<li><strong>服务端 Bundle</strong>：用于 <code>renderToString</code>，它知道如何在 Node.js 环境中渲染组件。</li>\n<li><strong>客户端 Bundle</strong>：用于在浏览器中“激活”静态页面并处理后续交互。</li>\n</ul>\n</li>\n<li>这是通过 <code>webpack</code> 的 <code>target: &#39;node&#39;</code> 和 <code>target: &#39;web&#39;</code> 分别配置实现的。</li>\n</ul>\n</li>\n<li><strong>数据预取与状态同步</strong>：<ul>\n<li>服务端获取的数据必须<strong>安全地传递到客户端</strong>，否则客户端 Vue 在初始化时没有数据，会导致虚拟 DOM 与服务器渲染的 HTML 不匹配，激活失败。</li>\n<li>Nuxt 通过 <code>window.__NUXT__</code> 对象将数据从服务器“脱水”到客户端“补水”，保证两端状态一致。</li>\n</ul>\n</li>\n<li><strong>生命周期</strong>：<ul>\n<li>在 SSR 过程中，<strong>只有</strong>** <strong><code>**beforeCreate**</code></strong> <strong><strong>和</strong></strong> <strong><code>**created**</code></strong> **<strong>这两个生命周期钩子会在服务端执行</strong>。</li>\n<li><code>mounted</code>、<code>beforeMount</code> 等只在客户端执行。因此，<strong>在</strong>** <strong><code>**created**</code></strong> <strong><strong>中操作</strong></strong> <strong><code>**window**</code></strong> **<strong>或 DOM 会报错</strong>。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"四、Universal-Mode-同构渲染\"><a href=\"#四、Universal-Mode-同构渲染\" class=\"headerlink\" title=\"四、Universal Mode (同构渲染)\"></a>四、Universal Mode (同构渲染)</h3><p>Nuxt.js 的 SSR 通常被称为 <strong>“Universal”应用</strong>或**“同构”应用**。</p>\n<ul>\n<li><strong>同构代码</strong>：同一份 Vue 组件代码（<code>.vue</code> 文件）既可以在<strong>服务器</strong>上运行（用于首屏生成 HTML），也可以在<strong>客户端</strong>运行（用于激活和后续交互）。</li>\n<li><strong>优势</strong>：开发者只需写一套代码，Nuxt 负责处理双端的构建和渲染协调，开发体验非常流畅。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>Nuxt.js 的 SSR 原理可以概括为：</p>\n<ol>\n<li><strong>服务端</strong>：为每个请求即时创建 Vue 应用，预先获取数据，渲染出包含内容的 HTML 字符串，并将数据状态一同返回。</li>\n<li><strong>客户端</strong>：快速展示静态内容，然后加载 JS，由 Vue 将静态页面“激活”为可交互的 SPA，最后接管所有后续导航。</li>\n</ol>\n<p>它完美地结合了<strong>传统服务端渲染首屏快、SEO 好</strong>的优势和<strong>单页应用用户体验流畅、交互丰富</strong>的优势，是现代 Web 应用开发的绝佳选择。</p>\n<h2 id=\"nuxt中调后端接口怎么做，要注意什么？\"><a href=\"#nuxt中调后端接口怎么做，要注意什么？\" class=\"headerlink\" title=\"nuxt中调后端接口怎么做，要注意什么？\"></a>nuxt中调后端接口怎么做，要注意什么？</h2><p>在 Nuxt.js 中调用后端接口是其核心功能之一，但根据你使用的 API 风格（Composition API 或 Options API）和渲染模式（SSR 或 SPA），做法和注意事项有所不同。</p>\n<p>下面将为你提供全面的指南，包括方法、最佳实践和常见陷阱。</p>\n<hr>\n<h3 id=\"一、如何调用后端接口？\"><a href=\"#一、如何调用后端接口？\" class=\"headerlink\" title=\"一、如何调用后端接口？\"></a>一、如何调用后端接口？</h3><p>Nuxt 3 推荐使用 Composition API，并提供了强大的组合式函数。</p>\n<h4 id=\"1-使用-useFetch-useAsyncData-Composition-API-首选\"><a href=\"#1-使用-useFetch-useAsyncData-Composition-API-首选\" class=\"headerlink\" title=\"1. 使用 useFetch &#x2F; useAsyncData (Composition API - 首选)\"></a>1. 使用 <code>useFetch</code> &#x2F; <code>useAsyncData</code> (Composition API - 首选)</h4><p>这是 Nuxt 3 中最现代、最推荐的方式，它完美处理了服务端和客户端的数据获取。</p>\n<p><strong>基本用法 (</strong><code>**useFetch**</code><strong>)：</strong><br><code>useFetch</code> 是专门为获取数据而设计的语法糖。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 直接在模板中使用，无需 .value</span><br><span class=\"line\">const &#123; data: posts, pending, error, refresh &#125; = useFetch(&#x27;/api/posts&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者指定完整 URL（注意配置代理或 CORS）</span><br><span class=\"line\">const &#123; data: users &#125; = useFetch(&#x27;https://api.example.com/users&#x27;, &#123;</span><br><span class=\"line\">  // 可选项：在客户端才获取数据（代替 onMounted + ref）</span><br><span class=\"line\">  // lazy: true,</span><br><span class=\"line\">  // server: false</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;pending&quot;&gt;Loading...&lt;/div&gt;</span><br><span class=\"line\">  &lt;div v-else-if=&quot;error&quot;&gt;Error: &#123;&#123; error.message &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">  &lt;ul v-else&gt;</span><br><span class=\"line\">    &lt;li v-for=&quot;post in posts&quot; :key=&quot;post.id&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/li&gt;</span><br><span class=\"line\">  &lt;/ul&gt;</span><br><span class=\"line\">  &lt;button @click=&quot;refresh&quot;&gt;Refresh&lt;/button&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>高级用法 (</strong><code>**useAsyncData**</code>** + <strong><code>**$fetch**</code></strong>)：**<br>当你需要更复杂的逻辑时（如多个请求、数据处理），使用 <code>useAsyncData</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">const &#123; data: combinedData, refresh &#125; = useAsyncData(&#x27;unique-key&#x27;, async () =&gt; &#123;</span><br><span class=\"line\">  // 这里可以写任何复杂的异步逻辑</span><br><span class=\"line\">  const [posts, users] = await Promise.all([</span><br><span class=\"line\">    $fetch(&#x27;/api/posts&#x27;),</span><br><span class=\"line\">    $fetch(&#x27;/api/users&#x27;)</span><br><span class=\"line\">  ])</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 对数据进行转换</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    posts: posts.map(post =&gt; (&#123; ...post, title: post.title.toUpperCase() &#125;)),</span><br><span class=\"line\">    users</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-使用-fetch-直接调用\"><a href=\"#2-使用-fetch-直接调用\" class=\"headerlink\" title=\"2. 使用 $fetch 直接调用\"></a>2. 使用 <code>$fetch</code> 直接调用</h4><p>Nuxt 3 内置了基于 <a class=\"link\"   href=\"https://github.com/unjs/ofetch\" >ofetch<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 的 <code>$fetch</code> 工具，可以在任何地方使用（如事件处理函数中）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">const handleSubmit = async () =&gt; &#123;</span><br><span class=\"line\">  try &#123;</span><br><span class=\"line\">    const response = await $fetch(&#x27;/api/submit&#x27;, &#123;</span><br><span class=\"line\">      method: &#x27;POST&#x27;,</span><br><span class=\"line\">      body: &#123; name: &#x27;John Doe&#x27; &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    console.log(&#x27;Success:&#x27;, response)</span><br><span class=\"line\">  &#125; catch (error) &#123;</span><br><span class=\"line\">    console.error(&#x27;Error:&#x27;, error)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-使用-useLazyFetch-useLazyAsyncData\"><a href=\"#3-使用-useLazyFetch-useLazyAsyncData\" class=\"headerlink\" title=\"3. 使用 useLazyFetch &#x2F; useLazyAsyncData\"></a>3. 使用 <code>useLazyFetch</code> &#x2F; <code>useLazyAsyncData</code></h4><p>它们是 <code>useFetch</code> 和 <code>useAsyncData</code> 的变体，<code>lazy: true</code> 是默认行为。<strong>不会阻塞导航</strong>，适用于非关键数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 不会阻塞路由导航，你需要自己处理 data 为 null 的情况</span><br><span class=\"line\">const &#123; data: nonCriticalData &#125; = useLazyFetch(&#x27;/api/non-critical-data&#x27;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;data&quot;&gt;</span><br><span class=\"line\">    &lt;!-- 渲染数据 --&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、最重要的注意事项\"><a href=\"#二、最重要的注意事项\" class=\"headerlink\" title=\"二、最重要的注意事项\"></a>二、最重要的注意事项</h3><h4 id=\"1-服务端渲染-SSR-vs-客户端渲染-CSR-行为\"><a href=\"#1-服务端渲染-SSR-vs-客户端渲染-CSR-行为\" class=\"headerlink\" title=\"1. 服务端渲染 (SSR) vs 客户端渲染 (CSR) 行为\"></a>1. 服务端渲染 (SSR) vs 客户端渲染 (CSR) 行为</h4><p>这是 <strong>最核心、最容易出错</strong> 的点！</p>\n<ul>\n<li><strong>默认行为</strong>：<code>useFetch</code> 和 <code>useAsyncData</code> <strong>会在服务端执行</strong>。这意味着：<ul>\n<li><strong>好处</strong>：返回的 HTML 直接包含数据，利于 SEO 和首屏加载。</li>\n<li><strong>陷阱</strong>：<strong>不能在它们内部或</strong>** <strong><code>**created**</code></strong> **<strong>生命周期中使用浏览器API</strong>（如 <code>window</code>, <code>document</code>, <code>localStorage</code>）。</li>\n</ul>\n</li>\n<li><strong>如何控制</strong>：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 选项 1: 强制只在客户端执行</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/data&#x27;</span>, &#123; <span class=\"attr\">server</span>: <span class=\"literal\">false</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 选项 2: 使用 useLazyFetch (默认不会阻塞导航，且在客户端执行)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useLazyFetch</span>(<span class=\"string\">&#x27;/api/data&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 选项 3: 在 onMounted 钩子中用 $fetch</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; onMounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = <span class=\"title function_\">ref</span>(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"title function_\">onMounted</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  data.<span class=\"property\">value</span> = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/data&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-处理-CORS-跨域资源共享\"><a href=\"#2-处理-CORS-跨域资源共享\" class=\"headerlink\" title=\"2. 处理 CORS (跨域资源共享)\"></a>2. 处理 CORS (跨域资源共享)</h4><p>如果你调用的接口不在同一个域下，会遇到 CORS 问题。</p>\n<ul>\n<li><strong>开发环境</strong>：在 <code>nuxt.config.ts</code> 中配置代理是最佳实践。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// nuxt.config.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineNuxtConfig</span>(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... 其他配置</span></span><br><span class=\"line\">  <span class=\"attr\">nitro</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">routeRules</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">&#x27;/api/**&#x27;</span>: &#123; <span class=\"attr\">proxy</span>: <span class=\"string\">&#x27;https://api.example.com/**&#x27;</span> &#125;, <span class=\"comment\">// 代理 API 请求</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 或者使用旧的 devServer 配置 (v3.0+ 推荐使用 nitro)</span></span><br><span class=\"line\">  <span class=\"comment\">// devServer: &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   proxy: &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//     &#x27;/api&#x27;: &#x27;https://api.example.com&#x27;</span></span><br><span class=\"line\">  <span class=\"comment\">//   &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后你在代码中请求 <code>/api/users</code>，开发服务器会将其代理到 <code>https://api.example.com/api/users</code>，避免 CORS。</li>\n<li><strong>生产环境</strong>：<ul>\n<li><strong>最佳方案</strong>：配置你的<strong>反向代理</strong>（如 Nginx）来处理跨域请求。</li>\n<li><strong>备选方案</strong>：确保后端 API 正确配置了 CORS 头 (<code>Access-Control-Allow-Origin</code> 等)。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-认证和令牌-Authentication\"><a href=\"#3-认证和令牌-Authentication\" class=\"headerlink\" title=\"3. 认证和令牌 (Authentication)\"></a>3. 认证和令牌 (Authentication)</h4><p>如何安全地传递身份验证信息（如 JWT Token）。</p>\n<ul>\n<li><strong>使用请求拦截器</strong>：利用 <code>ofetch</code> 的自动全局拦截器。</li>\n<li>如何安全地传递身份验证信息（如 JWT Token）。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// plugins/api.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineNuxtPlugin</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; token &#125; = <span class=\"title function_\">useAuth</span>() <span class=\"comment\">// 假设你有一个获取 token 的 composable</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 全局拦截 $fetch 请求</span></span><br><span class=\"line\">  globalThis.<span class=\"property\">$fetch</span> = $fetch.<span class=\"title function_\">create</span>(&#123;</span><br><span class=\"line\">    <span class=\"title function_\">onRequest</span>(<span class=\"params\">&#123; request, options &#125;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 添加认证头</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (token.<span class=\"property\">value</span>) &#123;</span><br><span class=\"line\">        options.<span class=\"property\">headers</span> = &#123;</span><br><span class=\"line\">          ...options.<span class=\"property\">headers</span>,</span><br><span class=\"line\">          <span class=\"title class_\">Authorization</span>: <span class=\"string\">`Bearer <span class=\"subst\">$&#123;token.value&#125;</span>`</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">onRequestError</span>(<span class=\"params\">&#123; error &#125;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;Request error:&#x27;</span>, error)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"title function_\">onResponseError</span>(<span class=\"params\">&#123; response &#125;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 统一处理 401 未授权错误</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (response.<span class=\"property\">status</span> === <span class=\"number\">401</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 跳转到登录页</span></span><br><span class=\"line\">        <span class=\"title function_\">navigateTo</span>(<span class=\"string\">&#x27;/login&#x27;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-错误处理\"><a href=\"#4-错误处理\" class=\"headerlink\" title=\"4. 错误处理\"></a>4. 错误处理</h4><p>永远不要假设请求一定会成功。</p>\n<ul>\n<li><strong>使用 try-catch</strong>：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/endpoint&#x27;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Nuxt 3 的 $fetch 会自动抛出错误</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(<span class=\"string\">&#x27;API call failed:&#x27;</span>, error)</span><br><span class=\"line\">  <span class=\"comment\">// 在这里显示用户友好的错误信息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>使用 <strong><code>**useFetch**</code></strong> 的状态</strong>：</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">const &#123; data, error &#125; = useFetch(&#x27;/api/endpoint&#x27;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;error&quot;&gt;</span><br><span class=\"line\">    Failed to load data: &#123;&#123; error.message &#125;&#125;</span><br><span class=\"line\">    &lt;button @click=&quot;refresh&quot;&gt;Try Again&lt;/button&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-性能优化：避免重复请求\"><a href=\"#5-性能优化：避免重复请求\" class=\"headerlink\" title=\"5. 性能优化：避免重复请求\"></a>5. 性能优化：避免重复请求</h4><ul>\n<li><strong>Key 的妙用</strong>：<code>useAsyncData</code> 和 <code>useFetch</code> 会<strong>自动去重</strong>具有相同 key 的请求。确保为唯一的数据集提供唯一的 key。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果两个组件使用相同的 key，只会发出一个请求</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useAsyncData</span>(<span class=\"string\">&#x27;user-profile&#x27;</span>, <span class=\"function\">() =&gt;</span> $fetch(<span class=\"string\">&#x27;/api/profile&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>缓存</strong>：<code>$fetch</code> 默认不会缓存 HTTP 缓存。如果你需要利用 HTTP 缓存，可以在 headers 中设置，或者使用更高级的缓存策略。</li>\n</ul>\n<hr>\n<h3 id=\"三、最佳实践总结\"><a href=\"#三、最佳实践总结\" class=\"headerlink\" title=\"三、最佳实践总结\"></a>三、最佳实践总结</h3><ol>\n<li><strong>首选</strong>** <strong><code>**useFetch**</code></strong>&#x2F;**<code>**useAsyncData**</code>：用于在组件中获取数据，它们能智能处理 SSR 和 hydration。</li>\n<li><strong>明确数据获取时机</strong>：想清楚你需要的数<strong>据是应该在服务端获取（SEO 关键）还是客户端获取（用户相关）</strong>，并用 <code>server: false</code> 或 <code>useLazyFetch</code> 控制。</li>\n<li><strong>开发环境用代理解决 CORS</strong>：在 <code>nuxt.config.ts</code> 中配置代理，避免跨域问题。</li>\n<li><strong>统一处理认证和错误</strong>：通过插件创建配置好的 <code>$fetch</code> 实例，全局处理 token 和错误。</li>\n<li><strong>善待你的 API</strong>：合理使用 key 去重，避免重复请求；考虑分页、限流和缓存。</li>\n</ol>\n<p>遵循这些指南，你就能在 Nuxt 应用中高效、可靠地与后端 API 进行交互。</p>\n<h2 id=\"开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\"><a href=\"#开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\" class=\"headerlink\" title=\"开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？\"></a>开发环境需要配置代理是指客户端发起请求的情况下吗？服务端请求应该没有跨域问题吧？</h2><p><strong>你这个问题问得非常好，直击要害！你的理解完全正确。</strong></p>\n<p>是的，你的推理是精准的：</p>\n<ul>\n<li><strong>服务端（Node.js）发起的请求</strong>：没有跨域概念。跨域是<strong>浏览器</strong>强加的安全策略。Node.js 发请求就像你用 <code>curl</code> 或 Postman 一样，可以去任何地方，不存在 CORS 问题。</li>\n<li><strong>客户端（浏览器）发起的请求</strong>：受跨域限制。浏览器会拦截违反同源策略的请求。</li>\n</ul>\n<p><strong>因此，“开发环境配置代理” 主要就是为了解决 —— 在客户端发起请求时遇到的跨域问题。</strong></p>\n<hr>\n<h3 id=\"为什么开发环境会有客户端请求？\"><a href=\"#为什么开发环境会有客户端请求？\" class=\"headerlink\" title=\"为什么开发环境会有客户端请求？\"></a>为什么开发环境会有客户端请求？</h3><p>在 Nuxt 3 的 SSR 模式下，一个页面渲染通常涉及<strong>两次</strong>数据获取：</p>\n<ol>\n<li><strong>第一次（服务端请求 - 无 CORS）</strong>：<ul>\n<li>当用户直接访问页面 URL 时，请求会先到达你的 Nuxt 服务器。</li>\n<li>Nuxt 服务器执行 <code>useFetch</code> 或 <code>useAsyncData</code>，<strong>在服务器环境</strong>（Node.js）中向后端 API 发起请求。</li>\n<li>此时是 <strong>服务器对服务器</strong> 的通信，没有浏览器参与，所以<strong>没有 CORS 问题</strong>。</li>\n<li>服务器拿到数据后，渲染出包含内容的 HTML 并返回给浏览器。</li>\n</ul>\n</li>\n<li><strong>第二次（客户端请求 - 有 CORS 风险）</strong>：<ul>\n<li>浏览器收到 HTML 并展示后，会加载 Nuxt 的客户端 JS Bundle。</li>\n<li>Vue 开始 <strong>“激活” (Hydration)</strong> 过程。</li>\n<li>在这个过程中，<code>useFetch</code> 和 <code>useAsyncData</code> 的代码会在<strong>客户端浏览器环境</strong>中再次运行，以确保数据状态一致。</li>\n<li>如果它们的 URL 是<strong>绝对路径</strong>（如 <code>https://api.example.com/data</code>），那么这次请求就是由<strong>浏览器</strong>直接发起的，就会触发 CORS 检查。</li>\n<li>如果后端 API 没有正确配置 CORS 头，浏览器就会拦截这次请求，导致错误。</li>\n</ul>\n</li>\n</ol>\n<p>此外，还有几种常见的<strong>纯客户端请求</strong>场景：</p>\n<ul>\n<li>用户交互（如点击按钮）触发的 <code>$fetch</code> 请求。</li>\n<li>在 <code>onMounted</code> 钩子中发起的请求。</li>\n<li>使用 <code>useLazyFetch</code>（它默认在客户端执行）。</li>\n</ul>\n<h3 id=\"总结与最佳实践\"><a href=\"#总结与最佳实践\" class=\"headerlink\" title=\"总结与最佳实践\"></a>总结与最佳实践</h3><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>请求发起方</th>\n<th>是否有 CORS 问题？</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>SSR 首屏渲染</strong></td>\n<td>Nuxt Server (Node.js)</td>\n<td><strong>否</strong></td>\n<td>无需额外配置。但需确保服务器能访问到 API（网络连通性）。</td>\n</tr>\n<tr>\n<td><strong>CSR Hydration&#x2F;交互</strong></td>\n<td>浏览器</td>\n<td><strong>是</strong></td>\n<td><strong>配置开发服务器代理</strong>（如下方代码）。这是最推荐的方法。</td>\n</tr>\n<tr>\n<td><strong>生产环境</strong></td>\n<td>浏览器</td>\n<td><strong>是</strong></td>\n<td><strong>配置生产级反向代理</strong>（如 Nginx），或确保后端 API 正确设置 CORS 头。</td>\n</tr>\n</tbody></table>\n<h2 id=\"nuxt中的-fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\"><a href=\"#nuxt中的-fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\" class=\"headerlink\" title=\"nuxt中的$fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？\"></a>nuxt中的$fetch是只能在客户端调用吗？，useFetch和useAsyncData呢？</h2><p>非常好的问题！这是理解 Nuxt 3 数据获取的关键。它们的执行环境行为是核心区别。</p>\n<p>简单直接的答案是：<strong>不，</strong><code>**$fetch**</code>** <strong><strong>可以在服务端和客户端调用。而</strong></strong> <strong><code>**useFetch**</code></strong> <strong><strong>和</strong></strong> <strong><code>**useAsyncData**</code></strong> **<strong>的行为是智能的，默认在服务端执行。</strong></p>\n<p>下面我们来详细拆解这三者的区别。</p>\n<hr>\n<h3 id=\"一、-fetch：双环境通用的请求工具\"><a href=\"#一、-fetch：双环境通用的请求工具\" class=\"headerlink\" title=\"一、$fetch：双环境通用的请求工具\"></a>一、<code>$fetch</code>：双环境通用的请求工具</h3><p><code>$fetch</code> 是 Nuxt 3 基于 <a class=\"link\"   href=\"https://github.com/unjs/ofetch\" >ofetch<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 提供的全局工具函数。它本身<strong>没有环境限制</strong>，你在哪里调用它，它就在哪个环境执行。</p>\n<ul>\n<li><strong>在服务端（Node.js）调用</strong>：它就像一个普通的 Node.js HTTP 客户端（比如 <code>axios</code>），直接向后端发起请求，<strong>没有跨域概念</strong>。</li>\n<li><strong>在客户端（浏览器）调用</strong>：它的行为类似于原生的 <code>fetch()</code>，但功能更强大（自动处理 JSON、更好的错误处理等），并且<strong>受浏览器跨域策略限制</strong>。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 在组件 setup 中直接调用 - 根据渲染环境决定</span></span><br><span class=\"line\"><span class=\"comment\">// 如果在服务端渲染，它在服务端执行；如果在客户端激活或导航，它在客户端执行。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/items&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 在明确的服务端环境调用 - 只在服务端执行</span></span><br><span class=\"line\"><span class=\"comment\">// 例如：在 API 路由、服务器中间件或 plugin 中</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineEventHandler</span>(<span class=\"title function_\">async</span> (event) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;https://external-api.com/data&#x27;</span>); <span class=\"comment\">// 在服务器上运行</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; data &#125;;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 在明确的客户端环境调用 - 只在客户端执行</span></span><br><span class=\"line\"><span class=\"comment\">// 例如：在事件处理函数或 onMounted 中</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">handleClick</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/items&#x27;</span>); <span class=\"comment\">// 在浏览器中运行，受 CORS 限制</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>**$fetch**</code>** <strong><strong>的陷阱</strong>：如果你在组件顶层直接使用 <code>$fetch</code>（没有包裹在 <code>useAsyncData</code> 或 <code>useFetch</code> 中），并且该组件在服务端渲染，那么请求会在服务端执行。但当客户端激活（Hydration）时，<strong>同样的</strong></strong> <strong><code>**$fetch**</code></strong> **<strong>代码又会在客户端再执行一次</strong>，造成重复请求。</p>\n<hr>\n<h3 id=\"二、useAsyncData-useFetch：智能的双环境数据获取器\"><a href=\"#二、useAsyncData-useFetch：智能的双环境数据获取器\" class=\"headerlink\" title=\"二、useAsyncData &amp; useFetch：智能的双环境数据获取器\"></a>二、<code>useAsyncData</code> &amp; <code>useFetch</code>：智能的双环境数据获取器</h3><p>这两个组合函数是 Nuxt 数据获取的“智能大脑”。它们的关键特性是：<strong>“在服务端预取数据，并自动将数据序列化到客户端，避免重复请求”</strong>。</p>\n<h4 id=\"核心行为：\"><a href=\"#核心行为：\" class=\"headerlink\" title=\"核心行为：\"></a>核心行为：</h4><ol>\n<li><strong>默认在服务端执行</strong>：在 SSR 模式下，当页面首次加载时，它们会在 Nuxt 服务器内部执行，获取数据并直接将数据嵌入到最终返回的 HTML 中。</li>\n<li><strong>在客户端激活</strong>：当 Vue 在客户端“激活”静态页面时，<code>useAsyncData</code> 和 <code>useFetch</code> 会识别到数据已经存在于从服务器传递过来的 payload 中，因此<strong>不会在客户端再次发起请求</strong>，而是直接使用已有的数据。</li>\n<li><strong>后续导航</strong>：当你在客户端通过导航跳转到另一个也使用了这些函数的页面时，它们会在<strong>客户端</strong>执行。</li>\n</ol>\n<h4 id=\"如何控制执行环境？\"><a href=\"#如何控制执行环境？\" class=\"headerlink\" title=\"如何控制执行环境？\"></a>如何控制执行环境？</h4><p>它们提供了一个 <code>server</code> 选项让你精确控制：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认：true - 在服务端执行（SSR 首屏）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/items&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 强制在客户端执行（CSR）</span></span><br><span class=\"line\"><span class=\"comment\">// 适合：用户相关的数据、不需要 SEO 的数据、访问浏览器 API 的数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/user-data&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">server</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// useAsyncData 用法相同</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useAsyncData</span>(<span class=\"string\">&#x27;user-key&#x27;</span>, <span class=\"function\">() =&gt;</span> $fetch(<span class=\"string\">&#x27;/api/user&#x27;</span>), &#123;</span><br><span class=\"line\">  <span class=\"attr\">server</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、三者的对比总结\"><a href=\"#三、三者的对比总结\" class=\"headerlink\" title=\"三、三者的对比总结\"></a>三、三者的对比总结</h3><p>为了更直观地理解，下面的流程图展示了不同调用方式在 Nuxt 应用生命周期中的执行时机和数据流向：</p>\n<p>这个图清晰地展示了：</p>\n<ol>\n<li><code>**useFetch**</code><strong>&#x2F;</strong><code>**useAsyncData**</code> 是贯穿服务端和客户端的“智能通道”，保证了数据的高效同步和无重复请求。</li>\n<li><strong>直接使用</strong>** **<code>**$fetch**</code> 在组件顶层会导致重复请求，是需要避免的反模式。</li>\n<li><strong>在事件中使用的</strong>** **<code>**$fetch**</code> 是纯客户端行为。</li>\n</ol>\n<h3 id=\"最佳实践与选择指南\"><a href=\"#最佳实践与选择指南\" class=\"headerlink\" title=\"最佳实践与选择指南\"></a>最佳实践与选择指南</h3><table>\n<thead>\n<tr>\n<th>场景</th>\n<th>推荐使用的工具</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>获取页面组件所需数据</strong></td>\n<td><code>**useFetch**</code><br/>** <strong><strong>或</strong></strong> **<code>**useAsyncData**</code></td>\n<td>自动处理 SSR&#x2F;CSR，避免重复请求，数据序列化到客户端。</td>\n</tr>\n<tr>\n<td><strong>在事件处理、</strong><code>**onMounted**</code><br/>** **<strong>中获取数据</strong></td>\n<td><code>**$fetch**</code></td>\n<td>明确需要在客户端触发的请求。</td>\n</tr>\n<tr>\n<td><strong>在 API 路由或服务器中间件中</strong></td>\n<td><code>**$fetch**</code></td>\n<td>明确的服务端环境，无需 <code>useAsyncData</code><br/> 的额外功能。</td>\n</tr>\n<tr>\n<td><strong>需要复杂的数据获取逻辑</strong></td>\n<td><code>**useAsyncData**</code><br/>** <strong><strong>+</strong></strong> **<code>**$fetch**</code></td>\n<td><code>useAsyncData</code><br/> 提供状态管理，内部函数可使用 <code>$fetch</code><br/> 进行复杂操作。</td>\n</tr>\n<tr>\n<td><strong>简单的 URL 请求</strong></td>\n<td><code>**useFetch**</code></td>\n<td>最简洁的写法。</td>\n</tr>\n</tbody></table>\n<p><strong>一句话总结：</strong></p>\n<ul>\n<li><strong>用</strong>** <strong><code>**useFetch**</code></strong>&#x2F;<strong><code>**useAsyncData**</code> 来获取</strong>组件初始化时所需的数据**，让 Nuxt 智能决定执行环境。</li>\n<li><strong>用</strong>** <strong><code>**$fetch**</code> 在</strong>明确的客户端交互<strong>或</strong>明确的服务端环境**中主动发起请求。</li>\n</ul>\n<p>遵循这个原则，你就能高效且正确地在 Nuxt 应用中处理数据获取。</p>\n<h2 id=\"激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\"><a href=\"#激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\" class=\"headerlink\" title=\"激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？\"></a>激活客户端需要开发手动调用什么api吗，服务端异步获取的数据注入到html这一步开发需要做什么？到客户端时如何获取数据呢？</h2><p>这些问题触及了 Nuxt.js SSR 的核心魔法。好消息是，<strong>这个过程绝大部分是自动化的，开发者几乎不需要手动干预</strong>。Nuxt 和 Vue 底层已经为你处理好了一切。</p>\n<p>下面我来逐一解答你的问题，你会看到 Nuxt 的设计是多么巧妙。</p>\n<hr>\n<h3 id=\"一、激活客户端需要开发手动调用什么-API-吗？\"><a href=\"#一、激活客户端需要开发手动调用什么-API-吗？\" class=\"headerlink\" title=\"一、激活客户端需要开发手动调用什么 API 吗？\"></a>一、激活客户端需要开发手动调用什么 API 吗？</h3><p><strong>答：完全不需要。这是 Vue 和 Nuxt 自动完成的。</strong></p>\n<p>这个过程称为 <strong>Hydration（混合）</strong>。它的流程是：</p>\n<ol>\n<li><strong>自动执行</strong>：当浏览器加载完 Nuxt 发送过来的 HTML 和客户端 JavaScript 包后，Vue 会自动启动。</li>\n<li><strong>自动匹配</strong>：Vue 会将它的虚拟 DOM 与服务器渲染好的、已经存在的静态 HTML 结构进行对比和匹配。</li>\n<li><strong>自动“激活”</strong>：Vue 不会重新创建 DOM 元素，而是会将事件监听器、响应式数据系统等“附加”到这些现有的 DOM 元素上，使静态页面瞬间变为一个完全交互式的 Vue 应用。</li>\n</ol>\n<p><strong>作为开发者，你唯一要做的就是：</strong></p>\n<ul>\n<li>确保你的代码是<strong>同构的</strong>（即同一份代码既能在 Node.js 环境运行，也能在浏览器环境运行）。</li>\n<li>避免在 <code>created</code> 或 <code>setup</code> 等生命周期中使用浏览器特有的 API（如 <code>window</code>, <code>document</code>），或者使用 <code>onMounted</code>（仅在客户端执行）来包裹它们。</li>\n</ul>\n<p><strong>你不用写任何像</strong>** <strong><code>**app.hydrate()**</code></strong> **<strong>这样的代码，一切都是开箱即用、自动发生的。</strong></p>\n<hr>\n<h3 id=\"二、服务端异步获取的数据注入到-HTML-这一步开发需要做什么？\"><a href=\"#二、服务端异步获取的数据注入到-HTML-这一步开发需要做什么？\" class=\"headerlink\" title=\"二、服务端异步获取的数据注入到 HTML 这一步开发需要做什么？\"></a>二、服务端异步获取的数据注入到 HTML 这一步开发需要做什么？</h3><p><strong>答：你只需要使用正确的 API（</strong><code>**useAsyncData**</code>** <strong><strong>或</strong></strong> <strong><code>**useFetch**</code></strong>），Nuxt 就会自动完成注入。**</p>\n<p>这个“注入”过程在 Nuxt 中被称为 <strong>State Serialization（状态序列化）</strong> 或 ** dehydration（脱水）**。</p>\n<p><strong>你的工作（非常简单）：</strong></p>\n<ol>\n<li>**使用 <strong><code>**useAsyncData**</code></strong> 或 **<code>**useFetch**</code>：在你的页面组件中，用它们来获取数据。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">  // pages/posts.vue</span><br><span class=\"line\">  const &#123; data: posts &#125; = await useFetch(&#x27;/api/posts&#x27;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>Nuxt 自动完成后续所有事情</strong>：<ul>\n<li>Nuxt 在服务端执行完 <code>useFetch</code> 后，会<strong>自动</strong>将 <code>posts</code> 数据序列化为 JSON 字符串。</li>\n<li>将这个 JSON 字符串<strong>自动嵌入</strong>到最终 HTML 的 <code>&lt;head&gt;</code> 部分的一个 <code>&lt;script&gt;</code> 标签中。</li>\n<li>这个标签的内容通常是 <code>window.__NUXT__ = &#123; ... &#125;</code>，其中就包含了所有页面的预取数据。</li>\n</ul>\n</li>\n</ol>\n<p><strong>你不需要手动操作 DOM 去注入数据，Nuxt 的渲染引擎为你包办了一切。</strong></p>\n<hr>\n<h3 id=\"三、到客户端时如何获取数据呢？\"><a href=\"#三、到客户端时如何获取数据呢？\" class=\"headerlink\" title=\"三、到客户端时如何获取数据呢？\"></a>三、到客户端时如何获取数据呢？</h3><p><strong>答：客户端 Vue 应用会自动从</strong>** <strong><code>**window.__NUXT__**</code></strong> **<strong>中提取并复用数据，无需再次请求。</strong></p>\n<p>这个过程是 <strong>State Deserialization（状态反序列化）</strong> 或 <strong>rehydration（补水）</strong>。</p>\n<p><strong>它的自动流程如下：</strong></p>\n<ol>\n<li><strong>数据随 HTML 到达浏览器</strong>：HTML 中的 <code>&lt;script&gt;window.__NUXT__ = &#123;...&#125;&lt;/script&gt;</code> 会先被执行，将数据挂载到全局对象上。</li>\n<li><strong>客户端 Vue 应用启动</strong>：客户端的 JavaScript 包加载完毕后，Vue 和 Nuxt 开始初始化。</li>\n<li><strong>自动提取数据</strong>：当客户端的 <code>useFetch(&#39;/api/posts&#39;)</code> 代码执行时，它不会真正去发起网络请求，而是会<strong>先自动去</strong>** <strong><code>**window.__NUXT__**</code></strong> **<strong>对象里查找</strong>，看是否存在服务端已经为它准备好的数据。</li>\n<li><strong>直接复用数据</strong>：如果找到了，它就直接使用这份数据，完全跳过网络请求。这样就保证了客户端和服务端的数据状态<strong>绝对一致</strong>，这也是 Hydration 能成功的前提。</li>\n</ol>\n<p><strong>你可以通过 <strong><code>**useNuxtData**</code></strong> 这个工具函数来验证和访问这些被缓存的数据：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 在客户端，你可以这样访问之前服务端获取的、被缓存的数据</span><br><span class=\"line\">const &#123; data: posts &#125; = useNuxtData(&#x27;posts&#x27;) // 使用 useFetch 时自动生成的 key</span><br><span class=\"line\"></span><br><span class=\"line\">// 这不会导致第二次请求，它只是从客户端缓存中读取</span><br><span class=\"line\">console.log(posts.value)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\"><a href=\"#服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\" class=\"headerlink\" title=\"服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？\"></a>服务端将预取数据潜入到script标签中并挂载到window上，那么预取数据是不是不能包含用户登录等敏感信息，否则不安全？</h2><p><strong>你这个问题问得非常非常关键，切中了SSR安全的核心！你的直觉完全正确。</strong></p>\n<p><strong>绝对不应该将任何敏感信息（如用户凭证、Token、个人身份信息PII等）内联到HTML的</strong>** <strong><code>**&lt;script&gt;**</code></strong> <strong><strong>标签中，并通过</strong></strong> <strong><code>**window.__NUXT__**</code></strong> **<strong>暴露给客户端。</strong></p>\n<p>这样做会带来严重的安全风险：</p>\n<ol>\n<li><strong>数据泄露</strong>：任何能打开浏览器开发者工具的人，都可以直接看到 <code>window.__NUXT__</code> 里的全部内容。</li>\n<li><strong>XSS攻击加剧</strong>：如果你的应用存在XSS（跨站脚本）漏洞，攻击者可以更容易地编写脚本窃取 <code>window.__NUXT__</code> 中的所有数据，而不必费力去窃取多个API请求的返回结果。</li>\n<li><strong>缓存风险</strong>：HTML页面可能会被CDN、代理服务器或浏览器缓存。如果其中包含了用户敏感信息，就意味着这些信息也可能被缓存并泄露给其他用户。</li>\n</ol>\n<hr>\n<h3 id=\"那么，如何处理需要认证的敏感数据？\"><a href=\"#那么，如何处理需要认证的敏感数据？\" class=\"headerlink\" title=\"那么，如何处理需要认证的敏感数据？\"></a>那么，如何处理需要认证的敏感数据？</h3><p>正确的做法是将敏感数据与非敏感数据<strong>分离</strong>，并遵循“<strong>按需索取</strong>”和“<strong>最小化暴露</strong>”的原则。以下是几种安全策略：</p>\n<h4 id=\"策略一：敏感数据绝不预取，仅在客户端获取\"><a href=\"#策略一：敏感数据绝不预取，仅在客户端获取\" class=\"headerlink\" title=\"策略一：敏感数据绝不预取，仅在客户端获取\"></a>策略一：敏感数据绝不预取，仅在客户端获取</h4><p>这是最常用、最安全的策略。用户登录状态、个人资料等高度敏感的数据，<strong>不应该</strong>在服务端的 <code>useFetch</code>&#x2F;<code>useAsyncData</code> 中获取。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 1. 非敏感、SEO需要的数据：在服务端预取（安全）</span><br><span class=\"line\">const &#123; data: publicPosts &#125; = await useFetch(&#x27;/api/public-posts&#x27;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 2. 敏感的用户数据：不在服务端预取，只在客户端获取</span><br><span class=\"line\">const user = ref(null)</span><br><span class=\"line\">const token = useCookie(&#x27;auth-token&#x27;) // Token应存放在HttpOnly Cookie中</span><br><span class=\"line\"></span><br><span class=\"line\">// 在客户端挂载后，再安全地获取用户数据</span><br><span class=\"line\">onMounted(async () =&gt; &#123;</span><br><span class=\"line\">  if (token.value) &#123;</span><br><span class=\"line\">    // 此请求在客户端发起，携带Cookie中的token</span><br><span class=\"line\">    user.value = await $fetch(&#x27;/api/me&#x27;, &#123;</span><br><span class=\"line\">      headers: &#123;</span><br><span class=\"line\">        // 通常Token会自动通过Cookie发送，无需手动设置，这里演示逻辑</span><br><span class=\"line\">        Authorization: `Bearer $&#123;token.value&#125;`</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;!-- 公开数据直接渲染 --&gt;</span><br><span class=\"line\">  &lt;div v-for=&quot;post in publicPosts&quot; :key=&quot;post.id&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &lt;!-- 用户数据，等客户端获取后再显示 --&gt;</span><br><span class=\"line\">  &lt;div v-if=&quot;user&quot;&gt;Welcome, &#123;&#123; user.name &#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"策略二：使用-useState-进行状态管理，区分服务端与客户端状态\"><a href=\"#策略二：使用-useState-进行状态管理，区分服务端与客户端状态\" class=\"headerlink\" title=\"策略二：使用 useState 进行状态管理，区分服务端与客户端状态\"></a>策略二：使用 <code>useState</code> 进行状态管理，区分服务端与客户端状态</h4><p>你可以利用 <code>useState</code> 的灵活性来管理不同环境的状态。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 创建一个响应式状态，服务端先初始化为 null</span><br><span class=\"line\">const secretData = useState(&#x27;secret-data&#x27;, () =&gt; null)</span><br><span class=\"line\"></span><br><span class=\"line\">// 在客户端再获取真实数据</span><br><span class=\"line\">onMounted(async () =&gt; &#123;</span><br><span class=\"line\">  if (!secretData.value) &#123; // 避免在服务端执行</span><br><span class=\"line\">    secretData.value = await $fetch(&#x27;/api/secret-data&#x27;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"策略三：API-设计分离-提供公开和私密端点\"><a href=\"#策略三：API-设计分离-提供公开和私密端点\" class=\"headerlink\" title=\"策略三：API 设计分离 - 提供公开和私密端点\"></a>策略三：API 设计分离 - 提供公开和私密端点</h4><p>从后端设计上就进行分离：</p>\n<ul>\n<li><code>/api/public/data</code>：返回不敏感的数据，可以安全地在服务端渲染。</li>\n<li><code>/api/private/user-data</code>：返回敏感数据，必须认证且在客户端获取。</li>\n</ul>\n<hr>\n<h3 id=\"Nuxt-如何安全地处理认证？\"><a href=\"#Nuxt-如何安全地处理认证？\" class=\"headerlink\" title=\"Nuxt 如何安全地处理认证？\"></a>Nuxt 如何安全地处理认证？</h3><p>认证的最佳实践是使用 <strong>HttpOnly Cookies</strong> 来传输令牌（Token），而不是通过 <code>window.__NUXT__</code> 或 JS 可读的 Cookie。</p>\n<ol>\n<li><strong>登录流程</strong>：<ul>\n<li>用户提交登录表单，客户端 <code>$fetch</code> 发送到 <code>/api/auth/login</code>。</li>\n<li><strong>后端</strong>验证成功后，设置一个 <strong>HttpOnly、Secure、SameSite&#x3D;Strict</strong> 的 Cookie（包含认证Token）。这个 Cookie 对 JavaScript 不可见，极大地增强了安全性。</li>\n<li>前端只需知道登录成功，无需接触 Token 本身。</li>\n</ul>\n</li>\n<li><strong>获取用户数据</strong>：<ul>\n<li>在客户端，调用 <code>$fetch(&#39;/api/me&#39;)</code>。</li>\n<li>浏览器会<strong>自动</strong>在请求中带上 HttpOnly Cookie。</li>\n<li>后端验证 Cookie 中的 Token 有效性后，返回对应用户的数据。</li>\n</ul>\n</li>\n<li><strong>服务端渲染中的认证</strong>：<ul>\n<li>如果服务端需要根据用户状态渲染不同内容（例如“您好，用户名”），可以通过<strong>服务器中间件</strong>或 <strong>API 路由</strong>来处理。</li>\n<li>服务端可以读取请求中的 Cookie，去后端验证用户身份，然后决定返回什么数据。但这个验证过程发生在后端，结果信息需要是<strong>非敏感</strong>的（例如只返回 <code>username</code>，而不是返回 <code>token</code> 或 <code>email</code>）。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">// 服务端可以安全地读取Cookie并获取非敏感的用户显示信息</span><br><span class=\"line\">const &#123; data: userInfo &#125; = await useFetch(&#x27;/api/user-display-info&#x27;)</span><br><span class=\"line\">// 这个 `/api/user-display-info` 接口在后端会验证Cookie，</span><br><span class=\"line\">// 但只返回 &#123; name: &#x27;John&#x27; &#125; 这样的非敏感信息用于界面显示。</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li><strong>核心原则</strong>：<strong>绝不将敏感数据内联到 HTML 中</strong>。<code>window.__NUXT__</code> 应该是“公开的”或“非敏感的”。</li>\n<li><strong>数据分离</strong>：将数据分为“公开”和“私密”两类。公开数据用 <code>useFetch</code> 服务端预取；私密数据在客户端用 <code>$fetch</code> 按需获取。</li>\n<li><strong>认证最佳实践</strong>：使用 <strong>HttpOnly Cookies</strong> 来安全地传输认证凭证，而不是将其暴露给客户端 JavaScript 或 <code>window</code> 对象。</li>\n<li><strong>信任后端</strong>：敏感的权限检查和数据处理逻辑应该始终放在后端 API 中。前端（包括SSR服务端）只负责展示非敏感的结果。</li>\n</ol>\n<p>你的安全意识非常到位，遵循这些原则可以让你构建出既高效又安全的 Nuxt.js 应用。</p>\n<h2 id=\"除此之外，服务端渲染还有什么不能实现的呢？canvas？\"><a href=\"#除此之外，服务端渲染还有什么不能实现的呢？canvas？\" class=\"headerlink\" title=\"除此之外，服务端渲染还有什么不能实现的呢？canvas？\"></a>除此之外，服务端渲染还有什么不能实现的呢？canvas？</h2><p>说得非常对！<strong>Canvas</strong> 是一个绝佳的例子，它完美地揭示了服务端渲染（SSR）的“盲区”。</p>\n<p>SSR 的核心是<strong>生成静态的 HTML 和 CSS 字符串</strong>。因此，任何<strong>动态的、依赖于浏览器 JavaScript 运行时环境</strong>的功能，在纯 SSR 阶段都无法实现或功能不全。</p>\n<p>除了 Canvas，还有很多类似的限制。我们可以将它们分为几大类：</p>\n<hr>\n<h3 id=\"一、浏览器特有的-API-和全局对象\"><a href=\"#一、浏览器特有的-API-和全局对象\" class=\"headerlink\" title=\"一、浏览器特有的 API 和全局对象\"></a>一、浏览器特有的 API 和全局对象</h3><p>这是最直接的一类。在 Node.js 服务器环境中，根本没有 <code>window</code>, <code>document</code>, <code>navigator</code> 等对象。</p>\n<table>\n<thead>\n<tr>\n<th>API&#x2F;功能</th>\n<th>原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>**window**</code><strong>、</strong><code>**document**</code></td>\n<td>Node.js 中不存在。</td>\n<td>使用 <code>onMounted</code>钩子或 <code>clientOnly</code>组件确保只在客户端访问。</td>\n</tr>\n<tr>\n<td><code>**alert**</code><strong>、</strong><code>**confirm**</code><strong>、</strong><code>**prompt**</code></td>\n<td>浏览器交互对话框。</td>\n<td>逻辑移至客户端，或使用基于组件的替代品（如模态框）。</td>\n</tr>\n<tr>\n<td><strong>Canvas (</strong><code>**&lt;canvas&gt;**</code><strong>) &#x2F; WebGL</strong></td>\n<td>需要浏览器渲染上下文来绘图和操作像素。</td>\n<td><strong>只能在客户端初始化和使用</strong>。SSR 只能渲染一个空画布。</td>\n</tr>\n<tr>\n<td><strong>地理位置 (</strong><code>**navigator.geolocation**</code><strong>)</strong></td>\n<td>需要用户的浏览器授权和设备硬件支持。</td>\n<td>仅在客户端通过 <code>onMounted</code>或用户交互触发。</td>\n</tr>\n<tr>\n<td><strong>本地存储 (</strong><code>**localStorage**</code><strong>, <strong><code>**sessionStorage**</code></strong>, <strong><code>**IndexedDB**</code></strong>)</strong></td>\n<td>是浏览器的持久化存储机制。</td>\n<td>在 <code>onMounted</code>中访问，或使用 <code>useLocalStorage</code>等组合式函数（内部做了客户端检查）。</td>\n</tr>\n<tr>\n<td><strong>媒体设备 (</strong><code>**navigator.mediaDevices**</code><strong>)</strong></td>\n<td>需要访问麦克风、摄像头等硬件。</td>\n<td>完全的用户客户端行为。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"二、依赖浏览器渲染或布局的功能\"><a href=\"#二、依赖浏览器渲染或布局的功能\" class=\"headerlink\" title=\"二、依赖浏览器渲染或布局的功能\"></a>二、依赖浏览器渲染或布局的功能</h3><p>这类功能需要知道元素的真实尺寸和位置，而这些信息在纯字符串的 SSR 阶段是无法获得的。</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>元素尺寸&#x2F;位置</strong> (如 <code>element.offsetWidth</code><br/>, <code>getBoundingClientRect()</code><br/>)</td>\n<td>SSR 只有 HTML 字符串，没有真实的布局和渲染。</td>\n<td>在 <code>onMounted</code><br/> 后使用，或使用 Vue 的 <code>nextTick</code><br/> 确保 DOM 已更新。</td>\n</tr>\n<tr>\n<td><strong>基于尺寸的渲染</strong> (如图表库 ECharts、D3.js)</td>\n<td>需要挂载到真实 DOM 元素并获取其宽高才能渲染。</td>\n<td>在 <code>onMounted</code><br/> 中初始化图表实例。</td>\n</tr>\n<tr>\n<td><strong>动画 (CSS 动画除外)</strong></td>\n<td>许多 JS 动画库需要操作 DOM 样式。</td>\n<td>使用 <code>onMounted</code><br/> 启动动画，或使用 CSS 动画（SSR 支持）。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"三、用户交互和状态\"><a href=\"#三、用户交互和状态\" class=\"headerlink\" title=\"三、用户交互和状态\"></a>三、用户交互和状态</h3><p>SSR 输出的是一个“快照”，无法预知用户未来的行为。</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>用户输入</strong> (表单输入、焦点状态)</td>\n<td>SSR 无法预知用户会输入什么。</td>\n<td>SSR 可以渲染表单结构，但交互和值绑定必须在客户端完成。</td>\n</tr>\n<tr>\n<td><strong>鼠标事件、键盘事件</strong></td>\n<td>纯静态环境，无用户交互。</td>\n<td>完全由客户端 JavaScript 处理。</td>\n</tr>\n<tr>\n<td><strong>浏览器标签页可见性</strong> (<code>document.visibilityState</code>)</td>\n<td>依赖于用户当前的浏览器状态。</td>\n<td>纯客户端逻辑。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"四、第三方库\"><a href=\"#四、第三方库\" class=\"headerlink\" title=\"四、第三方库\"></a>四、第三方库</h3><p>许多强大的第三方库在设计时就是为浏览器而生的。</p>\n<table>\n<thead>\n<tr>\n<th>库类型</th>\n<th>问题</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>地图库</strong> (如 Leaflet, Google Maps)</td>\n<td>需要挂载到 DOM 并初始化地图渲染上下文。</td>\n<td>使用 <code>onMounted</code><br/> 初始化，或使用 Nuxt 模块（如 <code>nuxt-leaflet</code><br/>）。</td>\n</tr>\n<tr>\n<td><strong>可视化库</strong> (如 D3, Three.js)</td>\n<td>严重依赖 Canvas、WebGL 或 SVG 操作。</td>\n<td><strong>只能在客户端运行</strong>。</td>\n</tr>\n<tr>\n<td><strong>分析&#x2F;广告库</strong> (如 Google Analytics)</td>\n<td>依赖 <code>window</code><br/> 对象和浏览器环境来跟踪用户。</td>\n<td>使用 Nuxt 插件（<code>client: true</code><br/> 选项）或直接在 <code>onMounted</code><br/> 中加载。</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"如何安全地处理这些限制？Nuxt-提供的解决方案\"><a href=\"#如何安全地处理这些限制？Nuxt-提供的解决方案\" class=\"headerlink\" title=\"如何安全地处理这些限制？Nuxt 提供的解决方案\"></a>如何安全地处理这些限制？Nuxt 提供的解决方案</h3><p>Nuxt 提供了一系列模式来优雅地解决这些问题：</p>\n<h4 id=\"1-onMounted-钩子-最常用\"><a href=\"#1-onMounted-钩子-最常用\" class=\"headerlink\" title=\"1. onMounted 钩子 (最常用)\"></a>1. <code>onMounted</code> 钩子 (最常用)</h4><p>确保代码只在客户端执行。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">import &#123; onMounted &#125; from &#x27;vue&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">const canvas = ref(null)</span><br><span class=\"line\"></span><br><span class=\"line\">onMounted(() =&gt; &#123;</span><br><span class=\"line\">  // 现在可以安全地访问 DOM 和浏览器 API 了</span><br><span class=\"line\">  const ctx = canvas.value.getContext(&#x27;2d&#x27;)</span><br><span class=\"line\">  ctx.fillStyle = &#x27;green&#x27;</span><br><span class=\"line\">  ctx.fillRect(10, 10, 150, 100)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;!-- SSR 会渲染一个空画布 --&gt;</span><br><span class=\"line\">  &lt;canvas ref=&quot;canvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-条件渲染与-组件\"><a href=\"#2-条件渲染与-组件\" class=\"headerlink\" title=\"2. 条件渲染与 &lt;ClientOnly&gt; 组件\"></a>2. 条件渲染与 <code>&lt;ClientOnly&gt;</code> 组件</h4><p>防止不支持 SSR 的组件在服务器端渲染时出错。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;!-- 默认插槽只在客户端渲染 --&gt;</span><br><span class=\"line\">  &lt;ClientOnly&gt;</span><br><span class=\"line\">    &lt;MyChartThatUsesWindow /&gt;</span><br><span class=\"line\">    &lt;!-- 可以设置回退内容，在SSR阶段显示 --&gt;</span><br><span class=\"line\">    &lt;template #fallback&gt;</span><br><span class=\"line\">      &lt;div&gt;Loading chart...&lt;/div&gt;</span><br><span class=\"line\">    &lt;/template&gt;</span><br><span class=\"line\">  &lt;/ClientOnly&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-使用-process-client-标志进行运行时检查\"><a href=\"#3-使用-process-client-标志进行运行时检查\" class=\"headerlink\" title=\"3. 使用 process.client 标志进行运行时检查\"></a>3. 使用 <code>process.client</code> 标志进行运行时检查</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\">if (process.client) &#123;</span><br><span class=\"line\">  // 此代码块只在客户端打包时包含，并在客户端执行</span><br><span class=\"line\">  console.log(&#x27;I am on the client!&#x27;, window.innerWidth)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-为第三方库创建客户端插件\"><a href=\"#4-为第三方库创建客户端插件\" class=\"headerlink\" title=\"4. 为第三方库创建客户端插件\"></a>4. 为第三方库创建客户端插件</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// plugins/analytics.client.js - 注意 .client 后缀</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineNuxtPlugin</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这个插件只会在客户端运行</span></span><br><span class=\"line\">  <span class=\"variable language_\">window</span>.<span class=\"property\">dataLayer</span> = <span class=\"variable language_\">window</span>.<span class=\"property\">dataLayer</span> || []</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">gtag</span>(<span class=\"params\"></span>)&#123; dataLayer.<span class=\"title function_\">push</span>(<span class=\"variable language_\">arguments</span>) &#125;</span><br><span class=\"line\">  <span class=\"title function_\">gtag</span>(<span class=\"string\">&#x27;js&#x27;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>())</span><br><span class=\"line\">  <span class=\"title function_\">gtag</span>(<span class=\"string\">&#x27;config&#x27;</span>, <span class=\"string\">&#x27;GA_MEASUREMENT_ID&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结-2\"><a href=\"#总结-2\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>服务端渲染 (SSR) 的本质是<strong>静态化</strong>，它擅长的是：</p>\n<ul>\n<li><strong>生成初始 HTML 内容</strong></li>\n<li><strong>提供更好的 SEO</strong></li>\n<li><strong>提升首屏加载性能</strong></li>\n</ul>\n<p>而<strong>动态交互</strong>和<strong>浏览器依赖</strong>永远是 SSR 的盲区，必须交给客户端处理。</p>\n<p><strong>因此，一个成熟的 Nuxt 应用是两者结合的“混合体”：</strong></p>\n<ol>\n<li><strong>服务端</strong>：生成静态结构和首屏内容。</li>\n<li><strong>客户端</strong>：“激活”页面，接管所有交互，并加载那些依赖浏览器环境的动态功能。</li>\n</ol>\n<p>你的工作就是清晰地界定哪些逻辑属于服务端，哪些属于客户端，并使用 Nuxt 提供的模式（<code>onMounted</code>, <code>&lt;ClientOnly&gt;</code>, <code>.client</code> 插件）将它们优雅地结合起来。</p>\n<h2 id=\"nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\"><a href=\"#nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\" class=\"headerlink\" title=\"nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？\"></a>nuxt中，客户端激活后，发起请求nuxt的中间件，会有跨域问题吗？</h2><p>这是一个非常好的问题，它触及了 Nuxt 全栈架构的核心优势。</p>\n<p><strong>简单而直接的答案是：不会。在客户端激活后，向同源的 Nuxt 中间件或 API 路由发起请求，绝对不会产生跨域问题。</strong></p>\n<p>这是因为你发起请求的目标和你的页面来源是<strong>完全同源的</strong>。</p>\n<hr>\n<h3 id=\"为什么不会跨域？——-同源策略详解\"><a href=\"#为什么不会跨域？——-同源策略详解\" class=\"headerlink\" title=\"为什么不会跨域？—— 同源策略详解\"></a>为什么不会跨域？—— 同源策略详解</h3><p>让我们回顾一下“同源策略”：当协议、域名、端口都相同时，即为同源，浏览器允许请求。</p>\n<p>假设你的 Nuxt 应用部署在：<br><code>https://www.my-app.com</code></p>\n<ol>\n<li><strong>你的页面来源</strong>：<br>浏览器中显示的地址是：<code>https://www.my-app.com/some-page</code></li>\n<li><strong>你请求的目标</strong>：<br>你在代码中发起的请求是：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用相对路径，目标自动补全为：https://www.my-app.com/api/hello</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> $fetch(<span class=\"string\">&#x27;/api/hello&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用 useFetch（同样基于相对路径）</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"title function_\">useFetch</span>(<span class=\"string\">&#x27;/api/auth/user&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>对比</strong>：<ul>\n<li><strong>协议</strong>：都是 <code>https</code></li>\n<li><strong>域名</strong>：都是 <code>www.my-app.com</code></li>\n<li><strong>端口</strong>：都是 <code>443</code> (HTTPS 默认端口)</li>\n</ul>\n</li>\n</ol>\n<p><strong>结论</strong>：<strong>完全同源</strong>，浏览器欣然放行，没有任何跨域限制。</p>\n<hr>\n<h3 id=\"Nuxt-如何处理这些请求？——-请求生命周期\"><a href=\"#Nuxt-如何处理这些请求？——-请求生命周期\" class=\"headerlink\" title=\"Nuxt 如何处理这些请求？—— 请求生命周期\"></a>Nuxt 如何处理这些请求？—— 请求生命周期</h3><p>理解这个过程能让你更清楚为什么这是安全的：</p>\n<p>如图所示，无论是开发还是生产环境，<strong>你的 API 请求和前端页面都由同一个主机处理</strong>。它们处于同一个“生态系统”内，通信是内部的、安全的，不存在跨域问题。</p>\n<hr>\n<h3 id=\"什么情况下会有跨域问题？\"><a href=\"#什么情况下会有跨域问题？\" class=\"headerlink\" title=\"什么情况下会有跨域问题？\"></a>什么情况下会有跨域问题？</h3><p>只有当你的<strong>页面来源</strong>和<strong>请求目标</strong>不同源时，才会触发跨域。例如：</p>\n<table>\n<thead>\n<tr>\n<th>你的页面在</th>\n<th>你请求的目标</th>\n<th>是否跨域</th>\n<th>原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>https://www.my-app.com</code></td>\n<td><code>https://www.my-app.com/api/hello</code></td>\n<td><strong>否</strong></td>\n<td>同源</td>\n</tr>\n<tr>\n<td><code>https://www.my-app.com</code></td>\n<td><code>https://api.my-app.com</code></td>\n<td><strong>是</strong></td>\n<td>子域名不同 (<code>www</code> vs <code>api</code>)</td>\n</tr>\n<tr>\n<td><code>http://localhost:3000</code></td>\n<td><code>https://api.third-party.com</code></td>\n<td><strong>是</strong></td>\n<td>完全不同的域名</td>\n</tr>\n<tr>\n<td><code>https://www.my-app.com</code></td>\n<td><code>http://www.my-app.com/api/hello</code></td>\n<td><strong>是</strong></td>\n<td>协议不同 (<code>https</code>vs <code>http</code>)</td>\n</tr>\n</tbody></table>\n<p><strong>对于最后一种情况（生产环境前后端分离），解决方案是：</strong></p>\n<ol>\n<li><strong>后端配置 CORS</strong>：在你的 <code>api.my-app.com</code> 服务器上设置 <code>Access-Control-Allow-Origin: https://www.my-app.com</code> 响应头。</li>\n<li><strong>使用反向代理</strong>：配置你的生产服务器（如 Nginx），将对 <code>/api/</code> 的请求代理到 <code>api.my-app.com</code>，让浏览器始终觉得是在请求同源地址。这是更推荐的做法。</li>\n</ol>\n<h3 id=\"总结-3\"><a href=\"#总结-3\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><strong>在 Nuxt 应用中，请求自身的 API 路由 (</strong><code>**/api/xxx**</code><strong>) 或服务器中间件是绝对同源的，没有跨域问题。</strong></li>\n<li>这是 Nuxt 全栈框架的巨大优势之一，它简化了开发，让你无需在开发阶段为 CORS 烦恼。</li>\n<li>跨域问题只会在你请求<strong>外部第三方 API</strong> 且对方未正确配置 CORS 时出现。</li>\n<li>如果你的生产环境是前后端完全分离的（不同域），那么需要在生产环境的<strong>后端配置 CORS</strong> 或通过<strong>反向代理</strong>来解决。</li>\n</ul>\n<p>所以，请放心地在你的 Nuxt 应用内部调用 API，这是最安全、最正确的做法。</p>\n<h2 id=\"那如果对后端接口-另一台服务器上-的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\"><a href=\"#那如果对后端接口-另一台服务器上-的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\" class=\"headerlink\" title=\"那如果对后端接口(另一台服务器上)的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？\"></a>那如果对后端接口(另一台服务器上)的请求都由nuxt中间件转发，是不是就不需要处理客户端请求后端接口的跨域问题了？开发环境不需要配代理，生产环境也不需要配反向代理和cors了？</h2><p><strong>你的这个思路非常棒，完全正确！</strong> 这正是构建现代 Web 应用的一种核心架构模式，被称为 <strong>“BFF（Backend For Frontend）模式”</strong> 或 <strong>“API 网关模式”</strong>。</p>\n<p>你的推理链条是：</p>\n<ol>\n<li><strong>所有客户端请求</strong>都只发往<strong>同源</strong>的 Nuxt 服务器（<code>/api/proxy</code>）。</li>\n<li>Nuxt 服务器上的<strong>中间件</strong>接收到请求后，<strong>代为转发</strong>给真正的后端服务器。</li>\n<li>由于服务器之间通信（Nuxt Server -&gt; Your Backend Server）<strong>没有跨域限制</strong>，所以问题迎刃而解。</li>\n</ol>\n<p>这个方案<strong>在理论上是完全可行且非常优雅的</strong>，它确实可以让你<strong>完全摆脱 CORS 的困扰</strong>。</p>\n<hr>\n<h3 id=\"这种架构的详细工作流程\"><a href=\"#这种架构的详细工作流程\" class=\"headerlink\" title=\"这种架构的详细工作流程\"></a>这种架构的详细工作流程</h3><p>如图所示，浏览器始终只与 <code>my-nuxt-app.com</code> 通信，完美符合同源策略。</p>\n<hr>\n<h3 id=\"优缺点分析：这是否是“万能药”？\"><a href=\"#优缺点分析：这是否是“万能药”？\" class=\"headerlink\" title=\"优缺点分析：这是否是“万能药”？\"></a>优缺点分析：这是否是“万能药”？</h3><p>虽然这个方案能根治跨域，但它也引入了一些新的考虑因素：</p>\n<h4 id=\"优点-✅\"><a href=\"#优点-✅\" class=\"headerlink\" title=\"优点 ✅\"></a>优点 ✅</h4><ol>\n<li><strong>彻底解决 CORS</strong>：前端开发者完全无需再关心跨域配置，开发体验极其流畅。</li>\n<li><strong>隐藏后端架构</strong>：真正的后端地址、端口、API 结构对客户端完全隐藏，更安全。</li>\n<li><strong>协议转换</strong>：可以轻松地在 Nuxt 中处理 HTTPS -&gt; HTTP 的请求（服务器间通信允许）。</li>\n<li><strong>数据处理与聚合</strong>：你可以在 Nuxt 中间件中对多个后端服务的返回值进行聚合、过滤、转换，为前端提供最合适的数据结构，减少前端请求次数。</li>\n</ol>\n<h4 id=\"缺点与需要考虑的因素-⚠️\"><a href=\"#缺点与需要考虑的因素-⚠️\" class=\"headerlink\" title=\"缺点与需要考虑的因素 ⚠️\"></a>缺点与需要考虑的因素 ⚠️</h4><ol>\n<li><strong>额外的网络跳转</strong>：所有请求都多经过一环（浏览器 -&gt; Nuxt -&gt; 真实后端），<strong>会增加微小的延迟</strong>。对于延迟敏感的应用需要优化。</li>\n<li><strong>单点压力与故障点</strong>：Nuxt 服务器现在成为了所有 API 流量的入口。如果它宕机，所有请求都会失败。需要保证其高可用性。</li>\n<li><strong>复杂性转移</strong>：虽然前端变简单了，但 Nuxt 层（BFF 层）的逻辑变复杂了。你需要在这里编写转发、错误处理、认证等逻辑。</li>\n<li><strong>认证问题</strong>：如果后端 API 需要认证，你需要决定如何传递认证信息。<ul>\n<li><strong>方案A（推荐）</strong>：浏览器将认证 Token 发给 Nuxt，Nuxt 再原样转发给后端。</li>\n<li><strong>方案B</strong>：Nuxt 服务器自己持有访问后端的凭证，替用户与后端通信。但这需要非常小心地管理权限。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"如何实现？\"><a href=\"#如何实现？\" class=\"headerlink\" title=\"如何实现？\"></a>如何实现？</h3><p>在 Nuxt 中，你通常使用 <strong>API 路由</strong> 或 <strong>服务器中间件</strong> 来实现，而不是普通的中间件，因为它们专门处理服务器逻辑。</p>\n<p><strong>示例：在 <strong><code>**server/api/proxy/[...].ts**</code></strong> 中创建一个捕获所有路由的 API</strong></p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// server/api/proxy/[...].ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title function_\">defineEventHandler</span>(<span class=\"title function_\">async</span> (event) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 获取请求路径和方法</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> path = <span class=\"title function_\">getRouterParam</span>(event, <span class=\"string\">&#x27;path&#x27;</span>) <span class=\"comment\">// 获取 ... 通配符参数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> method = <span class=\"title function_\">getMethod</span>(event)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> body = method === <span class=\"string\">&#x27;GET&#x27;</span> ? <span class=\"literal\">undefined</span> : <span class=\"keyword\">await</span> <span class=\"title function_\">readBody</span>(event)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 定义你的真实后端基础 URL（应从环境变量读取！）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> baseURL = <span class=\"string\">&#x27;https://your-real-backend.com/api&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> targetURL = <span class=\"string\">`<span class=\"subst\">$&#123;baseURL&#125;</span>/<span class=\"subst\">$&#123;path&#125;</span>`</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 可选：处理认证（例如，将前端传来的 token 转发给后端）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> headers = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> authHeader = <span class=\"title function_\">getHeader</span>(event, <span class=\"string\">&#x27;authorization&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (authHeader) &#123;</span><br><span class=\"line\">    headers[<span class=\"string\">&#x27;Authorization&#x27;</span>] = authHeader</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 4. 代理请求到真实后端</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> $fetch.<span class=\"title function_\">raw</span>(targetURL, &#123;</span><br><span class=\"line\">      method,</span><br><span class=\"line\">      body,</span><br><span class=\"line\">      headers,</span><br><span class=\"line\">      <span class=\"comment\">// 重要：转发查询参数 (?foo=bar)</span></span><br><span class=\"line\">      <span class=\"attr\">query</span>: <span class=\"title function_\">getQuery</span>(event),</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 5. 可选：根据需要设置响应头</span></span><br><span class=\"line\">    <span class=\"title function_\">setHeaders</span>(event, response.<span class=\"property\">headers</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 6. 返回后端响应的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.<span class=\"property\">_data</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 7. 错误处理，将后端错误返回给前端</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"title function_\">createError</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">statusCode</span>: error.<span class=\"property\">statusCode</span> || <span class=\"number\">500</span>,</span><br><span class=\"line\">      <span class=\"attr\">statusMessage</span>: error.<span class=\"property\">statusMessage</span> || <span class=\"string\">&#x27;Internal Server Error&#x27;</span>,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这样，前端所有发往 <code>/api/proxy/items</code>、<code>/api/proxy/user/profile</code> 的请求，都会被这个 handler 捕获，并转发到 <code>https://your-real-backend.com/api/items</code> 和 <code>https://your-real-backend.com/api/user/profile</code>。</p>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p><strong>是的，你的想法是完全正确且高效的。通过让 Nuxt 服务器作为所有后端请求的代理，你可以一劳永逸地解决跨域问题，无需在开发或生产环境配置任何 CORS 或代理规则。</strong></p>\n<p>这不仅是解决跨域的手段，更是一种先进的<strong>架构设计选择</strong>（BFF）。它特别适用于：</p>\n<ul>\n<li>中大型前后端分离项目。</li>\n<li>需要集成多个后端微服务的复杂前端。</li>\n<li>希望简化前端开发流程，将复杂性集中到 BFF 层的团队。</li>\n</ul>\n<p>你只需要评估其带来的<strong>额外延迟</strong>和<strong>单点压力</strong>是否在你的应用可接受范围内即可。对于绝大多数应用来说，这个方案的利远大于弊。</p>\n","_processedHighlight":true},{"title":"微前端","date":"2024-01-14T16:00:00.000Z","_content":"\n参考链接：\n\n[可能是你见过最完善的微前端解决方案](https://zhuanlan.zhihu.com/p/78362028)\n\n[深入调研了微前端，还是iframe最香](https://juejin.cn/post/7244070072788287544?searchId=202508250257166071DDB47E623E0BA671)\n\n[qiankun官方文档](https://qiankun.umijs.org/zh/guide/getting-started)\n\n### 什么是微前端？\n微前端是一种软件架构，可以将前端应用拆解成一些更小的能够独立开发部署的微型应用，然后在将这些微型应用组合使其成为整体的架构模式。\n\n微前端类似于组件架构，但不同的是，组件不能够独立构建和发布，但是微前端中的应用是可以的。\n\n微前端架构与框架无关，每个微应用都可以使用不同的框架。\n\n![](https://cdn.nlark.com/yuque/0/2025/png/55999631/1756118557192-c0cfb92e-8167-4ead-9795-0f7ddd7bb7c8.png)\n\n\n\n| **特性** | **单体前端** | **微前端** |\n| --- | --- | --- |\n| **代码库** | 单个大型代码库 | 多个独立代码库 |\n| **团队结构** | 集中式团队 | 分布式独立团队 |\n| **技术栈** | 统一技术栈 | 混合技术栈 |\n| **部署** | 整体部署 | 独立部署 |\n| **开发速度** | 后期变慢 | 持续快速 |\n| **复杂度** | 高度耦合 | 解耦独立 |\n\n\n### 微前端的价值\n微前端架构具备以下几个核心价值：\n\n+ 技术栈无关 主框架不限制接入应用的技术栈，子应用具备完全自主权\n+ 独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n+ 独立运行时 每个子应用之间状态隔离，运行时状态不共享\n\n微前端架构旨在解决[单体应用](https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLljZXkvZPlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.Sy3sQVozhhuQwuwmw8-zjyU0X_81Vve5linQ55OPo0k&zhida_source=entity)在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个[巨石应用](https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%B7%A8%E7%9F%B3%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLlt6jnn7PlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.3VWm6X4yZDpq2_EqJZDuDErH1ST1iWJUa0qPK8T5Abk&zhida_source=entity)([Frontend Monolith](https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DpU1gXA0rfwc))后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。\n\n应用架构如下：\n\n![](https://cdn.nlark.com/yuque/0/2025/png/55999631/1756120029405-72a7f34d-4e09-4c78-b290-6ae5836720cb.png)\n\n> Stitching layer 作为主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用。因此主框架的定位则仅仅是：**导航路由 + 资源加载框架**\n>\n\n\n\nsingle-spa是什么\n\n好的，我们来详细解释一下 **single-spa** 是什么。\n\n### 核心定义\n**single-spa 是一个用于构建【微前端】架构的 JavaScript 框架。** 你可以把它理解为一个**顶层的路由器和应用程序加载器**。\n\n它的核心思想是：将一个大型的单页前端应用（SPA）拆分成多个小型、独立、可以并行开发交付的“微应用”。然后，single-spa 负责在运行时根据一定的规则（通常是当前的 URL）动态地加载、展示、卸载这些微应用。\n\n---\n\n### 一个简单的比喻\n想象一下你的浏览器是一个舞台：\n\n+ **传统单体应用：** 只有一个庞大的剧团表演一整部冗长的戏剧。要更换一个演员（修改一个功能），需要整个剧团停下来重新排练（整个应用重新构建部署）。\n+ **single-spa 微前端：** 舞台（浏览器）本身是空的。有一个**导演（single-spa）**。导演手里有一个节目单（根配置），上面写着什么节目（微应用）在什么时刻（例如，URL 是 `/settings` 时）上台表演。\n    - 当报幕员说“下一个节目是《用户设置》”时（用户访问了 `/settings`），导演就喊：“《用户设置》剧组，上台！”（加载并挂载 React 微应用）。\n    - 节目表演完了（用户离开了 `/settings`），导演就喊：“《用户设置》剧组，下台！”（卸载 React 微应用）。\n    - 下一个节目是《商品列表》，另一个完全不同的剧组（Vue 微应用）就上台表演。\n\n**single-spa 就是这个导演**，它自己不表演具体内容，但它负责协调所有剧组（微应用）的上场和下场时机。\n\n---\n\n### 为什么需要 single-spa？（解决的问题）\n1. **技术栈无关：** 各个微应用可以使用不同的技术栈（React, Vue, Angular, Svelte 等）。团队可以自由选择或升级其技术栈，而不会影响其他团队。\n2. **独立开发、独立部署：** 每个微应用都由独立的团队开发、测试和部署，大大提升了团队的自治度和发布效率。\n3. **增量升级：** 允许你逐步重写一个老旧的巨型前端应用，可以一部分一部分地用新的框架替换，而不是一次性重写全部。\n4. **代码隔离：** 应用之间实现了良好的代码和样式隔离（虽然需要一些额外规范），避免了全局污染和冲突。\n\n---\n\n### single-spa 的核心工作原理\nsingle-spa 通过定义一套**生命周期协议**来工作。每个微应用都必须对外暴露三个核心的函数：\n\n1. `bootstrap`： 应用首次加载时执行一次，用于初始化。\n2. `mount`： 当激活条件满足时（例如用户访问了该应用的路由），执行此函数。应用需要在这个函数里完成渲染，将组件挂载到 DOM 上。\n3. `unmount`： 当激活条件不再满足时（例如用户离开了该路由），执行此函数。应用需要在这个函数里完成清理工作，将自己从 DOM 上卸载。\n\nsingle-spa 的“根配置”会**注册**所有微应用，并为每个应用定义一个 `activity function`（激活函数）。这个函数通常根据 `window.location` 进行判断。\n\njavascript\n\n```javascript\n// single-spa 根配置示例 (root-config.js)\nimport { registerApplication, start } from 'single-spa';\n\n// 注册一个应用\nregisterApplication({\n  name: 'my-react-app', // 应用唯一名\n  app: () => System.import('my-react-app'), // 如何加载该应用的代码\n  activeWhen: (location) => location.pathname.startsWith('/react'), // 激活函数：当路径以 /react 开头时，加载这个应用\n});\n\n// 启动 single-spa\nstart();\n```\n\n**流程如下：**\n\n1. 用户访问 `https://example.com/react`。\n2. single-spa 检查所有注册的应用，发现 `my-react-app` 的 `activeWhen` 函数返回 `true`。\n3. single-spa 动态加载 `my-react-app` 的代码包。\n4. 依次执行该应用的 `bootstrap` 和 `mount` 生命周期函数，应用被渲染到页面上。\n5. 用户导航到 `/vue`，`my-react-app` 的 `activeWhen` 返回 `false`。\n6. single-spa 执行它的 `unmount` 函数，将其卸载。\n\n---\n\n### 主要优缺点\n**优点：**\n\n+ **强大的解耦和能力：** 真正实现了前端应用的拆分和团队自治。\n+ **框架无关：** 是整合不同技术栈应用的理想选择。\n+ **懒加载：** 提升首次加载速度，按需加载应用。\n\n**缺点：**\n\n+ **复杂度高：** 引入了分布式系统的复杂性，需要解决依赖共享、样式隔离、通信机制等问题。\n+ **开发体验：** 调试和配置比单体应用更复杂。通常需要类似 `single-spa` 官方的 `create-single-spa` 工具链来简化流程。\n+ **依赖管理：** 需要谨慎处理共享库（如 `react`, `vue`）以避免重复打包。\n\n---\n\n### 与 Module Federation 的区别\nWebpack 5 的 **Module Federation（模块联邦）** 是另一种实现微前端的热门技术。它们不是互斥的，甚至可以结合使用：\n\n+ **single-spa** 主要解决的是**路由和应用生命周期管理**的问题（“什么时候加载哪个应用”）。\n+ **Module Federation** 主要解决的是**应用之间代码共享和依赖处理**的问题（“如何共享一个 React 实例，避免重复加载”）。\n\n一个常见的模式是：使用 **single-spa 作为路由器**，使用 **Module Federation 来加载微应用和共享依赖**。\n\n### 总结\n**single-spa 是一个成熟、强大的微前端解决方案，它通过一套生命周期协议，将多个独立开发、独立部署的微应用组合成一个完整的单体体验。它非常适合大型企业级应用、需要整合不同技术栈或进行增量迁移的项目。**虽然它引入了一定的复杂性，但它为解决前端单体膨胀问题提供了非常系统化的思路和工具。\n\nhtml entry和js entry的概念是什么\n\n好的，这是一个非常核心的微前端概念。`**js-entry**` 和 `**html-entry**` 是微前端中两种不同的应用打包和加载方式，它们代表了两种不同的设计哲学和实现技术。\n\n---\n\n### 核心概念对比\n| **特性** | **js-entry (JavaScript 入口)** | **html-entry (HTML 入口)** |\n| --- | --- | --- |\n| **入口文件** | 一个 JavaScript 文件 (e.g., `app.js`<br/>) | 一个 HTML 文件 (e.g., `index.html`<br/>) |\n| **内容** | 主要包含 **JavaScript 逻辑和组件** | 包含 **HTML、**`**<script>**`<br/>**、**`**<link>**`<br/>**、**`**<style>**` |\n| **加载方式** | 框架（如 single-spa）加载并执行 JS 文件 | 框架通过 **fetch** 获取 HTML，解析出其中的 JS/CSS 并执行 |\n| **样式处理** | **需要手动管理**。通常需要约定（如 CSS Modules, CSS-in-JS）或工具来避免冲突。 | **自动处理**。HTML 中的 `<link>`<br/> 和 `<style>`<br/> 标签会被自动插入到 `<head>`<br/> 中。 |\n| **沙箱隔离** | 通常需要额外的库（如 `qiankun`<br/> 的沙箱）来实现 JS 和 CSS 的运行时隔离。 | 天然更易于实现**HTML级别的沙箱**（例如，创建一个 Shadow DOM 来包裹整个微应用的内容）。 |\n| **代表性方案** | 原始的 **single-spa** 方案 | **qiankun**（基于 single-spa）、**Module Federation**（某种程度上） |\n\n\n---\n\n### 深入理解\n#### 1. js-entry (JavaScript 入口)\n这是 **single-spa 早期和官方推荐**的方式。它的理念是：一个微应用**本质上是一个 JavaScript 模块**，这个模块导出了 `bootstrap`, `mount`, `unmount` 等生命周期函数。\n\n**如何工作？**\n\n1. 主应用（容器）根据路由规则，判断需要加载微应用 A。\n2. 主应用通过 `System.import()` 或 `import()` 动态加载微应用 A 的 **入口 JS 文件**（例如 `https://a.com/app.js`）。\n3. 这个 JS 文件被执行，并返回一个包含生命周期函数的对象。\n4. 主应用依次调用微应用的 `bootstrap` 和 `mount` 函数。\n5. 在 `mount` 函数中，微应用**用自己的逻辑**将组件渲染到主应用提供的 DOM 容器中。\n\n**示例代码 (single-spa 配置)：**\n\njavascript\n\n```javascript\nregisterApplication({\n  name: 'my-app',\n  // 这里是一个 js-entry，指向一个 JS 文件\n  app: () => System.import('https://a.com/js/app.js'),\n  activeWhen: '/app'\n});\n```\n\n**优点：**\n\n+ 概念清晰，符合“应用即模块”的理念。\n+ 打包输出干净，通常是一个或多个 JS 包。\n\n**缺点：**\n\n+ **样式处理麻烦**：你需要自己在微应用的 JS 代码里引入 CSS（如 `import './app.css'`），并小心全局样式冲突。\n+ **需要额外配置**：为了实现资源加载和隔离，需要复杂的 Webpack 配置和额外的库。\n\n#### 2. html-entry (HTML 入口)\n这种方式的理念是：一个微应用是**一个完整的、可以独立运行的“页面”**。主应用只需要加载这个页面的 HTML 文件，剩下的资源（JS, CSS）都由这个 HTML 文件自己声明。\n\n**如何工作？**\n\n1. 主应用根据路由规则，判断需要加载微应用 B。\n2. 主应用通过 **fetch** 请求微应用 B 的**入口 HTML 文件**（例如 `https://b.com/index.html`）。\n3. 主应用**解析**这个 HTML 文件，提取出其中的 `**<script>**`** ****和**** **`**<link>**`** ****标签**。\n4. 主应用手动创建这些 `<script>` 和 `<link>` 元素，并将它们插入到主文档的 `<head>` 中，从而加载并执行微应用的 JS 和 CSS。\n5. 同时，主应用通常会提供一个**隔离的沙箱环境**（如 Shadow DOM），将微应用的整个 DOM 结构渲染在其中。\n\n**示例概念（qiankun 的做法）：**\n\njavascript\n\n```javascript\nimport { registerMicroApps, start } from 'qiankun';\n\nregisterMicroApps([\n  {\n    name: 'vue-app',\n    // 这里是一个 html-entry，指向一个 HTML 文件\n    entry: '//localhost:7101', // 会默认加载这个地址下的 index.html\n    container: '#container',\n    activeRule: '/vue',\n  },\n]);\nstart();\n```\n\n**优点：**\n\n+ **对旧项目更友好**：很多老项目（如 jQuery、Backbone 项目）本身就是以 HTML 为中心开发的，改造为 html-entry 更容易。\n+ **资源加载自动化**：无需在 JS 中手动引入资源，HTML 中声明的所有资源都会被自动加载。\n+ **更强大的隔离能力**：更容易与 Shadow DOM 结合，实现真正的样式和作用域隔离。\n\n**缺点：**\n\n+ **需要解析 HTML**：主应用需要具备解析 HTML 并提取资源的能力，实现起来比直接 `import` 一个 JS 文件更复杂。\n+ **可能加载多余资源**：如果 HTML 中声明了多个入口，需要更精细的解析策略来避免加载未使用的资源。\n\n---\n\n### 总结与类比\n| **概念** | **类比** |\n| --- | --- |\n| `**js-entry**` | 就像 **“组装电脑”**。主应用（你）买来各个零件（JS 逻辑、手动引入的 CSS），自己动手组装成一台完整的电脑（微应用）。控制力强，但过程繁琐。 |\n| `**html-entry**` | 就像 **“购买品牌整机”**。主应用（你）直接买来一台戴尔电脑（HTML 文件），插上电（插入 DOM）就能用。开箱即用，非常方便，但内部细节被封装了。 |\n\n\n**现代趋势：**\n\n+ 纯粹的 `js-entry` 由于其配置的复杂性，在直接使用时体验并不友好。\n+ **qiankun** 这类框架通过实现 `html-entry` 模式，极大地改善了开发者体验，降低了微前端的上手门槛。\n+ **Webpack Module Federation** 提供了另一种更现代化的 `js-entry`，它通过复杂的依赖共享机制，解决了 `js-entry` 的许多痛点（如共享库重复加载），可以看作是 `js-entry` 的终极进化形态。\n\n因此，选择哪种方式取决于你的技术栈和框架：\n\n+ 使用 **原始的 single-spa**，你通常需要处理 `js-entry`。\n+ 使用 **qiankun**，你享受的是 `html-entry` 带来的便利。\n+ 使用 **Module Federation**，你体验的是高级的、基于依赖共享的 `js-entry`。\n\n## 路由分发可以实现微前端架构吗\n当然可以。**路由分发是实现微前端架构最主要、最常用也是最经典的方式**。它被认为是微前端架构的“第一种模式”，并且非常有效。\n\n### 核心思想\n**通过路由（URL）的变化，来决定在页面容器中加载、展示和卸载哪个微前端应用。** 主应用（通常称为“容器应用”或“根应用”）充当一个**路由器**和**编排者**的角色，而各个微应用则是独立开发、部署的功能模块。\n\n---\n\n### 它是如何工作的？\n1. **一个路由规则集**：主应用中维护一个配置表，将特定的 URL 路径模式（如 `/app1/*`, `/settings`, `/dashboard`）映射到对应的微应用。\n2. **监听路由变化**：主应用监听 `popstate`、`hashchange` 等浏览器路由事件。\n3. **匹配与决策**：当路由发生变化时（用户点击链接或手动输入 URL），主应用根据配置表判断当前应该激活哪个微应用。\n4. **加载与挂载**：主应用动态获取该微应用的资源（JS, CSS），并将其挂载到页面中指定的 DOM 容器（如 `<div id=\"micro-app-container\">`）中。\n5. **卸载与清理**：当用户离开当前路由时，主应用会卸载之前的微应用，并进行必要的清理工作（如清除事件监听器、内存释放等），然后加载新的微应用。\n\n## webpack5的Module Federation可以详细说说嘛\n好的，我们来深入、详细地探讨 Webpack 5 的 **Module Federation（模块联邦）**。它不仅仅是微前端的一种实现方式，更是一种革命性的架构思想。\n\n### 一、核心概念：它是什么？\n**Module Federation (MF)** 的核心目标是：**允许一个 JavaScript 应用在运行时动态地从另一个应用加载代码并共享依赖**。\n\n你可以把它想象成在浏览器端实现了类似 Node.js 的 `require` 或 `import` 机制，但不是在本地文件系统，而是在**网络上的不同独立应用之间**。\n\n它打破了传统的应用隔离边界，允许应用彼此成为“模块提供者”和“模块消费者”。\n\n---\n\n### 二、为什么要用 Module Federation？(解决的核心痛点)\n1. **彻底解决依赖重复打包**\n    - **传统微前端**：如果主应用和微应用都使用了 React、Vue 等相同的库，这些库的代码会被分别打包到各自的 bundle 中。用户浏览器会多次下载和执行相同的库代码，导致体积膨胀和性能下降。\n    - **MF**：可以**指定共享依赖**。React 等库只加载一次，所有应用都使用同一份实例。这解决了最重要的“依赖地狱”问题。\n2. **更彻底的应用拆分与团队自治**\n    - 它允许将应用拆分成更细粒度的“模块”或“组件”，而不仅仅是“页面”或“应用”。\n    - 团队可以独立开发、部署**一个按钮、一个表单、一个页面**，并让其他团队直接消费。\n3. **运行时动态集成**\n    - 代码集成发生在运行时（Runtime），而非构建时（Build-time）。这意味着：\n        * 你可以进行 **A/B 测试**，动态切换不同版本的组件。\n        * 可以**独立部署**某个模块，而无需重新部署整个应用。\n        * 主应用甚至不需要提前知道所有可能被加载的微应用。\n\n---\n\n### 三、核心角色与配置\nMF 中有两个关键角色：\n\n1. **Remote (远程模块/消费者)**\n    - 它是一个**使用方**应用，在运行时从其他地方（`Host`）导入并执行代码。\n    - 它的配置使用 `remotes` 属性。\n2. **Host (宿主模块/提供者)**\n    - 它是一个**提供方**应用，将其内部的某些模块暴露给外部使用。\n    - 它的配置使用 `exposes` 属性。\n\n**一个应用可以同时是**** **`**Host**`** ****和**** **`**Remote**`。\n\n#### 配置详解 (`webpack.config.js`)\njavascript\n\n```javascript\n// Host 应用的配置 (提供模块的应用，端口3001)\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  // ...其他配置\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app1', // 必填，这个应用的唯一名称，是消费者调用时的标识\n      filename: 'remoteEntry.js', // 必填，对外暴露的入口文件清单名\n      exposes: { // 暴露哪些模块给外部使用\n        './Button': './src/components/Button', // 键：供外部使用的别名；值：本地模块路径\n        './App': './src/App',\n      },\n      shared: { // 共享的依赖库\n        react: { \n          singleton: true, // 确保只使用一个单例版本\n          requiredVersion: '^18.2.0' // 需要的版本\n        },\n        'react-dom': {\n          singleton: true,\n          requiredVersion: '^18.2.0'\n        },\n      },\n    }),\n  ],\n};\n```\n\njavascript\n\n```javascript\n// Remote 应用的配置 (消费模块的应用，端口3002)\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  // ...其他配置\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app2',\n      remotes: { // 声明要消费哪些远程应用\n        // 格式: \"name@url/remoteEntry.js\"\n        app1: 'app1@http://localhost:3001/remoteEntry.js',\n      },\n      shared: { // 共享依赖的配置必须与Host一致，才能成功共享\n        react: { \n          singleton: true,\n          requiredVersion: '^18.2.0'\n        },\n        'react-dom': {\n          singleton: true,\n          requiredVersion: '^18.2.0'\n        },\n      },\n    }),\n  ],\n};\n```\n\n---\n\n### 四、如何使用？\n在 `app2` (Remote) 的代码中，你可以像导入本地模块一样**动态导入** `app1` (Host) 暴露的模块：\n\njavascript\n\n```javascript\n// 在 app2 的 React 组件中\nimport React, { Suspense } from 'react';\n\n// 使用动态导入语法。`app1` 是配置中remotes的key，`./Button` 是app1暴露的模块名\nconst RemoteButton = React.lazy(() => import('app1/Button'));\n\nfunction App() {\n  return (\n    <div>\n    <h1>我是 App2</h1>\n    <Suspense fallback={<div>Loading Button...</div>}>\n  {/* 这个Button组件来自另一个独立应用 app1！ */}\n  <RemoteButton />\n    </Suspense>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n---\n\n### 五、工作流程（魔法是如何发生的？）\n1. **构建阶段**：\n    - `Host` (`app1`) 构建时，会生成一个 `remoteEntry.js` 文件。这个文件是一个**清单(Manifest)**，记录了 `exposes` 了哪些模块以及如何获取它们。\n    - `Remote` (`app2`) 构建时，会意识到 `import('app1/Button')` 是一个远程模块，不会将其打包到自己的 bundle 中。\n2. **运行时阶段**：\n    - 浏览器加载 `app2`。\n    - 当执行到 `import('app1/Button')` 时，Webpack 运行时就会去检查配置。\n    - 它发现 `app1` 对应 `http://localhost:3001/remoteEntry.js`，于是**动态加载**这个 `remoteEntry.js` 文件。\n    - `remoteEntry.js` 告诉 `app2` 如何从 `app1` 的服务器上获取 `Button` 组件的代码块。\n    - Webpack 加载这个代码块，并**与**** **`**app2**`** ****共享的**** **`**react**`** ****和**** **`**react-dom**`** ****实例一起执行它**。\n    - 组件渲染成功。\n\n---\n\n### 六、与 single-spa 等方案的对比\n| **特性** | **Module Federation** | **single-spa (传统方式)** |\n| --- | --- | --- |\n| **核心能力** | **模块共享与依赖管理** | **应用生命周期管理与路由** |\n| **集成方式** | **运行时动态导入** | 运行时加载（但依赖需各自处理） |\n| **依赖处理** | **卓越**。自动共享库，避免重复。 | **困难**。需要额外手动配置或工具解决。 |\n| **打包输出** | 生成 `remoteEntry.js`<br/> 清单文件 | 生成应用的入口 JS 文件 |\n| **粒度** | **非常细**。可以共享单个组件、函数、工具库。 | **较粗**。通常以整个“应用”或“页面”为单元。 |\n| **关系** | **互补**。可以**结合使用**：用 single-spa 做路由和生命周期管理，用 MF 来加载组件和共享依赖。 |  |\n\n\n### 总结\n**Webpack 5 的 Module Federation 是一项颠覆性的技术**。它不再是简单地将应用机械地拼凑在一起，而是真正实现了应用间代码的“无缝融合”与“依赖共享”。\n\n它最适合的场景包括：\n\n+ **大型平台型产品**：需要多个团队独立开发不同功能模块。\n+ **微前端架构**：是目前实现微前端最先进、最优雅的方案之一。\n+ **跨应用组件/工具库共享**：避免维护多个版本的通用组件。\n\n它代表了前端架构从“单体”到“分布式”演进的重要方向，是每一位前端架构师都应该深入理解的技术。\n\nweb component\n\n## 好的，我们来全面、深入地探讨 Web Components。\n### 一、核心概念：它是什么？\n**Web Components** 是一套**浏览器原生支持**的技术集合，允许你创建可重用的、封装的自定义 HTML 元素（类似于 `<div>`、`<button>`，但是是你自己定义的），并在任何现代浏览器中使用它们，无需任何外部框架（如 React、Vue、Angular）。\n\n它的核心目标是为 Web 开发提供**真正的组件化模型**，并解决代码重用和封装的问题。\n\n---\n\n### 二、为什么需要 Web Components？（解决的问题）\n1. **框架无关性 (Framework-Agnostic)**\n    - 你用 Web Components 编写的组件可以在任何 HTML 页面中使用，无论这个页面用的是 React、Vue、Angular、jQuery 还是纯 JavaScript。它提供了**最大程度的可移植性**。\n2. **原生封装 (Native Encapsulation)**\n    - **Shadow DOM** 提供了强大的样式和行为封装。组件内部的样式不会泄漏到外部，外部的样式也不会渗透到组件内部（除非特意允许）。这彻底解决了 CSS 全局污染的问题。\n3. **长期稳定性 (Longevity)**\n    - 作为**Web 平台标准**，它由浏览器厂商直接实现和维护，不像前端框架那样有生命周期（例如，AngularJS 到 Angular 的断代升级）。你写的组件在未来很多年内都能继续工作。\n4. **生态系统互操作性 (Interoperability)**\n    - 它可以在任何框架中被当作普通的 HTML 元素使用，成为了连接不同技术栈应用的“桥梁”。\n\n---\n\n### 三、技术构成（四大核心技术）\nWeb Components 主要由四项技术标准组成，它们可以单独使用，但组合在一起威力最大。\n\n#### 1. Custom Elements（自定义元素）\n一套 JavaScript API，允许你**定义自定义元素及其行为**。\n\n+ **如何定义**：通过继承 `HTMLElement` 类来创建一个新的元素类。\n+ **生命周期回调**：\n    - `connectedCallback`: 当元素首次被插入到 DOM 时调用。\n    - `disconnectedCallback`: 当元素从 DOM 中移除时调用。\n    - `adoptedCallback`: 当元素被移动到新的文档时调用。\n    - `attributeChangedCallback`: 当元素的被观察属性（在 `observedAttributes` 中定义）发生变化时调用。\n\n**示例：定义一个简单的自定义元素**\n\njavascript\n\n```javascript\nclass MyButton extends HTMLElement {\n  constructor() {\n    super();\n    // 初始化逻辑\n  }\n\n  connectedCallback() {\n    this.innerHTML = `<button>Click Me!</button>`;\n    this.addEventListener('click', () => {\n      alert('Button clicked!');\n    });\n  }\n\n  // 定义需要监听的属性\n  static get observedAttributes() {\n    return ['disabled'];\n  }\n\n  // 当disabled属性变化时触发\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === 'disabled') {\n      console.log(`disabled changed from ${oldValue} to ${newValue}`);\n    }\n  }\n}\n\n// 向浏览器注册这个新元素，标签名必须包含连字符 `-`\ncustomElements.define('my-button', MyButton);\n```\n\n**在 HTML 中使用**：\n\nhtml\n\n<my-button disabled></my-button>\n\n#### 2. Shadow DOM（影子 DOM）\n一套用于将**封装的、“影子”的 DOM 树附加到元素**的 API。这是实现样式和行为封装的关键。\n\n+ **Shadow Root**：Shadow DOM 的根节点。\n+ **模式**：\n    - `open`: 可以通过 JavaScript 从外部访问（例如 `element.shadowRoot`）。\n    - `closed`: 外部无法访问，封装性更强。\n+ **作用域**：在 Shadow DOM 内部定义的样式和脚本只在这个范围内有效，与外部隔离。\n\n**示例：为自定义元素添加 Shadow DOM**\n\njavascript\n\n```javascript\nclass MyCard extends HTMLElement {\n  constructor() {\n    super();\n    // 附加一个打开的 Shadow Root\n    const shadow = this.attachShadow({ mode: 'open' });\n\n    // 创建模板\n    const template = document.createElement('template');\n    template.innerHTML = `\n      <style>\n        /* 这些样式只在这个卡片内有效，不会影响外部 */\n        .card {\n          border: 1px solid #ccc;\n          padding: 16px;\n          border-radius: 8px;\n          font-family: sans-serif;\n        }\n        h2 { color: blue; margin-top: 0; }\n      </style>\n      <div class=\"card\">\n        <h2><slot name=\"title\">Default Title</slot></h2>\n        <p><slot name=\"content\">Default content...</slot></p>\n      </div>\n    `;\n\n    // 克隆模板内容并添加到 Shadow Root\n    shadow.appendChild(template.content.cloneNode(true));\n  }\n}\ncustomElements.define('my-card', MyCard);\n```\n\n**在 HTML 中使用**：\n\nhtml\n\n```plain\n<my-card>\n  <!-- 使用 slot 将外部内容投影到 Shadow DOM 中的指定位置 -->\n  <span slot=\"title\">My Awesome Title</span>\n  <span slot=\"content\">This is some fantastic content.</span>\n</my-card>\n```\n\n#### 3. HTML Templates（HTML 模板）\n`<template>` 和 `<slot>` 元素允许你编写**在页面加载时不会立即渲染的标记模板**。这些模板可以被后续的 JavaScript 激活和使用。\n\n+ `<template>`：内容不会被浏览器解析、渲染或执行，直到被 JavaScript 提取并使用。\n+ `<slot>`：在 Web Component 内部充当占位符，允许用户在使用组件时传入自己的自定义内容（如上例所示）。\n\n#### 4. ES Modules（ES 模块）\n现代 JavaScript 的模块标准，为在 Web 上包含和重用 JS 代码提供了官方机制。它使得导入和导出 Web Components 变得简单。\n\nhtml\n\n```html\n<!-- 在 HTML 中导入并使用一个定义好的 Web Component -->\n<script type=\"module\" src=\"./my-component.js\"></script>\n<my-component></my-component>\n```\n\n---\n\n### 四、Web Components 的优点与缺点\n#### 优点：\n1. **浏览器原生**：无需编译，无需复杂的构建工具。\n2. **高度封装**：Shadow DOM 解决了 CSS 和 DOM 的隔离问题。\n3. **框架无关**：极高的互操作性和可移植性。\n4. **永久可用**：作为 Web 标准，具有极长的生命周期和向后兼容性。\n\n#### 缺点：\n1. **生态相对年轻**：虽然基础功能强大，但缺少像 React/Vue 那样庞大的生态系统（状态管理、路由、测试工具等）。\n2. **数据流管理较弱**：原生不支持类似 React 的 Props 向下传递、事件向上冒泡的父子组件通信范式，需要自己实现（通常用 Custom Events）。\n3. **SSR (服务器端渲染) 支持差**：自定义元素可以在服务器上渲染，但其动态行为和客户端激活（Hydration）非常复杂，远不如 Next.js/Nuxt.js 成熟。\n4. **开发体验 (DX)**：原始的开发方式比较繁琐，需要写很多样板代码。但社区有诸如 **Lit**、**Stencil** 等库来极大地改善体验。\n\n---\n\n### 五、Web Components 与微前端和框架\n+ **在微前端中**：Web Components 是实现**技术栈无关**微前端的理想载体。每个团队可以用自己熟悉的技术（React, Vue）**开发**组件，但最终**发布**为一个封装好的 Web Component（例如，将一个 React 组件包装成 `<team-product-card>`），由主应用统一调度。\n+ **与框架的关系**：\n    - **不是替代关系**，而是**互补关系**。\n    - **框架 (React/Vue) 擅长解决：** 复杂的 UI 状态管理、数据流、高效的 DOM 差分更新。它们提供了**优秀的开发体验**和**完整的解决方案**。\n    - **Web Components 擅长解决：** 跨框架重用、底层 UI 组件库、集成遗留应用、长期稳定的基础组件。它们提供了**浏览器级别的互操作性**。\n\n**总结来说，Web Components 是 Web 平台的底层基础，为构建可长期存在、高度封装、框架无关的组件提供了强大的原生能力。** 虽然它在开发复杂应用时不如现代框架那么方便，但其独特优势使其在特定场景（如微前端、跨技术栈组件库、大型企业级应用）中是不可替代的选择。\n\nqiankun实现样式和js隔离的原理\n\n好的，我们来深入剖析 **qiankun** 实现样式和 JavaScript 隔离的原理。这是 qiankun 的核心能力之一，也是它相比原始 single-spa 更易用、更强大的关键。\n\n### 总体思想\nqiankun 的隔离策略可以概括为：**“重样式隔离，轻 JS 沙箱”**。它通过在应用加载和卸载时动态地操作样式和 JavaScript 执行环境来模拟一个隔离的沙箱环境。\n\n---\n\n### 一、样式隔离 (CSS Isolation)\nqiankun 提供了三种主要的样式隔离方案，根据场景不同自动或手动启用。\n\n#### 1. 严格样式隔离 (Scoped CSS)\n**原理：** 为每个微应用包裹一个 **Shadow DOM**。\n\n+ **如何工作：**\n    1. 当 qiankun 挂载一个微应用时，它会创建一个 Shadow Root，并将其作为该应用的容器。\n    2. 微应用的所有 DOM 结构都被渲染在这个 Shadow DOM 内部。\n    3. **Shadow DOM 的特性天然实现了样式的封装**：内部的样式不会影响外部，外部的样式也不会影响内部（除非使用 `::part` 或 `:host` 等特定语法）。\n+ **优点：** 隔离性最强，是浏览器原生的完美隔离方案。\n+ **缺点：**\n    - 某些第三方库（特别是弹窗类）可能会因为无法正确定位到 Shadow DOM 外部而出现问题。\n    - 微应用内的样式完全无法影响主应用，反之亦然，有时这可能不符合设计需求。\n+ **启用方式：** 在 `start` 函数中配置 `{ strictStyleIsolation: true }`。\n\njavascript\n\n```javascript\nimport { start } from 'qiankun';\nstart({\n  strictStyleIsolation: true, // 启用严格样式隔离\n});\n```\n\n#### 2. 实验性样式隔离 (CSS Scoped)\n**原理：** 一种更宽松的隔离方式，使用 **运行时动态样式表重写**。\n\n+ **如何工作：**\n    1. qiankun 会劫持微应用运行时**动态添加样式标签（**`**<style>**`**,**** **`**<link>**`**）** 的行为。\n    2. 当微应用插入一个新的样式标签时，qiankun 会将其内容抓取过来。\n    3. 使用 **CSS 规则重写器**（例如 `postcss` 插件）为所有 CSS 选择器**添加一个特殊的前缀**。这个前缀通常基于微应用的名称或一个特定属性。\n    4. 将重写后的 CSS 内容插入到 `document.head` 中。\n    5. 同时，qiankun 会为微应用的**容器元素**添加上一步中使用的**相同属性**。\n\n**示例：**\n\n    - 微应用有一个样式规则：`.button { color: red; }`\n    - qiankun 将其重写为：`[data-qiankun=\"my-app\"] .button { color: red; }`\n    - 同时，微应用的容器 `<div>` 会获得属性：`<div data-qiankun=\"my-app\">...</div>`\n    - 这样，样式规则就只会在这个容器内生效。\n+ **优点：** 比 Shadow DOM 兼容性更好，允许微应用样式影响其容器内的任何元素（包括动态 append 到 body 的弹窗）。\n+ **缺点：** 是运行时重写，有一定性能开销，且是实验性功能。\n+ **启用方式：** 在 `start` 函数中配置 `{ experimentalStyleIsolation: true }`。\n\njavascript\n\n```javascript\nstart({\n  experimentalStyleIsolation: true, // 启用实验性样式隔离\n});\n```\n\n#### 3. 动态样式表加载/卸载 (最常见的默认行为)\n如果不开启上述两种隔离，qiankun 默认采用一种更简单但有效的策略。\n\n+ **原理：**\n    1. **加载时：** qiankun 通过 `fetch` 获取微应用的 HTML 入口，解析出所有的 `<style>` 和 `<link>` 标签。\n    2. 将这些样式标签**直接插入到**** **`**document.head**` 中。\n    3. **卸载时：** qiankun 会**记录**所有由该微应用添加的样式标签，并在卸载微应用时**直接将这些标签从 DOM 中移除**。\n+ **优点：** 实现简单，性能好。\n+ **缺点：** **不是真正的隔离**。如果多个微应用有相同选择器的样式规则，后加载的会覆盖先加载的（因为后加载的样式表在更后面，优先级更高）。这依赖于开发者的约定。\n+ **这是 qiankun 的默认行为**，对于很多应用来说已经足够。\n\n---\n\n### 二、JavaScript 隔离 (JS Sandbox)\nqiankun 的 JS 沙箱的核心目标是：**防止微应用在全局环境（**`**window**`**）上留下永久的污染，并在应用切换时恢复和清理环境**。它主要模拟了三个环境的隔离：\n\n#### 1. 快照沙箱 (SnapshotSandbox) - 用于单实例场景\n**原理：** 在应用加载前后对全局 `window` 对象进行“拍照”和“diff”，适用于同一时间只能有一个微应用活跃的浏览器环境。\n\n+ **工作流程：**\n    1. **激活沙箱 (mount)：** 将当前 `window` 的所有属性拍一个**快照**（`windowSnapshot`），存起来。\n    2. **微应用运行：** 微应用可以任意修改 `window`。\n    3. **失活沙箱 (unmount)：**\n        * 将当前的 `window` 和之前存的 `windowSnapshot` 进行对比，得到修改的差异（`modifyPropsMap`）。\n        * **还原现场：** 遍历差异，将 `window` 上的属性**恢复**到拍快照时的状态。\n        * **记录污染：** 将微应用修改的差异保存起来。\n    4. **再次激活：** 将之前保存的差异（`modifyPropsMap`）**重新应用到**** **`**window**`** ****上**，让微应用感觉自己的修改一直都在。\n+ **优点：** 兼容性极好，支持所有浏览器。\n+ **缺点：** 无法支持多个微应用同时运行（多实例），因为共用一个全局 `window`。\n\n#### 2. 代理沙箱 (ProxySandbox) - 用于多实例场景（主流）\n**原理：** 使用 ES6 的 `Proxy` 为每个微应用创建一个假的、隔离的 `window` 对象。\n\n+ **工作流程：**\n    1. qiankun 为每个微应用创建一个空的 `fakeWindow` 对象。\n    2. 用 `Proxy` 代理这个 `fakeWindow`。\n    3. 当微应用操作 `window` 时：\n        * **读操作**：优先从 `fakeWindow` 里读，如果读不到，则 fallback 到真正的全局 `window`（这样可以共享 `document`, `location` 等全局对象）。\n        * **写操作**：所有对属性的新增和修改都只作用于 `fakeWindow` 上，**完全不会污染真正的全局**** **`**window**`。\n    4. 微应用的所有代码都在这个代理的上下文中执行（通过 `with` 语句或 `eval` 改写）。\n+ **示例：**\n\njavascript\n\n```javascript\n// 微应用代码\nwindow.myGlobalVar = 123; // 写入的是沙箱的 fakeWindow，真 window 不受影响\nconsole.log(document.title); // 读取的是真 window 的属性\n```\n\n+ **优点：**\n    - 真正的隔离，多个微应用可以同时运行，每个都有自己独立的 `window` 空间。\n    - 对微应用无感知，无需修改代码。\n+ **缺点：** 依赖 ES6 `Proxy`，无法在低版本浏览器（如 IE）中使用。\n\n#### 3. 遗留沙箱 (LegacySandbox) - 已逐渐被代理沙箱取代\n原理类似于快照沙箱，但性能优化更好。它只记录微应用修改过的属性，在卸载时还原这些属性。同样不支持多实例。\n\n---\n\n### 总结：qiankun 的隔离策略\n| **隔离类型** | **技术方案** | **优点** | **缺点** | **适用场景** |\n| --- | --- | --- | --- | --- |\n| **样式隔离** | **Shadow DOM** | 原生，隔离最彻底 | 兼容性问题，弹窗等组件可能异常 | 需要最强隔离的新应用 |\n|  | **动态样式表重写 (实验性)** | 兼容性好，支持弹窗 | 运行时开销，实验性功能 | 需要兼容弹窗的复杂应用 |\n|  | **动态加载/卸载 (默认)** | 简单，性能好 | 非真正隔离，依赖约定 | 大多数简单应用，样式冲突风险低 |\n| **JS 隔离** | **快照沙箱 (SnapshotSandbox)** | 兼容所有浏览器 | 不支持多实例 | 单实例模式，需兼容 IE 等老浏览器 |\n|  | **代理沙箱 (ProxySandbox)** | 真正隔离，支持多实例，对应用无感知 | 依赖 `Proxy`<br/>，不兼容 IE | **现代浏览器下的主流选择** |\n\n\n**qiankun 会自动选择最佳策略**：在支持 `Proxy` 的浏览器中默认使用**代理沙箱 (多实例)** 和**动态样式加载/卸载**。如果不支持 `Proxy`，则降级到**快照沙箱 (单实例)**。\n\n通过这种组合策略，qiankun 在绝大多数场景下为微前端应用提供了**足够安全、稳定且高性能的隔离环境**，极大地简化了微前端的落地复杂度。\n\nqiankun是如何实现父子应用通信的呢\n\n好的，**qiankun 的通信机制**是其核心功能之一，它设计得非常灵活，提供了多种方式来实现主应用（父应用）和微应用（子应用）之间的通信。\n\nqiankun 并没有强制使用某一种通信方式，而是提供了一个轻量的 **API（**`**initGlobalState**`**）** 作为推荐方案，同时也完全支持任何其他流行的状态管理库（如 Redux, Mobx, Vuex）或浏览器原生 API。\n\n---\n\n### 一、官方推荐方案：使用 `initGlobalState` (Actions 通信)\n这是 qiankun 官方提供的通信方式，适用于大多数场景。它的核心思想是一个**简单的发布-订阅模式**。\n\n#### 1. 在主应用中初始化状态并下发通信方法\n主应用是整个状态的管理中心。\n\njavascript\n\n```javascript\n// main-app/src/actions.js\nimport { initGlobalState } from 'qiankun';\n\n// 1. 初始化全局状态\nconst initialState = {\n  user: {\n    name: '张三',\n    token: 'abc123'\n  },\n  theme: 'light'\n};\n\n// 2. 创建 Actions 实例\nconst actions = initGlobalState(initialState);\n\n// 3. 监听状态变化（可选，主应用自己也可以监听）\nactions.onGlobalStateChange((state, prevState) => {\n  // state: 变更后的新状态\n  // prevState: 变更前的旧状态\n  console.log('主应用监听到状态变化: ', state, prevState);\n});\n\n// 4. 定义一个更新状态的方法\nexport const setGlobalState = (newState) => {\n  // 按层级合并状态\n  actions.setGlobalState(newState);\n};\n\n// 5. 将 actions 暴露出去，供微应用使用\nexport default actions;\n```\n\n#### 2. 在微应用中获取并操作状态\n微应用需要从生命周期函数中获取到 `props`，其中就包含了通信方法。\n\njavascript\n\n```javascript\n// micro-app/src/main.js (入口文件)\nlet microAppActions; // 用来保存通信方法\n\n// 导出 qiankun 生命周期函数\nexport async function mount(props) {\n  console.log('微应用挂载了', props);\n  // 1. 从 props 中获取主应用下发的 actions\n  microAppActions = props;\n\n  // 2. 监听全局状态变化\n  props.onGlobalStateChange((state, prevState) => {\n    console.log('微应用监听到状态变化: ', state, prevState);\n    // 状态变化后，更新微应用自己的视图\n    renderApp(state);\n  });\n\n  // 3. 首次挂载，获取当前全局状态并渲染应用\n  renderApp(props.getGlobalState());\n}\n\nexport async function unmount() {\n  // 卸载时取消监听（qiankun 内部会自动清理，但显式取消是好习惯）\n  microAppActions.offGlobalStateChange();\n}\n\n// React/Vue 应用的渲染函数\nfunction renderApp(state) {\n  ReactDOM.render(<App globalState={state} actions={microAppActions} />, document.getElementById('app'));\n}\n```\n\n#### 3. 在微应用组件中具体使用\njavascript\n\n```javascript\n// micro-app/src/App.jsx\nimport React from 'react';\n\nfunction App({ globalState, actions }) {\n  const { user, theme } = globalState;\n\n  const handleChangeTheme = () => {\n    // 更新全局状态\n    actions.setGlobalState({\n      theme: theme === 'light' ? 'dark' : 'light'\n    });\n  };\n\n  return (\n    <div className={`app ${theme}`}>\n  <h1>微应用页面</h1>\n  <p>用户名: {user.name}</p>\n  <button onClick={handleChangeTheme}>切换主题</button>\n  </div>\n);\n}\n\nexport default App;\n```\n\n#### `initGlobalState` API 说明：\n+ `setGlobalState(state: object)`: 设置新的全局状态，会自动与旧状态进行**浅合并**。\n+ `onGlobalStateChange(callback: function)`: 注册监听器，状态变化时触发。\n+ `offGlobalStateChange()`: 取消监听。\n+ `getGlobalState()`: 获取当前全局状态。\n\n---\n\n### 二、其他通信方案\nqiankun 是框架无关的，因此你也可以选择任何你熟悉的通信方式。\n\n#### 1. 使用 CustomEvent (浏览器原生事件)\n**原理：** 利用浏览器原生的 `window.dispatchEvent` 和 `window.addEventListener` 进行通信。\n\njavascript\n\n```javascript\n// 主应用 - 发送事件\nwindow.dispatchEvent(new CustomEvent('main-app-event', {\n  detail: { // 通过 detail 传递数据\n    type: 'CHANGE_THEME',\n    payload: 'dark'\n  }\n}));\n\n// 微应用 - 接收事件\nwindow.addEventListener('main-app-event', (event) => {\n  const { type, payload } = event.detail;\n  // 处理事件...\n});\n\n// 微应用 - 发送事件（同理）\nwindow.dispatchEvent(new CustomEvent('micro-app-event', {\n  detail: { message: 'Hello from micro app' }\n}));\n```\n\n**优点：** 原生支持，非常简单。  \n**缺点：** 数据传递能力较弱（只能同步），缺乏状态管理能力，事件需要全局唯一命名以免冲突。\n\n#### 2. 使用 Redux/Mobx/Vuex 等状态库\n**原理：** 主应用和微应用**共享同一个状态库实例**。\n\n+ **步骤：**\n    1. 主应用创建一个 Redux Store 或其他状态库实例。\n    2. 将这个 Store 通过 `window` 对象或者微应用的 `props` 暴露给微应用。\n    3. 微应用连接到这个全局的 Store，进行状态的读取和分发 Action。\n\njavascript\n\n```javascript\n// 主应用 - 创建并暴露 store\nimport { createStore } from 'redux';\nconst globalStore = createStore(/* ... */);\nwindow.__MAIN_APP_STORE__ = globalStore; // 挂到全局\n\n// 微应用 - 获取并使用 store\nconst store = window.__MAIN_APP_STORE__;\nstore.dispatch({ type: 'AN_ACTION' });\nconst state = store.getState();\n```\n\n**优点：** 功能强大，可以处理复杂的业务逻辑和状态流。  \n**缺点：** 紧密耦合，主应用和微应用必须使用同一种状态库，且版本需要兼容。\n\n#### 3. 通过 URL 或 Query Parameters 通信\n**原理：** 通过改变 URL 的查询参数来传递简单信息。\n\njavascript\n\n```javascript\n// 主应用改变URL\nconst newUrl = `${window.location.pathname}?theme=dark&userId=123`;\nhistory.pushState(null, '', newUrl);\n\n// 微应用监听URL变化\nwindow.addEventListener('popstate', () => {\n  const urlParams = new URLSearchParams(window.location.search);\n  const theme = urlParams.get('theme');\n  // ...使用参数\n});\n```\n\n**优点：** 非常简单，状态可被收藏和分享。  \n**缺点：** 只适合传递少量简单数据。\n\n---\n\n### 总结与选择建议\n| **方案** | **优点** | **缺点** | **适用场景** |\n| --- | --- | --- | --- |\n| **官方**** **`**initGlobalState**` | **官方推荐**，简单轻量，满足大部分通信需求 | 功能相对简单，不适合极其复杂的场景 | **绝大多数微前端通信场景的首选** |\n| **CustomEvent** | 浏览器原生，非常简单 | 功能弱，只能传简单数据，易产生事件名冲突 | 简单的父子通知、触发动作 |\n| **Redux/Vuex 等** | 功能强大，适合复杂状态管理 | 耦合度高，主子和微应用必须使用同一种状态库 | 大型复杂应用，且技术栈统一 |\n| **URL Parameters** | 实现简单，状态可分享 | 传递数据量有限，类型受限 | 过滤条件、简单配置等 |\n\n\n**最佳实践建议：**\n\n1. **优先使用官方的**** **`**initGlobalState**`，它能覆盖 90% 的微前端通信需求。\n2. 对于简单的、一次性的动作触发（如“刷新列表”、“显示通知”），可以辅以 **CustomEvent**。\n3. 只有在主应用和所有微应用技术栈统一且非常复杂时，才考虑使用**共享状态库**。\n4. 通信的设计应遵循**最小化原则**，尽量减少主应用和微应用之间的耦合，让微应用保持最大的独立性。\n\n\n\n","source":"_posts/微前端.md","raw":"---\ntitle: 微前端\ndate: 2024-01-15\ntags: [微前端, qiankun, single-spa, Module Federation]\ncategories: 微前端\n---\n\n参考链接：\n\n[可能是你见过最完善的微前端解决方案](https://zhuanlan.zhihu.com/p/78362028)\n\n[深入调研了微前端，还是iframe最香](https://juejin.cn/post/7244070072788287544?searchId=202508250257166071DDB47E623E0BA671)\n\n[qiankun官方文档](https://qiankun.umijs.org/zh/guide/getting-started)\n\n### 什么是微前端？\n微前端是一种软件架构，可以将前端应用拆解成一些更小的能够独立开发部署的微型应用，然后在将这些微型应用组合使其成为整体的架构模式。\n\n微前端类似于组件架构，但不同的是，组件不能够独立构建和发布，但是微前端中的应用是可以的。\n\n微前端架构与框架无关，每个微应用都可以使用不同的框架。\n\n![](https://cdn.nlark.com/yuque/0/2025/png/55999631/1756118557192-c0cfb92e-8167-4ead-9795-0f7ddd7bb7c8.png)\n\n\n\n| **特性** | **单体前端** | **微前端** |\n| --- | --- | --- |\n| **代码库** | 单个大型代码库 | 多个独立代码库 |\n| **团队结构** | 集中式团队 | 分布式独立团队 |\n| **技术栈** | 统一技术栈 | 混合技术栈 |\n| **部署** | 整体部署 | 独立部署 |\n| **开发速度** | 后期变慢 | 持续快速 |\n| **复杂度** | 高度耦合 | 解耦独立 |\n\n\n### 微前端的价值\n微前端架构具备以下几个核心价值：\n\n+ 技术栈无关 主框架不限制接入应用的技术栈，子应用具备完全自主权\n+ 独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新\n+ 独立运行时 每个子应用之间状态隔离，运行时状态不共享\n\n微前端架构旨在解决[单体应用](https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLljZXkvZPlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.Sy3sQVozhhuQwuwmw8-zjyU0X_81Vve5linQ55OPo0k&zhida_source=entity)在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个[巨石应用](https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%B7%A8%E7%9F%B3%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLlt6jnn7PlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.3VWm6X4yZDpq2_EqJZDuDErH1ST1iWJUa0qPK8T5Abk&zhida_source=entity)([Frontend Monolith](https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DpU1gXA0rfwc))后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。\n\n应用架构如下：\n\n![](https://cdn.nlark.com/yuque/0/2025/png/55999631/1756120029405-72a7f34d-4e09-4c78-b290-6ae5836720cb.png)\n\n> Stitching layer 作为主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用。因此主框架的定位则仅仅是：**导航路由 + 资源加载框架**\n>\n\n\n\nsingle-spa是什么\n\n好的，我们来详细解释一下 **single-spa** 是什么。\n\n### 核心定义\n**single-spa 是一个用于构建【微前端】架构的 JavaScript 框架。** 你可以把它理解为一个**顶层的路由器和应用程序加载器**。\n\n它的核心思想是：将一个大型的单页前端应用（SPA）拆分成多个小型、独立、可以并行开发交付的“微应用”。然后，single-spa 负责在运行时根据一定的规则（通常是当前的 URL）动态地加载、展示、卸载这些微应用。\n\n---\n\n### 一个简单的比喻\n想象一下你的浏览器是一个舞台：\n\n+ **传统单体应用：** 只有一个庞大的剧团表演一整部冗长的戏剧。要更换一个演员（修改一个功能），需要整个剧团停下来重新排练（整个应用重新构建部署）。\n+ **single-spa 微前端：** 舞台（浏览器）本身是空的。有一个**导演（single-spa）**。导演手里有一个节目单（根配置），上面写着什么节目（微应用）在什么时刻（例如，URL 是 `/settings` 时）上台表演。\n    - 当报幕员说“下一个节目是《用户设置》”时（用户访问了 `/settings`），导演就喊：“《用户设置》剧组，上台！”（加载并挂载 React 微应用）。\n    - 节目表演完了（用户离开了 `/settings`），导演就喊：“《用户设置》剧组，下台！”（卸载 React 微应用）。\n    - 下一个节目是《商品列表》，另一个完全不同的剧组（Vue 微应用）就上台表演。\n\n**single-spa 就是这个导演**，它自己不表演具体内容，但它负责协调所有剧组（微应用）的上场和下场时机。\n\n---\n\n### 为什么需要 single-spa？（解决的问题）\n1. **技术栈无关：** 各个微应用可以使用不同的技术栈（React, Vue, Angular, Svelte 等）。团队可以自由选择或升级其技术栈，而不会影响其他团队。\n2. **独立开发、独立部署：** 每个微应用都由独立的团队开发、测试和部署，大大提升了团队的自治度和发布效率。\n3. **增量升级：** 允许你逐步重写一个老旧的巨型前端应用，可以一部分一部分地用新的框架替换，而不是一次性重写全部。\n4. **代码隔离：** 应用之间实现了良好的代码和样式隔离（虽然需要一些额外规范），避免了全局污染和冲突。\n\n---\n\n### single-spa 的核心工作原理\nsingle-spa 通过定义一套**生命周期协议**来工作。每个微应用都必须对外暴露三个核心的函数：\n\n1. `bootstrap`： 应用首次加载时执行一次，用于初始化。\n2. `mount`： 当激活条件满足时（例如用户访问了该应用的路由），执行此函数。应用需要在这个函数里完成渲染，将组件挂载到 DOM 上。\n3. `unmount`： 当激活条件不再满足时（例如用户离开了该路由），执行此函数。应用需要在这个函数里完成清理工作，将自己从 DOM 上卸载。\n\nsingle-spa 的“根配置”会**注册**所有微应用，并为每个应用定义一个 `activity function`（激活函数）。这个函数通常根据 `window.location` 进行判断。\n\njavascript\n\n```javascript\n// single-spa 根配置示例 (root-config.js)\nimport { registerApplication, start } from 'single-spa';\n\n// 注册一个应用\nregisterApplication({\n  name: 'my-react-app', // 应用唯一名\n  app: () => System.import('my-react-app'), // 如何加载该应用的代码\n  activeWhen: (location) => location.pathname.startsWith('/react'), // 激活函数：当路径以 /react 开头时，加载这个应用\n});\n\n// 启动 single-spa\nstart();\n```\n\n**流程如下：**\n\n1. 用户访问 `https://example.com/react`。\n2. single-spa 检查所有注册的应用，发现 `my-react-app` 的 `activeWhen` 函数返回 `true`。\n3. single-spa 动态加载 `my-react-app` 的代码包。\n4. 依次执行该应用的 `bootstrap` 和 `mount` 生命周期函数，应用被渲染到页面上。\n5. 用户导航到 `/vue`，`my-react-app` 的 `activeWhen` 返回 `false`。\n6. single-spa 执行它的 `unmount` 函数，将其卸载。\n\n---\n\n### 主要优缺点\n**优点：**\n\n+ **强大的解耦和能力：** 真正实现了前端应用的拆分和团队自治。\n+ **框架无关：** 是整合不同技术栈应用的理想选择。\n+ **懒加载：** 提升首次加载速度，按需加载应用。\n\n**缺点：**\n\n+ **复杂度高：** 引入了分布式系统的复杂性，需要解决依赖共享、样式隔离、通信机制等问题。\n+ **开发体验：** 调试和配置比单体应用更复杂。通常需要类似 `single-spa` 官方的 `create-single-spa` 工具链来简化流程。\n+ **依赖管理：** 需要谨慎处理共享库（如 `react`, `vue`）以避免重复打包。\n\n---\n\n### 与 Module Federation 的区别\nWebpack 5 的 **Module Federation（模块联邦）** 是另一种实现微前端的热门技术。它们不是互斥的，甚至可以结合使用：\n\n+ **single-spa** 主要解决的是**路由和应用生命周期管理**的问题（“什么时候加载哪个应用”）。\n+ **Module Federation** 主要解决的是**应用之间代码共享和依赖处理**的问题（“如何共享一个 React 实例，避免重复加载”）。\n\n一个常见的模式是：使用 **single-spa 作为路由器**，使用 **Module Federation 来加载微应用和共享依赖**。\n\n### 总结\n**single-spa 是一个成熟、强大的微前端解决方案，它通过一套生命周期协议，将多个独立开发、独立部署的微应用组合成一个完整的单体体验。它非常适合大型企业级应用、需要整合不同技术栈或进行增量迁移的项目。**虽然它引入了一定的复杂性，但它为解决前端单体膨胀问题提供了非常系统化的思路和工具。\n\nhtml entry和js entry的概念是什么\n\n好的，这是一个非常核心的微前端概念。`**js-entry**` 和 `**html-entry**` 是微前端中两种不同的应用打包和加载方式，它们代表了两种不同的设计哲学和实现技术。\n\n---\n\n### 核心概念对比\n| **特性** | **js-entry (JavaScript 入口)** | **html-entry (HTML 入口)** |\n| --- | --- | --- |\n| **入口文件** | 一个 JavaScript 文件 (e.g., `app.js`<br/>) | 一个 HTML 文件 (e.g., `index.html`<br/>) |\n| **内容** | 主要包含 **JavaScript 逻辑和组件** | 包含 **HTML、**`**<script>**`<br/>**、**`**<link>**`<br/>**、**`**<style>**` |\n| **加载方式** | 框架（如 single-spa）加载并执行 JS 文件 | 框架通过 **fetch** 获取 HTML，解析出其中的 JS/CSS 并执行 |\n| **样式处理** | **需要手动管理**。通常需要约定（如 CSS Modules, CSS-in-JS）或工具来避免冲突。 | **自动处理**。HTML 中的 `<link>`<br/> 和 `<style>`<br/> 标签会被自动插入到 `<head>`<br/> 中。 |\n| **沙箱隔离** | 通常需要额外的库（如 `qiankun`<br/> 的沙箱）来实现 JS 和 CSS 的运行时隔离。 | 天然更易于实现**HTML级别的沙箱**（例如，创建一个 Shadow DOM 来包裹整个微应用的内容）。 |\n| **代表性方案** | 原始的 **single-spa** 方案 | **qiankun**（基于 single-spa）、**Module Federation**（某种程度上） |\n\n\n---\n\n### 深入理解\n#### 1. js-entry (JavaScript 入口)\n这是 **single-spa 早期和官方推荐**的方式。它的理念是：一个微应用**本质上是一个 JavaScript 模块**，这个模块导出了 `bootstrap`, `mount`, `unmount` 等生命周期函数。\n\n**如何工作？**\n\n1. 主应用（容器）根据路由规则，判断需要加载微应用 A。\n2. 主应用通过 `System.import()` 或 `import()` 动态加载微应用 A 的 **入口 JS 文件**（例如 `https://a.com/app.js`）。\n3. 这个 JS 文件被执行，并返回一个包含生命周期函数的对象。\n4. 主应用依次调用微应用的 `bootstrap` 和 `mount` 函数。\n5. 在 `mount` 函数中，微应用**用自己的逻辑**将组件渲染到主应用提供的 DOM 容器中。\n\n**示例代码 (single-spa 配置)：**\n\njavascript\n\n```javascript\nregisterApplication({\n  name: 'my-app',\n  // 这里是一个 js-entry，指向一个 JS 文件\n  app: () => System.import('https://a.com/js/app.js'),\n  activeWhen: '/app'\n});\n```\n\n**优点：**\n\n+ 概念清晰，符合“应用即模块”的理念。\n+ 打包输出干净，通常是一个或多个 JS 包。\n\n**缺点：**\n\n+ **样式处理麻烦**：你需要自己在微应用的 JS 代码里引入 CSS（如 `import './app.css'`），并小心全局样式冲突。\n+ **需要额外配置**：为了实现资源加载和隔离，需要复杂的 Webpack 配置和额外的库。\n\n#### 2. html-entry (HTML 入口)\n这种方式的理念是：一个微应用是**一个完整的、可以独立运行的“页面”**。主应用只需要加载这个页面的 HTML 文件，剩下的资源（JS, CSS）都由这个 HTML 文件自己声明。\n\n**如何工作？**\n\n1. 主应用根据路由规则，判断需要加载微应用 B。\n2. 主应用通过 **fetch** 请求微应用 B 的**入口 HTML 文件**（例如 `https://b.com/index.html`）。\n3. 主应用**解析**这个 HTML 文件，提取出其中的 `**<script>**`** ****和**** **`**<link>**`** ****标签**。\n4. 主应用手动创建这些 `<script>` 和 `<link>` 元素，并将它们插入到主文档的 `<head>` 中，从而加载并执行微应用的 JS 和 CSS。\n5. 同时，主应用通常会提供一个**隔离的沙箱环境**（如 Shadow DOM），将微应用的整个 DOM 结构渲染在其中。\n\n**示例概念（qiankun 的做法）：**\n\njavascript\n\n```javascript\nimport { registerMicroApps, start } from 'qiankun';\n\nregisterMicroApps([\n  {\n    name: 'vue-app',\n    // 这里是一个 html-entry，指向一个 HTML 文件\n    entry: '//localhost:7101', // 会默认加载这个地址下的 index.html\n    container: '#container',\n    activeRule: '/vue',\n  },\n]);\nstart();\n```\n\n**优点：**\n\n+ **对旧项目更友好**：很多老项目（如 jQuery、Backbone 项目）本身就是以 HTML 为中心开发的，改造为 html-entry 更容易。\n+ **资源加载自动化**：无需在 JS 中手动引入资源，HTML 中声明的所有资源都会被自动加载。\n+ **更强大的隔离能力**：更容易与 Shadow DOM 结合，实现真正的样式和作用域隔离。\n\n**缺点：**\n\n+ **需要解析 HTML**：主应用需要具备解析 HTML 并提取资源的能力，实现起来比直接 `import` 一个 JS 文件更复杂。\n+ **可能加载多余资源**：如果 HTML 中声明了多个入口，需要更精细的解析策略来避免加载未使用的资源。\n\n---\n\n### 总结与类比\n| **概念** | **类比** |\n| --- | --- |\n| `**js-entry**` | 就像 **“组装电脑”**。主应用（你）买来各个零件（JS 逻辑、手动引入的 CSS），自己动手组装成一台完整的电脑（微应用）。控制力强，但过程繁琐。 |\n| `**html-entry**` | 就像 **“购买品牌整机”**。主应用（你）直接买来一台戴尔电脑（HTML 文件），插上电（插入 DOM）就能用。开箱即用，非常方便，但内部细节被封装了。 |\n\n\n**现代趋势：**\n\n+ 纯粹的 `js-entry` 由于其配置的复杂性，在直接使用时体验并不友好。\n+ **qiankun** 这类框架通过实现 `html-entry` 模式，极大地改善了开发者体验，降低了微前端的上手门槛。\n+ **Webpack Module Federation** 提供了另一种更现代化的 `js-entry`，它通过复杂的依赖共享机制，解决了 `js-entry` 的许多痛点（如共享库重复加载），可以看作是 `js-entry` 的终极进化形态。\n\n因此，选择哪种方式取决于你的技术栈和框架：\n\n+ 使用 **原始的 single-spa**，你通常需要处理 `js-entry`。\n+ 使用 **qiankun**，你享受的是 `html-entry` 带来的便利。\n+ 使用 **Module Federation**，你体验的是高级的、基于依赖共享的 `js-entry`。\n\n## 路由分发可以实现微前端架构吗\n当然可以。**路由分发是实现微前端架构最主要、最常用也是最经典的方式**。它被认为是微前端架构的“第一种模式”，并且非常有效。\n\n### 核心思想\n**通过路由（URL）的变化，来决定在页面容器中加载、展示和卸载哪个微前端应用。** 主应用（通常称为“容器应用”或“根应用”）充当一个**路由器**和**编排者**的角色，而各个微应用则是独立开发、部署的功能模块。\n\n---\n\n### 它是如何工作的？\n1. **一个路由规则集**：主应用中维护一个配置表，将特定的 URL 路径模式（如 `/app1/*`, `/settings`, `/dashboard`）映射到对应的微应用。\n2. **监听路由变化**：主应用监听 `popstate`、`hashchange` 等浏览器路由事件。\n3. **匹配与决策**：当路由发生变化时（用户点击链接或手动输入 URL），主应用根据配置表判断当前应该激活哪个微应用。\n4. **加载与挂载**：主应用动态获取该微应用的资源（JS, CSS），并将其挂载到页面中指定的 DOM 容器（如 `<div id=\"micro-app-container\">`）中。\n5. **卸载与清理**：当用户离开当前路由时，主应用会卸载之前的微应用，并进行必要的清理工作（如清除事件监听器、内存释放等），然后加载新的微应用。\n\n## webpack5的Module Federation可以详细说说嘛\n好的，我们来深入、详细地探讨 Webpack 5 的 **Module Federation（模块联邦）**。它不仅仅是微前端的一种实现方式，更是一种革命性的架构思想。\n\n### 一、核心概念：它是什么？\n**Module Federation (MF)** 的核心目标是：**允许一个 JavaScript 应用在运行时动态地从另一个应用加载代码并共享依赖**。\n\n你可以把它想象成在浏览器端实现了类似 Node.js 的 `require` 或 `import` 机制，但不是在本地文件系统，而是在**网络上的不同独立应用之间**。\n\n它打破了传统的应用隔离边界，允许应用彼此成为“模块提供者”和“模块消费者”。\n\n---\n\n### 二、为什么要用 Module Federation？(解决的核心痛点)\n1. **彻底解决依赖重复打包**\n    - **传统微前端**：如果主应用和微应用都使用了 React、Vue 等相同的库，这些库的代码会被分别打包到各自的 bundle 中。用户浏览器会多次下载和执行相同的库代码，导致体积膨胀和性能下降。\n    - **MF**：可以**指定共享依赖**。React 等库只加载一次，所有应用都使用同一份实例。这解决了最重要的“依赖地狱”问题。\n2. **更彻底的应用拆分与团队自治**\n    - 它允许将应用拆分成更细粒度的“模块”或“组件”，而不仅仅是“页面”或“应用”。\n    - 团队可以独立开发、部署**一个按钮、一个表单、一个页面**，并让其他团队直接消费。\n3. **运行时动态集成**\n    - 代码集成发生在运行时（Runtime），而非构建时（Build-time）。这意味着：\n        * 你可以进行 **A/B 测试**，动态切换不同版本的组件。\n        * 可以**独立部署**某个模块，而无需重新部署整个应用。\n        * 主应用甚至不需要提前知道所有可能被加载的微应用。\n\n---\n\n### 三、核心角色与配置\nMF 中有两个关键角色：\n\n1. **Remote (远程模块/消费者)**\n    - 它是一个**使用方**应用，在运行时从其他地方（`Host`）导入并执行代码。\n    - 它的配置使用 `remotes` 属性。\n2. **Host (宿主模块/提供者)**\n    - 它是一个**提供方**应用，将其内部的某些模块暴露给外部使用。\n    - 它的配置使用 `exposes` 属性。\n\n**一个应用可以同时是**** **`**Host**`** ****和**** **`**Remote**`。\n\n#### 配置详解 (`webpack.config.js`)\njavascript\n\n```javascript\n// Host 应用的配置 (提供模块的应用，端口3001)\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  // ...其他配置\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app1', // 必填，这个应用的唯一名称，是消费者调用时的标识\n      filename: 'remoteEntry.js', // 必填，对外暴露的入口文件清单名\n      exposes: { // 暴露哪些模块给外部使用\n        './Button': './src/components/Button', // 键：供外部使用的别名；值：本地模块路径\n        './App': './src/App',\n      },\n      shared: { // 共享的依赖库\n        react: { \n          singleton: true, // 确保只使用一个单例版本\n          requiredVersion: '^18.2.0' // 需要的版本\n        },\n        'react-dom': {\n          singleton: true,\n          requiredVersion: '^18.2.0'\n        },\n      },\n    }),\n  ],\n};\n```\n\njavascript\n\n```javascript\n// Remote 应用的配置 (消费模块的应用，端口3002)\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  // ...其他配置\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'app2',\n      remotes: { // 声明要消费哪些远程应用\n        // 格式: \"name@url/remoteEntry.js\"\n        app1: 'app1@http://localhost:3001/remoteEntry.js',\n      },\n      shared: { // 共享依赖的配置必须与Host一致，才能成功共享\n        react: { \n          singleton: true,\n          requiredVersion: '^18.2.0'\n        },\n        'react-dom': {\n          singleton: true,\n          requiredVersion: '^18.2.0'\n        },\n      },\n    }),\n  ],\n};\n```\n\n---\n\n### 四、如何使用？\n在 `app2` (Remote) 的代码中，你可以像导入本地模块一样**动态导入** `app1` (Host) 暴露的模块：\n\njavascript\n\n```javascript\n// 在 app2 的 React 组件中\nimport React, { Suspense } from 'react';\n\n// 使用动态导入语法。`app1` 是配置中remotes的key，`./Button` 是app1暴露的模块名\nconst RemoteButton = React.lazy(() => import('app1/Button'));\n\nfunction App() {\n  return (\n    <div>\n    <h1>我是 App2</h1>\n    <Suspense fallback={<div>Loading Button...</div>}>\n  {/* 这个Button组件来自另一个独立应用 app1！ */}\n  <RemoteButton />\n    </Suspense>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n---\n\n### 五、工作流程（魔法是如何发生的？）\n1. **构建阶段**：\n    - `Host` (`app1`) 构建时，会生成一个 `remoteEntry.js` 文件。这个文件是一个**清单(Manifest)**，记录了 `exposes` 了哪些模块以及如何获取它们。\n    - `Remote` (`app2`) 构建时，会意识到 `import('app1/Button')` 是一个远程模块，不会将其打包到自己的 bundle 中。\n2. **运行时阶段**：\n    - 浏览器加载 `app2`。\n    - 当执行到 `import('app1/Button')` 时，Webpack 运行时就会去检查配置。\n    - 它发现 `app1` 对应 `http://localhost:3001/remoteEntry.js`，于是**动态加载**这个 `remoteEntry.js` 文件。\n    - `remoteEntry.js` 告诉 `app2` 如何从 `app1` 的服务器上获取 `Button` 组件的代码块。\n    - Webpack 加载这个代码块，并**与**** **`**app2**`** ****共享的**** **`**react**`** ****和**** **`**react-dom**`** ****实例一起执行它**。\n    - 组件渲染成功。\n\n---\n\n### 六、与 single-spa 等方案的对比\n| **特性** | **Module Federation** | **single-spa (传统方式)** |\n| --- | --- | --- |\n| **核心能力** | **模块共享与依赖管理** | **应用生命周期管理与路由** |\n| **集成方式** | **运行时动态导入** | 运行时加载（但依赖需各自处理） |\n| **依赖处理** | **卓越**。自动共享库，避免重复。 | **困难**。需要额外手动配置或工具解决。 |\n| **打包输出** | 生成 `remoteEntry.js`<br/> 清单文件 | 生成应用的入口 JS 文件 |\n| **粒度** | **非常细**。可以共享单个组件、函数、工具库。 | **较粗**。通常以整个“应用”或“页面”为单元。 |\n| **关系** | **互补**。可以**结合使用**：用 single-spa 做路由和生命周期管理，用 MF 来加载组件和共享依赖。 |  |\n\n\n### 总结\n**Webpack 5 的 Module Federation 是一项颠覆性的技术**。它不再是简单地将应用机械地拼凑在一起，而是真正实现了应用间代码的“无缝融合”与“依赖共享”。\n\n它最适合的场景包括：\n\n+ **大型平台型产品**：需要多个团队独立开发不同功能模块。\n+ **微前端架构**：是目前实现微前端最先进、最优雅的方案之一。\n+ **跨应用组件/工具库共享**：避免维护多个版本的通用组件。\n\n它代表了前端架构从“单体”到“分布式”演进的重要方向，是每一位前端架构师都应该深入理解的技术。\n\nweb component\n\n## 好的，我们来全面、深入地探讨 Web Components。\n### 一、核心概念：它是什么？\n**Web Components** 是一套**浏览器原生支持**的技术集合，允许你创建可重用的、封装的自定义 HTML 元素（类似于 `<div>`、`<button>`，但是是你自己定义的），并在任何现代浏览器中使用它们，无需任何外部框架（如 React、Vue、Angular）。\n\n它的核心目标是为 Web 开发提供**真正的组件化模型**，并解决代码重用和封装的问题。\n\n---\n\n### 二、为什么需要 Web Components？（解决的问题）\n1. **框架无关性 (Framework-Agnostic)**\n    - 你用 Web Components 编写的组件可以在任何 HTML 页面中使用，无论这个页面用的是 React、Vue、Angular、jQuery 还是纯 JavaScript。它提供了**最大程度的可移植性**。\n2. **原生封装 (Native Encapsulation)**\n    - **Shadow DOM** 提供了强大的样式和行为封装。组件内部的样式不会泄漏到外部，外部的样式也不会渗透到组件内部（除非特意允许）。这彻底解决了 CSS 全局污染的问题。\n3. **长期稳定性 (Longevity)**\n    - 作为**Web 平台标准**，它由浏览器厂商直接实现和维护，不像前端框架那样有生命周期（例如，AngularJS 到 Angular 的断代升级）。你写的组件在未来很多年内都能继续工作。\n4. **生态系统互操作性 (Interoperability)**\n    - 它可以在任何框架中被当作普通的 HTML 元素使用，成为了连接不同技术栈应用的“桥梁”。\n\n---\n\n### 三、技术构成（四大核心技术）\nWeb Components 主要由四项技术标准组成，它们可以单独使用，但组合在一起威力最大。\n\n#### 1. Custom Elements（自定义元素）\n一套 JavaScript API，允许你**定义自定义元素及其行为**。\n\n+ **如何定义**：通过继承 `HTMLElement` 类来创建一个新的元素类。\n+ **生命周期回调**：\n    - `connectedCallback`: 当元素首次被插入到 DOM 时调用。\n    - `disconnectedCallback`: 当元素从 DOM 中移除时调用。\n    - `adoptedCallback`: 当元素被移动到新的文档时调用。\n    - `attributeChangedCallback`: 当元素的被观察属性（在 `observedAttributes` 中定义）发生变化时调用。\n\n**示例：定义一个简单的自定义元素**\n\njavascript\n\n```javascript\nclass MyButton extends HTMLElement {\n  constructor() {\n    super();\n    // 初始化逻辑\n  }\n\n  connectedCallback() {\n    this.innerHTML = `<button>Click Me!</button>`;\n    this.addEventListener('click', () => {\n      alert('Button clicked!');\n    });\n  }\n\n  // 定义需要监听的属性\n  static get observedAttributes() {\n    return ['disabled'];\n  }\n\n  // 当disabled属性变化时触发\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === 'disabled') {\n      console.log(`disabled changed from ${oldValue} to ${newValue}`);\n    }\n  }\n}\n\n// 向浏览器注册这个新元素，标签名必须包含连字符 `-`\ncustomElements.define('my-button', MyButton);\n```\n\n**在 HTML 中使用**：\n\nhtml\n\n<my-button disabled></my-button>\n\n#### 2. Shadow DOM（影子 DOM）\n一套用于将**封装的、“影子”的 DOM 树附加到元素**的 API。这是实现样式和行为封装的关键。\n\n+ **Shadow Root**：Shadow DOM 的根节点。\n+ **模式**：\n    - `open`: 可以通过 JavaScript 从外部访问（例如 `element.shadowRoot`）。\n    - `closed`: 外部无法访问，封装性更强。\n+ **作用域**：在 Shadow DOM 内部定义的样式和脚本只在这个范围内有效，与外部隔离。\n\n**示例：为自定义元素添加 Shadow DOM**\n\njavascript\n\n```javascript\nclass MyCard extends HTMLElement {\n  constructor() {\n    super();\n    // 附加一个打开的 Shadow Root\n    const shadow = this.attachShadow({ mode: 'open' });\n\n    // 创建模板\n    const template = document.createElement('template');\n    template.innerHTML = `\n      <style>\n        /* 这些样式只在这个卡片内有效，不会影响外部 */\n        .card {\n          border: 1px solid #ccc;\n          padding: 16px;\n          border-radius: 8px;\n          font-family: sans-serif;\n        }\n        h2 { color: blue; margin-top: 0; }\n      </style>\n      <div class=\"card\">\n        <h2><slot name=\"title\">Default Title</slot></h2>\n        <p><slot name=\"content\">Default content...</slot></p>\n      </div>\n    `;\n\n    // 克隆模板内容并添加到 Shadow Root\n    shadow.appendChild(template.content.cloneNode(true));\n  }\n}\ncustomElements.define('my-card', MyCard);\n```\n\n**在 HTML 中使用**：\n\nhtml\n\n```plain\n<my-card>\n  <!-- 使用 slot 将外部内容投影到 Shadow DOM 中的指定位置 -->\n  <span slot=\"title\">My Awesome Title</span>\n  <span slot=\"content\">This is some fantastic content.</span>\n</my-card>\n```\n\n#### 3. HTML Templates（HTML 模板）\n`<template>` 和 `<slot>` 元素允许你编写**在页面加载时不会立即渲染的标记模板**。这些模板可以被后续的 JavaScript 激活和使用。\n\n+ `<template>`：内容不会被浏览器解析、渲染或执行，直到被 JavaScript 提取并使用。\n+ `<slot>`：在 Web Component 内部充当占位符，允许用户在使用组件时传入自己的自定义内容（如上例所示）。\n\n#### 4. ES Modules（ES 模块）\n现代 JavaScript 的模块标准，为在 Web 上包含和重用 JS 代码提供了官方机制。它使得导入和导出 Web Components 变得简单。\n\nhtml\n\n```html\n<!-- 在 HTML 中导入并使用一个定义好的 Web Component -->\n<script type=\"module\" src=\"./my-component.js\"></script>\n<my-component></my-component>\n```\n\n---\n\n### 四、Web Components 的优点与缺点\n#### 优点：\n1. **浏览器原生**：无需编译，无需复杂的构建工具。\n2. **高度封装**：Shadow DOM 解决了 CSS 和 DOM 的隔离问题。\n3. **框架无关**：极高的互操作性和可移植性。\n4. **永久可用**：作为 Web 标准，具有极长的生命周期和向后兼容性。\n\n#### 缺点：\n1. **生态相对年轻**：虽然基础功能强大，但缺少像 React/Vue 那样庞大的生态系统（状态管理、路由、测试工具等）。\n2. **数据流管理较弱**：原生不支持类似 React 的 Props 向下传递、事件向上冒泡的父子组件通信范式，需要自己实现（通常用 Custom Events）。\n3. **SSR (服务器端渲染) 支持差**：自定义元素可以在服务器上渲染，但其动态行为和客户端激活（Hydration）非常复杂，远不如 Next.js/Nuxt.js 成熟。\n4. **开发体验 (DX)**：原始的开发方式比较繁琐，需要写很多样板代码。但社区有诸如 **Lit**、**Stencil** 等库来极大地改善体验。\n\n---\n\n### 五、Web Components 与微前端和框架\n+ **在微前端中**：Web Components 是实现**技术栈无关**微前端的理想载体。每个团队可以用自己熟悉的技术（React, Vue）**开发**组件，但最终**发布**为一个封装好的 Web Component（例如，将一个 React 组件包装成 `<team-product-card>`），由主应用统一调度。\n+ **与框架的关系**：\n    - **不是替代关系**，而是**互补关系**。\n    - **框架 (React/Vue) 擅长解决：** 复杂的 UI 状态管理、数据流、高效的 DOM 差分更新。它们提供了**优秀的开发体验**和**完整的解决方案**。\n    - **Web Components 擅长解决：** 跨框架重用、底层 UI 组件库、集成遗留应用、长期稳定的基础组件。它们提供了**浏览器级别的互操作性**。\n\n**总结来说，Web Components 是 Web 平台的底层基础，为构建可长期存在、高度封装、框架无关的组件提供了强大的原生能力。** 虽然它在开发复杂应用时不如现代框架那么方便，但其独特优势使其在特定场景（如微前端、跨技术栈组件库、大型企业级应用）中是不可替代的选择。\n\nqiankun实现样式和js隔离的原理\n\n好的，我们来深入剖析 **qiankun** 实现样式和 JavaScript 隔离的原理。这是 qiankun 的核心能力之一，也是它相比原始 single-spa 更易用、更强大的关键。\n\n### 总体思想\nqiankun 的隔离策略可以概括为：**“重样式隔离，轻 JS 沙箱”**。它通过在应用加载和卸载时动态地操作样式和 JavaScript 执行环境来模拟一个隔离的沙箱环境。\n\n---\n\n### 一、样式隔离 (CSS Isolation)\nqiankun 提供了三种主要的样式隔离方案，根据场景不同自动或手动启用。\n\n#### 1. 严格样式隔离 (Scoped CSS)\n**原理：** 为每个微应用包裹一个 **Shadow DOM**。\n\n+ **如何工作：**\n    1. 当 qiankun 挂载一个微应用时，它会创建一个 Shadow Root，并将其作为该应用的容器。\n    2. 微应用的所有 DOM 结构都被渲染在这个 Shadow DOM 内部。\n    3. **Shadow DOM 的特性天然实现了样式的封装**：内部的样式不会影响外部，外部的样式也不会影响内部（除非使用 `::part` 或 `:host` 等特定语法）。\n+ **优点：** 隔离性最强，是浏览器原生的完美隔离方案。\n+ **缺点：**\n    - 某些第三方库（特别是弹窗类）可能会因为无法正确定位到 Shadow DOM 外部而出现问题。\n    - 微应用内的样式完全无法影响主应用，反之亦然，有时这可能不符合设计需求。\n+ **启用方式：** 在 `start` 函数中配置 `{ strictStyleIsolation: true }`。\n\njavascript\n\n```javascript\nimport { start } from 'qiankun';\nstart({\n  strictStyleIsolation: true, // 启用严格样式隔离\n});\n```\n\n#### 2. 实验性样式隔离 (CSS Scoped)\n**原理：** 一种更宽松的隔离方式，使用 **运行时动态样式表重写**。\n\n+ **如何工作：**\n    1. qiankun 会劫持微应用运行时**动态添加样式标签（**`**<style>**`**,**** **`**<link>**`**）** 的行为。\n    2. 当微应用插入一个新的样式标签时，qiankun 会将其内容抓取过来。\n    3. 使用 **CSS 规则重写器**（例如 `postcss` 插件）为所有 CSS 选择器**添加一个特殊的前缀**。这个前缀通常基于微应用的名称或一个特定属性。\n    4. 将重写后的 CSS 内容插入到 `document.head` 中。\n    5. 同时，qiankun 会为微应用的**容器元素**添加上一步中使用的**相同属性**。\n\n**示例：**\n\n    - 微应用有一个样式规则：`.button { color: red; }`\n    - qiankun 将其重写为：`[data-qiankun=\"my-app\"] .button { color: red; }`\n    - 同时，微应用的容器 `<div>` 会获得属性：`<div data-qiankun=\"my-app\">...</div>`\n    - 这样，样式规则就只会在这个容器内生效。\n+ **优点：** 比 Shadow DOM 兼容性更好，允许微应用样式影响其容器内的任何元素（包括动态 append 到 body 的弹窗）。\n+ **缺点：** 是运行时重写，有一定性能开销，且是实验性功能。\n+ **启用方式：** 在 `start` 函数中配置 `{ experimentalStyleIsolation: true }`。\n\njavascript\n\n```javascript\nstart({\n  experimentalStyleIsolation: true, // 启用实验性样式隔离\n});\n```\n\n#### 3. 动态样式表加载/卸载 (最常见的默认行为)\n如果不开启上述两种隔离，qiankun 默认采用一种更简单但有效的策略。\n\n+ **原理：**\n    1. **加载时：** qiankun 通过 `fetch` 获取微应用的 HTML 入口，解析出所有的 `<style>` 和 `<link>` 标签。\n    2. 将这些样式标签**直接插入到**** **`**document.head**` 中。\n    3. **卸载时：** qiankun 会**记录**所有由该微应用添加的样式标签，并在卸载微应用时**直接将这些标签从 DOM 中移除**。\n+ **优点：** 实现简单，性能好。\n+ **缺点：** **不是真正的隔离**。如果多个微应用有相同选择器的样式规则，后加载的会覆盖先加载的（因为后加载的样式表在更后面，优先级更高）。这依赖于开发者的约定。\n+ **这是 qiankun 的默认行为**，对于很多应用来说已经足够。\n\n---\n\n### 二、JavaScript 隔离 (JS Sandbox)\nqiankun 的 JS 沙箱的核心目标是：**防止微应用在全局环境（**`**window**`**）上留下永久的污染，并在应用切换时恢复和清理环境**。它主要模拟了三个环境的隔离：\n\n#### 1. 快照沙箱 (SnapshotSandbox) - 用于单实例场景\n**原理：** 在应用加载前后对全局 `window` 对象进行“拍照”和“diff”，适用于同一时间只能有一个微应用活跃的浏览器环境。\n\n+ **工作流程：**\n    1. **激活沙箱 (mount)：** 将当前 `window` 的所有属性拍一个**快照**（`windowSnapshot`），存起来。\n    2. **微应用运行：** 微应用可以任意修改 `window`。\n    3. **失活沙箱 (unmount)：**\n        * 将当前的 `window` 和之前存的 `windowSnapshot` 进行对比，得到修改的差异（`modifyPropsMap`）。\n        * **还原现场：** 遍历差异，将 `window` 上的属性**恢复**到拍快照时的状态。\n        * **记录污染：** 将微应用修改的差异保存起来。\n    4. **再次激活：** 将之前保存的差异（`modifyPropsMap`）**重新应用到**** **`**window**`** ****上**，让微应用感觉自己的修改一直都在。\n+ **优点：** 兼容性极好，支持所有浏览器。\n+ **缺点：** 无法支持多个微应用同时运行（多实例），因为共用一个全局 `window`。\n\n#### 2. 代理沙箱 (ProxySandbox) - 用于多实例场景（主流）\n**原理：** 使用 ES6 的 `Proxy` 为每个微应用创建一个假的、隔离的 `window` 对象。\n\n+ **工作流程：**\n    1. qiankun 为每个微应用创建一个空的 `fakeWindow` 对象。\n    2. 用 `Proxy` 代理这个 `fakeWindow`。\n    3. 当微应用操作 `window` 时：\n        * **读操作**：优先从 `fakeWindow` 里读，如果读不到，则 fallback 到真正的全局 `window`（这样可以共享 `document`, `location` 等全局对象）。\n        * **写操作**：所有对属性的新增和修改都只作用于 `fakeWindow` 上，**完全不会污染真正的全局**** **`**window**`。\n    4. 微应用的所有代码都在这个代理的上下文中执行（通过 `with` 语句或 `eval` 改写）。\n+ **示例：**\n\njavascript\n\n```javascript\n// 微应用代码\nwindow.myGlobalVar = 123; // 写入的是沙箱的 fakeWindow，真 window 不受影响\nconsole.log(document.title); // 读取的是真 window 的属性\n```\n\n+ **优点：**\n    - 真正的隔离，多个微应用可以同时运行，每个都有自己独立的 `window` 空间。\n    - 对微应用无感知，无需修改代码。\n+ **缺点：** 依赖 ES6 `Proxy`，无法在低版本浏览器（如 IE）中使用。\n\n#### 3. 遗留沙箱 (LegacySandbox) - 已逐渐被代理沙箱取代\n原理类似于快照沙箱，但性能优化更好。它只记录微应用修改过的属性，在卸载时还原这些属性。同样不支持多实例。\n\n---\n\n### 总结：qiankun 的隔离策略\n| **隔离类型** | **技术方案** | **优点** | **缺点** | **适用场景** |\n| --- | --- | --- | --- | --- |\n| **样式隔离** | **Shadow DOM** | 原生，隔离最彻底 | 兼容性问题，弹窗等组件可能异常 | 需要最强隔离的新应用 |\n|  | **动态样式表重写 (实验性)** | 兼容性好，支持弹窗 | 运行时开销，实验性功能 | 需要兼容弹窗的复杂应用 |\n|  | **动态加载/卸载 (默认)** | 简单，性能好 | 非真正隔离，依赖约定 | 大多数简单应用，样式冲突风险低 |\n| **JS 隔离** | **快照沙箱 (SnapshotSandbox)** | 兼容所有浏览器 | 不支持多实例 | 单实例模式，需兼容 IE 等老浏览器 |\n|  | **代理沙箱 (ProxySandbox)** | 真正隔离，支持多实例，对应用无感知 | 依赖 `Proxy`<br/>，不兼容 IE | **现代浏览器下的主流选择** |\n\n\n**qiankun 会自动选择最佳策略**：在支持 `Proxy` 的浏览器中默认使用**代理沙箱 (多实例)** 和**动态样式加载/卸载**。如果不支持 `Proxy`，则降级到**快照沙箱 (单实例)**。\n\n通过这种组合策略，qiankun 在绝大多数场景下为微前端应用提供了**足够安全、稳定且高性能的隔离环境**，极大地简化了微前端的落地复杂度。\n\nqiankun是如何实现父子应用通信的呢\n\n好的，**qiankun 的通信机制**是其核心功能之一，它设计得非常灵活，提供了多种方式来实现主应用（父应用）和微应用（子应用）之间的通信。\n\nqiankun 并没有强制使用某一种通信方式，而是提供了一个轻量的 **API（**`**initGlobalState**`**）** 作为推荐方案，同时也完全支持任何其他流行的状态管理库（如 Redux, Mobx, Vuex）或浏览器原生 API。\n\n---\n\n### 一、官方推荐方案：使用 `initGlobalState` (Actions 通信)\n这是 qiankun 官方提供的通信方式，适用于大多数场景。它的核心思想是一个**简单的发布-订阅模式**。\n\n#### 1. 在主应用中初始化状态并下发通信方法\n主应用是整个状态的管理中心。\n\njavascript\n\n```javascript\n// main-app/src/actions.js\nimport { initGlobalState } from 'qiankun';\n\n// 1. 初始化全局状态\nconst initialState = {\n  user: {\n    name: '张三',\n    token: 'abc123'\n  },\n  theme: 'light'\n};\n\n// 2. 创建 Actions 实例\nconst actions = initGlobalState(initialState);\n\n// 3. 监听状态变化（可选，主应用自己也可以监听）\nactions.onGlobalStateChange((state, prevState) => {\n  // state: 变更后的新状态\n  // prevState: 变更前的旧状态\n  console.log('主应用监听到状态变化: ', state, prevState);\n});\n\n// 4. 定义一个更新状态的方法\nexport const setGlobalState = (newState) => {\n  // 按层级合并状态\n  actions.setGlobalState(newState);\n};\n\n// 5. 将 actions 暴露出去，供微应用使用\nexport default actions;\n```\n\n#### 2. 在微应用中获取并操作状态\n微应用需要从生命周期函数中获取到 `props`，其中就包含了通信方法。\n\njavascript\n\n```javascript\n// micro-app/src/main.js (入口文件)\nlet microAppActions; // 用来保存通信方法\n\n// 导出 qiankun 生命周期函数\nexport async function mount(props) {\n  console.log('微应用挂载了', props);\n  // 1. 从 props 中获取主应用下发的 actions\n  microAppActions = props;\n\n  // 2. 监听全局状态变化\n  props.onGlobalStateChange((state, prevState) => {\n    console.log('微应用监听到状态变化: ', state, prevState);\n    // 状态变化后，更新微应用自己的视图\n    renderApp(state);\n  });\n\n  // 3. 首次挂载，获取当前全局状态并渲染应用\n  renderApp(props.getGlobalState());\n}\n\nexport async function unmount() {\n  // 卸载时取消监听（qiankun 内部会自动清理，但显式取消是好习惯）\n  microAppActions.offGlobalStateChange();\n}\n\n// React/Vue 应用的渲染函数\nfunction renderApp(state) {\n  ReactDOM.render(<App globalState={state} actions={microAppActions} />, document.getElementById('app'));\n}\n```\n\n#### 3. 在微应用组件中具体使用\njavascript\n\n```javascript\n// micro-app/src/App.jsx\nimport React from 'react';\n\nfunction App({ globalState, actions }) {\n  const { user, theme } = globalState;\n\n  const handleChangeTheme = () => {\n    // 更新全局状态\n    actions.setGlobalState({\n      theme: theme === 'light' ? 'dark' : 'light'\n    });\n  };\n\n  return (\n    <div className={`app ${theme}`}>\n  <h1>微应用页面</h1>\n  <p>用户名: {user.name}</p>\n  <button onClick={handleChangeTheme}>切换主题</button>\n  </div>\n);\n}\n\nexport default App;\n```\n\n#### `initGlobalState` API 说明：\n+ `setGlobalState(state: object)`: 设置新的全局状态，会自动与旧状态进行**浅合并**。\n+ `onGlobalStateChange(callback: function)`: 注册监听器，状态变化时触发。\n+ `offGlobalStateChange()`: 取消监听。\n+ `getGlobalState()`: 获取当前全局状态。\n\n---\n\n### 二、其他通信方案\nqiankun 是框架无关的，因此你也可以选择任何你熟悉的通信方式。\n\n#### 1. 使用 CustomEvent (浏览器原生事件)\n**原理：** 利用浏览器原生的 `window.dispatchEvent` 和 `window.addEventListener` 进行通信。\n\njavascript\n\n```javascript\n// 主应用 - 发送事件\nwindow.dispatchEvent(new CustomEvent('main-app-event', {\n  detail: { // 通过 detail 传递数据\n    type: 'CHANGE_THEME',\n    payload: 'dark'\n  }\n}));\n\n// 微应用 - 接收事件\nwindow.addEventListener('main-app-event', (event) => {\n  const { type, payload } = event.detail;\n  // 处理事件...\n});\n\n// 微应用 - 发送事件（同理）\nwindow.dispatchEvent(new CustomEvent('micro-app-event', {\n  detail: { message: 'Hello from micro app' }\n}));\n```\n\n**优点：** 原生支持，非常简单。  \n**缺点：** 数据传递能力较弱（只能同步），缺乏状态管理能力，事件需要全局唯一命名以免冲突。\n\n#### 2. 使用 Redux/Mobx/Vuex 等状态库\n**原理：** 主应用和微应用**共享同一个状态库实例**。\n\n+ **步骤：**\n    1. 主应用创建一个 Redux Store 或其他状态库实例。\n    2. 将这个 Store 通过 `window` 对象或者微应用的 `props` 暴露给微应用。\n    3. 微应用连接到这个全局的 Store，进行状态的读取和分发 Action。\n\njavascript\n\n```javascript\n// 主应用 - 创建并暴露 store\nimport { createStore } from 'redux';\nconst globalStore = createStore(/* ... */);\nwindow.__MAIN_APP_STORE__ = globalStore; // 挂到全局\n\n// 微应用 - 获取并使用 store\nconst store = window.__MAIN_APP_STORE__;\nstore.dispatch({ type: 'AN_ACTION' });\nconst state = store.getState();\n```\n\n**优点：** 功能强大，可以处理复杂的业务逻辑和状态流。  \n**缺点：** 紧密耦合，主应用和微应用必须使用同一种状态库，且版本需要兼容。\n\n#### 3. 通过 URL 或 Query Parameters 通信\n**原理：** 通过改变 URL 的查询参数来传递简单信息。\n\njavascript\n\n```javascript\n// 主应用改变URL\nconst newUrl = `${window.location.pathname}?theme=dark&userId=123`;\nhistory.pushState(null, '', newUrl);\n\n// 微应用监听URL变化\nwindow.addEventListener('popstate', () => {\n  const urlParams = new URLSearchParams(window.location.search);\n  const theme = urlParams.get('theme');\n  // ...使用参数\n});\n```\n\n**优点：** 非常简单，状态可被收藏和分享。  \n**缺点：** 只适合传递少量简单数据。\n\n---\n\n### 总结与选择建议\n| **方案** | **优点** | **缺点** | **适用场景** |\n| --- | --- | --- | --- |\n| **官方**** **`**initGlobalState**` | **官方推荐**，简单轻量，满足大部分通信需求 | 功能相对简单，不适合极其复杂的场景 | **绝大多数微前端通信场景的首选** |\n| **CustomEvent** | 浏览器原生，非常简单 | 功能弱，只能传简单数据，易产生事件名冲突 | 简单的父子通知、触发动作 |\n| **Redux/Vuex 等** | 功能强大，适合复杂状态管理 | 耦合度高，主子和微应用必须使用同一种状态库 | 大型复杂应用，且技术栈统一 |\n| **URL Parameters** | 实现简单，状态可分享 | 传递数据量有限，类型受限 | 过滤条件、简单配置等 |\n\n\n**最佳实践建议：**\n\n1. **优先使用官方的**** **`**initGlobalState**`，它能覆盖 90% 的微前端通信需求。\n2. 对于简单的、一次性的动作触发（如“刷新列表”、“显示通知”），可以辅以 **CustomEvent**。\n3. 只有在主应用和所有微应用技术栈统一且非常复杂时，才考虑使用**共享状态库**。\n4. 通信的设计应遵循**最小化原则**，尽量减少主应用和微应用之间的耦合，让微应用保持最大的独立性。\n\n\n\n","slug":"微前端","published":1,"updated":"2025-09-14T11:21:36.278Z","_id":"cmfjkpz9g0000ma5wfkkshevh","comments":1,"layout":"post","photos":[],"content":"<p>参考链接：</p>\n<p><a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/78362028\" >可能是你见过最完善的微前端解决方案<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p><a class=\"link\"   href=\"https://juejin.cn/post/7244070072788287544?searchId=202508250257166071DDB47E623E0BA671\" >深入调研了微前端，还是iframe最香<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p><a class=\"link\"   href=\"https://qiankun.umijs.org/zh/guide/getting-started\" >qiankun官方文档<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<h3 id=\"什么是微前端？\"><a href=\"#什么是微前端？\" class=\"headerlink\" title=\"什么是微前端？\"></a>什么是微前端？</h3><p>微前端是一种软件架构，可以将前端应用拆解成一些更小的能够独立开发部署的微型应用，然后在将这些微型应用组合使其成为整体的架构模式。</p>\n<p>微前端类似于组件架构，但不同的是，组件不能够独立构建和发布，但是微前端中的应用是可以的。</p>\n<p>微前端架构与框架无关，每个微应用都可以使用不同的框架。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/png/55999631/1756118557192-c0cfb92e-8167-4ead-9795-0f7ddd7bb7c8.png\"\n                     \n                ></p>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>单体前端</strong></th>\n<th><strong>微前端</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>代码库</strong></td>\n<td>单个大型代码库</td>\n<td>多个独立代码库</td>\n</tr>\n<tr>\n<td><strong>团队结构</strong></td>\n<td>集中式团队</td>\n<td>分布式独立团队</td>\n</tr>\n<tr>\n<td><strong>技术栈</strong></td>\n<td>统一技术栈</td>\n<td>混合技术栈</td>\n</tr>\n<tr>\n<td><strong>部署</strong></td>\n<td>整体部署</td>\n<td>独立部署</td>\n</tr>\n<tr>\n<td><strong>开发速度</strong></td>\n<td>后期变慢</td>\n<td>持续快速</td>\n</tr>\n<tr>\n<td><strong>复杂度</strong></td>\n<td>高度耦合</td>\n<td>解耦独立</td>\n</tr>\n</tbody></table>\n<h3 id=\"微前端的价值\"><a href=\"#微前端的价值\" class=\"headerlink\" title=\"微前端的价值\"></a>微前端的价值</h3><p>微前端架构具备以下几个核心价值：</p>\n<ul>\n<li>技术栈无关 主框架不限制接入应用的技术栈，子应用具备完全自主权</li>\n<li>独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</li>\n<li>独立运行时 每个子应用之间状态隔离，运行时状态不共享</li>\n</ul>\n<p>微前端架构旨在解决<a class=\"link\"   href=\"https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLljZXkvZPlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.Sy3sQVozhhuQwuwmw8-zjyU0X_81Vve5linQ55OPo0k&zhida_source=entity\" >单体应用<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个<a class=\"link\"   href=\"https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%B7%A8%E7%9F%B3%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLlt6jnn7PlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.3VWm6X4yZDpq2_EqJZDuDErH1ST1iWJUa0qPK8T5Abk&zhida_source=entity\" >巨石应用<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>(<a class=\"link\"   href=\"https://link.zhihu.com/?target=https://www.youtube.com/watch?v=pU1gXA0rfwc\" >Frontend Monolith<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。</p>\n<p>应用架构如下：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/png/55999631/1756120029405-72a7f34d-4e09-4c78-b290-6ae5836720cb.png\"\n                     \n                ></p>\n<blockquote>\n<p>Stitching layer 作为主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用。因此主框架的定位则仅仅是：<strong>导航路由 + 资源加载框架</strong></p>\n</blockquote>\n<p>single-spa是什么</p>\n<p>好的，我们来详细解释一下 <strong>single-spa</strong> 是什么。</p>\n<h3 id=\"核心定义\"><a href=\"#核心定义\" class=\"headerlink\" title=\"核心定义\"></a>核心定义</h3><p><strong>single-spa 是一个用于构建【微前端】架构的 JavaScript 框架。</strong> 你可以把它理解为一个<strong>顶层的路由器和应用程序加载器</strong>。</p>\n<p>它的核心思想是：将一个大型的单页前端应用（SPA）拆分成多个小型、独立、可以并行开发交付的“微应用”。然后，single-spa 负责在运行时根据一定的规则（通常是当前的 URL）动态地加载、展示、卸载这些微应用。</p>\n<hr>\n<h3 id=\"一个简单的比喻\"><a href=\"#一个简单的比喻\" class=\"headerlink\" title=\"一个简单的比喻\"></a>一个简单的比喻</h3><p>想象一下你的浏览器是一个舞台：</p>\n<ul>\n<li><strong>传统单体应用：</strong> 只有一个庞大的剧团表演一整部冗长的戏剧。要更换一个演员（修改一个功能），需要整个剧团停下来重新排练（整个应用重新构建部署）。</li>\n<li><strong>single-spa 微前端：</strong> 舞台（浏览器）本身是空的。有一个<strong>导演（single-spa）</strong>。导演手里有一个节目单（根配置），上面写着什么节目（微应用）在什么时刻（例如，URL 是 <code>/settings</code> 时）上台表演。<ul>\n<li>当报幕员说“下一个节目是《用户设置》”时（用户访问了 <code>/settings</code>），导演就喊：“《用户设置》剧组，上台！”（加载并挂载 React 微应用）。</li>\n<li>节目表演完了（用户离开了 <code>/settings</code>），导演就喊：“《用户设置》剧组，下台！”（卸载 React 微应用）。</li>\n<li>下一个节目是《商品列表》，另一个完全不同的剧组（Vue 微应用）就上台表演。</li>\n</ul>\n</li>\n</ul>\n<p><strong>single-spa 就是这个导演</strong>，它自己不表演具体内容，但它负责协调所有剧组（微应用）的上场和下场时机。</p>\n<hr>\n<h3 id=\"为什么需要-single-spa？（解决的问题）\"><a href=\"#为什么需要-single-spa？（解决的问题）\" class=\"headerlink\" title=\"为什么需要 single-spa？（解决的问题）\"></a>为什么需要 single-spa？（解决的问题）</h3><ol>\n<li><strong>技术栈无关：</strong> 各个微应用可以使用不同的技术栈（React, Vue, Angular, Svelte 等）。团队可以自由选择或升级其技术栈，而不会影响其他团队。</li>\n<li><strong>独立开发、独立部署：</strong> 每个微应用都由独立的团队开发、测试和部署，大大提升了团队的自治度和发布效率。</li>\n<li><strong>增量升级：</strong> 允许你逐步重写一个老旧的巨型前端应用，可以一部分一部分地用新的框架替换，而不是一次性重写全部。</li>\n<li><strong>代码隔离：</strong> 应用之间实现了良好的代码和样式隔离（虽然需要一些额外规范），避免了全局污染和冲突。</li>\n</ol>\n<hr>\n<h3 id=\"single-spa-的核心工作原理\"><a href=\"#single-spa-的核心工作原理\" class=\"headerlink\" title=\"single-spa 的核心工作原理\"></a>single-spa 的核心工作原理</h3><p>single-spa 通过定义一套<strong>生命周期协议</strong>来工作。每个微应用都必须对外暴露三个核心的函数：</p>\n<ol>\n<li><code>bootstrap</code>： 应用首次加载时执行一次，用于初始化。</li>\n<li><code>mount</code>： 当激活条件满足时（例如用户访问了该应用的路由），执行此函数。应用需要在这个函数里完成渲染，将组件挂载到 DOM 上。</li>\n<li><code>unmount</code>： 当激活条件不再满足时（例如用户离开了该路由），执行此函数。应用需要在这个函数里完成清理工作，将自己从 DOM 上卸载。</li>\n</ol>\n<p>single-spa 的“根配置”会<strong>注册</strong>所有微应用，并为每个应用定义一个 <code>activity function</code>（激活函数）。这个函数通常根据 <code>window.location</code> 进行判断。</p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// single-spa 根配置示例 (root-config.js)</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; registerApplication, start &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;single-spa&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册一个应用</span></span><br><span class=\"line\"><span class=\"title function_\">registerApplication</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;my-react-app&#x27;</span>, <span class=\"comment\">// 应用唯一名</span></span><br><span class=\"line\">  <span class=\"attr\">app</span>: <span class=\"function\">() =&gt;</span> <span class=\"title class_\">System</span>.<span class=\"keyword\">import</span>(<span class=\"string\">&#x27;my-react-app&#x27;</span>), <span class=\"comment\">// 如何加载该应用的代码</span></span><br><span class=\"line\">  <span class=\"attr\">activeWhen</span>: <span class=\"function\">(<span class=\"params\">location</span>) =&gt;</span> location.<span class=\"property\">pathname</span>.<span class=\"title function_\">startsWith</span>(<span class=\"string\">&#x27;/react&#x27;</span>), <span class=\"comment\">// 激活函数：当路径以 /react 开头时，加载这个应用</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动 single-spa</span></span><br><span class=\"line\"><span class=\"title function_\">start</span>();</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>流程如下：</strong></p>\n<ol>\n<li>用户访问 <code>https://example.com/react</code>。</li>\n<li>single-spa 检查所有注册的应用，发现 <code>my-react-app</code> 的 <code>activeWhen</code> 函数返回 <code>true</code>。</li>\n<li>single-spa 动态加载 <code>my-react-app</code> 的代码包。</li>\n<li>依次执行该应用的 <code>bootstrap</code> 和 <code>mount</code> 生命周期函数，应用被渲染到页面上。</li>\n<li>用户导航到 <code>/vue</code>，<code>my-react-app</code> 的 <code>activeWhen</code> 返回 <code>false</code>。</li>\n<li>single-spa 执行它的 <code>unmount</code> 函数，将其卸载。</li>\n</ol>\n<hr>\n<h3 id=\"主要优缺点\"><a href=\"#主要优缺点\" class=\"headerlink\" title=\"主要优缺点\"></a>主要优缺点</h3><p><strong>优点：</strong></p>\n<ul>\n<li><strong>强大的解耦和能力：</strong> 真正实现了前端应用的拆分和团队自治。</li>\n<li><strong>框架无关：</strong> 是整合不同技术栈应用的理想选择。</li>\n<li><strong>懒加载：</strong> 提升首次加载速度，按需加载应用。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>复杂度高：</strong> 引入了分布式系统的复杂性，需要解决依赖共享、样式隔离、通信机制等问题。</li>\n<li><strong>开发体验：</strong> 调试和配置比单体应用更复杂。通常需要类似 <code>single-spa</code> 官方的 <code>create-single-spa</code> 工具链来简化流程。</li>\n<li><strong>依赖管理：</strong> 需要谨慎处理共享库（如 <code>react</code>, <code>vue</code>）以避免重复打包。</li>\n</ul>\n<hr>\n<h3 id=\"与-Module-Federation-的区别\"><a href=\"#与-Module-Federation-的区别\" class=\"headerlink\" title=\"与 Module Federation 的区别\"></a>与 Module Federation 的区别</h3><p>Webpack 5 的 <strong>Module Federation（模块联邦）</strong> 是另一种实现微前端的热门技术。它们不是互斥的，甚至可以结合使用：</p>\n<ul>\n<li><strong>single-spa</strong> 主要解决的是<strong>路由和应用生命周期管理</strong>的问题（“什么时候加载哪个应用”）。</li>\n<li><strong>Module Federation</strong> 主要解决的是<strong>应用之间代码共享和依赖处理</strong>的问题（“如何共享一个 React 实例，避免重复加载”）。</li>\n</ul>\n<p>一个常见的模式是：使用 <strong>single-spa 作为路由器</strong>，使用 <strong>Module Federation 来加载微应用和共享依赖</strong>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>**single-spa 是一个成熟、强大的微前端解决方案，它通过一套生命周期协议，将多个独立开发、独立部署的微应用组合成一个完整的单体体验。它非常适合大型企业级应用、需要整合不同技术栈或进行增量迁移的项目。**虽然它引入了一定的复杂性，但它为解决前端单体膨胀问题提供了非常系统化的思路和工具。</p>\n<p>html entry和js entry的概念是什么</p>\n<p>好的，这是一个非常核心的微前端概念。<code>**js-entry**</code> 和 <code>**html-entry**</code> 是微前端中两种不同的应用打包和加载方式，它们代表了两种不同的设计哲学和实现技术。</p>\n<hr>\n<h3 id=\"核心概念对比\"><a href=\"#核心概念对比\" class=\"headerlink\" title=\"核心概念对比\"></a>核心概念对比</h3><table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>js-entry (JavaScript 入口)</strong></th>\n<th><strong>html-entry (HTML 入口)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>入口文件</strong></td>\n<td>一个 JavaScript 文件 (e.g., <code>app.js</code><br/>)</td>\n<td>一个 HTML 文件 (e.g., <code>index.html</code><br/>)</td>\n</tr>\n<tr>\n<td><strong>内容</strong></td>\n<td>主要包含 <strong>JavaScript 逻辑和组件</strong></td>\n<td>包含 <strong>HTML、</strong><code>**&lt;script&gt;**</code><br/><strong>、</strong><code>**&lt;link&gt;**</code><br/><strong>、</strong><code>**&lt;style&gt;**</code></td>\n</tr>\n<tr>\n<td><strong>加载方式</strong></td>\n<td>框架（如 single-spa）加载并执行 JS 文件</td>\n<td>框架通过 <strong>fetch</strong> 获取 HTML，解析出其中的 JS&#x2F;CSS 并执行</td>\n</tr>\n<tr>\n<td><strong>样式处理</strong></td>\n<td><strong>需要手动管理</strong>。通常需要约定（如 CSS Modules, CSS-in-JS）或工具来避免冲突。</td>\n<td><strong>自动处理</strong>。HTML 中的 <code>&lt;link&gt;</code><br/> 和 <code>&lt;style&gt;</code><br/> 标签会被自动插入到 <code>&lt;head&gt;</code><br/> 中。</td>\n</tr>\n<tr>\n<td><strong>沙箱隔离</strong></td>\n<td>通常需要额外的库（如 <code>qiankun</code><br/> 的沙箱）来实现 JS 和 CSS 的运行时隔离。</td>\n<td>天然更易于实现<strong>HTML级别的沙箱</strong>（例如，创建一个 Shadow DOM 来包裹整个微应用的内容）。</td>\n</tr>\n<tr>\n<td><strong>代表性方案</strong></td>\n<td>原始的 <strong>single-spa</strong> 方案</td>\n<td><strong>qiankun</strong>（基于 single-spa）、<strong>Module Federation</strong>（某种程度上）</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"深入理解\"><a href=\"#深入理解\" class=\"headerlink\" title=\"深入理解\"></a>深入理解</h3><h4 id=\"1-js-entry-JavaScript-入口\"><a href=\"#1-js-entry-JavaScript-入口\" class=\"headerlink\" title=\"1. js-entry (JavaScript 入口)\"></a>1. js-entry (JavaScript 入口)</h4><p>这是 <strong>single-spa 早期和官方推荐</strong>的方式。它的理念是：一个微应用<strong>本质上是一个 JavaScript 模块</strong>，这个模块导出了 <code>bootstrap</code>, <code>mount</code>, <code>unmount</code> 等生命周期函数。</p>\n<p><strong>如何工作？</strong></p>\n<ol>\n<li>主应用（容器）根据路由规则，判断需要加载微应用 A。</li>\n<li>主应用通过 <code>System.import()</code> 或 <code>import()</code> 动态加载微应用 A 的 <strong>入口 JS 文件</strong>（例如 <code>https://a.com/app.js</code>）。</li>\n<li>这个 JS 文件被执行，并返回一个包含生命周期函数的对象。</li>\n<li>主应用依次调用微应用的 <code>bootstrap</code> 和 <code>mount</code> 函数。</li>\n<li>在 <code>mount</code> 函数中，微应用<strong>用自己的逻辑</strong>将组件渲染到主应用提供的 DOM 容器中。</li>\n</ol>\n<p><strong>示例代码 (single-spa 配置)：</strong></p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">registerApplication</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;my-app&#x27;</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 这里是一个 js-entry，指向一个 JS 文件</span></span><br><span class=\"line\">  <span class=\"attr\">app</span>: <span class=\"function\">() =&gt;</span> <span class=\"title class_\">System</span>.<span class=\"keyword\">import</span>(<span class=\"string\">&#x27;https://a.com/js/app.js&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">activeWhen</span>: <span class=\"string\">&#x27;/app&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>概念清晰，符合“应用即模块”的理念。</li>\n<li>打包输出干净，通常是一个或多个 JS 包。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>样式处理麻烦</strong>：你需要自己在微应用的 JS 代码里引入 CSS（如 <code>import &#39;./app.css&#39;</code>），并小心全局样式冲突。</li>\n<li><strong>需要额外配置</strong>：为了实现资源加载和隔离，需要复杂的 Webpack 配置和额外的库。</li>\n</ul>\n<h4 id=\"2-html-entry-HTML-入口\"><a href=\"#2-html-entry-HTML-入口\" class=\"headerlink\" title=\"2. html-entry (HTML 入口)\"></a>2. html-entry (HTML 入口)</h4><p>这种方式的理念是：一个微应用是<strong>一个完整的、可以独立运行的“页面”</strong>。主应用只需要加载这个页面的 HTML 文件，剩下的资源（JS, CSS）都由这个 HTML 文件自己声明。</p>\n<p><strong>如何工作？</strong></p>\n<ol>\n<li>主应用根据路由规则，判断需要加载微应用 B。</li>\n<li>主应用通过 <strong>fetch</strong> 请求微应用 B 的<strong>入口 HTML 文件</strong>（例如 <code>https://b.com/index.html</code>）。</li>\n<li>主应用<strong>解析</strong>这个 HTML 文件，提取出其中的 <code>**&lt;script&gt;**</code>** <strong><strong>和</strong></strong> <strong><code>**&lt;link&gt;**</code></strong> **<strong>标签</strong>。</li>\n<li>主应用手动创建这些 <code>&lt;script&gt;</code> 和 <code>&lt;link&gt;</code> 元素，并将它们插入到主文档的 <code>&lt;head&gt;</code> 中，从而加载并执行微应用的 JS 和 CSS。</li>\n<li>同时，主应用通常会提供一个<strong>隔离的沙箱环境</strong>（如 Shadow DOM），将微应用的整个 DOM 结构渲染在其中。</li>\n</ol>\n<p><strong>示例概念（qiankun 的做法）：</strong></p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; registerMicroApps, start &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;qiankun&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">registerMicroApps</span>([</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;vue-app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 这里是一个 html-entry，指向一个 HTML 文件</span></span><br><span class=\"line\">    <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;//localhost:7101&#x27;</span>, <span class=\"comment\">// 会默认加载这个地址下的 index.html</span></span><br><span class=\"line\">    <span class=\"attr\">container</span>: <span class=\"string\">&#x27;#container&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">activeRule</span>: <span class=\"string\">&#x27;/vue&#x27;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]);</span><br><span class=\"line\"><span class=\"title function_\">start</span>();</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li><strong>对旧项目更友好</strong>：很多老项目（如 jQuery、Backbone 项目）本身就是以 HTML 为中心开发的，改造为 html-entry 更容易。</li>\n<li><strong>资源加载自动化</strong>：无需在 JS 中手动引入资源，HTML 中声明的所有资源都会被自动加载。</li>\n<li><strong>更强大的隔离能力</strong>：更容易与 Shadow DOM 结合，实现真正的样式和作用域隔离。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>需要解析 HTML</strong>：主应用需要具备解析 HTML 并提取资源的能力，实现起来比直接 <code>import</code> 一个 JS 文件更复杂。</li>\n<li><strong>可能加载多余资源</strong>：如果 HTML 中声明了多个入口，需要更精细的解析策略来避免加载未使用的资源。</li>\n</ul>\n<hr>\n<h3 id=\"总结与类比\"><a href=\"#总结与类比\" class=\"headerlink\" title=\"总结与类比\"></a>总结与类比</h3><table>\n<thead>\n<tr>\n<th><strong>概念</strong></th>\n<th><strong>类比</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>**js-entry**</code></td>\n<td>就像 <strong>“组装电脑”</strong>。主应用（你）买来各个零件（JS 逻辑、手动引入的 CSS），自己动手组装成一台完整的电脑（微应用）。控制力强，但过程繁琐。</td>\n</tr>\n<tr>\n<td><code>**html-entry**</code></td>\n<td>就像 <strong>“购买品牌整机”</strong>。主应用（你）直接买来一台戴尔电脑（HTML 文件），插上电（插入 DOM）就能用。开箱即用，非常方便，但内部细节被封装了。</td>\n</tr>\n</tbody></table>\n<p><strong>现代趋势：</strong></p>\n<ul>\n<li>纯粹的 <code>js-entry</code> 由于其配置的复杂性，在直接使用时体验并不友好。</li>\n<li><strong>qiankun</strong> 这类框架通过实现 <code>html-entry</code> 模式，极大地改善了开发者体验，降低了微前端的上手门槛。</li>\n<li><strong>Webpack Module Federation</strong> 提供了另一种更现代化的 <code>js-entry</code>，它通过复杂的依赖共享机制，解决了 <code>js-entry</code> 的许多痛点（如共享库重复加载），可以看作是 <code>js-entry</code> 的终极进化形态。</li>\n</ul>\n<p>因此，选择哪种方式取决于你的技术栈和框架：</p>\n<ul>\n<li>使用 <strong>原始的 single-spa</strong>，你通常需要处理 <code>js-entry</code>。</li>\n<li>使用 <strong>qiankun</strong>，你享受的是 <code>html-entry</code> 带来的便利。</li>\n<li>使用 <strong>Module Federation</strong>，你体验的是高级的、基于依赖共享的 <code>js-entry</code>。</li>\n</ul>\n<h2 id=\"路由分发可以实现微前端架构吗\"><a href=\"#路由分发可以实现微前端架构吗\" class=\"headerlink\" title=\"路由分发可以实现微前端架构吗\"></a>路由分发可以实现微前端架构吗</h2><p>当然可以。<strong>路由分发是实现微前端架构最主要、最常用也是最经典的方式</strong>。它被认为是微前端架构的“第一种模式”，并且非常有效。</p>\n<h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p><strong>通过路由（URL）的变化，来决定在页面容器中加载、展示和卸载哪个微前端应用。</strong> 主应用（通常称为“容器应用”或“根应用”）充当一个<strong>路由器</strong>和<strong>编排者</strong>的角色，而各个微应用则是独立开发、部署的功能模块。</p>\n<hr>\n<h3 id=\"它是如何工作的？\"><a href=\"#它是如何工作的？\" class=\"headerlink\" title=\"它是如何工作的？\"></a>它是如何工作的？</h3><ol>\n<li><strong>一个路由规则集</strong>：主应用中维护一个配置表，将特定的 URL 路径模式（如 <code>/app1/*</code>, <code>/settings</code>, <code>/dashboard</code>）映射到对应的微应用。</li>\n<li><strong>监听路由变化</strong>：主应用监听 <code>popstate</code>、<code>hashchange</code> 等浏览器路由事件。</li>\n<li><strong>匹配与决策</strong>：当路由发生变化时（用户点击链接或手动输入 URL），主应用根据配置表判断当前应该激活哪个微应用。</li>\n<li><strong>加载与挂载</strong>：主应用动态获取该微应用的资源（JS, CSS），并将其挂载到页面中指定的 DOM 容器（如 <code>&lt;div id=&quot;micro-app-container&quot;&gt;</code>）中。</li>\n<li><strong>卸载与清理</strong>：当用户离开当前路由时，主应用会卸载之前的微应用，并进行必要的清理工作（如清除事件监听器、内存释放等），然后加载新的微应用。</li>\n</ol>\n<h2 id=\"webpack5的Module-Federation可以详细说说嘛\"><a href=\"#webpack5的Module-Federation可以详细说说嘛\" class=\"headerlink\" title=\"webpack5的Module Federation可以详细说说嘛\"></a>webpack5的Module Federation可以详细说说嘛</h2><p>好的，我们来深入、详细地探讨 Webpack 5 的 <strong>Module Federation（模块联邦）</strong>。它不仅仅是微前端的一种实现方式，更是一种革命性的架构思想。</p>\n<h3 id=\"一、核心概念：它是什么？\"><a href=\"#一、核心概念：它是什么？\" class=\"headerlink\" title=\"一、核心概念：它是什么？\"></a>一、核心概念：它是什么？</h3><p><strong>Module Federation (MF)</strong> 的核心目标是：<strong>允许一个 JavaScript 应用在运行时动态地从另一个应用加载代码并共享依赖</strong>。</p>\n<p>你可以把它想象成在浏览器端实现了类似 Node.js 的 <code>require</code> 或 <code>import</code> 机制，但不是在本地文件系统，而是在<strong>网络上的不同独立应用之间</strong>。</p>\n<p>它打破了传统的应用隔离边界，允许应用彼此成为“模块提供者”和“模块消费者”。</p>\n<hr>\n<h3 id=\"二、为什么要用-Module-Federation？-解决的核心痛点\"><a href=\"#二、为什么要用-Module-Federation？-解决的核心痛点\" class=\"headerlink\" title=\"二、为什么要用 Module Federation？(解决的核心痛点)\"></a>二、为什么要用 Module Federation？(解决的核心痛点)</h3><ol>\n<li><strong>彻底解决依赖重复打包</strong><ul>\n<li><strong>传统微前端</strong>：如果主应用和微应用都使用了 React、Vue 等相同的库，这些库的代码会被分别打包到各自的 bundle 中。用户浏览器会多次下载和执行相同的库代码，导致体积膨胀和性能下降。</li>\n<li><strong>MF</strong>：可以<strong>指定共享依赖</strong>。React 等库只加载一次，所有应用都使用同一份实例。这解决了最重要的“依赖地狱”问题。</li>\n</ul>\n</li>\n<li><strong>更彻底的应用拆分与团队自治</strong><ul>\n<li>它允许将应用拆分成更细粒度的“模块”或“组件”，而不仅仅是“页面”或“应用”。</li>\n<li>团队可以独立开发、部署<strong>一个按钮、一个表单、一个页面</strong>，并让其他团队直接消费。</li>\n</ul>\n</li>\n<li><strong>运行时动态集成</strong><ul>\n<li>代码集成发生在运行时（Runtime），而非构建时（Build-time）。这意味着：<ul>\n<li>你可以进行 <strong>A&#x2F;B 测试</strong>，动态切换不同版本的组件。</li>\n<li>可以<strong>独立部署</strong>某个模块，而无需重新部署整个应用。</li>\n<li>主应用甚至不需要提前知道所有可能被加载的微应用。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"三、核心角色与配置\"><a href=\"#三、核心角色与配置\" class=\"headerlink\" title=\"三、核心角色与配置\"></a>三、核心角色与配置</h3><p>MF 中有两个关键角色：</p>\n<ol>\n<li><strong>Remote (远程模块&#x2F;消费者)</strong><ul>\n<li>它是一个<strong>使用方</strong>应用，在运行时从其他地方（<code>Host</code>）导入并执行代码。</li>\n<li>它的配置使用 <code>remotes</code> 属性。</li>\n</ul>\n</li>\n<li><strong>Host (宿主模块&#x2F;提供者)</strong><ul>\n<li>它是一个<strong>提供方</strong>应用，将其内部的某些模块暴露给外部使用。</li>\n<li>它的配置使用 <code>exposes</code> 属性。</li>\n</ul>\n</li>\n</ol>\n<p><strong>一个应用可以同时是</strong>** <strong><code>**Host**</code></strong> <strong><strong>和</strong></strong> **<code>**Remote**</code>。</p>\n<h4 id=\"配置详解-webpack-config-js\"><a href=\"#配置详解-webpack-config-js\" class=\"headerlink\" title=\"配置详解 (webpack.config.js)\"></a>配置详解 (<code>webpack.config.js</code>)</h4><p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Host 应用的配置 (提供模块的应用，端口3001)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ModuleFederationPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack/lib/container/ModuleFederationPlugin&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...其他配置</span></span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">ModuleFederationPlugin</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;app1&#x27;</span>, <span class=\"comment\">// 必填，这个应用的唯一名称，是消费者调用时的标识</span></span><br><span class=\"line\">      <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;remoteEntry.js&#x27;</span>, <span class=\"comment\">// 必填，对外暴露的入口文件清单名</span></span><br><span class=\"line\">      <span class=\"attr\">exposes</span>: &#123; <span class=\"comment\">// 暴露哪些模块给外部使用</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;./Button&#x27;</span>: <span class=\"string\">&#x27;./src/components/Button&#x27;</span>, <span class=\"comment\">// 键：供外部使用的别名；值：本地模块路径</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;./App&#x27;</span>: <span class=\"string\">&#x27;./src/App&#x27;</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">shared</span>: &#123; <span class=\"comment\">// 共享的依赖库</span></span><br><span class=\"line\">        <span class=\"attr\">react</span>: &#123; </span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 确保只使用一个单例版本</span></span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span> <span class=\"comment\">// 需要的版本</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&#x27;react-dom&#x27;</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Remote 应用的配置 (消费模块的应用，端口3002)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ModuleFederationPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack/lib/container/ModuleFederationPlugin&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...其他配置</span></span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">ModuleFederationPlugin</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;app2&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">remotes</span>: &#123; <span class=\"comment\">// 声明要消费哪些远程应用</span></span><br><span class=\"line\">        <span class=\"comment\">// 格式: &quot;name@url/remoteEntry.js&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">app1</span>: <span class=\"string\">&#x27;app1@http://localhost:3001/remoteEntry.js&#x27;</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">shared</span>: &#123; <span class=\"comment\">// 共享依赖的配置必须与Host一致，才能成功共享</span></span><br><span class=\"line\">        <span class=\"attr\">react</span>: &#123; </span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&#x27;react-dom&#x27;</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h3 id=\"四、如何使用？\"><a href=\"#四、如何使用？\" class=\"headerlink\" title=\"四、如何使用？\"></a>四、如何使用？</h3><p>在 <code>app2</code> (Remote) 的代码中，你可以像导入本地模块一样<strong>动态导入</strong> <code>app1</code> (Host) 暴露的模块：</p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 app2 的 React 组件中</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; <span class=\"title class_\">Suspense</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用动态导入语法。`app1` 是配置中remotes的key，`./Button` 是app1暴露的模块名</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">RemoteButton</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">lazy</span>(<span class=\"function\">() =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;app1/Button&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>我是 App2<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">Suspense</span> <span class=\"attr\">fallback</span>=<span class=\"string\">&#123;</span>&lt;<span class=\"attr\">div</span>&gt;</span>Loading Button...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">  &#123;/* 这个Button组件来自另一个独立应用 app1！ */&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">RemoteButton</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Suspense</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span>;</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h3 id=\"五、工作流程（魔法是如何发生的？）\"><a href=\"#五、工作流程（魔法是如何发生的？）\" class=\"headerlink\" title=\"五、工作流程（魔法是如何发生的？）\"></a>五、工作流程（魔法是如何发生的？）</h3><ol>\n<li><strong>构建阶段</strong>：<ul>\n<li><code>Host</code> (<code>app1</code>) 构建时，会生成一个 <code>remoteEntry.js</code> 文件。这个文件是一个<strong>清单(Manifest)</strong>，记录了 <code>exposes</code> 了哪些模块以及如何获取它们。</li>\n<li><code>Remote</code> (<code>app2</code>) 构建时，会意识到 <code>import(&#39;app1/Button&#39;)</code> 是一个远程模块，不会将其打包到自己的 bundle 中。</li>\n</ul>\n</li>\n<li><strong>运行时阶段</strong>：<ul>\n<li>浏览器加载 <code>app2</code>。</li>\n<li>当执行到 <code>import(&#39;app1/Button&#39;)</code> 时，Webpack 运行时就会去检查配置。</li>\n<li>它发现 <code>app1</code> 对应 <code>http://localhost:3001/remoteEntry.js</code>，于是<strong>动态加载</strong>这个 <code>remoteEntry.js</code> 文件。</li>\n<li><code>remoteEntry.js</code> 告诉 <code>app2</code> 如何从 <code>app1</code> 的服务器上获取 <code>Button</code> 组件的代码块。</li>\n<li>Webpack 加载这个代码块，并<strong>与</strong>** <strong><code>**app2**</code></strong> <strong><strong>共享的</strong></strong> <strong><code>**react**</code></strong> <strong><strong>和</strong></strong> <strong><code>**react-dom**</code></strong> **<strong>实例一起执行它</strong>。</li>\n<li>组件渲染成功。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"六、与-single-spa-等方案的对比\"><a href=\"#六、与-single-spa-等方案的对比\" class=\"headerlink\" title=\"六、与 single-spa 等方案的对比\"></a>六、与 single-spa 等方案的对比</h3><table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>Module Federation</strong></th>\n<th><strong>single-spa (传统方式)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>核心能力</strong></td>\n<td><strong>模块共享与依赖管理</strong></td>\n<td><strong>应用生命周期管理与路由</strong></td>\n</tr>\n<tr>\n<td><strong>集成方式</strong></td>\n<td><strong>运行时动态导入</strong></td>\n<td>运行时加载（但依赖需各自处理）</td>\n</tr>\n<tr>\n<td><strong>依赖处理</strong></td>\n<td><strong>卓越</strong>。自动共享库，避免重复。</td>\n<td><strong>困难</strong>。需要额外手动配置或工具解决。</td>\n</tr>\n<tr>\n<td><strong>打包输出</strong></td>\n<td>生成 <code>remoteEntry.js</code><br/> 清单文件</td>\n<td>生成应用的入口 JS 文件</td>\n</tr>\n<tr>\n<td><strong>粒度</strong></td>\n<td><strong>非常细</strong>。可以共享单个组件、函数、工具库。</td>\n<td><strong>较粗</strong>。通常以整个“应用”或“页面”为单元。</td>\n</tr>\n<tr>\n<td><strong>关系</strong></td>\n<td><strong>互补</strong>。可以<strong>结合使用</strong>：用 single-spa 做路由和生命周期管理，用 MF 来加载组件和共享依赖。</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>Webpack 5 的 Module Federation 是一项颠覆性的技术</strong>。它不再是简单地将应用机械地拼凑在一起，而是真正实现了应用间代码的“无缝融合”与“依赖共享”。</p>\n<p>它最适合的场景包括：</p>\n<ul>\n<li><strong>大型平台型产品</strong>：需要多个团队独立开发不同功能模块。</li>\n<li><strong>微前端架构</strong>：是目前实现微前端最先进、最优雅的方案之一。</li>\n<li><strong>跨应用组件&#x2F;工具库共享</strong>：避免维护多个版本的通用组件。</li>\n</ul>\n<p>它代表了前端架构从“单体”到“分布式”演进的重要方向，是每一位前端架构师都应该深入理解的技术。</p>\n<p>web component</p>\n<h2 id=\"好的，我们来全面、深入地探讨-Web-Components。\"><a href=\"#好的，我们来全面、深入地探讨-Web-Components。\" class=\"headerlink\" title=\"好的，我们来全面、深入地探讨 Web Components。\"></a>好的，我们来全面、深入地探讨 Web Components。</h2><h3 id=\"一、核心概念：它是什么？-1\"><a href=\"#一、核心概念：它是什么？-1\" class=\"headerlink\" title=\"一、核心概念：它是什么？\"></a>一、核心概念：它是什么？</h3><p><strong>Web Components</strong> 是一套<strong>浏览器原生支持</strong>的技术集合，允许你创建可重用的、封装的自定义 HTML 元素（类似于 <code>&lt;div&gt;</code>、<code>&lt;button&gt;</code>，但是是你自己定义的），并在任何现代浏览器中使用它们，无需任何外部框架（如 React、Vue、Angular）。</p>\n<p>它的核心目标是为 Web 开发提供<strong>真正的组件化模型</strong>，并解决代码重用和封装的问题。</p>\n<hr>\n<h3 id=\"二、为什么需要-Web-Components？（解决的问题）\"><a href=\"#二、为什么需要-Web-Components？（解决的问题）\" class=\"headerlink\" title=\"二、为什么需要 Web Components？（解决的问题）\"></a>二、为什么需要 Web Components？（解决的问题）</h3><ol>\n<li><strong>框架无关性 (Framework-Agnostic)</strong><ul>\n<li>你用 Web Components 编写的组件可以在任何 HTML 页面中使用，无论这个页面用的是 React、Vue、Angular、jQuery 还是纯 JavaScript。它提供了<strong>最大程度的可移植性</strong>。</li>\n</ul>\n</li>\n<li><strong>原生封装 (Native Encapsulation)</strong><ul>\n<li><strong>Shadow DOM</strong> 提供了强大的样式和行为封装。组件内部的样式不会泄漏到外部，外部的样式也不会渗透到组件内部（除非特意允许）。这彻底解决了 CSS 全局污染的问题。</li>\n</ul>\n</li>\n<li><strong>长期稳定性 (Longevity)</strong><ul>\n<li>作为<strong>Web 平台标准</strong>，它由浏览器厂商直接实现和维护，不像前端框架那样有生命周期（例如，AngularJS 到 Angular 的断代升级）。你写的组件在未来很多年内都能继续工作。</li>\n</ul>\n</li>\n<li><strong>生态系统互操作性 (Interoperability)</strong><ul>\n<li>它可以在任何框架中被当作普通的 HTML 元素使用，成为了连接不同技术栈应用的“桥梁”。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"三、技术构成（四大核心技术）\"><a href=\"#三、技术构成（四大核心技术）\" class=\"headerlink\" title=\"三、技术构成（四大核心技术）\"></a>三、技术构成（四大核心技术）</h3><p>Web Components 主要由四项技术标准组成，它们可以单独使用，但组合在一起威力最大。</p>\n<h4 id=\"1-Custom-Elements（自定义元素）\"><a href=\"#1-Custom-Elements（自定义元素）\" class=\"headerlink\" title=\"1. Custom Elements（自定义元素）\"></a>1. Custom Elements（自定义元素）</h4><p>一套 JavaScript API，允许你<strong>定义自定义元素及其行为</strong>。</p>\n<ul>\n<li><strong>如何定义</strong>：通过继承 <code>HTMLElement</code> 类来创建一个新的元素类。</li>\n<li><strong>生命周期回调</strong>：<ul>\n<li><code>connectedCallback</code>: 当元素首次被插入到 DOM 时调用。</li>\n<li><code>disconnectedCallback</code>: 当元素从 DOM 中移除时调用。</li>\n<li><code>adoptedCallback</code>: 当元素被移动到新的文档时调用。</li>\n<li><code>attributeChangedCallback</code>: 当元素的被观察属性（在 <code>observedAttributes</code> 中定义）发生变化时调用。</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例：定义一个简单的自定义元素</strong></p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyButton</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">HTMLElement</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 初始化逻辑</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">connectedCallback</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">innerHTML</span> = <span class=\"string\">`&lt;button&gt;Click Me!&lt;/button&gt;`</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;Button clicked!&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义需要监听的属性</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> <span class=\"title function_\">observedAttributes</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">&#x27;disabled&#x27;</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 当disabled属性变化时触发</span></span><br><span class=\"line\">  <span class=\"title function_\">attributeChangedCallback</span>(<span class=\"params\">name, oldValue, newValue</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"string\">&#x27;disabled&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`disabled changed from <span class=\"subst\">$&#123;oldValue&#125;</span> to <span class=\"subst\">$&#123;newValue&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向浏览器注册这个新元素，标签名必须包含连字符 `-`</span></span><br><span class=\"line\">customElements.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;my-button&#x27;</span>, <span class=\"title class_\">MyButton</span>);</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>在 HTML 中使用</strong>：</p>\n<p>html</p>\n<p><my-button disabled></my-button></p>\n<h4 id=\"2-Shadow-DOM（影子-DOM）\"><a href=\"#2-Shadow-DOM（影子-DOM）\" class=\"headerlink\" title=\"2. Shadow DOM（影子 DOM）\"></a>2. Shadow DOM（影子 DOM）</h4><p>一套用于将<strong>封装的、“影子”的 DOM 树附加到元素</strong>的 API。这是实现样式和行为封装的关键。</p>\n<ul>\n<li><strong>Shadow Root</strong>：Shadow DOM 的根节点。</li>\n<li><strong>模式</strong>：<ul>\n<li><code>open</code>: 可以通过 JavaScript 从外部访问（例如 <code>element.shadowRoot</code>）。</li>\n<li><code>closed</code>: 外部无法访问，封装性更强。</li>\n</ul>\n</li>\n<li><strong>作用域</strong>：在 Shadow DOM 内部定义的样式和脚本只在这个范围内有效，与外部隔离。</li>\n</ul>\n<p><strong>示例：为自定义元素添加 Shadow DOM</strong></p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyCard</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">HTMLElement</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 附加一个打开的 Shadow Root</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> shadow = <span class=\"variable language_\">this</span>.<span class=\"title function_\">attachShadow</span>(&#123; <span class=\"attr\">mode</span>: <span class=\"string\">&#x27;open&#x27;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建模板</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> template = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;template&#x27;</span>);</span><br><span class=\"line\">    template.<span class=\"property\">innerHTML</span> = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      &lt;style&gt;</span></span><br><span class=\"line\"><span class=\"string\">        /* 这些样式只在这个卡片内有效，不会影响外部 */</span></span><br><span class=\"line\"><span class=\"string\">        .card &#123;</span></span><br><span class=\"line\"><span class=\"string\">          border: 1px solid #ccc;</span></span><br><span class=\"line\"><span class=\"string\">          padding: 16px;</span></span><br><span class=\"line\"><span class=\"string\">          border-radius: 8px;</span></span><br><span class=\"line\"><span class=\"string\">          font-family: sans-serif;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        h2 &#123; color: blue; margin-top: 0; &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/style&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;div class=&quot;card&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;h2&gt;&lt;slot name=&quot;title&quot;&gt;Default Title&lt;/slot&gt;&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;&lt;slot name=&quot;content&quot;&gt;Default content...&lt;/slot&gt;&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 克隆模板内容并添加到 Shadow Root</span></span><br><span class=\"line\">    shadow.<span class=\"title function_\">appendChild</span>(template.<span class=\"property\">content</span>.<span class=\"title function_\">cloneNode</span>(<span class=\"literal\">true</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">customElements.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;my-card&#x27;</span>, <span class=\"title class_\">MyCard</span>);</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>在 HTML 中使用</strong>：</p>\n<p>html</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-card&gt;</span><br><span class=\"line\">  &lt;!-- 使用 slot 将外部内容投影到 Shadow DOM 中的指定位置 --&gt;</span><br><span class=\"line\">  &lt;span slot=&quot;title&quot;&gt;My Awesome Title&lt;/span&gt;</span><br><span class=\"line\">  &lt;span slot=&quot;content&quot;&gt;This is some fantastic content.&lt;/span&gt;</span><br><span class=\"line\">&lt;/my-card&gt;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"3-HTML-Templates（HTML-模板）\"><a href=\"#3-HTML-Templates（HTML-模板）\" class=\"headerlink\" title=\"3. HTML Templates（HTML 模板）\"></a>3. HTML Templates（HTML 模板）</h4><p><code>&lt;template&gt;</code> 和 <code>&lt;slot&gt;</code> 元素允许你编写<strong>在页面加载时不会立即渲染的标记模板</strong>。这些模板可以被后续的 JavaScript 激活和使用。</p>\n<ul>\n<li><code>&lt;template&gt;</code>：内容不会被浏览器解析、渲染或执行，直到被 JavaScript 提取并使用。</li>\n<li><code>&lt;slot&gt;</code>：在 Web Component 内部充当占位符，允许用户在使用组件时传入自己的自定义内容（如上例所示）。</li>\n</ul>\n<h4 id=\"4-ES-Modules（ES-模块）\"><a href=\"#4-ES-Modules（ES-模块）\" class=\"headerlink\" title=\"4. ES Modules（ES 模块）\"></a>4. ES Modules（ES 模块）</h4><p>现代 JavaScript 的模块标准，为在 Web 上包含和重用 JS 代码提供了官方机制。它使得导入和导出 Web Components 变得简单。</p>\n<p>html</p>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 在 HTML 中导入并使用一个定义好的 Web Component --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;module&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./my-component.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h3 id=\"四、Web-Components-的优点与缺点\"><a href=\"#四、Web-Components-的优点与缺点\" class=\"headerlink\" title=\"四、Web Components 的优点与缺点\"></a>四、Web Components 的优点与缺点</h3><h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ol>\n<li><strong>浏览器原生</strong>：无需编译，无需复杂的构建工具。</li>\n<li><strong>高度封装</strong>：Shadow DOM 解决了 CSS 和 DOM 的隔离问题。</li>\n<li><strong>框架无关</strong>：极高的互操作性和可移植性。</li>\n<li><strong>永久可用</strong>：作为 Web 标准，具有极长的生命周期和向后兼容性。</li>\n</ol>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ol>\n<li><strong>生态相对年轻</strong>：虽然基础功能强大，但缺少像 React&#x2F;Vue 那样庞大的生态系统（状态管理、路由、测试工具等）。</li>\n<li><strong>数据流管理较弱</strong>：原生不支持类似 React 的 Props 向下传递、事件向上冒泡的父子组件通信范式，需要自己实现（通常用 Custom Events）。</li>\n<li><strong>SSR (服务器端渲染) 支持差</strong>：自定义元素可以在服务器上渲染，但其动态行为和客户端激活（Hydration）非常复杂，远不如 Next.js&#x2F;Nuxt.js 成熟。</li>\n<li><strong>开发体验 (DX)</strong>：原始的开发方式比较繁琐，需要写很多样板代码。但社区有诸如 <strong>Lit</strong>、<strong>Stencil</strong> 等库来极大地改善体验。</li>\n</ol>\n<hr>\n<h3 id=\"五、Web-Components-与微前端和框架\"><a href=\"#五、Web-Components-与微前端和框架\" class=\"headerlink\" title=\"五、Web Components 与微前端和框架\"></a>五、Web Components 与微前端和框架</h3><ul>\n<li><strong>在微前端中</strong>：Web Components 是实现<strong>技术栈无关</strong>微前端的理想载体。每个团队可以用自己熟悉的技术（React, Vue）<strong>开发</strong>组件，但最终<strong>发布</strong>为一个封装好的 Web Component（例如，将一个 React 组件包装成 <code>&lt;team-product-card&gt;</code>），由主应用统一调度。</li>\n<li><strong>与框架的关系</strong>：<ul>\n<li><strong>不是替代关系</strong>，而是<strong>互补关系</strong>。</li>\n<li><strong>框架 (React&#x2F;Vue) 擅长解决：</strong> 复杂的 UI 状态管理、数据流、高效的 DOM 差分更新。它们提供了<strong>优秀的开发体验</strong>和<strong>完整的解决方案</strong>。</li>\n<li><strong>Web Components 擅长解决：</strong> 跨框架重用、底层 UI 组件库、集成遗留应用、长期稳定的基础组件。它们提供了<strong>浏览器级别的互操作性</strong>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>总结来说，Web Components 是 Web 平台的底层基础，为构建可长期存在、高度封装、框架无关的组件提供了强大的原生能力。</strong> 虽然它在开发复杂应用时不如现代框架那么方便，但其独特优势使其在特定场景（如微前端、跨技术栈组件库、大型企业级应用）中是不可替代的选择。</p>\n<p>qiankun实现样式和js隔离的原理</p>\n<p>好的，我们来深入剖析 <strong>qiankun</strong> 实现样式和 JavaScript 隔离的原理。这是 qiankun 的核心能力之一，也是它相比原始 single-spa 更易用、更强大的关键。</p>\n<h3 id=\"总体思想\"><a href=\"#总体思想\" class=\"headerlink\" title=\"总体思想\"></a>总体思想</h3><p>qiankun 的隔离策略可以概括为：<strong>“重样式隔离，轻 JS 沙箱”</strong>。它通过在应用加载和卸载时动态地操作样式和 JavaScript 执行环境来模拟一个隔离的沙箱环境。</p>\n<hr>\n<h3 id=\"一、样式隔离-CSS-Isolation\"><a href=\"#一、样式隔离-CSS-Isolation\" class=\"headerlink\" title=\"一、样式隔离 (CSS Isolation)\"></a>一、样式隔离 (CSS Isolation)</h3><p>qiankun 提供了三种主要的样式隔离方案，根据场景不同自动或手动启用。</p>\n<h4 id=\"1-严格样式隔离-Scoped-CSS\"><a href=\"#1-严格样式隔离-Scoped-CSS\" class=\"headerlink\" title=\"1. 严格样式隔离 (Scoped CSS)\"></a>1. 严格样式隔离 (Scoped CSS)</h4><p><strong>原理：</strong> 为每个微应用包裹一个 <strong>Shadow DOM</strong>。</p>\n<ul>\n<li><strong>如何工作：</strong><ol>\n<li>当 qiankun 挂载一个微应用时，它会创建一个 Shadow Root，并将其作为该应用的容器。</li>\n<li>微应用的所有 DOM 结构都被渲染在这个 Shadow DOM 内部。</li>\n<li><strong>Shadow DOM 的特性天然实现了样式的封装</strong>：内部的样式不会影响外部，外部的样式也不会影响内部（除非使用 <code>::part</code> 或 <code>:host</code> 等特定语法）。</li>\n</ol>\n</li>\n<li><strong>优点：</strong> 隔离性最强，是浏览器原生的完美隔离方案。</li>\n<li><strong>缺点：</strong><ul>\n<li>某些第三方库（特别是弹窗类）可能会因为无法正确定位到 Shadow DOM 外部而出现问题。</li>\n<li>微应用内的样式完全无法影响主应用，反之亦然，有时这可能不符合设计需求。</li>\n</ul>\n</li>\n<li><strong>启用方式：</strong> 在 <code>start</code> 函数中配置 <code>&#123; strictStyleIsolation: true &#125;</code>。</li>\n</ul>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; start &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;qiankun&#x27;</span>;</span><br><span class=\"line\"><span class=\"title function_\">start</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">strictStyleIsolation</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 启用严格样式隔离</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"2-实验性样式隔离-CSS-Scoped\"><a href=\"#2-实验性样式隔离-CSS-Scoped\" class=\"headerlink\" title=\"2. 实验性样式隔离 (CSS Scoped)\"></a>2. 实验性样式隔离 (CSS Scoped)</h4><p><strong>原理：</strong> 一种更宽松的隔离方式，使用 <strong>运行时动态样式表重写</strong>。</p>\n<ul>\n<li><strong>如何工作：</strong><ol>\n<li>qiankun 会劫持微应用运行时<strong>动态添加样式标签（</strong><code>**&lt;style&gt;**</code><strong>,</strong>** <strong><code>**&lt;link&gt;**</code></strong>）** 的行为。</li>\n<li>当微应用插入一个新的样式标签时，qiankun 会将其内容抓取过来。</li>\n<li>使用 <strong>CSS 规则重写器</strong>（例如 <code>postcss</code> 插件）为所有 CSS 选择器<strong>添加一个特殊的前缀</strong>。这个前缀通常基于微应用的名称或一个特定属性。</li>\n<li>将重写后的 CSS 内容插入到 <code>document.head</code> 中。</li>\n<li>同时，qiankun 会为微应用的<strong>容器元素</strong>添加上一步中使用的<strong>相同属性</strong>。</li>\n</ol>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code>- 微应用有一个样式规则：`.button &#123; color: red; &#125;`\n- qiankun 将其重写为：`[data-qiankun=&quot;my-app&quot;] .button &#123; color: red; &#125;`\n- 同时，微应用的容器 `&lt;div&gt;` 会获得属性：`&lt;div data-qiankun=&quot;my-app&quot;&gt;...&lt;/div&gt;`\n- 这样，样式规则就只会在这个容器内生效。\n</code></pre>\n<ul>\n<li><strong>优点：</strong> 比 Shadow DOM 兼容性更好，允许微应用样式影响其容器内的任何元素（包括动态 append 到 body 的弹窗）。</li>\n<li><strong>缺点：</strong> 是运行时重写，有一定性能开销，且是实验性功能。</li>\n<li><strong>启用方式：</strong> 在 <code>start</code> 函数中配置 <code>&#123; experimentalStyleIsolation: true &#125;</code>。</li>\n</ul>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">start</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">experimentalStyleIsolation</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 启用实验性样式隔离</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"3-动态样式表加载-卸载-最常见的默认行为\"><a href=\"#3-动态样式表加载-卸载-最常见的默认行为\" class=\"headerlink\" title=\"3. 动态样式表加载&#x2F;卸载 (最常见的默认行为)\"></a>3. 动态样式表加载&#x2F;卸载 (最常见的默认行为)</h4><p>如果不开启上述两种隔离，qiankun 默认采用一种更简单但有效的策略。</p>\n<ul>\n<li><strong>原理：</strong><ol>\n<li><strong>加载时：</strong> qiankun 通过 <code>fetch</code> 获取微应用的 HTML 入口，解析出所有的 <code>&lt;style&gt;</code> 和 <code>&lt;link&gt;</code> 标签。</li>\n<li>将这些样式标签<strong>直接插入到</strong>** **<code>**document.head**</code> 中。</li>\n<li><strong>卸载时：</strong> qiankun 会<strong>记录</strong>所有由该微应用添加的样式标签，并在卸载微应用时<strong>直接将这些标签从 DOM 中移除</strong>。</li>\n</ol>\n</li>\n<li><strong>优点：</strong> 实现简单，性能好。</li>\n<li><strong>缺点：</strong> <strong>不是真正的隔离</strong>。如果多个微应用有相同选择器的样式规则，后加载的会覆盖先加载的（因为后加载的样式表在更后面，优先级更高）。这依赖于开发者的约定。</li>\n<li><strong>这是 qiankun 的默认行为</strong>，对于很多应用来说已经足够。</li>\n</ul>\n<hr>\n<h3 id=\"二、JavaScript-隔离-JS-Sandbox\"><a href=\"#二、JavaScript-隔离-JS-Sandbox\" class=\"headerlink\" title=\"二、JavaScript 隔离 (JS Sandbox)\"></a>二、JavaScript 隔离 (JS Sandbox)</h3><p>qiankun 的 JS 沙箱的核心目标是：<strong>防止微应用在全局环境（</strong><code>**window**</code><strong>）上留下永久的污染，并在应用切换时恢复和清理环境</strong>。它主要模拟了三个环境的隔离：</p>\n<h4 id=\"1-快照沙箱-SnapshotSandbox-用于单实例场景\"><a href=\"#1-快照沙箱-SnapshotSandbox-用于单实例场景\" class=\"headerlink\" title=\"1. 快照沙箱 (SnapshotSandbox) - 用于单实例场景\"></a>1. 快照沙箱 (SnapshotSandbox) - 用于单实例场景</h4><p><strong>原理：</strong> 在应用加载前后对全局 <code>window</code> 对象进行“拍照”和“diff”，适用于同一时间只能有一个微应用活跃的浏览器环境。</p>\n<ul>\n<li><strong>工作流程：</strong><ol>\n<li><strong>激活沙箱 (mount)：</strong> 将当前 <code>window</code> 的所有属性拍一个<strong>快照</strong>（<code>windowSnapshot</code>），存起来。</li>\n<li><strong>微应用运行：</strong> 微应用可以任意修改 <code>window</code>。</li>\n<li><strong>失活沙箱 (unmount)：</strong><ul>\n<li>将当前的 <code>window</code> 和之前存的 <code>windowSnapshot</code> 进行对比，得到修改的差异（<code>modifyPropsMap</code>）。</li>\n<li><strong>还原现场：</strong> 遍历差异，将 <code>window</code> 上的属性<strong>恢复</strong>到拍快照时的状态。</li>\n<li><strong>记录污染：</strong> 将微应用修改的差异保存起来。</li>\n</ul>\n</li>\n<li><strong>再次激活：</strong> 将之前保存的差异（<code>modifyPropsMap</code>）<strong>重新应用到</strong>** <strong><code>**window**</code></strong> **<strong>上</strong>，让微应用感觉自己的修改一直都在。</li>\n</ol>\n</li>\n<li><strong>优点：</strong> 兼容性极好，支持所有浏览器。</li>\n<li><strong>缺点：</strong> 无法支持多个微应用同时运行（多实例），因为共用一个全局 <code>window</code>。</li>\n</ul>\n<h4 id=\"2-代理沙箱-ProxySandbox-用于多实例场景（主流）\"><a href=\"#2-代理沙箱-ProxySandbox-用于多实例场景（主流）\" class=\"headerlink\" title=\"2. 代理沙箱 (ProxySandbox) - 用于多实例场景（主流）\"></a>2. 代理沙箱 (ProxySandbox) - 用于多实例场景（主流）</h4><p><strong>原理：</strong> 使用 ES6 的 <code>Proxy</code> 为每个微应用创建一个假的、隔离的 <code>window</code> 对象。</p>\n<ul>\n<li><strong>工作流程：</strong><ol>\n<li>qiankun 为每个微应用创建一个空的 <code>fakeWindow</code> 对象。</li>\n<li>用 <code>Proxy</code> 代理这个 <code>fakeWindow</code>。</li>\n<li>当微应用操作 <code>window</code> 时：<ul>\n<li><strong>读操作</strong>：优先从 <code>fakeWindow</code> 里读，如果读不到，则 fallback 到真正的全局 <code>window</code>（这样可以共享 <code>document</code>, <code>location</code> 等全局对象）。</li>\n<li><strong>写操作</strong>：所有对属性的新增和修改都只作用于 <code>fakeWindow</code> 上，<strong>完全不会污染真正的全局</strong>** **<code>**window**</code>。</li>\n</ul>\n</li>\n<li>微应用的所有代码都在这个代理的上下文中执行（通过 <code>with</code> 语句或 <code>eval</code> 改写）。</li>\n</ol>\n</li>\n<li><strong>示例：</strong></li>\n</ul>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 微应用代码</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">myGlobalVar</span> = <span class=\"number\">123</span>; <span class=\"comment\">// 写入的是沙箱的 fakeWindow，真 window 不受影响</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">document</span>.<span class=\"property\">title</span>); <span class=\"comment\">// 读取的是真 window 的属性</span></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><strong>优点：</strong><ul>\n<li>真正的隔离，多个微应用可以同时运行，每个都有自己独立的 <code>window</code> 空间。</li>\n<li>对微应用无感知，无需修改代码。</li>\n</ul>\n</li>\n<li><strong>缺点：</strong> 依赖 ES6 <code>Proxy</code>，无法在低版本浏览器（如 IE）中使用。</li>\n</ul>\n<h4 id=\"3-遗留沙箱-LegacySandbox-已逐渐被代理沙箱取代\"><a href=\"#3-遗留沙箱-LegacySandbox-已逐渐被代理沙箱取代\" class=\"headerlink\" title=\"3. 遗留沙箱 (LegacySandbox) - 已逐渐被代理沙箱取代\"></a>3. 遗留沙箱 (LegacySandbox) - 已逐渐被代理沙箱取代</h4><p>原理类似于快照沙箱，但性能优化更好。它只记录微应用修改过的属性，在卸载时还原这些属性。同样不支持多实例。</p>\n<hr>\n<h3 id=\"总结：qiankun-的隔离策略\"><a href=\"#总结：qiankun-的隔离策略\" class=\"headerlink\" title=\"总结：qiankun 的隔离策略\"></a>总结：qiankun 的隔离策略</h3><table>\n<thead>\n<tr>\n<th><strong>隔离类型</strong></th>\n<th><strong>技术方案</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>样式隔离</strong></td>\n<td><strong>Shadow DOM</strong></td>\n<td>原生，隔离最彻底</td>\n<td>兼容性问题，弹窗等组件可能异常</td>\n<td>需要最强隔离的新应用</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>动态样式表重写 (实验性)</strong></td>\n<td>兼容性好，支持弹窗</td>\n<td>运行时开销，实验性功能</td>\n<td>需要兼容弹窗的复杂应用</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>动态加载&#x2F;卸载 (默认)</strong></td>\n<td>简单，性能好</td>\n<td>非真正隔离，依赖约定</td>\n<td>大多数简单应用，样式冲突风险低</td>\n</tr>\n<tr>\n<td><strong>JS 隔离</strong></td>\n<td><strong>快照沙箱 (SnapshotSandbox)</strong></td>\n<td>兼容所有浏览器</td>\n<td>不支持多实例</td>\n<td>单实例模式，需兼容 IE 等老浏览器</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>代理沙箱 (ProxySandbox)</strong></td>\n<td>真正隔离，支持多实例，对应用无感知</td>\n<td>依赖 <code>Proxy</code><br/>，不兼容 IE</td>\n<td><strong>现代浏览器下的主流选择</strong></td>\n</tr>\n</tbody></table>\n<p><strong>qiankun 会自动选择最佳策略</strong>：在支持 <code>Proxy</code> 的浏览器中默认使用<strong>代理沙箱 (多实例)</strong> 和<strong>动态样式加载&#x2F;卸载</strong>。如果不支持 <code>Proxy</code>，则降级到<strong>快照沙箱 (单实例)</strong>。</p>\n<p>通过这种组合策略，qiankun 在绝大多数场景下为微前端应用提供了<strong>足够安全、稳定且高性能的隔离环境</strong>，极大地简化了微前端的落地复杂度。</p>\n<p>qiankun是如何实现父子应用通信的呢</p>\n<p>好的，<strong>qiankun 的通信机制</strong>是其核心功能之一，它设计得非常灵活，提供了多种方式来实现主应用（父应用）和微应用（子应用）之间的通信。</p>\n<p>qiankun 并没有强制使用某一种通信方式，而是提供了一个轻量的 <strong>API（</strong><code>**initGlobalState**</code><strong>）</strong> 作为推荐方案，同时也完全支持任何其他流行的状态管理库（如 Redux, Mobx, Vuex）或浏览器原生 API。</p>\n<hr>\n<h3 id=\"一、官方推荐方案：使用-initGlobalState-Actions-通信\"><a href=\"#一、官方推荐方案：使用-initGlobalState-Actions-通信\" class=\"headerlink\" title=\"一、官方推荐方案：使用 initGlobalState (Actions 通信)\"></a>一、官方推荐方案：使用 <code>initGlobalState</code> (Actions 通信)</h3><p>这是 qiankun 官方提供的通信方式，适用于大多数场景。它的核心思想是一个<strong>简单的发布-订阅模式</strong>。</p>\n<h4 id=\"1-在主应用中初始化状态并下发通信方法\"><a href=\"#1-在主应用中初始化状态并下发通信方法\" class=\"headerlink\" title=\"1. 在主应用中初始化状态并下发通信方法\"></a>1. 在主应用中初始化状态并下发通信方法</h4><p>主应用是整个状态的管理中心。</p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main-app/src/actions.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; initGlobalState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;qiankun&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 初始化全局状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\">  <span class=\"attr\">user</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;张三&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">token</span>: <span class=\"string\">&#x27;abc123&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">theme</span>: <span class=\"string\">&#x27;light&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 创建 Actions 实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> actions = <span class=\"title function_\">initGlobalState</span>(initialState);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 监听状态变化（可选，主应用自己也可以监听）</span></span><br><span class=\"line\">actions.<span class=\"title function_\">onGlobalStateChange</span>(<span class=\"function\">(<span class=\"params\">state, prevState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// state: 变更后的新状态</span></span><br><span class=\"line\">  <span class=\"comment\">// prevState: 变更前的旧状态</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;主应用监听到状态变化: &#x27;</span>, state, prevState);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 定义一个更新状态的方法</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">setGlobalState</span> = (<span class=\"params\">newState</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 按层级合并状态</span></span><br><span class=\"line\">  actions.<span class=\"title function_\">setGlobalState</span>(newState);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 将 actions 暴露出去，供微应用使用</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> actions;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"2-在微应用中获取并操作状态\"><a href=\"#2-在微应用中获取并操作状态\" class=\"headerlink\" title=\"2. 在微应用中获取并操作状态\"></a>2. 在微应用中获取并操作状态</h4><p>微应用需要从生命周期函数中获取到 <code>props</code>，其中就包含了通信方法。</p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// micro-app/src/main.js (入口文件)</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> microAppActions; <span class=\"comment\">// 用来保存通信方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导出 qiankun 生命周期函数</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">mount</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;微应用挂载了&#x27;</span>, props);</span><br><span class=\"line\">  <span class=\"comment\">// 1. 从 props 中获取主应用下发的 actions</span></span><br><span class=\"line\">  microAppActions = props;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 监听全局状态变化</span></span><br><span class=\"line\">  props.<span class=\"title function_\">onGlobalStateChange</span>(<span class=\"function\">(<span class=\"params\">state, prevState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;微应用监听到状态变化: &#x27;</span>, state, prevState);</span><br><span class=\"line\">    <span class=\"comment\">// 状态变化后，更新微应用自己的视图</span></span><br><span class=\"line\">    <span class=\"title function_\">renderApp</span>(state);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 首次挂载，获取当前全局状态并渲染应用</span></span><br><span class=\"line\">  <span class=\"title function_\">renderApp</span>(props.<span class=\"title function_\">getGlobalState</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">unmount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 卸载时取消监听（qiankun 内部会自动清理，但显式取消是好习惯）</span></span><br><span class=\"line\">  microAppActions.<span class=\"title function_\">offGlobalStateChange</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// React/Vue 应用的渲染函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">renderApp</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">globalState</span>=<span class=\"string\">&#123;state&#125;</span> <span class=\"attr\">actions</span>=<span class=\"string\">&#123;microAppActions&#125;</span> /&gt;</span></span>, <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"3-在微应用组件中具体使用\"><a href=\"#3-在微应用组件中具体使用\" class=\"headerlink\" title=\"3. 在微应用组件中具体使用\"></a>3. 在微应用组件中具体使用</h4><p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// micro-app/src/App.jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\">&#123; globalState, actions &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; user, theme &#125; = globalState;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleChangeTheme</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新全局状态</span></span><br><span class=\"line\">    actions.<span class=\"title function_\">setGlobalState</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">theme</span>: theme === <span class=\"string\">&#x27;light&#x27;</span> ? <span class=\"string\">&#x27;dark&#x27;</span> : <span class=\"string\">&#x27;light&#x27;</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;</span>`<span class=\"attr\">app</span> $&#123;<span class=\"attr\">theme</span>&#125;`&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>微应用页面<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>用户名: &#123;user.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleChangeTheme&#125;</span>&gt;</span>切换主题<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span>;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"initGlobalState-API-说明：\"><a href=\"#initGlobalState-API-说明：\" class=\"headerlink\" title=\"initGlobalState API 说明：\"></a><code>initGlobalState</code> API 说明：</h4><ul>\n<li><code>setGlobalState(state: object)</code>: 设置新的全局状态，会自动与旧状态进行<strong>浅合并</strong>。</li>\n<li><code>onGlobalStateChange(callback: function)</code>: 注册监听器，状态变化时触发。</li>\n<li><code>offGlobalStateChange()</code>: 取消监听。</li>\n<li><code>getGlobalState()</code>: 获取当前全局状态。</li>\n</ul>\n<hr>\n<h3 id=\"二、其他通信方案\"><a href=\"#二、其他通信方案\" class=\"headerlink\" title=\"二、其他通信方案\"></a>二、其他通信方案</h3><p>qiankun 是框架无关的，因此你也可以选择任何你熟悉的通信方式。</p>\n<h4 id=\"1-使用-CustomEvent-浏览器原生事件\"><a href=\"#1-使用-CustomEvent-浏览器原生事件\" class=\"headerlink\" title=\"1. 使用 CustomEvent (浏览器原生事件)\"></a>1. 使用 CustomEvent (浏览器原生事件)</h4><p><strong>原理：</strong> 利用浏览器原生的 <code>window.dispatchEvent</code> 和 <code>window.addEventListener</code> 进行通信。</p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主应用 - 发送事件</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;main-app-event&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">detail</span>: &#123; <span class=\"comment\">// 通过 detail 传递数据</span></span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;CHANGE_THEME&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">payload</span>: <span class=\"string\">&#x27;dark&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用 - 接收事件</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;main-app-event&#x27;</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; type, payload &#125; = event.<span class=\"property\">detail</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 处理事件...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用 - 发送事件（同理）</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;micro-app-event&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">detail</span>: &#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Hello from micro app&#x27;</span> &#125;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>优点：</strong> 原生支持，非常简单。<br><strong>缺点：</strong> 数据传递能力较弱（只能同步），缺乏状态管理能力，事件需要全局唯一命名以免冲突。</p>\n<h4 id=\"2-使用-Redux-Mobx-Vuex-等状态库\"><a href=\"#2-使用-Redux-Mobx-Vuex-等状态库\" class=\"headerlink\" title=\"2. 使用 Redux&#x2F;Mobx&#x2F;Vuex 等状态库\"></a>2. 使用 Redux&#x2F;Mobx&#x2F;Vuex 等状态库</h4><p><strong>原理：</strong> 主应用和微应用<strong>共享同一个状态库实例</strong>。</p>\n<ul>\n<li><strong>步骤：</strong><ol>\n<li>主应用创建一个 Redux Store 或其他状态库实例。</li>\n<li>将这个 Store 通过 <code>window</code> 对象或者微应用的 <code>props</code> 暴露给微应用。</li>\n<li>微应用连接到这个全局的 Store，进行状态的读取和分发 Action。</li>\n</ol>\n</li>\n</ul>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主应用 - 创建并暴露 store</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;redux&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> globalStore = <span class=\"title function_\">createStore</span>(<span class=\"comment\">/* ... */</span>);</span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">__MAIN_APP_STORE__</span> = globalStore; <span class=\"comment\">// 挂到全局</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用 - 获取并使用 store</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"variable language_\">window</span>.<span class=\"property\">__MAIN_APP_STORE__</span>;</span><br><span class=\"line\">store.<span class=\"title function_\">dispatch</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;AN_ACTION&#x27;</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> state = store.<span class=\"title function_\">getState</span>();</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>优点：</strong> 功能强大，可以处理复杂的业务逻辑和状态流。<br><strong>缺点：</strong> 紧密耦合，主应用和微应用必须使用同一种状态库，且版本需要兼容。</p>\n<h4 id=\"3-通过-URL-或-Query-Parameters-通信\"><a href=\"#3-通过-URL-或-Query-Parameters-通信\" class=\"headerlink\" title=\"3. 通过 URL 或 Query Parameters 通信\"></a>3. 通过 URL 或 Query Parameters 通信</h4><p><strong>原理：</strong> 通过改变 URL 的查询参数来传递简单信息。</p>\n<p>javascript</p>\n<div class=\"code-container\" data-rel=\"Javascript\"><figure class=\"iseeu highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主应用改变URL</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newUrl = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"variable language_\">window</span>.location.pathname&#125;</span>?theme=dark&amp;userId=123`</span>;</span><br><span class=\"line\">history.<span class=\"title function_\">pushState</span>(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;&#x27;</span>, newUrl);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用监听URL变化</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;popstate&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> urlParams = <span class=\"keyword\">new</span> <span class=\"title class_\">URLSearchParams</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">location</span>.<span class=\"property\">search</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> theme = urlParams.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;theme&#x27;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ...使用参数</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>优点：</strong> 非常简单，状态可被收藏和分享。<br><strong>缺点：</strong> 只适合传递少量简单数据。</p>\n<hr>\n<h3 id=\"总结与选择建议\"><a href=\"#总结与选择建议\" class=\"headerlink\" title=\"总结与选择建议\"></a>总结与选择建议</h3><table>\n<thead>\n<tr>\n<th><strong>方案</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>官方</strong>** **<code>**initGlobalState**</code></td>\n<td><strong>官方推荐</strong>，简单轻量，满足大部分通信需求</td>\n<td>功能相对简单，不适合极其复杂的场景</td>\n<td><strong>绝大多数微前端通信场景的首选</strong></td>\n</tr>\n<tr>\n<td><strong>CustomEvent</strong></td>\n<td>浏览器原生，非常简单</td>\n<td>功能弱，只能传简单数据，易产生事件名冲突</td>\n<td>简单的父子通知、触发动作</td>\n</tr>\n<tr>\n<td><strong>Redux&#x2F;Vuex 等</strong></td>\n<td>功能强大，适合复杂状态管理</td>\n<td>耦合度高，主子和微应用必须使用同一种状态库</td>\n<td>大型复杂应用，且技术栈统一</td>\n</tr>\n<tr>\n<td><strong>URL Parameters</strong></td>\n<td>实现简单，状态可分享</td>\n<td>传递数据量有限，类型受限</td>\n<td>过滤条件、简单配置等</td>\n</tr>\n</tbody></table>\n<p><strong>最佳实践建议：</strong></p>\n<ol>\n<li><strong>优先使用官方的</strong>** **<code>**initGlobalState**</code>，它能覆盖 90% 的微前端通信需求。</li>\n<li>对于简单的、一次性的动作触发（如“刷新列表”、“显示通知”），可以辅以 <strong>CustomEvent</strong>。</li>\n<li>只有在主应用和所有微应用技术栈统一且非常复杂时，才考虑使用<strong>共享状态库</strong>。</li>\n<li>通信的设计应遵循<strong>最小化原则</strong>，尽量减少主应用和微应用之间的耦合，让微应用保持最大的独立性。</li>\n</ol>\n","excerpt":"","more":"<p>参考链接：</p>\n<p><a class=\"link\"   href=\"https://zhuanlan.zhihu.com/p/78362028\" >可能是你见过最完善的微前端解决方案<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p><a class=\"link\"   href=\"https://juejin.cn/post/7244070072788287544?searchId=202508250257166071DDB47E623E0BA671\" >深入调研了微前端，还是iframe最香<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<p><a class=\"link\"   href=\"https://qiankun.umijs.org/zh/guide/getting-started\" >qiankun官方文档<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<h3 id=\"什么是微前端？\"><a href=\"#什么是微前端？\" class=\"headerlink\" title=\"什么是微前端？\"></a>什么是微前端？</h3><p>微前端是一种软件架构，可以将前端应用拆解成一些更小的能够独立开发部署的微型应用，然后在将这些微型应用组合使其成为整体的架构模式。</p>\n<p>微前端类似于组件架构，但不同的是，组件不能够独立构建和发布，但是微前端中的应用是可以的。</p>\n<p>微前端架构与框架无关，每个微应用都可以使用不同的框架。</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/png/55999631/1756118557192-c0cfb92e-8167-4ead-9795-0f7ddd7bb7c8.png\"\n                     \n                ></p>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>单体前端</strong></th>\n<th><strong>微前端</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>代码库</strong></td>\n<td>单个大型代码库</td>\n<td>多个独立代码库</td>\n</tr>\n<tr>\n<td><strong>团队结构</strong></td>\n<td>集中式团队</td>\n<td>分布式独立团队</td>\n</tr>\n<tr>\n<td><strong>技术栈</strong></td>\n<td>统一技术栈</td>\n<td>混合技术栈</td>\n</tr>\n<tr>\n<td><strong>部署</strong></td>\n<td>整体部署</td>\n<td>独立部署</td>\n</tr>\n<tr>\n<td><strong>开发速度</strong></td>\n<td>后期变慢</td>\n<td>持续快速</td>\n</tr>\n<tr>\n<td><strong>复杂度</strong></td>\n<td>高度耦合</td>\n<td>解耦独立</td>\n</tr>\n</tbody></table>\n<h3 id=\"微前端的价值\"><a href=\"#微前端的价值\" class=\"headerlink\" title=\"微前端的价值\"></a>微前端的价值</h3><p>微前端架构具备以下几个核心价值：</p>\n<ul>\n<li>技术栈无关 主框架不限制接入应用的技术栈，子应用具备完全自主权</li>\n<li>独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新</li>\n<li>独立运行时 每个子应用之间状态隔离，运行时状态不共享</li>\n</ul>\n<p>微前端架构旨在解决<a class=\"link\"   href=\"https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLljZXkvZPlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.Sy3sQVozhhuQwuwmw8-zjyU0X_81Vve5linQ55OPo0k&zhida_source=entity\" >单体应用<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个<a class=\"link\"   href=\"https://zhida.zhihu.com/search?content_id=105543172&content_type=Article&match_order=1&q=%E5%B7%A8%E7%9F%B3%E5%BA%94%E7%94%A8&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTYyOTAzMjEsInEiOiLlt6jnn7PlupTnlKgiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMDU1NDMxNzIsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.3VWm6X4yZDpq2_EqJZDuDErH1ST1iWJUa0qPK8T5Abk&zhida_source=entity\" >巨石应用<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>(<a class=\"link\"   href=\"https://link.zhihu.com/?target=https://www.youtube.com/watch?v=pU1gXA0rfwc\" >Frontend Monolith<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。</p>\n<p>应用架构如下：</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/png/55999631/1756120029405-72a7f34d-4e09-4c78-b290-6ae5836720cb.png\"\n                     \n                ></p>\n<blockquote>\n<p>Stitching layer 作为主框架的核心成员，充当调度者的角色，由它来决定在不同的条件下激活不同的子应用。因此主框架的定位则仅仅是：<strong>导航路由 + 资源加载框架</strong></p>\n</blockquote>\n<p>single-spa是什么</p>\n<p>好的，我们来详细解释一下 <strong>single-spa</strong> 是什么。</p>\n<h3 id=\"核心定义\"><a href=\"#核心定义\" class=\"headerlink\" title=\"核心定义\"></a>核心定义</h3><p><strong>single-spa 是一个用于构建【微前端】架构的 JavaScript 框架。</strong> 你可以把它理解为一个<strong>顶层的路由器和应用程序加载器</strong>。</p>\n<p>它的核心思想是：将一个大型的单页前端应用（SPA）拆分成多个小型、独立、可以并行开发交付的“微应用”。然后，single-spa 负责在运行时根据一定的规则（通常是当前的 URL）动态地加载、展示、卸载这些微应用。</p>\n<hr>\n<h3 id=\"一个简单的比喻\"><a href=\"#一个简单的比喻\" class=\"headerlink\" title=\"一个简单的比喻\"></a>一个简单的比喻</h3><p>想象一下你的浏览器是一个舞台：</p>\n<ul>\n<li><strong>传统单体应用：</strong> 只有一个庞大的剧团表演一整部冗长的戏剧。要更换一个演员（修改一个功能），需要整个剧团停下来重新排练（整个应用重新构建部署）。</li>\n<li><strong>single-spa 微前端：</strong> 舞台（浏览器）本身是空的。有一个<strong>导演（single-spa）</strong>。导演手里有一个节目单（根配置），上面写着什么节目（微应用）在什么时刻（例如，URL 是 <code>/settings</code> 时）上台表演。<ul>\n<li>当报幕员说“下一个节目是《用户设置》”时（用户访问了 <code>/settings</code>），导演就喊：“《用户设置》剧组，上台！”（加载并挂载 React 微应用）。</li>\n<li>节目表演完了（用户离开了 <code>/settings</code>），导演就喊：“《用户设置》剧组，下台！”（卸载 React 微应用）。</li>\n<li>下一个节目是《商品列表》，另一个完全不同的剧组（Vue 微应用）就上台表演。</li>\n</ul>\n</li>\n</ul>\n<p><strong>single-spa 就是这个导演</strong>，它自己不表演具体内容，但它负责协调所有剧组（微应用）的上场和下场时机。</p>\n<hr>\n<h3 id=\"为什么需要-single-spa？（解决的问题）\"><a href=\"#为什么需要-single-spa？（解决的问题）\" class=\"headerlink\" title=\"为什么需要 single-spa？（解决的问题）\"></a>为什么需要 single-spa？（解决的问题）</h3><ol>\n<li><strong>技术栈无关：</strong> 各个微应用可以使用不同的技术栈（React, Vue, Angular, Svelte 等）。团队可以自由选择或升级其技术栈，而不会影响其他团队。</li>\n<li><strong>独立开发、独立部署：</strong> 每个微应用都由独立的团队开发、测试和部署，大大提升了团队的自治度和发布效率。</li>\n<li><strong>增量升级：</strong> 允许你逐步重写一个老旧的巨型前端应用，可以一部分一部分地用新的框架替换，而不是一次性重写全部。</li>\n<li><strong>代码隔离：</strong> 应用之间实现了良好的代码和样式隔离（虽然需要一些额外规范），避免了全局污染和冲突。</li>\n</ol>\n<hr>\n<h3 id=\"single-spa-的核心工作原理\"><a href=\"#single-spa-的核心工作原理\" class=\"headerlink\" title=\"single-spa 的核心工作原理\"></a>single-spa 的核心工作原理</h3><p>single-spa 通过定义一套<strong>生命周期协议</strong>来工作。每个微应用都必须对外暴露三个核心的函数：</p>\n<ol>\n<li><code>bootstrap</code>： 应用首次加载时执行一次，用于初始化。</li>\n<li><code>mount</code>： 当激活条件满足时（例如用户访问了该应用的路由），执行此函数。应用需要在这个函数里完成渲染，将组件挂载到 DOM 上。</li>\n<li><code>unmount</code>： 当激活条件不再满足时（例如用户离开了该路由），执行此函数。应用需要在这个函数里完成清理工作，将自己从 DOM 上卸载。</li>\n</ol>\n<p>single-spa 的“根配置”会<strong>注册</strong>所有微应用，并为每个应用定义一个 <code>activity function</code>（激活函数）。这个函数通常根据 <code>window.location</code> 进行判断。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// single-spa 根配置示例 (root-config.js)</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; registerApplication, start &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;single-spa&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 注册一个应用</span></span><br><span class=\"line\"><span class=\"title function_\">registerApplication</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;my-react-app&#x27;</span>, <span class=\"comment\">// 应用唯一名</span></span><br><span class=\"line\">  <span class=\"attr\">app</span>: <span class=\"function\">() =&gt;</span> <span class=\"title class_\">System</span>.<span class=\"keyword\">import</span>(<span class=\"string\">&#x27;my-react-app&#x27;</span>), <span class=\"comment\">// 如何加载该应用的代码</span></span><br><span class=\"line\">  <span class=\"attr\">activeWhen</span>: <span class=\"function\">(<span class=\"params\">location</span>) =&gt;</span> location.<span class=\"property\">pathname</span>.<span class=\"title function_\">startsWith</span>(<span class=\"string\">&#x27;/react&#x27;</span>), <span class=\"comment\">// 激活函数：当路径以 /react 开头时，加载这个应用</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动 single-spa</span></span><br><span class=\"line\"><span class=\"title function_\">start</span>();</span><br></pre></td></tr></table></figure>\n\n<p><strong>流程如下：</strong></p>\n<ol>\n<li>用户访问 <code>https://example.com/react</code>。</li>\n<li>single-spa 检查所有注册的应用，发现 <code>my-react-app</code> 的 <code>activeWhen</code> 函数返回 <code>true</code>。</li>\n<li>single-spa 动态加载 <code>my-react-app</code> 的代码包。</li>\n<li>依次执行该应用的 <code>bootstrap</code> 和 <code>mount</code> 生命周期函数，应用被渲染到页面上。</li>\n<li>用户导航到 <code>/vue</code>，<code>my-react-app</code> 的 <code>activeWhen</code> 返回 <code>false</code>。</li>\n<li>single-spa 执行它的 <code>unmount</code> 函数，将其卸载。</li>\n</ol>\n<hr>\n<h3 id=\"主要优缺点\"><a href=\"#主要优缺点\" class=\"headerlink\" title=\"主要优缺点\"></a>主要优缺点</h3><p><strong>优点：</strong></p>\n<ul>\n<li><strong>强大的解耦和能力：</strong> 真正实现了前端应用的拆分和团队自治。</li>\n<li><strong>框架无关：</strong> 是整合不同技术栈应用的理想选择。</li>\n<li><strong>懒加载：</strong> 提升首次加载速度，按需加载应用。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>复杂度高：</strong> 引入了分布式系统的复杂性，需要解决依赖共享、样式隔离、通信机制等问题。</li>\n<li><strong>开发体验：</strong> 调试和配置比单体应用更复杂。通常需要类似 <code>single-spa</code> 官方的 <code>create-single-spa</code> 工具链来简化流程。</li>\n<li><strong>依赖管理：</strong> 需要谨慎处理共享库（如 <code>react</code>, <code>vue</code>）以避免重复打包。</li>\n</ul>\n<hr>\n<h3 id=\"与-Module-Federation-的区别\"><a href=\"#与-Module-Federation-的区别\" class=\"headerlink\" title=\"与 Module Federation 的区别\"></a>与 Module Federation 的区别</h3><p>Webpack 5 的 <strong>Module Federation（模块联邦）</strong> 是另一种实现微前端的热门技术。它们不是互斥的，甚至可以结合使用：</p>\n<ul>\n<li><strong>single-spa</strong> 主要解决的是<strong>路由和应用生命周期管理</strong>的问题（“什么时候加载哪个应用”）。</li>\n<li><strong>Module Federation</strong> 主要解决的是<strong>应用之间代码共享和依赖处理</strong>的问题（“如何共享一个 React 实例，避免重复加载”）。</li>\n</ul>\n<p>一个常见的模式是：使用 <strong>single-spa 作为路由器</strong>，使用 <strong>Module Federation 来加载微应用和共享依赖</strong>。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>**single-spa 是一个成熟、强大的微前端解决方案，它通过一套生命周期协议，将多个独立开发、独立部署的微应用组合成一个完整的单体体验。它非常适合大型企业级应用、需要整合不同技术栈或进行增量迁移的项目。**虽然它引入了一定的复杂性，但它为解决前端单体膨胀问题提供了非常系统化的思路和工具。</p>\n<p>html entry和js entry的概念是什么</p>\n<p>好的，这是一个非常核心的微前端概念。<code>**js-entry**</code> 和 <code>**html-entry**</code> 是微前端中两种不同的应用打包和加载方式，它们代表了两种不同的设计哲学和实现技术。</p>\n<hr>\n<h3 id=\"核心概念对比\"><a href=\"#核心概念对比\" class=\"headerlink\" title=\"核心概念对比\"></a>核心概念对比</h3><table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>js-entry (JavaScript 入口)</strong></th>\n<th><strong>html-entry (HTML 入口)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>入口文件</strong></td>\n<td>一个 JavaScript 文件 (e.g., <code>app.js</code><br/>)</td>\n<td>一个 HTML 文件 (e.g., <code>index.html</code><br/>)</td>\n</tr>\n<tr>\n<td><strong>内容</strong></td>\n<td>主要包含 <strong>JavaScript 逻辑和组件</strong></td>\n<td>包含 <strong>HTML、</strong><code>**&lt;script&gt;**</code><br/><strong>、</strong><code>**&lt;link&gt;**</code><br/><strong>、</strong><code>**&lt;style&gt;**</code></td>\n</tr>\n<tr>\n<td><strong>加载方式</strong></td>\n<td>框架（如 single-spa）加载并执行 JS 文件</td>\n<td>框架通过 <strong>fetch</strong> 获取 HTML，解析出其中的 JS&#x2F;CSS 并执行</td>\n</tr>\n<tr>\n<td><strong>样式处理</strong></td>\n<td><strong>需要手动管理</strong>。通常需要约定（如 CSS Modules, CSS-in-JS）或工具来避免冲突。</td>\n<td><strong>自动处理</strong>。HTML 中的 <code>&lt;link&gt;</code><br/> 和 <code>&lt;style&gt;</code><br/> 标签会被自动插入到 <code>&lt;head&gt;</code><br/> 中。</td>\n</tr>\n<tr>\n<td><strong>沙箱隔离</strong></td>\n<td>通常需要额外的库（如 <code>qiankun</code><br/> 的沙箱）来实现 JS 和 CSS 的运行时隔离。</td>\n<td>天然更易于实现<strong>HTML级别的沙箱</strong>（例如，创建一个 Shadow DOM 来包裹整个微应用的内容）。</td>\n</tr>\n<tr>\n<td><strong>代表性方案</strong></td>\n<td>原始的 <strong>single-spa</strong> 方案</td>\n<td><strong>qiankun</strong>（基于 single-spa）、<strong>Module Federation</strong>（某种程度上）</td>\n</tr>\n</tbody></table>\n<hr>\n<h3 id=\"深入理解\"><a href=\"#深入理解\" class=\"headerlink\" title=\"深入理解\"></a>深入理解</h3><h4 id=\"1-js-entry-JavaScript-入口\"><a href=\"#1-js-entry-JavaScript-入口\" class=\"headerlink\" title=\"1. js-entry (JavaScript 入口)\"></a>1. js-entry (JavaScript 入口)</h4><p>这是 <strong>single-spa 早期和官方推荐</strong>的方式。它的理念是：一个微应用<strong>本质上是一个 JavaScript 模块</strong>，这个模块导出了 <code>bootstrap</code>, <code>mount</code>, <code>unmount</code> 等生命周期函数。</p>\n<p><strong>如何工作？</strong></p>\n<ol>\n<li>主应用（容器）根据路由规则，判断需要加载微应用 A。</li>\n<li>主应用通过 <code>System.import()</code> 或 <code>import()</code> 动态加载微应用 A 的 <strong>入口 JS 文件</strong>（例如 <code>https://a.com/app.js</code>）。</li>\n<li>这个 JS 文件被执行，并返回一个包含生命周期函数的对象。</li>\n<li>主应用依次调用微应用的 <code>bootstrap</code> 和 <code>mount</code> 函数。</li>\n<li>在 <code>mount</code> 函数中，微应用<strong>用自己的逻辑</strong>将组件渲染到主应用提供的 DOM 容器中。</li>\n</ol>\n<p><strong>示例代码 (single-spa 配置)：</strong></p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">registerApplication</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;my-app&#x27;</span>,</span><br><span class=\"line\">  <span class=\"comment\">// 这里是一个 js-entry，指向一个 JS 文件</span></span><br><span class=\"line\">  <span class=\"attr\">app</span>: <span class=\"function\">() =&gt;</span> <span class=\"title class_\">System</span>.<span class=\"keyword\">import</span>(<span class=\"string\">&#x27;https://a.com/js/app.js&#x27;</span>),</span><br><span class=\"line\">  <span class=\"attr\">activeWhen</span>: <span class=\"string\">&#x27;/app&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li>概念清晰，符合“应用即模块”的理念。</li>\n<li>打包输出干净，通常是一个或多个 JS 包。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>样式处理麻烦</strong>：你需要自己在微应用的 JS 代码里引入 CSS（如 <code>import &#39;./app.css&#39;</code>），并小心全局样式冲突。</li>\n<li><strong>需要额外配置</strong>：为了实现资源加载和隔离，需要复杂的 Webpack 配置和额外的库。</li>\n</ul>\n<h4 id=\"2-html-entry-HTML-入口\"><a href=\"#2-html-entry-HTML-入口\" class=\"headerlink\" title=\"2. html-entry (HTML 入口)\"></a>2. html-entry (HTML 入口)</h4><p>这种方式的理念是：一个微应用是<strong>一个完整的、可以独立运行的“页面”</strong>。主应用只需要加载这个页面的 HTML 文件，剩下的资源（JS, CSS）都由这个 HTML 文件自己声明。</p>\n<p><strong>如何工作？</strong></p>\n<ol>\n<li>主应用根据路由规则，判断需要加载微应用 B。</li>\n<li>主应用通过 <strong>fetch</strong> 请求微应用 B 的<strong>入口 HTML 文件</strong>（例如 <code>https://b.com/index.html</code>）。</li>\n<li>主应用<strong>解析</strong>这个 HTML 文件，提取出其中的 <code>**&lt;script&gt;**</code>** <strong><strong>和</strong></strong> <strong><code>**&lt;link&gt;**</code></strong> **<strong>标签</strong>。</li>\n<li>主应用手动创建这些 <code>&lt;script&gt;</code> 和 <code>&lt;link&gt;</code> 元素，并将它们插入到主文档的 <code>&lt;head&gt;</code> 中，从而加载并执行微应用的 JS 和 CSS。</li>\n<li>同时，主应用通常会提供一个<strong>隔离的沙箱环境</strong>（如 Shadow DOM），将微应用的整个 DOM 结构渲染在其中。</li>\n</ol>\n<p><strong>示例概念（qiankun 的做法）：</strong></p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; registerMicroApps, start &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;qiankun&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">registerMicroApps</span>([</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;vue-app&#x27;</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 这里是一个 html-entry，指向一个 HTML 文件</span></span><br><span class=\"line\">    <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;//localhost:7101&#x27;</span>, <span class=\"comment\">// 会默认加载这个地址下的 index.html</span></span><br><span class=\"line\">    <span class=\"attr\">container</span>: <span class=\"string\">&#x27;#container&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">activeRule</span>: <span class=\"string\">&#x27;/vue&#x27;</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">]);</span><br><span class=\"line\"><span class=\"title function_\">start</span>();</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong></p>\n<ul>\n<li><strong>对旧项目更友好</strong>：很多老项目（如 jQuery、Backbone 项目）本身就是以 HTML 为中心开发的，改造为 html-entry 更容易。</li>\n<li><strong>资源加载自动化</strong>：无需在 JS 中手动引入资源，HTML 中声明的所有资源都会被自动加载。</li>\n<li><strong>更强大的隔离能力</strong>：更容易与 Shadow DOM 结合，实现真正的样式和作用域隔离。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li><strong>需要解析 HTML</strong>：主应用需要具备解析 HTML 并提取资源的能力，实现起来比直接 <code>import</code> 一个 JS 文件更复杂。</li>\n<li><strong>可能加载多余资源</strong>：如果 HTML 中声明了多个入口，需要更精细的解析策略来避免加载未使用的资源。</li>\n</ul>\n<hr>\n<h3 id=\"总结与类比\"><a href=\"#总结与类比\" class=\"headerlink\" title=\"总结与类比\"></a>总结与类比</h3><table>\n<thead>\n<tr>\n<th><strong>概念</strong></th>\n<th><strong>类比</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>**js-entry**</code></td>\n<td>就像 <strong>“组装电脑”</strong>。主应用（你）买来各个零件（JS 逻辑、手动引入的 CSS），自己动手组装成一台完整的电脑（微应用）。控制力强，但过程繁琐。</td>\n</tr>\n<tr>\n<td><code>**html-entry**</code></td>\n<td>就像 <strong>“购买品牌整机”</strong>。主应用（你）直接买来一台戴尔电脑（HTML 文件），插上电（插入 DOM）就能用。开箱即用，非常方便，但内部细节被封装了。</td>\n</tr>\n</tbody></table>\n<p><strong>现代趋势：</strong></p>\n<ul>\n<li>纯粹的 <code>js-entry</code> 由于其配置的复杂性，在直接使用时体验并不友好。</li>\n<li><strong>qiankun</strong> 这类框架通过实现 <code>html-entry</code> 模式，极大地改善了开发者体验，降低了微前端的上手门槛。</li>\n<li><strong>Webpack Module Federation</strong> 提供了另一种更现代化的 <code>js-entry</code>，它通过复杂的依赖共享机制，解决了 <code>js-entry</code> 的许多痛点（如共享库重复加载），可以看作是 <code>js-entry</code> 的终极进化形态。</li>\n</ul>\n<p>因此，选择哪种方式取决于你的技术栈和框架：</p>\n<ul>\n<li>使用 <strong>原始的 single-spa</strong>，你通常需要处理 <code>js-entry</code>。</li>\n<li>使用 <strong>qiankun</strong>，你享受的是 <code>html-entry</code> 带来的便利。</li>\n<li>使用 <strong>Module Federation</strong>，你体验的是高级的、基于依赖共享的 <code>js-entry</code>。</li>\n</ul>\n<h2 id=\"路由分发可以实现微前端架构吗\"><a href=\"#路由分发可以实现微前端架构吗\" class=\"headerlink\" title=\"路由分发可以实现微前端架构吗\"></a>路由分发可以实现微前端架构吗</h2><p>当然可以。<strong>路由分发是实现微前端架构最主要、最常用也是最经典的方式</strong>。它被认为是微前端架构的“第一种模式”，并且非常有效。</p>\n<h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p><strong>通过路由（URL）的变化，来决定在页面容器中加载、展示和卸载哪个微前端应用。</strong> 主应用（通常称为“容器应用”或“根应用”）充当一个<strong>路由器</strong>和<strong>编排者</strong>的角色，而各个微应用则是独立开发、部署的功能模块。</p>\n<hr>\n<h3 id=\"它是如何工作的？\"><a href=\"#它是如何工作的？\" class=\"headerlink\" title=\"它是如何工作的？\"></a>它是如何工作的？</h3><ol>\n<li><strong>一个路由规则集</strong>：主应用中维护一个配置表，将特定的 URL 路径模式（如 <code>/app1/*</code>, <code>/settings</code>, <code>/dashboard</code>）映射到对应的微应用。</li>\n<li><strong>监听路由变化</strong>：主应用监听 <code>popstate</code>、<code>hashchange</code> 等浏览器路由事件。</li>\n<li><strong>匹配与决策</strong>：当路由发生变化时（用户点击链接或手动输入 URL），主应用根据配置表判断当前应该激活哪个微应用。</li>\n<li><strong>加载与挂载</strong>：主应用动态获取该微应用的资源（JS, CSS），并将其挂载到页面中指定的 DOM 容器（如 <code>&lt;div id=&quot;micro-app-container&quot;&gt;</code>）中。</li>\n<li><strong>卸载与清理</strong>：当用户离开当前路由时，主应用会卸载之前的微应用，并进行必要的清理工作（如清除事件监听器、内存释放等），然后加载新的微应用。</li>\n</ol>\n<h2 id=\"webpack5的Module-Federation可以详细说说嘛\"><a href=\"#webpack5的Module-Federation可以详细说说嘛\" class=\"headerlink\" title=\"webpack5的Module Federation可以详细说说嘛\"></a>webpack5的Module Federation可以详细说说嘛</h2><p>好的，我们来深入、详细地探讨 Webpack 5 的 <strong>Module Federation（模块联邦）</strong>。它不仅仅是微前端的一种实现方式，更是一种革命性的架构思想。</p>\n<h3 id=\"一、核心概念：它是什么？\"><a href=\"#一、核心概念：它是什么？\" class=\"headerlink\" title=\"一、核心概念：它是什么？\"></a>一、核心概念：它是什么？</h3><p><strong>Module Federation (MF)</strong> 的核心目标是：<strong>允许一个 JavaScript 应用在运行时动态地从另一个应用加载代码并共享依赖</strong>。</p>\n<p>你可以把它想象成在浏览器端实现了类似 Node.js 的 <code>require</code> 或 <code>import</code> 机制，但不是在本地文件系统，而是在<strong>网络上的不同独立应用之间</strong>。</p>\n<p>它打破了传统的应用隔离边界，允许应用彼此成为“模块提供者”和“模块消费者”。</p>\n<hr>\n<h3 id=\"二、为什么要用-Module-Federation？-解决的核心痛点\"><a href=\"#二、为什么要用-Module-Federation？-解决的核心痛点\" class=\"headerlink\" title=\"二、为什么要用 Module Federation？(解决的核心痛点)\"></a>二、为什么要用 Module Federation？(解决的核心痛点)</h3><ol>\n<li><strong>彻底解决依赖重复打包</strong><ul>\n<li><strong>传统微前端</strong>：如果主应用和微应用都使用了 React、Vue 等相同的库，这些库的代码会被分别打包到各自的 bundle 中。用户浏览器会多次下载和执行相同的库代码，导致体积膨胀和性能下降。</li>\n<li><strong>MF</strong>：可以<strong>指定共享依赖</strong>。React 等库只加载一次，所有应用都使用同一份实例。这解决了最重要的“依赖地狱”问题。</li>\n</ul>\n</li>\n<li><strong>更彻底的应用拆分与团队自治</strong><ul>\n<li>它允许将应用拆分成更细粒度的“模块”或“组件”，而不仅仅是“页面”或“应用”。</li>\n<li>团队可以独立开发、部署<strong>一个按钮、一个表单、一个页面</strong>，并让其他团队直接消费。</li>\n</ul>\n</li>\n<li><strong>运行时动态集成</strong><ul>\n<li>代码集成发生在运行时（Runtime），而非构建时（Build-time）。这意味着：<ul>\n<li>你可以进行 <strong>A&#x2F;B 测试</strong>，动态切换不同版本的组件。</li>\n<li>可以<strong>独立部署</strong>某个模块，而无需重新部署整个应用。</li>\n<li>主应用甚至不需要提前知道所有可能被加载的微应用。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"三、核心角色与配置\"><a href=\"#三、核心角色与配置\" class=\"headerlink\" title=\"三、核心角色与配置\"></a>三、核心角色与配置</h3><p>MF 中有两个关键角色：</p>\n<ol>\n<li><strong>Remote (远程模块&#x2F;消费者)</strong><ul>\n<li>它是一个<strong>使用方</strong>应用，在运行时从其他地方（<code>Host</code>）导入并执行代码。</li>\n<li>它的配置使用 <code>remotes</code> 属性。</li>\n</ul>\n</li>\n<li><strong>Host (宿主模块&#x2F;提供者)</strong><ul>\n<li>它是一个<strong>提供方</strong>应用，将其内部的某些模块暴露给外部使用。</li>\n<li>它的配置使用 <code>exposes</code> 属性。</li>\n</ul>\n</li>\n</ol>\n<p><strong>一个应用可以同时是</strong>** <strong><code>**Host**</code></strong> <strong><strong>和</strong></strong> **<code>**Remote**</code>。</p>\n<h4 id=\"配置详解-webpack-config-js\"><a href=\"#配置详解-webpack-config-js\" class=\"headerlink\" title=\"配置详解 (webpack.config.js)\"></a>配置详解 (<code>webpack.config.js</code>)</h4><p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Host 应用的配置 (提供模块的应用，端口3001)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ModuleFederationPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack/lib/container/ModuleFederationPlugin&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...其他配置</span></span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">ModuleFederationPlugin</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;app1&#x27;</span>, <span class=\"comment\">// 必填，这个应用的唯一名称，是消费者调用时的标识</span></span><br><span class=\"line\">      <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;remoteEntry.js&#x27;</span>, <span class=\"comment\">// 必填，对外暴露的入口文件清单名</span></span><br><span class=\"line\">      <span class=\"attr\">exposes</span>: &#123; <span class=\"comment\">// 暴露哪些模块给外部使用</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;./Button&#x27;</span>: <span class=\"string\">&#x27;./src/components/Button&#x27;</span>, <span class=\"comment\">// 键：供外部使用的别名；值：本地模块路径</span></span><br><span class=\"line\">        <span class=\"string\">&#x27;./App&#x27;</span>: <span class=\"string\">&#x27;./src/App&#x27;</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">shared</span>: &#123; <span class=\"comment\">// 共享的依赖库</span></span><br><span class=\"line\">        <span class=\"attr\">react</span>: &#123; </span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 确保只使用一个单例版本</span></span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span> <span class=\"comment\">// 需要的版本</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&#x27;react-dom&#x27;</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Remote 应用的配置 (消费模块的应用，端口3002)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ModuleFederationPlugin</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack/lib/container/ModuleFederationPlugin&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">module</span>.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...其他配置</span></span><br><span class=\"line\">  <span class=\"attr\">plugins</span>: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">ModuleFederationPlugin</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">&#x27;app2&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">remotes</span>: &#123; <span class=\"comment\">// 声明要消费哪些远程应用</span></span><br><span class=\"line\">        <span class=\"comment\">// 格式: &quot;name@url/remoteEntry.js&quot;</span></span><br><span class=\"line\">        <span class=\"attr\">app1</span>: <span class=\"string\">&#x27;app1@http://localhost:3001/remoteEntry.js&#x27;</span>,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">shared</span>: &#123; <span class=\"comment\">// 共享依赖的配置必须与Host一致，才能成功共享</span></span><br><span class=\"line\">        <span class=\"attr\">react</span>: &#123; </span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"string\">&#x27;react-dom&#x27;</span>: &#123;</span><br><span class=\"line\">          <span class=\"attr\">singleton</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">          <span class=\"attr\">requiredVersion</span>: <span class=\"string\">&#x27;^18.2.0&#x27;</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"四、如何使用？\"><a href=\"#四、如何使用？\" class=\"headerlink\" title=\"四、如何使用？\"></a>四、如何使用？</h3><p>在 <code>app2</code> (Remote) 的代码中，你可以像导入本地模块一样<strong>动态导入</strong> <code>app1</code> (Host) 暴露的模块：</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 app2 的 React 组件中</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; <span class=\"title class_\">Suspense</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用动态导入语法。`app1` 是配置中remotes的key，`./Button` 是app1暴露的模块名</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">RemoteButton</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">lazy</span>(<span class=\"function\">() =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">&#x27;app1/Button&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>我是 App2<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;<span class=\"name\">Suspense</span> <span class=\"attr\">fallback</span>=<span class=\"string\">&#123;</span>&lt;<span class=\"attr\">div</span>&gt;</span>Loading Button...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>&#125;&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">  &#123;/* 这个Button组件来自另一个独立应用 app1！ */&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">RemoteButton</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Suspense</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"五、工作流程（魔法是如何发生的？）\"><a href=\"#五、工作流程（魔法是如何发生的？）\" class=\"headerlink\" title=\"五、工作流程（魔法是如何发生的？）\"></a>五、工作流程（魔法是如何发生的？）</h3><ol>\n<li><strong>构建阶段</strong>：<ul>\n<li><code>Host</code> (<code>app1</code>) 构建时，会生成一个 <code>remoteEntry.js</code> 文件。这个文件是一个<strong>清单(Manifest)</strong>，记录了 <code>exposes</code> 了哪些模块以及如何获取它们。</li>\n<li><code>Remote</code> (<code>app2</code>) 构建时，会意识到 <code>import(&#39;app1/Button&#39;)</code> 是一个远程模块，不会将其打包到自己的 bundle 中。</li>\n</ul>\n</li>\n<li><strong>运行时阶段</strong>：<ul>\n<li>浏览器加载 <code>app2</code>。</li>\n<li>当执行到 <code>import(&#39;app1/Button&#39;)</code> 时，Webpack 运行时就会去检查配置。</li>\n<li>它发现 <code>app1</code> 对应 <code>http://localhost:3001/remoteEntry.js</code>，于是<strong>动态加载</strong>这个 <code>remoteEntry.js</code> 文件。</li>\n<li><code>remoteEntry.js</code> 告诉 <code>app2</code> 如何从 <code>app1</code> 的服务器上获取 <code>Button</code> 组件的代码块。</li>\n<li>Webpack 加载这个代码块，并<strong>与</strong>** <strong><code>**app2**</code></strong> <strong><strong>共享的</strong></strong> <strong><code>**react**</code></strong> <strong><strong>和</strong></strong> <strong><code>**react-dom**</code></strong> **<strong>实例一起执行它</strong>。</li>\n<li>组件渲染成功。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"六、与-single-spa-等方案的对比\"><a href=\"#六、与-single-spa-等方案的对比\" class=\"headerlink\" title=\"六、与 single-spa 等方案的对比\"></a>六、与 single-spa 等方案的对比</h3><table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>Module Federation</strong></th>\n<th><strong>single-spa (传统方式)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>核心能力</strong></td>\n<td><strong>模块共享与依赖管理</strong></td>\n<td><strong>应用生命周期管理与路由</strong></td>\n</tr>\n<tr>\n<td><strong>集成方式</strong></td>\n<td><strong>运行时动态导入</strong></td>\n<td>运行时加载（但依赖需各自处理）</td>\n</tr>\n<tr>\n<td><strong>依赖处理</strong></td>\n<td><strong>卓越</strong>。自动共享库，避免重复。</td>\n<td><strong>困难</strong>。需要额外手动配置或工具解决。</td>\n</tr>\n<tr>\n<td><strong>打包输出</strong></td>\n<td>生成 <code>remoteEntry.js</code><br/> 清单文件</td>\n<td>生成应用的入口 JS 文件</td>\n</tr>\n<tr>\n<td><strong>粒度</strong></td>\n<td><strong>非常细</strong>。可以共享单个组件、函数、工具库。</td>\n<td><strong>较粗</strong>。通常以整个“应用”或“页面”为单元。</td>\n</tr>\n<tr>\n<td><strong>关系</strong></td>\n<td><strong>互补</strong>。可以<strong>结合使用</strong>：用 single-spa 做路由和生命周期管理，用 MF 来加载组件和共享依赖。</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>Webpack 5 的 Module Federation 是一项颠覆性的技术</strong>。它不再是简单地将应用机械地拼凑在一起，而是真正实现了应用间代码的“无缝融合”与“依赖共享”。</p>\n<p>它最适合的场景包括：</p>\n<ul>\n<li><strong>大型平台型产品</strong>：需要多个团队独立开发不同功能模块。</li>\n<li><strong>微前端架构</strong>：是目前实现微前端最先进、最优雅的方案之一。</li>\n<li><strong>跨应用组件&#x2F;工具库共享</strong>：避免维护多个版本的通用组件。</li>\n</ul>\n<p>它代表了前端架构从“单体”到“分布式”演进的重要方向，是每一位前端架构师都应该深入理解的技术。</p>\n<p>web component</p>\n<h2 id=\"好的，我们来全面、深入地探讨-Web-Components。\"><a href=\"#好的，我们来全面、深入地探讨-Web-Components。\" class=\"headerlink\" title=\"好的，我们来全面、深入地探讨 Web Components。\"></a>好的，我们来全面、深入地探讨 Web Components。</h2><h3 id=\"一、核心概念：它是什么？-1\"><a href=\"#一、核心概念：它是什么？-1\" class=\"headerlink\" title=\"一、核心概念：它是什么？\"></a>一、核心概念：它是什么？</h3><p><strong>Web Components</strong> 是一套<strong>浏览器原生支持</strong>的技术集合，允许你创建可重用的、封装的自定义 HTML 元素（类似于 <code>&lt;div&gt;</code>、<code>&lt;button&gt;</code>，但是是你自己定义的），并在任何现代浏览器中使用它们，无需任何外部框架（如 React、Vue、Angular）。</p>\n<p>它的核心目标是为 Web 开发提供<strong>真正的组件化模型</strong>，并解决代码重用和封装的问题。</p>\n<hr>\n<h3 id=\"二、为什么需要-Web-Components？（解决的问题）\"><a href=\"#二、为什么需要-Web-Components？（解决的问题）\" class=\"headerlink\" title=\"二、为什么需要 Web Components？（解决的问题）\"></a>二、为什么需要 Web Components？（解决的问题）</h3><ol>\n<li><strong>框架无关性 (Framework-Agnostic)</strong><ul>\n<li>你用 Web Components 编写的组件可以在任何 HTML 页面中使用，无论这个页面用的是 React、Vue、Angular、jQuery 还是纯 JavaScript。它提供了<strong>最大程度的可移植性</strong>。</li>\n</ul>\n</li>\n<li><strong>原生封装 (Native Encapsulation)</strong><ul>\n<li><strong>Shadow DOM</strong> 提供了强大的样式和行为封装。组件内部的样式不会泄漏到外部，外部的样式也不会渗透到组件内部（除非特意允许）。这彻底解决了 CSS 全局污染的问题。</li>\n</ul>\n</li>\n<li><strong>长期稳定性 (Longevity)</strong><ul>\n<li>作为<strong>Web 平台标准</strong>，它由浏览器厂商直接实现和维护，不像前端框架那样有生命周期（例如，AngularJS 到 Angular 的断代升级）。你写的组件在未来很多年内都能继续工作。</li>\n</ul>\n</li>\n<li><strong>生态系统互操作性 (Interoperability)</strong><ul>\n<li>它可以在任何框架中被当作普通的 HTML 元素使用，成为了连接不同技术栈应用的“桥梁”。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"三、技术构成（四大核心技术）\"><a href=\"#三、技术构成（四大核心技术）\" class=\"headerlink\" title=\"三、技术构成（四大核心技术）\"></a>三、技术构成（四大核心技术）</h3><p>Web Components 主要由四项技术标准组成，它们可以单独使用，但组合在一起威力最大。</p>\n<h4 id=\"1-Custom-Elements（自定义元素）\"><a href=\"#1-Custom-Elements（自定义元素）\" class=\"headerlink\" title=\"1. Custom Elements（自定义元素）\"></a>1. Custom Elements（自定义元素）</h4><p>一套 JavaScript API，允许你<strong>定义自定义元素及其行为</strong>。</p>\n<ul>\n<li><strong>如何定义</strong>：通过继承 <code>HTMLElement</code> 类来创建一个新的元素类。</li>\n<li><strong>生命周期回调</strong>：<ul>\n<li><code>connectedCallback</code>: 当元素首次被插入到 DOM 时调用。</li>\n<li><code>disconnectedCallback</code>: 当元素从 DOM 中移除时调用。</li>\n<li><code>adoptedCallback</code>: 当元素被移动到新的文档时调用。</li>\n<li><code>attributeChangedCallback</code>: 当元素的被观察属性（在 <code>observedAttributes</code> 中定义）发生变化时调用。</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例：定义一个简单的自定义元素</strong></p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyButton</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">HTMLElement</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 初始化逻辑</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">connectedCallback</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">innerHTML</span> = <span class=\"string\">`&lt;button&gt;Click Me!&lt;/button&gt;`</span>;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">alert</span>(<span class=\"string\">&#x27;Button clicked!&#x27;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 定义需要监听的属性</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">get</span> <span class=\"title function_\">observedAttributes</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">&#x27;disabled&#x27;</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 当disabled属性变化时触发</span></span><br><span class=\"line\">  <span class=\"title function_\">attributeChangedCallback</span>(<span class=\"params\">name, oldValue, newValue</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name === <span class=\"string\">&#x27;disabled&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`disabled changed from <span class=\"subst\">$&#123;oldValue&#125;</span> to <span class=\"subst\">$&#123;newValue&#125;</span>`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 向浏览器注册这个新元素，标签名必须包含连字符 `-`</span></span><br><span class=\"line\">customElements.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;my-button&#x27;</span>, <span class=\"title class_\">MyButton</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>在 HTML 中使用</strong>：</p>\n<p>html</p>\n<p><my-button disabled></my-button></p>\n<h4 id=\"2-Shadow-DOM（影子-DOM）\"><a href=\"#2-Shadow-DOM（影子-DOM）\" class=\"headerlink\" title=\"2. Shadow DOM（影子 DOM）\"></a>2. Shadow DOM（影子 DOM）</h4><p>一套用于将<strong>封装的、“影子”的 DOM 树附加到元素</strong>的 API。这是实现样式和行为封装的关键。</p>\n<ul>\n<li><strong>Shadow Root</strong>：Shadow DOM 的根节点。</li>\n<li><strong>模式</strong>：<ul>\n<li><code>open</code>: 可以通过 JavaScript 从外部访问（例如 <code>element.shadowRoot</code>）。</li>\n<li><code>closed</code>: 外部无法访问，封装性更强。</li>\n</ul>\n</li>\n<li><strong>作用域</strong>：在 Shadow DOM 内部定义的样式和脚本只在这个范围内有效，与外部隔离。</li>\n</ul>\n<p><strong>示例：为自定义元素添加 Shadow DOM</strong></p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyCard</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">HTMLElement</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 附加一个打开的 Shadow Root</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> shadow = <span class=\"variable language_\">this</span>.<span class=\"title function_\">attachShadow</span>(&#123; <span class=\"attr\">mode</span>: <span class=\"string\">&#x27;open&#x27;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建模板</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> template = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">&#x27;template&#x27;</span>);</span><br><span class=\"line\">    template.<span class=\"property\">innerHTML</span> = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      &lt;style&gt;</span></span><br><span class=\"line\"><span class=\"string\">        /* 这些样式只在这个卡片内有效，不会影响外部 */</span></span><br><span class=\"line\"><span class=\"string\">        .card &#123;</span></span><br><span class=\"line\"><span class=\"string\">          border: 1px solid #ccc;</span></span><br><span class=\"line\"><span class=\"string\">          padding: 16px;</span></span><br><span class=\"line\"><span class=\"string\">          border-radius: 8px;</span></span><br><span class=\"line\"><span class=\"string\">          font-family: sans-serif;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">        h2 &#123; color: blue; margin-top: 0; &#125;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/style&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;div class=&quot;card&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;h2&gt;&lt;slot name=&quot;title&quot;&gt;Default Title&lt;/slot&gt;&lt;/h2&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;&lt;slot name=&quot;content&quot;&gt;Default content...&lt;/slot&gt;&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 克隆模板内容并添加到 Shadow Root</span></span><br><span class=\"line\">    shadow.<span class=\"title function_\">appendChild</span>(template.<span class=\"property\">content</span>.<span class=\"title function_\">cloneNode</span>(<span class=\"literal\">true</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">customElements.<span class=\"title function_\">define</span>(<span class=\"string\">&#x27;my-card&#x27;</span>, <span class=\"title class_\">MyCard</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>在 HTML 中使用</strong>：</p>\n<p>html</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;my-card&gt;</span><br><span class=\"line\">  &lt;!-- 使用 slot 将外部内容投影到 Shadow DOM 中的指定位置 --&gt;</span><br><span class=\"line\">  &lt;span slot=&quot;title&quot;&gt;My Awesome Title&lt;/span&gt;</span><br><span class=\"line\">  &lt;span slot=&quot;content&quot;&gt;This is some fantastic content.&lt;/span&gt;</span><br><span class=\"line\">&lt;/my-card&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-HTML-Templates（HTML-模板）\"><a href=\"#3-HTML-Templates（HTML-模板）\" class=\"headerlink\" title=\"3. HTML Templates（HTML 模板）\"></a>3. HTML Templates（HTML 模板）</h4><p><code>&lt;template&gt;</code> 和 <code>&lt;slot&gt;</code> 元素允许你编写<strong>在页面加载时不会立即渲染的标记模板</strong>。这些模板可以被后续的 JavaScript 激活和使用。</p>\n<ul>\n<li><code>&lt;template&gt;</code>：内容不会被浏览器解析、渲染或执行，直到被 JavaScript 提取并使用。</li>\n<li><code>&lt;slot&gt;</code>：在 Web Component 内部充当占位符，允许用户在使用组件时传入自己的自定义内容（如上例所示）。</li>\n</ul>\n<h4 id=\"4-ES-Modules（ES-模块）\"><a href=\"#4-ES-Modules（ES-模块）\" class=\"headerlink\" title=\"4. ES Modules（ES 模块）\"></a>4. ES Modules（ES 模块）</h4><p>现代 JavaScript 的模块标准，为在 Web 上包含和重用 JS 代码提供了官方机制。它使得导入和导出 Web Components 变得简单。</p>\n<p>html</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 在 HTML 中导入并使用一个定义好的 Web Component --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;module&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;./my-component.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">my-component</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"四、Web-Components-的优点与缺点\"><a href=\"#四、Web-Components-的优点与缺点\" class=\"headerlink\" title=\"四、Web Components 的优点与缺点\"></a>四、Web Components 的优点与缺点</h3><h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ol>\n<li><strong>浏览器原生</strong>：无需编译，无需复杂的构建工具。</li>\n<li><strong>高度封装</strong>：Shadow DOM 解决了 CSS 和 DOM 的隔离问题。</li>\n<li><strong>框架无关</strong>：极高的互操作性和可移植性。</li>\n<li><strong>永久可用</strong>：作为 Web 标准，具有极长的生命周期和向后兼容性。</li>\n</ol>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ol>\n<li><strong>生态相对年轻</strong>：虽然基础功能强大，但缺少像 React&#x2F;Vue 那样庞大的生态系统（状态管理、路由、测试工具等）。</li>\n<li><strong>数据流管理较弱</strong>：原生不支持类似 React 的 Props 向下传递、事件向上冒泡的父子组件通信范式，需要自己实现（通常用 Custom Events）。</li>\n<li><strong>SSR (服务器端渲染) 支持差</strong>：自定义元素可以在服务器上渲染，但其动态行为和客户端激活（Hydration）非常复杂，远不如 Next.js&#x2F;Nuxt.js 成熟。</li>\n<li><strong>开发体验 (DX)</strong>：原始的开发方式比较繁琐，需要写很多样板代码。但社区有诸如 <strong>Lit</strong>、<strong>Stencil</strong> 等库来极大地改善体验。</li>\n</ol>\n<hr>\n<h3 id=\"五、Web-Components-与微前端和框架\"><a href=\"#五、Web-Components-与微前端和框架\" class=\"headerlink\" title=\"五、Web Components 与微前端和框架\"></a>五、Web Components 与微前端和框架</h3><ul>\n<li><strong>在微前端中</strong>：Web Components 是实现<strong>技术栈无关</strong>微前端的理想载体。每个团队可以用自己熟悉的技术（React, Vue）<strong>开发</strong>组件，但最终<strong>发布</strong>为一个封装好的 Web Component（例如，将一个 React 组件包装成 <code>&lt;team-product-card&gt;</code>），由主应用统一调度。</li>\n<li><strong>与框架的关系</strong>：<ul>\n<li><strong>不是替代关系</strong>，而是<strong>互补关系</strong>。</li>\n<li><strong>框架 (React&#x2F;Vue) 擅长解决：</strong> 复杂的 UI 状态管理、数据流、高效的 DOM 差分更新。它们提供了<strong>优秀的开发体验</strong>和<strong>完整的解决方案</strong>。</li>\n<li><strong>Web Components 擅长解决：</strong> 跨框架重用、底层 UI 组件库、集成遗留应用、长期稳定的基础组件。它们提供了<strong>浏览器级别的互操作性</strong>。</li>\n</ul>\n</li>\n</ul>\n<p><strong>总结来说，Web Components 是 Web 平台的底层基础，为构建可长期存在、高度封装、框架无关的组件提供了强大的原生能力。</strong> 虽然它在开发复杂应用时不如现代框架那么方便，但其独特优势使其在特定场景（如微前端、跨技术栈组件库、大型企业级应用）中是不可替代的选择。</p>\n<p>qiankun实现样式和js隔离的原理</p>\n<p>好的，我们来深入剖析 <strong>qiankun</strong> 实现样式和 JavaScript 隔离的原理。这是 qiankun 的核心能力之一，也是它相比原始 single-spa 更易用、更强大的关键。</p>\n<h3 id=\"总体思想\"><a href=\"#总体思想\" class=\"headerlink\" title=\"总体思想\"></a>总体思想</h3><p>qiankun 的隔离策略可以概括为：<strong>“重样式隔离，轻 JS 沙箱”</strong>。它通过在应用加载和卸载时动态地操作样式和 JavaScript 执行环境来模拟一个隔离的沙箱环境。</p>\n<hr>\n<h3 id=\"一、样式隔离-CSS-Isolation\"><a href=\"#一、样式隔离-CSS-Isolation\" class=\"headerlink\" title=\"一、样式隔离 (CSS Isolation)\"></a>一、样式隔离 (CSS Isolation)</h3><p>qiankun 提供了三种主要的样式隔离方案，根据场景不同自动或手动启用。</p>\n<h4 id=\"1-严格样式隔离-Scoped-CSS\"><a href=\"#1-严格样式隔离-Scoped-CSS\" class=\"headerlink\" title=\"1. 严格样式隔离 (Scoped CSS)\"></a>1. 严格样式隔离 (Scoped CSS)</h4><p><strong>原理：</strong> 为每个微应用包裹一个 <strong>Shadow DOM</strong>。</p>\n<ul>\n<li><strong>如何工作：</strong><ol>\n<li>当 qiankun 挂载一个微应用时，它会创建一个 Shadow Root，并将其作为该应用的容器。</li>\n<li>微应用的所有 DOM 结构都被渲染在这个 Shadow DOM 内部。</li>\n<li><strong>Shadow DOM 的特性天然实现了样式的封装</strong>：内部的样式不会影响外部，外部的样式也不会影响内部（除非使用 <code>::part</code> 或 <code>:host</code> 等特定语法）。</li>\n</ol>\n</li>\n<li><strong>优点：</strong> 隔离性最强，是浏览器原生的完美隔离方案。</li>\n<li><strong>缺点：</strong><ul>\n<li>某些第三方库（特别是弹窗类）可能会因为无法正确定位到 Shadow DOM 外部而出现问题。</li>\n<li>微应用内的样式完全无法影响主应用，反之亦然，有时这可能不符合设计需求。</li>\n</ul>\n</li>\n<li><strong>启用方式：</strong> 在 <code>start</code> 函数中配置 <code>&#123; strictStyleIsolation: true &#125;</code>。</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; start &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;qiankun&#x27;</span>;</span><br><span class=\"line\"><span class=\"title function_\">start</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">strictStyleIsolation</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 启用严格样式隔离</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-实验性样式隔离-CSS-Scoped\"><a href=\"#2-实验性样式隔离-CSS-Scoped\" class=\"headerlink\" title=\"2. 实验性样式隔离 (CSS Scoped)\"></a>2. 实验性样式隔离 (CSS Scoped)</h4><p><strong>原理：</strong> 一种更宽松的隔离方式，使用 <strong>运行时动态样式表重写</strong>。</p>\n<ul>\n<li><strong>如何工作：</strong><ol>\n<li>qiankun 会劫持微应用运行时<strong>动态添加样式标签（</strong><code>**&lt;style&gt;**</code><strong>,</strong>** <strong><code>**&lt;link&gt;**</code></strong>）** 的行为。</li>\n<li>当微应用插入一个新的样式标签时，qiankun 会将其内容抓取过来。</li>\n<li>使用 <strong>CSS 规则重写器</strong>（例如 <code>postcss</code> 插件）为所有 CSS 选择器<strong>添加一个特殊的前缀</strong>。这个前缀通常基于微应用的名称或一个特定属性。</li>\n<li>将重写后的 CSS 内容插入到 <code>document.head</code> 中。</li>\n<li>同时，qiankun 会为微应用的<strong>容器元素</strong>添加上一步中使用的<strong>相同属性</strong>。</li>\n</ol>\n</li>\n</ul>\n<p><strong>示例：</strong></p>\n<pre><code>- 微应用有一个样式规则：`.button &#123; color: red; &#125;`\n- qiankun 将其重写为：`[data-qiankun=&quot;my-app&quot;] .button &#123; color: red; &#125;`\n- 同时，微应用的容器 `&lt;div&gt;` 会获得属性：`&lt;div data-qiankun=&quot;my-app&quot;&gt;...&lt;/div&gt;`\n- 这样，样式规则就只会在这个容器内生效。\n</code></pre>\n<ul>\n<li><strong>优点：</strong> 比 Shadow DOM 兼容性更好，允许微应用样式影响其容器内的任何元素（包括动态 append 到 body 的弹窗）。</li>\n<li><strong>缺点：</strong> 是运行时重写，有一定性能开销，且是实验性功能。</li>\n<li><strong>启用方式：</strong> 在 <code>start</code> 函数中配置 <code>&#123; experimentalStyleIsolation: true &#125;</code>。</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">start</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">experimentalStyleIsolation</span>: <span class=\"literal\">true</span>, <span class=\"comment\">// 启用实验性样式隔离</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-动态样式表加载-卸载-最常见的默认行为\"><a href=\"#3-动态样式表加载-卸载-最常见的默认行为\" class=\"headerlink\" title=\"3. 动态样式表加载&#x2F;卸载 (最常见的默认行为)\"></a>3. 动态样式表加载&#x2F;卸载 (最常见的默认行为)</h4><p>如果不开启上述两种隔离，qiankun 默认采用一种更简单但有效的策略。</p>\n<ul>\n<li><strong>原理：</strong><ol>\n<li><strong>加载时：</strong> qiankun 通过 <code>fetch</code> 获取微应用的 HTML 入口，解析出所有的 <code>&lt;style&gt;</code> 和 <code>&lt;link&gt;</code> 标签。</li>\n<li>将这些样式标签<strong>直接插入到</strong>** **<code>**document.head**</code> 中。</li>\n<li><strong>卸载时：</strong> qiankun 会<strong>记录</strong>所有由该微应用添加的样式标签，并在卸载微应用时<strong>直接将这些标签从 DOM 中移除</strong>。</li>\n</ol>\n</li>\n<li><strong>优点：</strong> 实现简单，性能好。</li>\n<li><strong>缺点：</strong> <strong>不是真正的隔离</strong>。如果多个微应用有相同选择器的样式规则，后加载的会覆盖先加载的（因为后加载的样式表在更后面，优先级更高）。这依赖于开发者的约定。</li>\n<li><strong>这是 qiankun 的默认行为</strong>，对于很多应用来说已经足够。</li>\n</ul>\n<hr>\n<h3 id=\"二、JavaScript-隔离-JS-Sandbox\"><a href=\"#二、JavaScript-隔离-JS-Sandbox\" class=\"headerlink\" title=\"二、JavaScript 隔离 (JS Sandbox)\"></a>二、JavaScript 隔离 (JS Sandbox)</h3><p>qiankun 的 JS 沙箱的核心目标是：<strong>防止微应用在全局环境（</strong><code>**window**</code><strong>）上留下永久的污染，并在应用切换时恢复和清理环境</strong>。它主要模拟了三个环境的隔离：</p>\n<h4 id=\"1-快照沙箱-SnapshotSandbox-用于单实例场景\"><a href=\"#1-快照沙箱-SnapshotSandbox-用于单实例场景\" class=\"headerlink\" title=\"1. 快照沙箱 (SnapshotSandbox) - 用于单实例场景\"></a>1. 快照沙箱 (SnapshotSandbox) - 用于单实例场景</h4><p><strong>原理：</strong> 在应用加载前后对全局 <code>window</code> 对象进行“拍照”和“diff”，适用于同一时间只能有一个微应用活跃的浏览器环境。</p>\n<ul>\n<li><strong>工作流程：</strong><ol>\n<li><strong>激活沙箱 (mount)：</strong> 将当前 <code>window</code> 的所有属性拍一个<strong>快照</strong>（<code>windowSnapshot</code>），存起来。</li>\n<li><strong>微应用运行：</strong> 微应用可以任意修改 <code>window</code>。</li>\n<li><strong>失活沙箱 (unmount)：</strong><ul>\n<li>将当前的 <code>window</code> 和之前存的 <code>windowSnapshot</code> 进行对比，得到修改的差异（<code>modifyPropsMap</code>）。</li>\n<li><strong>还原现场：</strong> 遍历差异，将 <code>window</code> 上的属性<strong>恢复</strong>到拍快照时的状态。</li>\n<li><strong>记录污染：</strong> 将微应用修改的差异保存起来。</li>\n</ul>\n</li>\n<li><strong>再次激活：</strong> 将之前保存的差异（<code>modifyPropsMap</code>）<strong>重新应用到</strong>** <strong><code>**window**</code></strong> **<strong>上</strong>，让微应用感觉自己的修改一直都在。</li>\n</ol>\n</li>\n<li><strong>优点：</strong> 兼容性极好，支持所有浏览器。</li>\n<li><strong>缺点：</strong> 无法支持多个微应用同时运行（多实例），因为共用一个全局 <code>window</code>。</li>\n</ul>\n<h4 id=\"2-代理沙箱-ProxySandbox-用于多实例场景（主流）\"><a href=\"#2-代理沙箱-ProxySandbox-用于多实例场景（主流）\" class=\"headerlink\" title=\"2. 代理沙箱 (ProxySandbox) - 用于多实例场景（主流）\"></a>2. 代理沙箱 (ProxySandbox) - 用于多实例场景（主流）</h4><p><strong>原理：</strong> 使用 ES6 的 <code>Proxy</code> 为每个微应用创建一个假的、隔离的 <code>window</code> 对象。</p>\n<ul>\n<li><strong>工作流程：</strong><ol>\n<li>qiankun 为每个微应用创建一个空的 <code>fakeWindow</code> 对象。</li>\n<li>用 <code>Proxy</code> 代理这个 <code>fakeWindow</code>。</li>\n<li>当微应用操作 <code>window</code> 时：<ul>\n<li><strong>读操作</strong>：优先从 <code>fakeWindow</code> 里读，如果读不到，则 fallback 到真正的全局 <code>window</code>（这样可以共享 <code>document</code>, <code>location</code> 等全局对象）。</li>\n<li><strong>写操作</strong>：所有对属性的新增和修改都只作用于 <code>fakeWindow</code> 上，<strong>完全不会污染真正的全局</strong>** **<code>**window**</code>。</li>\n</ul>\n</li>\n<li>微应用的所有代码都在这个代理的上下文中执行（通过 <code>with</code> 语句或 <code>eval</code> 改写）。</li>\n</ol>\n</li>\n<li><strong>示例：</strong></li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 微应用代码</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">myGlobalVar</span> = <span class=\"number\">123</span>; <span class=\"comment\">// 写入的是沙箱的 fakeWindow，真 window 不受影响</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">document</span>.<span class=\"property\">title</span>); <span class=\"comment\">// 读取的是真 window 的属性</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>优点：</strong><ul>\n<li>真正的隔离，多个微应用可以同时运行，每个都有自己独立的 <code>window</code> 空间。</li>\n<li>对微应用无感知，无需修改代码。</li>\n</ul>\n</li>\n<li><strong>缺点：</strong> 依赖 ES6 <code>Proxy</code>，无法在低版本浏览器（如 IE）中使用。</li>\n</ul>\n<h4 id=\"3-遗留沙箱-LegacySandbox-已逐渐被代理沙箱取代\"><a href=\"#3-遗留沙箱-LegacySandbox-已逐渐被代理沙箱取代\" class=\"headerlink\" title=\"3. 遗留沙箱 (LegacySandbox) - 已逐渐被代理沙箱取代\"></a>3. 遗留沙箱 (LegacySandbox) - 已逐渐被代理沙箱取代</h4><p>原理类似于快照沙箱，但性能优化更好。它只记录微应用修改过的属性，在卸载时还原这些属性。同样不支持多实例。</p>\n<hr>\n<h3 id=\"总结：qiankun-的隔离策略\"><a href=\"#总结：qiankun-的隔离策略\" class=\"headerlink\" title=\"总结：qiankun 的隔离策略\"></a>总结：qiankun 的隔离策略</h3><table>\n<thead>\n<tr>\n<th><strong>隔离类型</strong></th>\n<th><strong>技术方案</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>样式隔离</strong></td>\n<td><strong>Shadow DOM</strong></td>\n<td>原生，隔离最彻底</td>\n<td>兼容性问题，弹窗等组件可能异常</td>\n<td>需要最强隔离的新应用</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>动态样式表重写 (实验性)</strong></td>\n<td>兼容性好，支持弹窗</td>\n<td>运行时开销，实验性功能</td>\n<td>需要兼容弹窗的复杂应用</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>动态加载&#x2F;卸载 (默认)</strong></td>\n<td>简单，性能好</td>\n<td>非真正隔离，依赖约定</td>\n<td>大多数简单应用，样式冲突风险低</td>\n</tr>\n<tr>\n<td><strong>JS 隔离</strong></td>\n<td><strong>快照沙箱 (SnapshotSandbox)</strong></td>\n<td>兼容所有浏览器</td>\n<td>不支持多实例</td>\n<td>单实例模式，需兼容 IE 等老浏览器</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>代理沙箱 (ProxySandbox)</strong></td>\n<td>真正隔离，支持多实例，对应用无感知</td>\n<td>依赖 <code>Proxy</code><br/>，不兼容 IE</td>\n<td><strong>现代浏览器下的主流选择</strong></td>\n</tr>\n</tbody></table>\n<p><strong>qiankun 会自动选择最佳策略</strong>：在支持 <code>Proxy</code> 的浏览器中默认使用<strong>代理沙箱 (多实例)</strong> 和<strong>动态样式加载&#x2F;卸载</strong>。如果不支持 <code>Proxy</code>，则降级到<strong>快照沙箱 (单实例)</strong>。</p>\n<p>通过这种组合策略，qiankun 在绝大多数场景下为微前端应用提供了<strong>足够安全、稳定且高性能的隔离环境</strong>，极大地简化了微前端的落地复杂度。</p>\n<p>qiankun是如何实现父子应用通信的呢</p>\n<p>好的，<strong>qiankun 的通信机制</strong>是其核心功能之一，它设计得非常灵活，提供了多种方式来实现主应用（父应用）和微应用（子应用）之间的通信。</p>\n<p>qiankun 并没有强制使用某一种通信方式，而是提供了一个轻量的 <strong>API（</strong><code>**initGlobalState**</code><strong>）</strong> 作为推荐方案，同时也完全支持任何其他流行的状态管理库（如 Redux, Mobx, Vuex）或浏览器原生 API。</p>\n<hr>\n<h3 id=\"一、官方推荐方案：使用-initGlobalState-Actions-通信\"><a href=\"#一、官方推荐方案：使用-initGlobalState-Actions-通信\" class=\"headerlink\" title=\"一、官方推荐方案：使用 initGlobalState (Actions 通信)\"></a>一、官方推荐方案：使用 <code>initGlobalState</code> (Actions 通信)</h3><p>这是 qiankun 官方提供的通信方式，适用于大多数场景。它的核心思想是一个<strong>简单的发布-订阅模式</strong>。</p>\n<h4 id=\"1-在主应用中初始化状态并下发通信方法\"><a href=\"#1-在主应用中初始化状态并下发通信方法\" class=\"headerlink\" title=\"1. 在主应用中初始化状态并下发通信方法\"></a>1. 在主应用中初始化状态并下发通信方法</h4><p>主应用是整个状态的管理中心。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main-app/src/actions.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; initGlobalState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;qiankun&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 初始化全局状态</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\">  <span class=\"attr\">user</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;张三&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">token</span>: <span class=\"string\">&#x27;abc123&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">theme</span>: <span class=\"string\">&#x27;light&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 创建 Actions 实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> actions = <span class=\"title function_\">initGlobalState</span>(initialState);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 监听状态变化（可选，主应用自己也可以监听）</span></span><br><span class=\"line\">actions.<span class=\"title function_\">onGlobalStateChange</span>(<span class=\"function\">(<span class=\"params\">state, prevState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// state: 变更后的新状态</span></span><br><span class=\"line\">  <span class=\"comment\">// prevState: 变更前的旧状态</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;主应用监听到状态变化: &#x27;</span>, state, prevState);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 定义一个更新状态的方法</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> <span class=\"title function_\">setGlobalState</span> = (<span class=\"params\">newState</span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 按层级合并状态</span></span><br><span class=\"line\">  actions.<span class=\"title function_\">setGlobalState</span>(newState);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5. 将 actions 暴露出去，供微应用使用</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> actions;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-在微应用中获取并操作状态\"><a href=\"#2-在微应用中获取并操作状态\" class=\"headerlink\" title=\"2. 在微应用中获取并操作状态\"></a>2. 在微应用中获取并操作状态</h4><p>微应用需要从生命周期函数中获取到 <code>props</code>，其中就包含了通信方法。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// micro-app/src/main.js (入口文件)</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> microAppActions; <span class=\"comment\">// 用来保存通信方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导出 qiankun 生命周期函数</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">mount</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;微应用挂载了&#x27;</span>, props);</span><br><span class=\"line\">  <span class=\"comment\">// 1. 从 props 中获取主应用下发的 actions</span></span><br><span class=\"line\">  microAppActions = props;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 监听全局状态变化</span></span><br><span class=\"line\">  props.<span class=\"title function_\">onGlobalStateChange</span>(<span class=\"function\">(<span class=\"params\">state, prevState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;微应用监听到状态变化: &#x27;</span>, state, prevState);</span><br><span class=\"line\">    <span class=\"comment\">// 状态变化后，更新微应用自己的视图</span></span><br><span class=\"line\">    <span class=\"title function_\">renderApp</span>(state);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 首次挂载，获取当前全局状态并渲染应用</span></span><br><span class=\"line\">  <span class=\"title function_\">renderApp</span>(props.<span class=\"title function_\">getGlobalState</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">unmount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 卸载时取消监听（qiankun 内部会自动清理，但显式取消是好习惯）</span></span><br><span class=\"line\">  microAppActions.<span class=\"title function_\">offGlobalStateChange</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// React/Vue 应用的渲染函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">renderApp</span>(<span class=\"params\">state</span>) &#123;</span><br><span class=\"line\">  <span class=\"title class_\">ReactDOM</span>.<span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> <span class=\"attr\">globalState</span>=<span class=\"string\">&#123;state&#125;</span> <span class=\"attr\">actions</span>=<span class=\"string\">&#123;microAppActions&#125;</span> /&gt;</span></span>, <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">&#x27;app&#x27;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-在微应用组件中具体使用\"><a href=\"#3-在微应用组件中具体使用\" class=\"headerlink\" title=\"3. 在微应用组件中具体使用\"></a>3. 在微应用组件中具体使用</h4><p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// micro-app/src/App.jsx</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\">&#123; globalState, actions &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; user, theme &#125; = globalState;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">handleChangeTheme</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新全局状态</span></span><br><span class=\"line\">    actions.<span class=\"title function_\">setGlobalState</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">theme</span>: theme === <span class=\"string\">&#x27;light&#x27;</span> ? <span class=\"string\">&#x27;dark&#x27;</span> : <span class=\"string\">&#x27;light&#x27;</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">&#123;</span>`<span class=\"attr\">app</span> $&#123;<span class=\"attr\">theme</span>&#125;`&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>微应用页面<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>用户名: &#123;user.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;handleChangeTheme&#125;</span>&gt;</span>切换主题<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"title class_\">App</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"initGlobalState-API-说明：\"><a href=\"#initGlobalState-API-说明：\" class=\"headerlink\" title=\"initGlobalState API 说明：\"></a><code>initGlobalState</code> API 说明：</h4><ul>\n<li><code>setGlobalState(state: object)</code>: 设置新的全局状态，会自动与旧状态进行<strong>浅合并</strong>。</li>\n<li><code>onGlobalStateChange(callback: function)</code>: 注册监听器，状态变化时触发。</li>\n<li><code>offGlobalStateChange()</code>: 取消监听。</li>\n<li><code>getGlobalState()</code>: 获取当前全局状态。</li>\n</ul>\n<hr>\n<h3 id=\"二、其他通信方案\"><a href=\"#二、其他通信方案\" class=\"headerlink\" title=\"二、其他通信方案\"></a>二、其他通信方案</h3><p>qiankun 是框架无关的，因此你也可以选择任何你熟悉的通信方式。</p>\n<h4 id=\"1-使用-CustomEvent-浏览器原生事件\"><a href=\"#1-使用-CustomEvent-浏览器原生事件\" class=\"headerlink\" title=\"1. 使用 CustomEvent (浏览器原生事件)\"></a>1. 使用 CustomEvent (浏览器原生事件)</h4><p><strong>原理：</strong> 利用浏览器原生的 <code>window.dispatchEvent</code> 和 <code>window.addEventListener</code> 进行通信。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主应用 - 发送事件</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;main-app-event&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">detail</span>: &#123; <span class=\"comment\">// 通过 detail 传递数据</span></span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">&#x27;CHANGE_THEME&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">payload</span>: <span class=\"string\">&#x27;dark&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用 - 接收事件</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;main-app-event&#x27;</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; type, payload &#125; = event.<span class=\"property\">detail</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 处理事件...</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用 - 发送事件（同理）</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">dispatchEvent</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomEvent</span>(<span class=\"string\">&#x27;micro-app-event&#x27;</span>, &#123;</span><br><span class=\"line\">  <span class=\"attr\">detail</span>: &#123; <span class=\"attr\">message</span>: <span class=\"string\">&#x27;Hello from micro app&#x27;</span> &#125;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong> 原生支持，非常简单。<br><strong>缺点：</strong> 数据传递能力较弱（只能同步），缺乏状态管理能力，事件需要全局唯一命名以免冲突。</p>\n<h4 id=\"2-使用-Redux-Mobx-Vuex-等状态库\"><a href=\"#2-使用-Redux-Mobx-Vuex-等状态库\" class=\"headerlink\" title=\"2. 使用 Redux&#x2F;Mobx&#x2F;Vuex 等状态库\"></a>2. 使用 Redux&#x2F;Mobx&#x2F;Vuex 等状态库</h4><p><strong>原理：</strong> 主应用和微应用<strong>共享同一个状态库实例</strong>。</p>\n<ul>\n<li><strong>步骤：</strong><ol>\n<li>主应用创建一个 Redux Store 或其他状态库实例。</li>\n<li>将这个 Store 通过 <code>window</code> 对象或者微应用的 <code>props</code> 暴露给微应用。</li>\n<li>微应用连接到这个全局的 Store，进行状态的读取和分发 Action。</li>\n</ol>\n</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主应用 - 创建并暴露 store</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;redux&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> globalStore = <span class=\"title function_\">createStore</span>(<span class=\"comment\">/* ... */</span>);</span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">__MAIN_APP_STORE__</span> = globalStore; <span class=\"comment\">// 挂到全局</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用 - 获取并使用 store</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"variable language_\">window</span>.<span class=\"property\">__MAIN_APP_STORE__</span>;</span><br><span class=\"line\">store.<span class=\"title function_\">dispatch</span>(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&#x27;AN_ACTION&#x27;</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">const</span> state = store.<span class=\"title function_\">getState</span>();</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong> 功能强大，可以处理复杂的业务逻辑和状态流。<br><strong>缺点：</strong> 紧密耦合，主应用和微应用必须使用同一种状态库，且版本需要兼容。</p>\n<h4 id=\"3-通过-URL-或-Query-Parameters-通信\"><a href=\"#3-通过-URL-或-Query-Parameters-通信\" class=\"headerlink\" title=\"3. 通过 URL 或 Query Parameters 通信\"></a>3. 通过 URL 或 Query Parameters 通信</h4><p><strong>原理：</strong> 通过改变 URL 的查询参数来传递简单信息。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主应用改变URL</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newUrl = <span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"variable language_\">window</span>.location.pathname&#125;</span>?theme=dark&amp;userId=123`</span>;</span><br><span class=\"line\">history.<span class=\"title function_\">pushState</span>(<span class=\"literal\">null</span>, <span class=\"string\">&#x27;&#x27;</span>, newUrl);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 微应用监听URL变化</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">&#x27;popstate&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> urlParams = <span class=\"keyword\">new</span> <span class=\"title class_\">URLSearchParams</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">location</span>.<span class=\"property\">search</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> theme = urlParams.<span class=\"title function_\">get</span>(<span class=\"string\">&#x27;theme&#x27;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ...使用参数</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>优点：</strong> 非常简单，状态可被收藏和分享。<br><strong>缺点：</strong> 只适合传递少量简单数据。</p>\n<hr>\n<h3 id=\"总结与选择建议\"><a href=\"#总结与选择建议\" class=\"headerlink\" title=\"总结与选择建议\"></a>总结与选择建议</h3><table>\n<thead>\n<tr>\n<th><strong>方案</strong></th>\n<th><strong>优点</strong></th>\n<th><strong>缺点</strong></th>\n<th><strong>适用场景</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>官方</strong>** **<code>**initGlobalState**</code></td>\n<td><strong>官方推荐</strong>，简单轻量，满足大部分通信需求</td>\n<td>功能相对简单，不适合极其复杂的场景</td>\n<td><strong>绝大多数微前端通信场景的首选</strong></td>\n</tr>\n<tr>\n<td><strong>CustomEvent</strong></td>\n<td>浏览器原生，非常简单</td>\n<td>功能弱，只能传简单数据，易产生事件名冲突</td>\n<td>简单的父子通知、触发动作</td>\n</tr>\n<tr>\n<td><strong>Redux&#x2F;Vuex 等</strong></td>\n<td>功能强大，适合复杂状态管理</td>\n<td>耦合度高，主子和微应用必须使用同一种状态库</td>\n<td>大型复杂应用，且技术栈统一</td>\n</tr>\n<tr>\n<td><strong>URL Parameters</strong></td>\n<td>实现简单，状态可分享</td>\n<td>传递数据量有限，类型受限</td>\n<td>过滤条件、简单配置等</td>\n</tr>\n</tbody></table>\n<p><strong>最佳实践建议：</strong></p>\n<ol>\n<li><strong>优先使用官方的</strong>** **<code>**initGlobalState**</code>，它能覆盖 90% 的微前端通信需求。</li>\n<li>对于简单的、一次性的动作触发（如“刷新列表”、“显示通知”），可以辅以 <strong>CustomEvent</strong>。</li>\n<li>只有在主应用和所有微应用技术栈统一且非常复杂时，才考虑使用<strong>共享状态库</strong>。</li>\n<li>通信的设计应遵循<strong>最小化原则</strong>，尽量减少主应用和微应用之间的耦合，让微应用保持最大的独立性。</li>\n</ol>\n","_processedHighlight":true},{"title":"前端部署详解","date":"2025-03-25T16:00:00.000Z","_content":"\n# CI/CD\n## 🧠 核心概念：CI/CD是什么？\nCI/CD 是现代软件工程中的一套最佳实践和方法论，旨在自动化软件的集成、测试和部署流程。它由两个部分组成：\n\nCI - 持续集成 (Continuous Integration)\n\nCD - 持续交付/持续部署 (Continuous Delivery / Continuous Deployment)\n\n可以把 CI/CD 想象成一个全自动的软件装配流水线。开发者提交代码（如同送上原料），流水线会自动进行一系列质量检测、打包和发布，最终将合格的产品交付给用户。\n\n## 🔧 详解两个部分\n### 1. CI - 持续集成\n**核心思想：** 开发者频繁地将代码更改合并到共享的主干分支（如每天多次）。每次合并都会自动触发一系列构建和测试，以便快速发现和修复错误。\n\n:::tips\n![](https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756740541342-f73ad130-61e5-4ba6-9386-4bd47fda11ff.svg)\n\n:::\n\n**好处：**\n\n+ ✅ **快速发现错误**：问题在引入后几分钟内就能被发现。\n+ ✅ **减少集成冲突**：频繁合并小批量代码，避免在发布前一次性合并大量代码带来的巨大冲突。\n+ ✅ 提高代码质量**：自动化测试保障了代码标准。\n\n### 2. CD - 持续交付 / 持续部署\n**CD 有两种细微差别的含义：**\n\n#### a) 持续交付 (Continuous Delivery)\n**核心思想：** CI流程结束后，代码总是处于**可随时、一键手动部署**到生产环境的状态。\n\n**流程：** `代码 -> CI -> 生成制品 -> 等待手动点击部署`\n\n#### b) 持续部署 (Continuous Deployment)\n**核心思想：** 这是持续交付的更高阶段。只要代码通过所有测试流程，就**自动地、无需人工干预地**部署到生产环境。\n\n**流程：** `代码 -> CI -> 生成制品 -> 自动部署到生产环境`\n\n可以这样理解：\n\n+ **持续交付** = \"软件已经打包好放在门口了，你随时可以签收（手动部署）。\"\n+ **持续部署** = \"软件通过质检后，快递机器人自动送货上门（自动部署）。\"\n\n## 🛠️ CI/CD 工具链\n整个流程依赖于一系列自动化工具，常见的工具有：\n\n| **阶段** | **流行工具** |\n| --- | --- |\n| **源代码管理****** | Git (GitLab, GitHub, Gitee) |\n| **CI/CD 流水线引擎** | **Jenkins**, GitLab CI/CD, GitHub Actions, Drone |\n| **构建工具** | Maven, Gradle (Java), npm, Webpack (JS), Make |\n| **测试工具** | JUnit, Selenium, Jest, Cypress |\n| **部署工具** | Ansible, Kubernetes, Docker, Terraform |\n| **监控工具** | Prometheus, Grafana, ELK Stack |\n\n\n## 💡 为什么需要 CI/CD？它的价值是什么？\n1. **加速开发流程**\n    - 自动化代替手动操作，释放开发者的生产力。\n    - 快速反馈，开发者能立即知道这次提交是否破坏了系统。\n2. **提高软件质量**\n    - 通过自动化测试在早期发现缺陷，修复成本远低于生产环境才发现。\n    - 代码规范、安全漏洞扫描等流程被标准化。\n3. **降低发布风险**\n    - 小批量、频繁的发布使得每次变更的内容很少。如果出现问题，可以快速定位和回滚。\n    - 传统的\"半年发布一次，一次改动500个功能\"的方式风险极高。\n4. **增强项目可见性**\n    - 每个人都能清晰地看到代码从提交到部署的整个状态，构建是否成功、测试是否通过。\n\n## ✅ 总结\n**CI/CD** 是一套通过**自动化**来**优化软件开发生命周期**的实践，其核心目标是：\n\n+ **更快的发布速度**\n+ **更高质量的软件**\n+ **更低的发布风险**\n\n它不是某个特定的工具，而是一种文化和流程的变革，是现代DevOps理念的核心支柱，已经成为中大型软件开发团队的标配。\n\n# OpenVpn与跳板机/堡垒机\n## 🔧 什么是 OpenVPN 客户端？\n**OpenVPN 客户端**是一个安装在您本地设备（如电脑、手机）上的**软件程序**。\n\n它的核心功能是：**根据配置文件（.ovpn 文件），与远端的 OpenVPN 服务器建立一条加密的、安全的隧道连接。**\n\n+ **它是什么？** 一个软件（例如：OpenVPN Connect、Tunnelblick等）。\n+ **它在哪里运行？** 在你的个人设备上（Windows PC, Mac, Linux, 手机）。\n+ **它的作用？** 创建加密通道，让你的所有或指定网络流量都通过这个通道流向VPN服务器。\n\n**就像一个专门的电话（客户端），用于拨打一个安全的号码（服务器）。**\n\n---\n\n## 🖥️ 什么是跳板机？\n**跳板机**（Jump Server / Bastion Host）是一台位于某个特定网络区域（如公司内网）的**服务器**。\n\n它的核心功能是：**作为一个唯一的、受严格控制的访问入口，所有外部人员必须先连接到这台服务器，才能进一步访问目标网络内部的其他设备。**\n\n+ **它是什么？** 一台物理或虚拟的服务器/计算机。\n+ **它在哪里运行？** 在目标网络的入口处（例如公司机房或公有云上）。\n+ **它的作用？** 提供访问桥梁和安全审计。所有操作都通过它进行，便于监控和记录日志。\n\n**就像是大楼的门卫室（跳板机），所有访客（用户）必须先在门卫室登记、核实身份，由门卫带领才能进入大楼内部（内网）。**\n\n---\n\n## 🔄 它们如何协同工作？（两者的关系）\nOpenVPN 客户端和跳板机通常**配合使用**，但它们扮演完全不同的角色。\n\n### 工作流程分解：\n#### 阶段一：建立安全隧道（认证与连接）\n1. **配置加载**：用户在自己的电脑上启动OpenVPN客户端软件，并加载管理员提供的 `.ovpn`配置文件。这个文件包含了连接所需的所有信息：\n    - **跳板机的公网IP/域名**\n    - 加密算法和协议类型\n    - **CA根证书**（用于验证服务器身份）\n    - **客户端证书和私钥**（用于向服务器证明自身身份）\n    - 其他参数（如使用的端口、是否使用密码等）\n2. **发起连接**：客户端根据配置，向跳板机的公网IP和指定端口发起TCP/UDP连接请求。\n3. **TLS双向认证**（最关键的安全步骤）：\n    - **服务器认证**：跳板机上的OpenVPN服务端将自己的证书发给客户端。客户端用CA根证书验证服务器证书的有效性，**确保连接的是真正的公司跳板机，而不是钓鱼服务器**。\n    - **客户端认证**：客户端将自己的证书和私钥签名发给服务器。服务器用CA根证书验证客户端证书，**确保连接的是授权员工，而不是外人**。\n    - 这个过程通常还辅以用户名/密码认证。\n4. **隧道建立**：认证通过后，双方利用协商好的密钥，建立一条**加密隧道**。跳板机为客户端分配一个内网IP地址（如 `10.8.0.100`）。此时，用户的电脑在逻辑上已经“接入”了公司内网。\n\n#### 阶段二：访问内部资源（路由与转发）\n1. **发起访问请求**：用户需要访问内网的一台Web服务器（`192.168.1.100`）。他在本地使用SSH命令：`ssh developer@192.168.1.100`。\n2. **流量封装与路由**：\n    - 客户端的操作系统会根据路由表规则，将所有发往 `192.168.1.0/24` 网段的流量，都指向OpenVPN创建的虚拟网卡。\n    - OpenVPN客户端将原始的SSH数据包（TCP协议）**整个加密并包裹（封装）** 在一个新的数据包内，这个新数据包的目的地是跳板机的公网IP。\n    - 这个加密后的数据包通过互联网发送到跳板机。\n3. **跳板机处理**（流量枢纽）：\n    - 跳板机上的OpenVPN服务端**解密**收到的数据包，**解出**原始的SSH请求数据包。\n    - 跳板机的**操作系统内核**根据其自身的路由表，发现这个目标是 `192.168.1.100` 的数据包需要从其内部网卡（如 `eth0`）发出。\n    - **防火墙和访问控制**：在转发前，跳板机上的防火墙规则（如 `iptables`）会进行检查，判断源IP（`10.8.0.100`）是否有权限访问目标IP（`192.168.1.100`）的22端口。通过后，才将数据包转发给目标Web服务器。\n4. **响应返回**：\n    - Web服务器处理SSH请求后，将响应包发回给跳板机（因为请求的来源IP是跳板机）。\n    - 跳板机收到响应后，再将其加密，通过隧道发回给远端的用户客户端。\n    - 客户端解密后，得到原始的SSH响应，完成一次完整的交互。\n\n#### 🛡️ 核心价值与优势\n这种架构的优势在于提供了**双重安全性和极佳的可管理性**：\n\n1. **强身份认证**：通过证书方式，同时验证了服务器和客户端的身份，避免了密码泄露和中间人攻击。\n2. **通信加密**：所有数据在公网上传输时都是加密的，保证机密性。\n3. **访问隔离**：跳板机成为唯一的入口，外部无法直接访问任何其他内网机器，攻击面最小化。\n4. **集中审计与管控**：所有对内网的访问都必须经过跳板机，便于**记录完整的操作日志**、**监控会话**和**统一设置访问权限策略**。管理员只需要在跳板机上修改规则，就可以控制所有用户的权限。\n\n### 结论：\n+ **OpenVPN客户端**是您用来**连接**的**软件**。\n+ **跳板机**是您**连接上去**的那台**服务器**。\n+ OpenVPN是**实现安全连接的方式之一**，而跳板机是**一种网络访问策略和架构**。\n\n您可以**不使用OpenVPN**而用其他方式（如SSH）登录跳板机；也可以**使用OpenVPN**连接到一台**不是跳板机**的服务器（例如只是为了加密咖啡店的公共Wi-Fi流量）。\n\n但当它们结合时，就构成了一个非常经典和强大的安全远程访问方案。\n\n## 🧠 什么是堡垒机？\n如果说「跳板机」是一个基础概念，那么「堡垒机」就是它的**完全体、企业级、工业化**的形态。\n\n**堡垒机**（Bastion Host）是一种位于内部网络和外部网络之间的**高性能、高安全性的专用服务器**，其核心设计理念是 **“网络要塞”** 。所有内部设备的远程访问（如 SSH, RDP, SFTP）都必须通过它进行，它作为唯一的入口点，集中进行**身份认证、授权、审计和监控**。\n\n您可以把它想象成一个**极其严格的银行金库门卫**：\n\n1. **唯一入口**：所有人都必须从这个门进出。\n2. **严格安检**：需要多重身份验证（工牌、指纹、密码）。\n3. **权限分明**：你只能进入你有权限进入的区域（金库、柜台、办公室）。\n4. **全程监控**：你进去后的一举一动都被全程录像，说了什么话（执行的命令）、拿了什么东西（传输的文件）都有记录。\n\n---\n\n### 🆚 堡垒机 vs. 简单跳板机：有何不同？\n很多人会混用这两个词，但它们有本质上的区别：\n\n| **特性** | **简单跳板机 (Jump Server)** | **堡垒机 (Bastion Host)** |\n| --- | --- | --- |\n| **核心功能** | **网络转发**、基础连接 | **4A管理**：认证、授权、账号、审计 |\n| **安全性** | 相对较低，依赖系统自身安全 | **极高**，有专门的安全加固和防护 |\n| **用户体验** | 命令行，原始 | **Web图形化界面**，易于操作 |\n| **权限控制** | 粗粒度（能/不能登录某台机器） | **细粒度**（能登录，且只能执行某些命令） |\n| **审计能力** | 基础日志（谁什么时候登录了） | **强大审计****：****   ****-**** ****会话录像**（全程录屏）   - **命令记录**（精确到每一条命令）   - **文件传输记录** |\n| **账号管理** | 分散在各台服务器上 | **统一账号管理**，单点登录（SSO） |\n| **本质** | **一台功能单一的服务器** | **一套完整的安全运维管控系统** |\n\n\n**简单说：跳板机主要解决“**怎么进去**”的问题，而堡垒机在此基础上，更解决了“**谁能进**”、“**能干什么**”和“**干了什么**”的问题。**\n\n---\n\n### 🛡️ 堡垒机的核心功能（4A管理）\n#### 1. 认证 (Authentication)：“你是谁？”\n+ **多种认证方式**：支持密码、SSH密钥、动态令牌（如Google Authenticator）、LDAP/AD域集成、生物识别等。\n+ **多因子认证 (MFA)**：强制要求使用两种及以上方式验证身份，极大提升安全性。\n\n#### 2. 授权 (Authorization)：“你能干什么？”\n+ **精细化的权限控制**：\n    - **主机权限**：允许用户访问哪些服务器（如：只能访问Web服务器，不能访问数据库服务器）。\n    - **操作权限**：允许用户执行哪些命令（如：可以执行 `systemctl restart nginx`，但不能执行 `rm -rf /`）。\n    - **时间权限**：允许用户在什么时间段内访问（如：只能在工作时间访问）。\n+ **临时权限申请与审批**：如果需要临时获得更高权限，可以通过工单系统申请，由管理员审批后自动授权，过期自动回收。\n\n#### 3. 账号 (Account)：“你的身份是什么？”\n+ **统一账号管理**：在堡垒机上创建账号，即可映射到后端的多台服务器，无需在每个服务器上单独创建账号。实现了“一个堡垒机账号，访问所有授权资产”。\n+ **托管服务器账号**：服务器账号和密码可以由堡垒机托管，用户无需知道目标服务器的真实密码。\n\n#### 4. 审计 (Audit)：“你干了什么？”（这是堡垒机的灵魂）\n+ ****会话录像 (Session Recording)**：** 像录屏一样，完整记录用户在目标服务器上的**所有操作过程**，包括敲打的命令、返回的结果。无法抵赖。\n+ **命令记录**：详细记录执行过的每一条命令及其时间、来源IP。\n+ **文件传输审计**：记录所有通过SFTP/SCP/RDP上传和下载的文件日志。\n+ **行为分析**：对异常操作、危险命令（如 `rm`、`chmod`）进行实时告警。\n\n---\n\n### 🏗️ 堡垒机的工作流程\n下图以一个运维人员需要通过堡垒机修复网站为例，展示了其核心工作流程与4A功能：\n\n:::tips\n![](https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756749301182-aa40bc89-4556-4198-8134-31e398991d2f.svg)\n\n:::\n\n---\n\n### 🚀 常见的堡垒机方案\n1. **开源方案**：\n    - **Jumpserver**：国内最流行的开源堡垒机，功能全面，对中文支持好，社区活跃。\n    - **Teleport**：现代、轻量级，对云原生和Kubernetes环境支持良好。\n    - **Apache Guacamole**：无客户端堡垒机，通过浏览器即可实现RDP、SSH、VNC等连接。\n2. **商业方案**：\n    - **齐治堡垒机**：国内老牌商业产品，市场份额大。\n    - ** Cisco Secure Access (前Duo)**、**CyberArk**：国际知名的商业解决方案，功能强大，价格昂贵。\n\n---\n\n### ✅ 总结：为什么需要堡垒机？\n1. **安全第一**：极大缩小了网络攻击面，保护了内部资产。\n2. **合规要求**：满足等保2.0、ISO27001、GDPR等法规对运维审计的强制性要求。\n3. **权限清晰**：实现最小权限原则，避免权限滥用。\n4. **责任界定**：出现问题时，可以通过录像和日志快速定位责任人、还原事故现场。\n5. **运维效率**：统一入口，简化了账号管理和访问流程。\n\n简而言之，堡垒机是企业IT基础设施中**不可或缺的安全与审计基石**，尤其对于金融、政府、互联网等对安全性和合规性要求极高的行业来说，是标配产品。\n\n# OpenVpn+跳板机/堡垒机实现前端部署\n这是一个非常经典的DevOps场景：OpenVpn+跳板机/堡垒机与前端工程部署结合起来，可以构建一个既安全又高效的部署流程。\n\n这种架构的核心思想是：通过 OpenVPN 建立安全通道，通过跳板机/堡垒机作为统一、受控的入口，来执行部署操作。\n\n## 🧩 核心架构与角色分工\n在这种架构下，各个组件的职责非常清晰：\n\n1. **OpenVPN Server**：**负责建“路”**。建立一条从开发者本地到部署环境的加密隧道，确保传输安全。\n2. **跳板机/堡垒机 (Bastion Host)**：**负责管“门”和看“人”**。它是唯一的部署操作入口，负责身份验证、权限控制和操作审计。\n3. **部署目标服务器**：**负责住“应用”**。这是最终运行前端项目（Nginx, Node.js 等）的服务器。\n4. **CI/CD 工具 (可选但推荐)**：**负责自动“开车”**。例如 Jenkins、GitLab Runner 等，它们可以自动从仓库拉取代码、构建，并通过跳板机执行部署脚本。\n\n整个从前端代码到部署上线的安全部署流程，如图所述：\n\n:::tips\n![](https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756747253378-aa010295-0b0b-4500-a839-7162fc66eaa3.svg)\n\n:::\n\n\n\n## 🛠️ 两种常见的部署模式\n### 模式一：手动部署（适合小团队或初期）\n**流程：** 开发者本地构建，然后通过跳板机手动上传文件。\n\n**本地构建**：\n\n```bash\nnpm run build\n```\n\n这会在项目根目录生成 `dist` 或 `build` 文件夹，里面是静态文件（HTML, CSS, JS）。\n\n1. **连接VPN**：确保 OpenVPN 客户端已连接，获得访问内网的权限。\n2. **通过跳板机上传文件**：\n\n```bash\n# 使用 scp 命令，通过跳板机转发到目标服务器\n# 注意：跳板机需要配置SSH代理转发或用户有直接权限\nscp -r -o 'ProxyJump user@jumpbox-ip' ./dist/* user@target-server-ip:/path/to/nginx/html/\n\n# 或者使用更现代的 rsync\nrsync -avz -e \"ssh -J user@jumpbox-ip\" ./dist/ user@target-server-ip:/path/to/nginx/html/\n```\n\n3. **通过跳板机执行远程命令**（如果需要）：\n\n```bash\n# 登录跳板机，再从跳板机SSH到目标服务器\nssh user@jumpbox-ip\n# 然后，在跳板机上执行\nssh user@target-server-ip \"sudo nginx -s reload\"\n```\n\n### 模式二：自动化部署（推荐，适合成熟团队）\n**流程：** CI/CD 工具（如 Jenkins、GitLab CI）在检测到 Git 标签或特定分支更新后，自动完成所有步骤。\n\n这是一个在 GitLab 中实现的自动化部署流程示例：\n\n```yaml\n# .gitlab-ci.yml\n\nstages:\n  - build\n  - deploy\n\nbuild_production:\n  stage: build\n  image: node:16\n  rules:\n    - if: $CI_COMMIT_TAG # 通常在打标签时触发生产环境部署\n  script:\n    - npm install\n    - npm run build\n  artifacts:\n    paths:\n      - dist/ # 将构建产物传递给下一个阶段\n\ndeploy_to_production:\n  stage: deploy\n  image: alpine\n  rules:\n    - if: $CI_COMMIT_TAG\n  script:\n    - apk add --no-cache openssh-client rsync\n    # 使用 SSH 通过跳板机部署 (-o ProxyJump)\n    - rsync -avz --delete -e \"ssh -o StrictHostKeyChecking=no -J $JUMPBOX_USER@$JUMPBOX_IP\" dist/ $TARGET_SERVER_USER@$TARGET_SERVER_IP:/app/frontend/\n    # 通过跳板机执行远程命令，重启服务\n    - ssh -J $JUMPBOX_USER@$JUMPBOX_IP $TARGET_SERVER_USER@$TARGET_SERVER_IP \"sudo systemctl reload nginx\"\n```\n\n**关键点：**\n\n+ `$JUMPBOX_IP`, `$TARGET_SERVER_IP` 等变量在 GitLab 的 **CI/CD 设置**中配置，避免写在代码里。\n+ `-J` 参数是 SSH 的 **代理跳跃**，让 SSH 连接自动通过跳板机。\n+ 堡垒机上需要存放 CI/CD 工具的 **SSH 私钥**，并且该密钥对目标服务器有访问权限。\n\n---\n\n## ⚙️ 部署前的重要准备工作\n1. **网络与权限配置**：\n    - 确保 OpenVPN 服务器配置的路由规则，能让客户端访问到跳板机和目标服务器。\n    - 在跳板机上为每个开发者或CI/CD服务创建账号，并配置严格的 SSH 密钥认证。\n    - 配置跳板机的权限控制，确保用户只能访问特定的目标服务器。\n2. **堡垒机审计**：\n    - 开启堡垒机的会话录制功能，记录所有通过它执行的部署命令和文件传输操作。一旦出问题，可以快速回放定位。\n3. **目标服务器配置**：\n    - **Nginx 配置示例**：\n\n```nginx\nserver {\n  listen 80;\n  server_name your-app.com;\n  root /app/frontend; # 前端文件部署的目录\n  index index.html;\n\n  # 处理 SPA 路由（如 Vue Router 的 history 模式）\n  location / {\n    try_files $uri $uri/ /index.html;\n  }\n\n  # 启用 gzip 压缩\n  gzip on;\n  gzip_types text/css application/javascript;\n}\n```\n\n---\n\n## ✅ 这种架构的优势\n1. **极致安全**：\n    - 内部服务器**完全不用暴露到公网**，攻击者无法直接扫描到。\n    - 所有部署操作都经过**加密隧道**和**严格审计**。\n2. **权限清晰**：\n    - 开发者可能根本不知道目标服务器的密码，而是通过堡垒机的授权来访问，实现了权限最小化原则。\n3. **流程标准化**：\n    - 无论是谁部署，都必须走同一个通道，执行相同的流程，减少了人为出错的可能。\n4. **可追溯性**：\n    - 结合堡垒机的录像功能，可以清晰看到**谁**、在**什么时间**、**部署了什么**、**执行了什么命令**，便于故障排查和审计。\n\n## ⚠️ 注意事项\n+ **复杂度**：初始设置比直接部署到公网服务器要复杂，但长期来看收益巨大。\n+ **性能**：如果 CI/CD 服务器在海外，而跳板机和目标服务器在国内，传输大量文件可能会慢，可以考虑在目标服务器上直接构建。\n+ **成本**：需要维护额外的跳板机/堡垒机组件。\n\n**总结：** **OpenVPN + 跳板机/堡垒机的部署模式，是企业级前端工程部署的最佳实践之一。** 它通过牺牲一点点部署的便利性，换来了极高的安全性和规范性，非常适合对安全有要求的中大型项目。\n\n# SaaS使用的部署方式到底叫什么呢？\n描述：没有使用jenkins，开发者通过堡垒机连入目标网络中通过git拉取代码并执行打包命令后生成dist或build文件夹，执行shell脚本将打包后的静态资源放到对应的目标服务器的路径下。\n\n**手动或半自动的基于堡垒机的 Git 拉取部署。**\n\n更具体地说，它属于 **\"Git-Based Deployment\"** 的一种演变形式，核心特点是**通过安全堡垒机作为跳板，直接在目标环境或邻近网络中执行构建和部署**。\n\n## 🧩 这种部署模式的详细流程拆解\n:::tips\n![](https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756747641121-afeda975-ab3a-4be8-a945-8b803dd7b2bd.svg)\n\n:::\n\n它与纯CI/CD自动化部署的**核心区别**在于，流程图中**黄色框线**的部分（从 `git push` 到 `重启服务`）完全由**开发者手动触发和执行**，而非由CI/CD工具（如Jenkins、GitLab CI）自动触发。\n\n---\n\n## ⚙️ 这种模式的特点\n### 优点：\n1. **环境高度一致**：在**目标网络内**进行构建，可以有效避免“在我本地是好的”这类问题。构建环境与生产环境一致（操作系统、Node版本等）。\n2. **安全性高**：所有操作都通过受审计的堡垒机进行，目标服务器无需暴露到公网，也无需在本地和服务器之间开放额外的端口。\n3. **简单直接，无需复杂配置**：不需要搭建和维护一整套CI/CD系统（如Jenkins），对于小团队或项目初期来说，成本更低，更轻量。\n4. **依赖少**：只需要目标服务器上有Git和Node.js环境即可，不需要安装CI/CD的Agent。\n\n### 缺点：\n1. **自动化程度低**：严重依赖人工操作。开发者需要手动登录、执行一系列命令。容易因操作失误（比如忘了拉最新代码、在错误目录执行）导致部署失败。\n2. **无法实现真正的持续交付**：部署过程不是自动触发的，通常需要人工干预，无法做到代码一提交就自动测试和部署。\n3. **可追溯性较差**：虽然堡垒机会记录执行了哪些命令，但**“谁在什么时候部署了哪个版本的代码”** 这一信息没有与代码提交（Git Tag/Commit ID）强关联地记录下来。出问题时，需要回溯堡垒机日志。\n4. **效率较低**：每次部署都需要在服务器上重新执行完整的构建过程，占用服务器资源，如果服务器性能不佳，构建时间会很长。\n\n---\n\n## 🚀 如何优化这种模式？\n即使不引入Jenkins，也可以让这个流程变得更高效、更可靠：\n\n### 1. 编写自动化部署脚本\n将一系列手动命令写成一个Shell脚本，例如 `deploy.sh`，放在代码库根目录。\n\n**（这就是SaaS的做法）**\n\n```bash\n#!/bin/bash\n# deploy.sh\n\nset -e # 遇到错误就退出\n\necho \"1. Pulling latest code...\"\ngit pull origin main\n\necho \"2. Installing dependencies...\"\nnpm install\n\necho \"3. Building project...\"\nnpm run build\n\necho \"4. Backing up old version...\"\ntar -czf /app/backup/frontend-$(date +%Y%m%d-%H%M%S).tar.gz /usr/share/nginx/html/\n\necho \"5. Deploying new version...\"\nrsync -av --delete ./dist/ /usr/share/nginx/html/\n\necho \"6. Reloading Nginx...\"\nsudo systemctl reload nginx\n\necho \"Deployment completed successfully!\"\n```\n\n**使用方式：** 开发者登录后，只需要执行一条命令：\n\n```bash\nbash deploy.sh\n```\n\n### 2. 使用 Git Hooks（简单CI）\n在**代码服务器的Git仓库**上配置 `post-receive` Hook（例如使用Gitea），当收到`push`时，自动通知目标服务器执行拉取和部署脚本。这实现了简单的自动触发。\n\n### 3. 使用 SSH 直接执行远程命令\n开发者可以在本地电脑上通过一条命令完成部署，无需手动登录。\n\n```bash\nssh -J user@jumpbox-ip user@target-server-ip \"cd /path/to/project && bash deploy.sh\"\n```\n\n### 4. 引入版本标记\n在脚本中加入步骤，在部署成功后，给当前的提交打上一个Tag。\n\n```bash\ngit tag deploy-$(date +%Y%m%d-%H%M%S)\ngit push origin --tags\n```\n\n这样就能清晰地知道生产环境对应的是哪个代码版本。\n\n---\n\n## ✅ 总结\n这是一种 **“基于堡垒机的半自动 Git 拉取部署”**。\n\n+ **它不是什么？** 它不是全自动的CI/CD（如Jenkins Pipeline），也不是传统的FTP上传部署。\n+ **它是什么？** 它是一种在**安全约束条件下**、**介于手动部署和全自动部署之间**的实用型方案。\n\n**适用场景：**\n\n+ 内部系统、管理后台等对发布频率要求不高的项目。\n+ 团队规模较小，尚未引入完整CI/CD工具链的初期阶段。\n+ 对安全性要求极高，所有内部网络访问必须通过堡垒机的环境。\n\n对于很多项目来说，这是一个非常好的起点。随着项目发展，当您觉得每次手动运行脚本也很麻烦时，就是考虑引入 **GitLab CI/CD、Github Actions** 等真正自动化工具的时候了。\n\n# <font style=\"color:#FFFFFF;background-color:#ED740C;\"> 待完善内容 </font>\n- [ ] CI/CD工具：jekins\n- [ ] Docker\n\n","source":"_posts/前端部署详解.md","raw":"---\ntitle: 前端部署详解\ndate: 2025-03-26\ntags: [部署, 前端, CI/CD]\ncategories: 前端\n---\n\n# CI/CD\n## 🧠 核心概念：CI/CD是什么？\nCI/CD 是现代软件工程中的一套最佳实践和方法论，旨在自动化软件的集成、测试和部署流程。它由两个部分组成：\n\nCI - 持续集成 (Continuous Integration)\n\nCD - 持续交付/持续部署 (Continuous Delivery / Continuous Deployment)\n\n可以把 CI/CD 想象成一个全自动的软件装配流水线。开发者提交代码（如同送上原料），流水线会自动进行一系列质量检测、打包和发布，最终将合格的产品交付给用户。\n\n## 🔧 详解两个部分\n### 1. CI - 持续集成\n**核心思想：** 开发者频繁地将代码更改合并到共享的主干分支（如每天多次）。每次合并都会自动触发一系列构建和测试，以便快速发现和修复错误。\n\n:::tips\n![](https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756740541342-f73ad130-61e5-4ba6-9386-4bd47fda11ff.svg)\n\n:::\n\n**好处：**\n\n+ ✅ **快速发现错误**：问题在引入后几分钟内就能被发现。\n+ ✅ **减少集成冲突**：频繁合并小批量代码，避免在发布前一次性合并大量代码带来的巨大冲突。\n+ ✅ 提高代码质量**：自动化测试保障了代码标准。\n\n### 2. CD - 持续交付 / 持续部署\n**CD 有两种细微差别的含义：**\n\n#### a) 持续交付 (Continuous Delivery)\n**核心思想：** CI流程结束后，代码总是处于**可随时、一键手动部署**到生产环境的状态。\n\n**流程：** `代码 -> CI -> 生成制品 -> 等待手动点击部署`\n\n#### b) 持续部署 (Continuous Deployment)\n**核心思想：** 这是持续交付的更高阶段。只要代码通过所有测试流程，就**自动地、无需人工干预地**部署到生产环境。\n\n**流程：** `代码 -> CI -> 生成制品 -> 自动部署到生产环境`\n\n可以这样理解：\n\n+ **持续交付** = \"软件已经打包好放在门口了，你随时可以签收（手动部署）。\"\n+ **持续部署** = \"软件通过质检后，快递机器人自动送货上门（自动部署）。\"\n\n## 🛠️ CI/CD 工具链\n整个流程依赖于一系列自动化工具，常见的工具有：\n\n| **阶段** | **流行工具** |\n| --- | --- |\n| **源代码管理****** | Git (GitLab, GitHub, Gitee) |\n| **CI/CD 流水线引擎** | **Jenkins**, GitLab CI/CD, GitHub Actions, Drone |\n| **构建工具** | Maven, Gradle (Java), npm, Webpack (JS), Make |\n| **测试工具** | JUnit, Selenium, Jest, Cypress |\n| **部署工具** | Ansible, Kubernetes, Docker, Terraform |\n| **监控工具** | Prometheus, Grafana, ELK Stack |\n\n\n## 💡 为什么需要 CI/CD？它的价值是什么？\n1. **加速开发流程**\n    - 自动化代替手动操作，释放开发者的生产力。\n    - 快速反馈，开发者能立即知道这次提交是否破坏了系统。\n2. **提高软件质量**\n    - 通过自动化测试在早期发现缺陷，修复成本远低于生产环境才发现。\n    - 代码规范、安全漏洞扫描等流程被标准化。\n3. **降低发布风险**\n    - 小批量、频繁的发布使得每次变更的内容很少。如果出现问题，可以快速定位和回滚。\n    - 传统的\"半年发布一次，一次改动500个功能\"的方式风险极高。\n4. **增强项目可见性**\n    - 每个人都能清晰地看到代码从提交到部署的整个状态，构建是否成功、测试是否通过。\n\n## ✅ 总结\n**CI/CD** 是一套通过**自动化**来**优化软件开发生命周期**的实践，其核心目标是：\n\n+ **更快的发布速度**\n+ **更高质量的软件**\n+ **更低的发布风险**\n\n它不是某个特定的工具，而是一种文化和流程的变革，是现代DevOps理念的核心支柱，已经成为中大型软件开发团队的标配。\n\n# OpenVpn与跳板机/堡垒机\n## 🔧 什么是 OpenVPN 客户端？\n**OpenVPN 客户端**是一个安装在您本地设备（如电脑、手机）上的**软件程序**。\n\n它的核心功能是：**根据配置文件（.ovpn 文件），与远端的 OpenVPN 服务器建立一条加密的、安全的隧道连接。**\n\n+ **它是什么？** 一个软件（例如：OpenVPN Connect、Tunnelblick等）。\n+ **它在哪里运行？** 在你的个人设备上（Windows PC, Mac, Linux, 手机）。\n+ **它的作用？** 创建加密通道，让你的所有或指定网络流量都通过这个通道流向VPN服务器。\n\n**就像一个专门的电话（客户端），用于拨打一个安全的号码（服务器）。**\n\n---\n\n## 🖥️ 什么是跳板机？\n**跳板机**（Jump Server / Bastion Host）是一台位于某个特定网络区域（如公司内网）的**服务器**。\n\n它的核心功能是：**作为一个唯一的、受严格控制的访问入口，所有外部人员必须先连接到这台服务器，才能进一步访问目标网络内部的其他设备。**\n\n+ **它是什么？** 一台物理或虚拟的服务器/计算机。\n+ **它在哪里运行？** 在目标网络的入口处（例如公司机房或公有云上）。\n+ **它的作用？** 提供访问桥梁和安全审计。所有操作都通过它进行，便于监控和记录日志。\n\n**就像是大楼的门卫室（跳板机），所有访客（用户）必须先在门卫室登记、核实身份，由门卫带领才能进入大楼内部（内网）。**\n\n---\n\n## 🔄 它们如何协同工作？（两者的关系）\nOpenVPN 客户端和跳板机通常**配合使用**，但它们扮演完全不同的角色。\n\n### 工作流程分解：\n#### 阶段一：建立安全隧道（认证与连接）\n1. **配置加载**：用户在自己的电脑上启动OpenVPN客户端软件，并加载管理员提供的 `.ovpn`配置文件。这个文件包含了连接所需的所有信息：\n    - **跳板机的公网IP/域名**\n    - 加密算法和协议类型\n    - **CA根证书**（用于验证服务器身份）\n    - **客户端证书和私钥**（用于向服务器证明自身身份）\n    - 其他参数（如使用的端口、是否使用密码等）\n2. **发起连接**：客户端根据配置，向跳板机的公网IP和指定端口发起TCP/UDP连接请求。\n3. **TLS双向认证**（最关键的安全步骤）：\n    - **服务器认证**：跳板机上的OpenVPN服务端将自己的证书发给客户端。客户端用CA根证书验证服务器证书的有效性，**确保连接的是真正的公司跳板机，而不是钓鱼服务器**。\n    - **客户端认证**：客户端将自己的证书和私钥签名发给服务器。服务器用CA根证书验证客户端证书，**确保连接的是授权员工，而不是外人**。\n    - 这个过程通常还辅以用户名/密码认证。\n4. **隧道建立**：认证通过后，双方利用协商好的密钥，建立一条**加密隧道**。跳板机为客户端分配一个内网IP地址（如 `10.8.0.100`）。此时，用户的电脑在逻辑上已经“接入”了公司内网。\n\n#### 阶段二：访问内部资源（路由与转发）\n1. **发起访问请求**：用户需要访问内网的一台Web服务器（`192.168.1.100`）。他在本地使用SSH命令：`ssh developer@192.168.1.100`。\n2. **流量封装与路由**：\n    - 客户端的操作系统会根据路由表规则，将所有发往 `192.168.1.0/24` 网段的流量，都指向OpenVPN创建的虚拟网卡。\n    - OpenVPN客户端将原始的SSH数据包（TCP协议）**整个加密并包裹（封装）** 在一个新的数据包内，这个新数据包的目的地是跳板机的公网IP。\n    - 这个加密后的数据包通过互联网发送到跳板机。\n3. **跳板机处理**（流量枢纽）：\n    - 跳板机上的OpenVPN服务端**解密**收到的数据包，**解出**原始的SSH请求数据包。\n    - 跳板机的**操作系统内核**根据其自身的路由表，发现这个目标是 `192.168.1.100` 的数据包需要从其内部网卡（如 `eth0`）发出。\n    - **防火墙和访问控制**：在转发前，跳板机上的防火墙规则（如 `iptables`）会进行检查，判断源IP（`10.8.0.100`）是否有权限访问目标IP（`192.168.1.100`）的22端口。通过后，才将数据包转发给目标Web服务器。\n4. **响应返回**：\n    - Web服务器处理SSH请求后，将响应包发回给跳板机（因为请求的来源IP是跳板机）。\n    - 跳板机收到响应后，再将其加密，通过隧道发回给远端的用户客户端。\n    - 客户端解密后，得到原始的SSH响应，完成一次完整的交互。\n\n#### 🛡️ 核心价值与优势\n这种架构的优势在于提供了**双重安全性和极佳的可管理性**：\n\n1. **强身份认证**：通过证书方式，同时验证了服务器和客户端的身份，避免了密码泄露和中间人攻击。\n2. **通信加密**：所有数据在公网上传输时都是加密的，保证机密性。\n3. **访问隔离**：跳板机成为唯一的入口，外部无法直接访问任何其他内网机器，攻击面最小化。\n4. **集中审计与管控**：所有对内网的访问都必须经过跳板机，便于**记录完整的操作日志**、**监控会话**和**统一设置访问权限策略**。管理员只需要在跳板机上修改规则，就可以控制所有用户的权限。\n\n### 结论：\n+ **OpenVPN客户端**是您用来**连接**的**软件**。\n+ **跳板机**是您**连接上去**的那台**服务器**。\n+ OpenVPN是**实现安全连接的方式之一**，而跳板机是**一种网络访问策略和架构**。\n\n您可以**不使用OpenVPN**而用其他方式（如SSH）登录跳板机；也可以**使用OpenVPN**连接到一台**不是跳板机**的服务器（例如只是为了加密咖啡店的公共Wi-Fi流量）。\n\n但当它们结合时，就构成了一个非常经典和强大的安全远程访问方案。\n\n## 🧠 什么是堡垒机？\n如果说「跳板机」是一个基础概念，那么「堡垒机」就是它的**完全体、企业级、工业化**的形态。\n\n**堡垒机**（Bastion Host）是一种位于内部网络和外部网络之间的**高性能、高安全性的专用服务器**，其核心设计理念是 **“网络要塞”** 。所有内部设备的远程访问（如 SSH, RDP, SFTP）都必须通过它进行，它作为唯一的入口点，集中进行**身份认证、授权、审计和监控**。\n\n您可以把它想象成一个**极其严格的银行金库门卫**：\n\n1. **唯一入口**：所有人都必须从这个门进出。\n2. **严格安检**：需要多重身份验证（工牌、指纹、密码）。\n3. **权限分明**：你只能进入你有权限进入的区域（金库、柜台、办公室）。\n4. **全程监控**：你进去后的一举一动都被全程录像，说了什么话（执行的命令）、拿了什么东西（传输的文件）都有记录。\n\n---\n\n### 🆚 堡垒机 vs. 简单跳板机：有何不同？\n很多人会混用这两个词，但它们有本质上的区别：\n\n| **特性** | **简单跳板机 (Jump Server)** | **堡垒机 (Bastion Host)** |\n| --- | --- | --- |\n| **核心功能** | **网络转发**、基础连接 | **4A管理**：认证、授权、账号、审计 |\n| **安全性** | 相对较低，依赖系统自身安全 | **极高**，有专门的安全加固和防护 |\n| **用户体验** | 命令行，原始 | **Web图形化界面**，易于操作 |\n| **权限控制** | 粗粒度（能/不能登录某台机器） | **细粒度**（能登录，且只能执行某些命令） |\n| **审计能力** | 基础日志（谁什么时候登录了） | **强大审计****：****   ****-**** ****会话录像**（全程录屏）   - **命令记录**（精确到每一条命令）   - **文件传输记录** |\n| **账号管理** | 分散在各台服务器上 | **统一账号管理**，单点登录（SSO） |\n| **本质** | **一台功能单一的服务器** | **一套完整的安全运维管控系统** |\n\n\n**简单说：跳板机主要解决“**怎么进去**”的问题，而堡垒机在此基础上，更解决了“**谁能进**”、“**能干什么**”和“**干了什么**”的问题。**\n\n---\n\n### 🛡️ 堡垒机的核心功能（4A管理）\n#### 1. 认证 (Authentication)：“你是谁？”\n+ **多种认证方式**：支持密码、SSH密钥、动态令牌（如Google Authenticator）、LDAP/AD域集成、生物识别等。\n+ **多因子认证 (MFA)**：强制要求使用两种及以上方式验证身份，极大提升安全性。\n\n#### 2. 授权 (Authorization)：“你能干什么？”\n+ **精细化的权限控制**：\n    - **主机权限**：允许用户访问哪些服务器（如：只能访问Web服务器，不能访问数据库服务器）。\n    - **操作权限**：允许用户执行哪些命令（如：可以执行 `systemctl restart nginx`，但不能执行 `rm -rf /`）。\n    - **时间权限**：允许用户在什么时间段内访问（如：只能在工作时间访问）。\n+ **临时权限申请与审批**：如果需要临时获得更高权限，可以通过工单系统申请，由管理员审批后自动授权，过期自动回收。\n\n#### 3. 账号 (Account)：“你的身份是什么？”\n+ **统一账号管理**：在堡垒机上创建账号，即可映射到后端的多台服务器，无需在每个服务器上单独创建账号。实现了“一个堡垒机账号，访问所有授权资产”。\n+ **托管服务器账号**：服务器账号和密码可以由堡垒机托管，用户无需知道目标服务器的真实密码。\n\n#### 4. 审计 (Audit)：“你干了什么？”（这是堡垒机的灵魂）\n+ ****会话录像 (Session Recording)**：** 像录屏一样，完整记录用户在目标服务器上的**所有操作过程**，包括敲打的命令、返回的结果。无法抵赖。\n+ **命令记录**：详细记录执行过的每一条命令及其时间、来源IP。\n+ **文件传输审计**：记录所有通过SFTP/SCP/RDP上传和下载的文件日志。\n+ **行为分析**：对异常操作、危险命令（如 `rm`、`chmod`）进行实时告警。\n\n---\n\n### 🏗️ 堡垒机的工作流程\n下图以一个运维人员需要通过堡垒机修复网站为例，展示了其核心工作流程与4A功能：\n\n:::tips\n![](https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756749301182-aa40bc89-4556-4198-8134-31e398991d2f.svg)\n\n:::\n\n---\n\n### 🚀 常见的堡垒机方案\n1. **开源方案**：\n    - **Jumpserver**：国内最流行的开源堡垒机，功能全面，对中文支持好，社区活跃。\n    - **Teleport**：现代、轻量级，对云原生和Kubernetes环境支持良好。\n    - **Apache Guacamole**：无客户端堡垒机，通过浏览器即可实现RDP、SSH、VNC等连接。\n2. **商业方案**：\n    - **齐治堡垒机**：国内老牌商业产品，市场份额大。\n    - ** Cisco Secure Access (前Duo)**、**CyberArk**：国际知名的商业解决方案，功能强大，价格昂贵。\n\n---\n\n### ✅ 总结：为什么需要堡垒机？\n1. **安全第一**：极大缩小了网络攻击面，保护了内部资产。\n2. **合规要求**：满足等保2.0、ISO27001、GDPR等法规对运维审计的强制性要求。\n3. **权限清晰**：实现最小权限原则，避免权限滥用。\n4. **责任界定**：出现问题时，可以通过录像和日志快速定位责任人、还原事故现场。\n5. **运维效率**：统一入口，简化了账号管理和访问流程。\n\n简而言之，堡垒机是企业IT基础设施中**不可或缺的安全与审计基石**，尤其对于金融、政府、互联网等对安全性和合规性要求极高的行业来说，是标配产品。\n\n# OpenVpn+跳板机/堡垒机实现前端部署\n这是一个非常经典的DevOps场景：OpenVpn+跳板机/堡垒机与前端工程部署结合起来，可以构建一个既安全又高效的部署流程。\n\n这种架构的核心思想是：通过 OpenVPN 建立安全通道，通过跳板机/堡垒机作为统一、受控的入口，来执行部署操作。\n\n## 🧩 核心架构与角色分工\n在这种架构下，各个组件的职责非常清晰：\n\n1. **OpenVPN Server**：**负责建“路”**。建立一条从开发者本地到部署环境的加密隧道，确保传输安全。\n2. **跳板机/堡垒机 (Bastion Host)**：**负责管“门”和看“人”**。它是唯一的部署操作入口，负责身份验证、权限控制和操作审计。\n3. **部署目标服务器**：**负责住“应用”**。这是最终运行前端项目（Nginx, Node.js 等）的服务器。\n4. **CI/CD 工具 (可选但推荐)**：**负责自动“开车”**。例如 Jenkins、GitLab Runner 等，它们可以自动从仓库拉取代码、构建，并通过跳板机执行部署脚本。\n\n整个从前端代码到部署上线的安全部署流程，如图所述：\n\n:::tips\n![](https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756747253378-aa010295-0b0b-4500-a839-7162fc66eaa3.svg)\n\n:::\n\n\n\n## 🛠️ 两种常见的部署模式\n### 模式一：手动部署（适合小团队或初期）\n**流程：** 开发者本地构建，然后通过跳板机手动上传文件。\n\n**本地构建**：\n\n```bash\nnpm run build\n```\n\n这会在项目根目录生成 `dist` 或 `build` 文件夹，里面是静态文件（HTML, CSS, JS）。\n\n1. **连接VPN**：确保 OpenVPN 客户端已连接，获得访问内网的权限。\n2. **通过跳板机上传文件**：\n\n```bash\n# 使用 scp 命令，通过跳板机转发到目标服务器\n# 注意：跳板机需要配置SSH代理转发或用户有直接权限\nscp -r -o 'ProxyJump user@jumpbox-ip' ./dist/* user@target-server-ip:/path/to/nginx/html/\n\n# 或者使用更现代的 rsync\nrsync -avz -e \"ssh -J user@jumpbox-ip\" ./dist/ user@target-server-ip:/path/to/nginx/html/\n```\n\n3. **通过跳板机执行远程命令**（如果需要）：\n\n```bash\n# 登录跳板机，再从跳板机SSH到目标服务器\nssh user@jumpbox-ip\n# 然后，在跳板机上执行\nssh user@target-server-ip \"sudo nginx -s reload\"\n```\n\n### 模式二：自动化部署（推荐，适合成熟团队）\n**流程：** CI/CD 工具（如 Jenkins、GitLab CI）在检测到 Git 标签或特定分支更新后，自动完成所有步骤。\n\n这是一个在 GitLab 中实现的自动化部署流程示例：\n\n```yaml\n# .gitlab-ci.yml\n\nstages:\n  - build\n  - deploy\n\nbuild_production:\n  stage: build\n  image: node:16\n  rules:\n    - if: $CI_COMMIT_TAG # 通常在打标签时触发生产环境部署\n  script:\n    - npm install\n    - npm run build\n  artifacts:\n    paths:\n      - dist/ # 将构建产物传递给下一个阶段\n\ndeploy_to_production:\n  stage: deploy\n  image: alpine\n  rules:\n    - if: $CI_COMMIT_TAG\n  script:\n    - apk add --no-cache openssh-client rsync\n    # 使用 SSH 通过跳板机部署 (-o ProxyJump)\n    - rsync -avz --delete -e \"ssh -o StrictHostKeyChecking=no -J $JUMPBOX_USER@$JUMPBOX_IP\" dist/ $TARGET_SERVER_USER@$TARGET_SERVER_IP:/app/frontend/\n    # 通过跳板机执行远程命令，重启服务\n    - ssh -J $JUMPBOX_USER@$JUMPBOX_IP $TARGET_SERVER_USER@$TARGET_SERVER_IP \"sudo systemctl reload nginx\"\n```\n\n**关键点：**\n\n+ `$JUMPBOX_IP`, `$TARGET_SERVER_IP` 等变量在 GitLab 的 **CI/CD 设置**中配置，避免写在代码里。\n+ `-J` 参数是 SSH 的 **代理跳跃**，让 SSH 连接自动通过跳板机。\n+ 堡垒机上需要存放 CI/CD 工具的 **SSH 私钥**，并且该密钥对目标服务器有访问权限。\n\n---\n\n## ⚙️ 部署前的重要准备工作\n1. **网络与权限配置**：\n    - 确保 OpenVPN 服务器配置的路由规则，能让客户端访问到跳板机和目标服务器。\n    - 在跳板机上为每个开发者或CI/CD服务创建账号，并配置严格的 SSH 密钥认证。\n    - 配置跳板机的权限控制，确保用户只能访问特定的目标服务器。\n2. **堡垒机审计**：\n    - 开启堡垒机的会话录制功能，记录所有通过它执行的部署命令和文件传输操作。一旦出问题，可以快速回放定位。\n3. **目标服务器配置**：\n    - **Nginx 配置示例**：\n\n```nginx\nserver {\n  listen 80;\n  server_name your-app.com;\n  root /app/frontend; # 前端文件部署的目录\n  index index.html;\n\n  # 处理 SPA 路由（如 Vue Router 的 history 模式）\n  location / {\n    try_files $uri $uri/ /index.html;\n  }\n\n  # 启用 gzip 压缩\n  gzip on;\n  gzip_types text/css application/javascript;\n}\n```\n\n---\n\n## ✅ 这种架构的优势\n1. **极致安全**：\n    - 内部服务器**完全不用暴露到公网**，攻击者无法直接扫描到。\n    - 所有部署操作都经过**加密隧道**和**严格审计**。\n2. **权限清晰**：\n    - 开发者可能根本不知道目标服务器的密码，而是通过堡垒机的授权来访问，实现了权限最小化原则。\n3. **流程标准化**：\n    - 无论是谁部署，都必须走同一个通道，执行相同的流程，减少了人为出错的可能。\n4. **可追溯性**：\n    - 结合堡垒机的录像功能，可以清晰看到**谁**、在**什么时间**、**部署了什么**、**执行了什么命令**，便于故障排查和审计。\n\n## ⚠️ 注意事项\n+ **复杂度**：初始设置比直接部署到公网服务器要复杂，但长期来看收益巨大。\n+ **性能**：如果 CI/CD 服务器在海外，而跳板机和目标服务器在国内，传输大量文件可能会慢，可以考虑在目标服务器上直接构建。\n+ **成本**：需要维护额外的跳板机/堡垒机组件。\n\n**总结：** **OpenVPN + 跳板机/堡垒机的部署模式，是企业级前端工程部署的最佳实践之一。** 它通过牺牲一点点部署的便利性，换来了极高的安全性和规范性，非常适合对安全有要求的中大型项目。\n\n# SaaS使用的部署方式到底叫什么呢？\n描述：没有使用jenkins，开发者通过堡垒机连入目标网络中通过git拉取代码并执行打包命令后生成dist或build文件夹，执行shell脚本将打包后的静态资源放到对应的目标服务器的路径下。\n\n**手动或半自动的基于堡垒机的 Git 拉取部署。**\n\n更具体地说，它属于 **\"Git-Based Deployment\"** 的一种演变形式，核心特点是**通过安全堡垒机作为跳板，直接在目标环境或邻近网络中执行构建和部署**。\n\n## 🧩 这种部署模式的详细流程拆解\n:::tips\n![](https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756747641121-afeda975-ab3a-4be8-a945-8b803dd7b2bd.svg)\n\n:::\n\n它与纯CI/CD自动化部署的**核心区别**在于，流程图中**黄色框线**的部分（从 `git push` 到 `重启服务`）完全由**开发者手动触发和执行**，而非由CI/CD工具（如Jenkins、GitLab CI）自动触发。\n\n---\n\n## ⚙️ 这种模式的特点\n### 优点：\n1. **环境高度一致**：在**目标网络内**进行构建，可以有效避免“在我本地是好的”这类问题。构建环境与生产环境一致（操作系统、Node版本等）。\n2. **安全性高**：所有操作都通过受审计的堡垒机进行，目标服务器无需暴露到公网，也无需在本地和服务器之间开放额外的端口。\n3. **简单直接，无需复杂配置**：不需要搭建和维护一整套CI/CD系统（如Jenkins），对于小团队或项目初期来说，成本更低，更轻量。\n4. **依赖少**：只需要目标服务器上有Git和Node.js环境即可，不需要安装CI/CD的Agent。\n\n### 缺点：\n1. **自动化程度低**：严重依赖人工操作。开发者需要手动登录、执行一系列命令。容易因操作失误（比如忘了拉最新代码、在错误目录执行）导致部署失败。\n2. **无法实现真正的持续交付**：部署过程不是自动触发的，通常需要人工干预，无法做到代码一提交就自动测试和部署。\n3. **可追溯性较差**：虽然堡垒机会记录执行了哪些命令，但**“谁在什么时候部署了哪个版本的代码”** 这一信息没有与代码提交（Git Tag/Commit ID）强关联地记录下来。出问题时，需要回溯堡垒机日志。\n4. **效率较低**：每次部署都需要在服务器上重新执行完整的构建过程，占用服务器资源，如果服务器性能不佳，构建时间会很长。\n\n---\n\n## 🚀 如何优化这种模式？\n即使不引入Jenkins，也可以让这个流程变得更高效、更可靠：\n\n### 1. 编写自动化部署脚本\n将一系列手动命令写成一个Shell脚本，例如 `deploy.sh`，放在代码库根目录。\n\n**（这就是SaaS的做法）**\n\n```bash\n#!/bin/bash\n# deploy.sh\n\nset -e # 遇到错误就退出\n\necho \"1. Pulling latest code...\"\ngit pull origin main\n\necho \"2. Installing dependencies...\"\nnpm install\n\necho \"3. Building project...\"\nnpm run build\n\necho \"4. Backing up old version...\"\ntar -czf /app/backup/frontend-$(date +%Y%m%d-%H%M%S).tar.gz /usr/share/nginx/html/\n\necho \"5. Deploying new version...\"\nrsync -av --delete ./dist/ /usr/share/nginx/html/\n\necho \"6. Reloading Nginx...\"\nsudo systemctl reload nginx\n\necho \"Deployment completed successfully!\"\n```\n\n**使用方式：** 开发者登录后，只需要执行一条命令：\n\n```bash\nbash deploy.sh\n```\n\n### 2. 使用 Git Hooks（简单CI）\n在**代码服务器的Git仓库**上配置 `post-receive` Hook（例如使用Gitea），当收到`push`时，自动通知目标服务器执行拉取和部署脚本。这实现了简单的自动触发。\n\n### 3. 使用 SSH 直接执行远程命令\n开发者可以在本地电脑上通过一条命令完成部署，无需手动登录。\n\n```bash\nssh -J user@jumpbox-ip user@target-server-ip \"cd /path/to/project && bash deploy.sh\"\n```\n\n### 4. 引入版本标记\n在脚本中加入步骤，在部署成功后，给当前的提交打上一个Tag。\n\n```bash\ngit tag deploy-$(date +%Y%m%d-%H%M%S)\ngit push origin --tags\n```\n\n这样就能清晰地知道生产环境对应的是哪个代码版本。\n\n---\n\n## ✅ 总结\n这是一种 **“基于堡垒机的半自动 Git 拉取部署”**。\n\n+ **它不是什么？** 它不是全自动的CI/CD（如Jenkins Pipeline），也不是传统的FTP上传部署。\n+ **它是什么？** 它是一种在**安全约束条件下**、**介于手动部署和全自动部署之间**的实用型方案。\n\n**适用场景：**\n\n+ 内部系统、管理后台等对发布频率要求不高的项目。\n+ 团队规模较小，尚未引入完整CI/CD工具链的初期阶段。\n+ 对安全性要求极高，所有内部网络访问必须通过堡垒机的环境。\n\n对于很多项目来说，这是一个非常好的起点。随着项目发展，当您觉得每次手动运行脚本也很麻烦时，就是考虑引入 **GitLab CI/CD、Github Actions** 等真正自动化工具的时候了。\n\n# <font style=\"color:#FFFFFF;background-color:#ED740C;\"> 待完善内容 </font>\n- [ ] CI/CD工具：jekins\n- [ ] Docker\n\n","slug":"前端部署详解","published":1,"updated":"2025-09-14T11:25:15.083Z","_id":"cmfjktvt00000tx5w8wom0bev","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"CI-CD\"><a href=\"#CI-CD\" class=\"headerlink\" title=\"CI&#x2F;CD\"></a>CI&#x2F;CD</h1><h2 id=\"🧠-核心概念：CI-CD是什么？\"><a href=\"#🧠-核心概念：CI-CD是什么？\" class=\"headerlink\" title=\"🧠 核心概念：CI&#x2F;CD是什么？\"></a>🧠 核心概念：CI&#x2F;CD是什么？</h2><p>CI&#x2F;CD 是现代软件工程中的一套最佳实践和方法论，旨在自动化软件的集成、测试和部署流程。它由两个部分组成：</p>\n<p>CI - 持续集成 (Continuous Integration)</p>\n<p>CD - 持续交付&#x2F;持续部署 (Continuous Delivery &#x2F; Continuous Deployment)</p>\n<p>可以把 CI&#x2F;CD 想象成一个全自动的软件装配流水线。开发者提交代码（如同送上原料），流水线会自动进行一系列质量检测、打包和发布，最终将合格的产品交付给用户。</p>\n<h2 id=\"🔧-详解两个部分\"><a href=\"#🔧-详解两个部分\" class=\"headerlink\" title=\"🔧 详解两个部分\"></a>🔧 详解两个部分</h2><h3 id=\"1-CI-持续集成\"><a href=\"#1-CI-持续集成\" class=\"headerlink\" title=\"1. CI - 持续集成\"></a>1. CI - 持续集成</h3><p><strong>核心思想：</strong> 开发者频繁地将代码更改合并到共享的主干分支（如每天多次）。每次合并都会自动触发一系列构建和测试，以便快速发现和修复错误。</p>\n<p>:::tips<br><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756740541342-f73ad130-61e5-4ba6-9386-4bd47fda11ff.svg\"\n                     \n                ></p>\n<p>:::</p>\n<p><strong>好处：</strong></p>\n<ul>\n<li>✅ <strong>快速发现错误</strong>：问题在引入后几分钟内就能被发现。</li>\n<li>✅ <strong>减少集成冲突</strong>：频繁合并小批量代码，避免在发布前一次性合并大量代码带来的巨大冲突。</li>\n<li>✅ 提高代码质量**：自动化测试保障了代码标准。</li>\n</ul>\n<h3 id=\"2-CD-持续交付-持续部署\"><a href=\"#2-CD-持续交付-持续部署\" class=\"headerlink\" title=\"2. CD - 持续交付 &#x2F; 持续部署\"></a>2. CD - 持续交付 &#x2F; 持续部署</h3><p><strong>CD 有两种细微差别的含义：</strong></p>\n<h4 id=\"a-持续交付-Continuous-Delivery\"><a href=\"#a-持续交付-Continuous-Delivery\" class=\"headerlink\" title=\"a) 持续交付 (Continuous Delivery)\"></a>a) 持续交付 (Continuous Delivery)</h4><p><strong>核心思想：</strong> CI流程结束后，代码总是处于<strong>可随时、一键手动部署</strong>到生产环境的状态。</p>\n<p><strong>流程：</strong> <code>代码 -&gt; CI -&gt; 生成制品 -&gt; 等待手动点击部署</code></p>\n<h4 id=\"b-持续部署-Continuous-Deployment\"><a href=\"#b-持续部署-Continuous-Deployment\" class=\"headerlink\" title=\"b) 持续部署 (Continuous Deployment)\"></a>b) 持续部署 (Continuous Deployment)</h4><p><strong>核心思想：</strong> 这是持续交付的更高阶段。只要代码通过所有测试流程，就<strong>自动地、无需人工干预地</strong>部署到生产环境。</p>\n<p><strong>流程：</strong> <code>代码 -&gt; CI -&gt; 生成制品 -&gt; 自动部署到生产环境</code></p>\n<p>可以这样理解：</p>\n<ul>\n<li><strong>持续交付</strong> &#x3D; “软件已经打包好放在门口了，你随时可以签收（手动部署）。”</li>\n<li><strong>持续部署</strong> &#x3D; “软件通过质检后，快递机器人自动送货上门（自动部署）。”</li>\n</ul>\n<h2 id=\"🛠️-CI-CD-工具链\"><a href=\"#🛠️-CI-CD-工具链\" class=\"headerlink\" title=\"🛠️ CI&#x2F;CD 工具链\"></a>🛠️ CI&#x2F;CD 工具链</h2><p>整个流程依赖于一系列自动化工具，常见的工具有：</p>\n<table>\n<thead>\n<tr>\n<th><strong>阶段</strong></th>\n<th><strong>流行工具</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>源代码管理</strong>****</td>\n<td>Git (GitLab, GitHub, Gitee)</td>\n</tr>\n<tr>\n<td><strong>CI&#x2F;CD 流水线引擎</strong></td>\n<td><strong>Jenkins</strong>, GitLab CI&#x2F;CD, GitHub Actions, Drone</td>\n</tr>\n<tr>\n<td><strong>构建工具</strong></td>\n<td>Maven, Gradle (Java), npm, Webpack (JS), Make</td>\n</tr>\n<tr>\n<td><strong>测试工具</strong></td>\n<td>JUnit, Selenium, Jest, Cypress</td>\n</tr>\n<tr>\n<td><strong>部署工具</strong></td>\n<td>Ansible, Kubernetes, Docker, Terraform</td>\n</tr>\n<tr>\n<td><strong>监控工具</strong></td>\n<td>Prometheus, Grafana, ELK Stack</td>\n</tr>\n</tbody></table>\n<h2 id=\"💡-为什么需要-CI-CD？它的价值是什么？\"><a href=\"#💡-为什么需要-CI-CD？它的价值是什么？\" class=\"headerlink\" title=\"💡 为什么需要 CI&#x2F;CD？它的价值是什么？\"></a>💡 为什么需要 CI&#x2F;CD？它的价值是什么？</h2><ol>\n<li><strong>加速开发流程</strong><ul>\n<li>自动化代替手动操作，释放开发者的生产力。</li>\n<li>快速反馈，开发者能立即知道这次提交是否破坏了系统。</li>\n</ul>\n</li>\n<li><strong>提高软件质量</strong><ul>\n<li>通过自动化测试在早期发现缺陷，修复成本远低于生产环境才发现。</li>\n<li>代码规范、安全漏洞扫描等流程被标准化。</li>\n</ul>\n</li>\n<li><strong>降低发布风险</strong><ul>\n<li>小批量、频繁的发布使得每次变更的内容很少。如果出现问题，可以快速定位和回滚。</li>\n<li>传统的”半年发布一次，一次改动500个功能”的方式风险极高。</li>\n</ul>\n</li>\n<li><strong>增强项目可见性</strong><ul>\n<li>每个人都能清晰地看到代码从提交到部署的整个状态，构建是否成功、测试是否通过。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"✅-总结\"><a href=\"#✅-总结\" class=\"headerlink\" title=\"✅ 总结\"></a>✅ 总结</h2><p><strong>CI&#x2F;CD</strong> 是一套通过<strong>自动化</strong>来<strong>优化软件开发生命周期</strong>的实践，其核心目标是：</p>\n<ul>\n<li><strong>更快的发布速度</strong></li>\n<li><strong>更高质量的软件</strong></li>\n<li><strong>更低的发布风险</strong></li>\n</ul>\n<p>它不是某个特定的工具，而是一种文化和流程的变革，是现代DevOps理念的核心支柱，已经成为中大型软件开发团队的标配。</p>\n<h1 id=\"OpenVpn与跳板机-堡垒机\"><a href=\"#OpenVpn与跳板机-堡垒机\" class=\"headerlink\" title=\"OpenVpn与跳板机&#x2F;堡垒机\"></a>OpenVpn与跳板机&#x2F;堡垒机</h1><h2 id=\"🔧-什么是-OpenVPN-客户端？\"><a href=\"#🔧-什么是-OpenVPN-客户端？\" class=\"headerlink\" title=\"🔧 什么是 OpenVPN 客户端？\"></a>🔧 什么是 OpenVPN 客户端？</h2><p><strong>OpenVPN 客户端</strong>是一个安装在您本地设备（如电脑、手机）上的<strong>软件程序</strong>。</p>\n<p>它的核心功能是：<strong>根据配置文件（.ovpn 文件），与远端的 OpenVPN 服务器建立一条加密的、安全的隧道连接。</strong></p>\n<ul>\n<li><strong>它是什么？</strong> 一个软件（例如：OpenVPN Connect、Tunnelblick等）。</li>\n<li><strong>它在哪里运行？</strong> 在你的个人设备上（Windows PC, Mac, Linux, 手机）。</li>\n<li><strong>它的作用？</strong> 创建加密通道，让你的所有或指定网络流量都通过这个通道流向VPN服务器。</li>\n</ul>\n<p><strong>就像一个专门的电话（客户端），用于拨打一个安全的号码（服务器）。</strong></p>\n<hr>\n<h2 id=\"🖥️-什么是跳板机？\"><a href=\"#🖥️-什么是跳板机？\" class=\"headerlink\" title=\"🖥️ 什么是跳板机？\"></a>🖥️ 什么是跳板机？</h2><p><strong>跳板机</strong>（Jump Server &#x2F; Bastion Host）是一台位于某个特定网络区域（如公司内网）的<strong>服务器</strong>。</p>\n<p>它的核心功能是：<strong>作为一个唯一的、受严格控制的访问入口，所有外部人员必须先连接到这台服务器，才能进一步访问目标网络内部的其他设备。</strong></p>\n<ul>\n<li><strong>它是什么？</strong> 一台物理或虚拟的服务器&#x2F;计算机。</li>\n<li><strong>它在哪里运行？</strong> 在目标网络的入口处（例如公司机房或公有云上）。</li>\n<li><strong>它的作用？</strong> 提供访问桥梁和安全审计。所有操作都通过它进行，便于监控和记录日志。</li>\n</ul>\n<p><strong>就像是大楼的门卫室（跳板机），所有访客（用户）必须先在门卫室登记、核实身份，由门卫带领才能进入大楼内部（内网）。</strong></p>\n<hr>\n<h2 id=\"🔄-它们如何协同工作？（两者的关系）\"><a href=\"#🔄-它们如何协同工作？（两者的关系）\" class=\"headerlink\" title=\"🔄 它们如何协同工作？（两者的关系）\"></a>🔄 它们如何协同工作？（两者的关系）</h2><p>OpenVPN 客户端和跳板机通常<strong>配合使用</strong>，但它们扮演完全不同的角色。</p>\n<h3 id=\"工作流程分解：\"><a href=\"#工作流程分解：\" class=\"headerlink\" title=\"工作流程分解：\"></a>工作流程分解：</h3><h4 id=\"阶段一：建立安全隧道（认证与连接）\"><a href=\"#阶段一：建立安全隧道（认证与连接）\" class=\"headerlink\" title=\"阶段一：建立安全隧道（认证与连接）\"></a>阶段一：建立安全隧道（认证与连接）</h4><ol>\n<li><strong>配置加载</strong>：用户在自己的电脑上启动OpenVPN客户端软件，并加载管理员提供的 <code>.ovpn</code>配置文件。这个文件包含了连接所需的所有信息：<ul>\n<li><strong>跳板机的公网IP&#x2F;域名</strong></li>\n<li>加密算法和协议类型</li>\n<li><strong>CA根证书</strong>（用于验证服务器身份）</li>\n<li><strong>客户端证书和私钥</strong>（用于向服务器证明自身身份）</li>\n<li>其他参数（如使用的端口、是否使用密码等）</li>\n</ul>\n</li>\n<li><strong>发起连接</strong>：客户端根据配置，向跳板机的公网IP和指定端口发起TCP&#x2F;UDP连接请求。</li>\n<li><strong>TLS双向认证</strong>（最关键的安全步骤）：<ul>\n<li><strong>服务器认证</strong>：跳板机上的OpenVPN服务端将自己的证书发给客户端。客户端用CA根证书验证服务器证书的有效性，<strong>确保连接的是真正的公司跳板机，而不是钓鱼服务器</strong>。</li>\n<li><strong>客户端认证</strong>：客户端将自己的证书和私钥签名发给服务器。服务器用CA根证书验证客户端证书，<strong>确保连接的是授权员工，而不是外人</strong>。</li>\n<li>这个过程通常还辅以用户名&#x2F;密码认证。</li>\n</ul>\n</li>\n<li><strong>隧道建立</strong>：认证通过后，双方利用协商好的密钥，建立一条<strong>加密隧道</strong>。跳板机为客户端分配一个内网IP地址（如 <code>10.8.0.100</code>）。此时，用户的电脑在逻辑上已经“接入”了公司内网。</li>\n</ol>\n<h4 id=\"阶段二：访问内部资源（路由与转发）\"><a href=\"#阶段二：访问内部资源（路由与转发）\" class=\"headerlink\" title=\"阶段二：访问内部资源（路由与转发）\"></a>阶段二：访问内部资源（路由与转发）</h4><ol>\n<li><strong>发起访问请求</strong>：用户需要访问内网的一台Web服务器（<code>192.168.1.100</code>）。他在本地使用SSH命令：<code>ssh developer@192.168.1.100</code>。</li>\n<li><strong>流量封装与路由</strong>：<ul>\n<li>客户端的操作系统会根据路由表规则，将所有发往 <code>192.168.1.0/24</code> 网段的流量，都指向OpenVPN创建的虚拟网卡。</li>\n<li>OpenVPN客户端将原始的SSH数据包（TCP协议）<strong>整个加密并包裹（封装）</strong> 在一个新的数据包内，这个新数据包的目的地是跳板机的公网IP。</li>\n<li>这个加密后的数据包通过互联网发送到跳板机。</li>\n</ul>\n</li>\n<li><strong>跳板机处理</strong>（流量枢纽）：<ul>\n<li>跳板机上的OpenVPN服务端<strong>解密</strong>收到的数据包，<strong>解出</strong>原始的SSH请求数据包。</li>\n<li>跳板机的<strong>操作系统内核</strong>根据其自身的路由表，发现这个目标是 <code>192.168.1.100</code> 的数据包需要从其内部网卡（如 <code>eth0</code>）发出。</li>\n<li><strong>防火墙和访问控制</strong>：在转发前，跳板机上的防火墙规则（如 <code>iptables</code>）会进行检查，判断源IP（<code>10.8.0.100</code>）是否有权限访问目标IP（<code>192.168.1.100</code>）的22端口。通过后，才将数据包转发给目标Web服务器。</li>\n</ul>\n</li>\n<li><strong>响应返回</strong>：<ul>\n<li>Web服务器处理SSH请求后，将响应包发回给跳板机（因为请求的来源IP是跳板机）。</li>\n<li>跳板机收到响应后，再将其加密，通过隧道发回给远端的用户客户端。</li>\n<li>客户端解密后，得到原始的SSH响应，完成一次完整的交互。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"🛡️-核心价值与优势\"><a href=\"#🛡️-核心价值与优势\" class=\"headerlink\" title=\"🛡️ 核心价值与优势\"></a>🛡️ 核心价值与优势</h4><p>这种架构的优势在于提供了<strong>双重安全性和极佳的可管理性</strong>：</p>\n<ol>\n<li><strong>强身份认证</strong>：通过证书方式，同时验证了服务器和客户端的身份，避免了密码泄露和中间人攻击。</li>\n<li><strong>通信加密</strong>：所有数据在公网上传输时都是加密的，保证机密性。</li>\n<li><strong>访问隔离</strong>：跳板机成为唯一的入口，外部无法直接访问任何其他内网机器，攻击面最小化。</li>\n<li><strong>集中审计与管控</strong>：所有对内网的访问都必须经过跳板机，便于<strong>记录完整的操作日志</strong>、<strong>监控会话</strong>和<strong>统一设置访问权限策略</strong>。管理员只需要在跳板机上修改规则，就可以控制所有用户的权限。</li>\n</ol>\n<h3 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h3><ul>\n<li><strong>OpenVPN客户端</strong>是您用来<strong>连接</strong>的<strong>软件</strong>。</li>\n<li><strong>跳板机</strong>是您<strong>连接上去</strong>的那台<strong>服务器</strong>。</li>\n<li>OpenVPN是<strong>实现安全连接的方式之一</strong>，而跳板机是<strong>一种网络访问策略和架构</strong>。</li>\n</ul>\n<p>您可以<strong>不使用OpenVPN</strong>而用其他方式（如SSH）登录跳板机；也可以<strong>使用OpenVPN</strong>连接到一台<strong>不是跳板机</strong>的服务器（例如只是为了加密咖啡店的公共Wi-Fi流量）。</p>\n<p>但当它们结合时，就构成了一个非常经典和强大的安全远程访问方案。</p>\n<h2 id=\"🧠-什么是堡垒机？\"><a href=\"#🧠-什么是堡垒机？\" class=\"headerlink\" title=\"🧠 什么是堡垒机？\"></a>🧠 什么是堡垒机？</h2><p>如果说「跳板机」是一个基础概念，那么「堡垒机」就是它的<strong>完全体、企业级、工业化</strong>的形态。</p>\n<p><strong>堡垒机</strong>（Bastion Host）是一种位于内部网络和外部网络之间的<strong>高性能、高安全性的专用服务器</strong>，其核心设计理念是 <strong>“网络要塞”</strong> 。所有内部设备的远程访问（如 SSH, RDP, SFTP）都必须通过它进行，它作为唯一的入口点，集中进行<strong>身份认证、授权、审计和监控</strong>。</p>\n<p>您可以把它想象成一个<strong>极其严格的银行金库门卫</strong>：</p>\n<ol>\n<li><strong>唯一入口</strong>：所有人都必须从这个门进出。</li>\n<li><strong>严格安检</strong>：需要多重身份验证（工牌、指纹、密码）。</li>\n<li><strong>权限分明</strong>：你只能进入你有权限进入的区域（金库、柜台、办公室）。</li>\n<li><strong>全程监控</strong>：你进去后的一举一动都被全程录像，说了什么话（执行的命令）、拿了什么东西（传输的文件）都有记录。</li>\n</ol>\n<hr>\n<h3 id=\"🆚-堡垒机-vs-简单跳板机：有何不同？\"><a href=\"#🆚-堡垒机-vs-简单跳板机：有何不同？\" class=\"headerlink\" title=\"🆚 堡垒机 vs. 简单跳板机：有何不同？\"></a>🆚 堡垒机 vs. 简单跳板机：有何不同？</h3><p>很多人会混用这两个词，但它们有本质上的区别：</p>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>简单跳板机 (Jump Server)</strong></th>\n<th><strong>堡垒机 (Bastion Host)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>核心功能</strong></td>\n<td><strong>网络转发</strong>、基础连接</td>\n<td><strong>4A管理</strong>：认证、授权、账号、审计</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>相对较低，依赖系统自身安全</td>\n<td><strong>极高</strong>，有专门的安全加固和防护</td>\n</tr>\n<tr>\n<td><strong>用户体验</strong></td>\n<td>命令行，原始</td>\n<td><strong>Web图形化界面</strong>，易于操作</td>\n</tr>\n<tr>\n<td><strong>权限控制</strong></td>\n<td>粗粒度（能&#x2F;不能登录某台机器）</td>\n<td><strong>细粒度</strong>（能登录，且只能执行某些命令）</td>\n</tr>\n<tr>\n<td><strong>审计能力</strong></td>\n<td>基础日志（谁什么时候登录了）</td>\n<td><strong>强大审计</strong><strong>：</strong>**   <strong><strong>-</strong></strong> **<strong>会话录像</strong>（全程录屏）   - <strong>命令记录</strong>（精确到每一条命令）   - <strong>文件传输记录</strong></td>\n</tr>\n<tr>\n<td><strong>账号管理</strong></td>\n<td>分散在各台服务器上</td>\n<td><strong>统一账号管理</strong>，单点登录（SSO）</td>\n</tr>\n<tr>\n<td><strong>本质</strong></td>\n<td><strong>一台功能单一的服务器</strong></td>\n<td><strong>一套完整的安全运维管控系统</strong></td>\n</tr>\n</tbody></table>\n<p><strong>简单说：跳板机主要解决“<strong>怎么进去</strong>”的问题，而堡垒机在此基础上，更解决了“<strong>谁能进</strong>”、“<strong>能干什么</strong>”和“<strong>干了什么</strong>”的问题。</strong></p>\n<hr>\n<h3 id=\"🛡️-堡垒机的核心功能（4A管理）\"><a href=\"#🛡️-堡垒机的核心功能（4A管理）\" class=\"headerlink\" title=\"🛡️ 堡垒机的核心功能（4A管理）\"></a>🛡️ 堡垒机的核心功能（4A管理）</h3><h4 id=\"1-认证-Authentication-：“你是谁？”\"><a href=\"#1-认证-Authentication-：“你是谁？”\" class=\"headerlink\" title=\"1. 认证 (Authentication)：“你是谁？”\"></a>1. 认证 (Authentication)：“你是谁？”</h4><ul>\n<li><strong>多种认证方式</strong>：支持密码、SSH密钥、动态令牌（如Google Authenticator）、LDAP&#x2F;AD域集成、生物识别等。</li>\n<li><strong>多因子认证 (MFA)</strong>：强制要求使用两种及以上方式验证身份，极大提升安全性。</li>\n</ul>\n<h4 id=\"2-授权-Authorization-：“你能干什么？”\"><a href=\"#2-授权-Authorization-：“你能干什么？”\" class=\"headerlink\" title=\"2. 授权 (Authorization)：“你能干什么？”\"></a>2. 授权 (Authorization)：“你能干什么？”</h4><ul>\n<li><strong>精细化的权限控制</strong>：<ul>\n<li><strong>主机权限</strong>：允许用户访问哪些服务器（如：只能访问Web服务器，不能访问数据库服务器）。</li>\n<li><strong>操作权限</strong>：允许用户执行哪些命令（如：可以执行 <code>systemctl restart nginx</code>，但不能执行 <code>rm -rf /</code>）。</li>\n<li><strong>时间权限</strong>：允许用户在什么时间段内访问（如：只能在工作时间访问）。</li>\n</ul>\n</li>\n<li><strong>临时权限申请与审批</strong>：如果需要临时获得更高权限，可以通过工单系统申请，由管理员审批后自动授权，过期自动回收。</li>\n</ul>\n<h4 id=\"3-账号-Account-：“你的身份是什么？”\"><a href=\"#3-账号-Account-：“你的身份是什么？”\" class=\"headerlink\" title=\"3. 账号 (Account)：“你的身份是什么？”\"></a>3. 账号 (Account)：“你的身份是什么？”</h4><ul>\n<li><strong>统一账号管理</strong>：在堡垒机上创建账号，即可映射到后端的多台服务器，无需在每个服务器上单独创建账号。实现了“一个堡垒机账号，访问所有授权资产”。</li>\n<li><strong>托管服务器账号</strong>：服务器账号和密码可以由堡垒机托管，用户无需知道目标服务器的真实密码。</li>\n</ul>\n<h4 id=\"4-审计-Audit-：“你干了什么？”（这是堡垒机的灵魂）\"><a href=\"#4-审计-Audit-：“你干了什么？”（这是堡垒机的灵魂）\" class=\"headerlink\" title=\"4. 审计 (Audit)：“你干了什么？”（这是堡垒机的灵魂）\"></a>4. 审计 (Audit)：“你干了什么？”（这是堡垒机的灵魂）</h4><ul>\n<li><strong><strong>会话录像 (Session Recording)</strong>：** 像录屏一样，完整记录用户在目标服务器上的**所有操作过程</strong>，包括敲打的命令、返回的结果。无法抵赖。</li>\n<li><strong>命令记录</strong>：详细记录执行过的每一条命令及其时间、来源IP。</li>\n<li><strong>文件传输审计</strong>：记录所有通过SFTP&#x2F;SCP&#x2F;RDP上传和下载的文件日志。</li>\n<li><strong>行为分析</strong>：对异常操作、危险命令（如 <code>rm</code>、<code>chmod</code>）进行实时告警。</li>\n</ul>\n<hr>\n<h3 id=\"🏗️-堡垒机的工作流程\"><a href=\"#🏗️-堡垒机的工作流程\" class=\"headerlink\" title=\"🏗️ 堡垒机的工作流程\"></a>🏗️ 堡垒机的工作流程</h3><p>下图以一个运维人员需要通过堡垒机修复网站为例，展示了其核心工作流程与4A功能：</p>\n<p>:::tips<br><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756749301182-aa40bc89-4556-4198-8134-31e398991d2f.svg\"\n                     \n                ></p>\n<p>:::</p>\n<hr>\n<h3 id=\"🚀-常见的堡垒机方案\"><a href=\"#🚀-常见的堡垒机方案\" class=\"headerlink\" title=\"🚀 常见的堡垒机方案\"></a>🚀 常见的堡垒机方案</h3><ol>\n<li><strong>开源方案</strong>：<ul>\n<li><strong>Jumpserver</strong>：国内最流行的开源堡垒机，功能全面，对中文支持好，社区活跃。</li>\n<li><strong>Teleport</strong>：现代、轻量级，对云原生和Kubernetes环境支持良好。</li>\n<li><strong>Apache Guacamole</strong>：无客户端堡垒机，通过浏览器即可实现RDP、SSH、VNC等连接。</li>\n</ul>\n</li>\n<li><strong>商业方案</strong>：<ul>\n<li><strong>齐治堡垒机</strong>：国内老牌商业产品，市场份额大。</li>\n<li>** Cisco Secure Access (前Duo)**、<strong>CyberArk</strong>：国际知名的商业解决方案，功能强大，价格昂贵。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"✅-总结：为什么需要堡垒机？\"><a href=\"#✅-总结：为什么需要堡垒机？\" class=\"headerlink\" title=\"✅ 总结：为什么需要堡垒机？\"></a>✅ 总结：为什么需要堡垒机？</h3><ol>\n<li><strong>安全第一</strong>：极大缩小了网络攻击面，保护了内部资产。</li>\n<li><strong>合规要求</strong>：满足等保2.0、ISO27001、GDPR等法规对运维审计的强制性要求。</li>\n<li><strong>权限清晰</strong>：实现最小权限原则，避免权限滥用。</li>\n<li><strong>责任界定</strong>：出现问题时，可以通过录像和日志快速定位责任人、还原事故现场。</li>\n<li><strong>运维效率</strong>：统一入口，简化了账号管理和访问流程。</li>\n</ol>\n<p>简而言之，堡垒机是企业IT基础设施中<strong>不可或缺的安全与审计基石</strong>，尤其对于金融、政府、互联网等对安全性和合规性要求极高的行业来说，是标配产品。</p>\n<h1 id=\"OpenVpn-跳板机-堡垒机实现前端部署\"><a href=\"#OpenVpn-跳板机-堡垒机实现前端部署\" class=\"headerlink\" title=\"OpenVpn+跳板机&#x2F;堡垒机实现前端部署\"></a>OpenVpn+跳板机&#x2F;堡垒机实现前端部署</h1><p>这是一个非常经典的DevOps场景：OpenVpn+跳板机&#x2F;堡垒机与前端工程部署结合起来，可以构建一个既安全又高效的部署流程。</p>\n<p>这种架构的核心思想是：通过 OpenVPN 建立安全通道，通过跳板机&#x2F;堡垒机作为统一、受控的入口，来执行部署操作。</p>\n<h2 id=\"🧩-核心架构与角色分工\"><a href=\"#🧩-核心架构与角色分工\" class=\"headerlink\" title=\"🧩 核心架构与角色分工\"></a>🧩 核心架构与角色分工</h2><p>在这种架构下，各个组件的职责非常清晰：</p>\n<ol>\n<li><strong>OpenVPN Server</strong>：<strong>负责建“路”</strong>。建立一条从开发者本地到部署环境的加密隧道，确保传输安全。</li>\n<li><strong>跳板机&#x2F;堡垒机 (Bastion Host)</strong>：<strong>负责管“门”和看“人”</strong>。它是唯一的部署操作入口，负责身份验证、权限控制和操作审计。</li>\n<li><strong>部署目标服务器</strong>：<strong>负责住“应用”</strong>。这是最终运行前端项目（Nginx, Node.js 等）的服务器。</li>\n<li><strong>CI&#x2F;CD 工具 (可选但推荐)</strong>：<strong>负责自动“开车”</strong>。例如 Jenkins、GitLab Runner 等，它们可以自动从仓库拉取代码、构建，并通过跳板机执行部署脚本。</li>\n</ol>\n<p>整个从前端代码到部署上线的安全部署流程，如图所述：</p>\n<p>:::tips<br><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756747253378-aa010295-0b0b-4500-a839-7162fc66eaa3.svg\"\n                     \n                ></p>\n<p>:::</p>\n<h2 id=\"🛠️-两种常见的部署模式\"><a href=\"#🛠️-两种常见的部署模式\" class=\"headerlink\" title=\"🛠️ 两种常见的部署模式\"></a>🛠️ 两种常见的部署模式</h2><h3 id=\"模式一：手动部署（适合小团队或初期）\"><a href=\"#模式一：手动部署（适合小团队或初期）\" class=\"headerlink\" title=\"模式一：手动部署（适合小团队或初期）\"></a>模式一：手动部署（适合小团队或初期）</h3><p><strong>流程：</strong> 开发者本地构建，然后通过跳板机手动上传文件。</p>\n<p><strong>本地构建</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure></div>\n\n<p>这会在项目根目录生成 <code>dist</code> 或 <code>build</code> 文件夹，里面是静态文件（HTML, CSS, JS）。</p>\n<ol>\n<li><strong>连接VPN</strong>：确保 OpenVPN 客户端已连接，获得访问内网的权限。</li>\n<li><strong>通过跳板机上传文件</strong>：</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 scp 命令，通过跳板机转发到目标服务器</span></span><br><span class=\"line\"><span class=\"comment\"># 注意：跳板机需要配置SSH代理转发或用户有直接权限</span></span><br><span class=\"line\">scp -r -o <span class=\"string\">&#x27;ProxyJump user@jumpbox-ip&#x27;</span> ./dist/* user@target-server-ip:/path/to/nginx/html/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或者使用更现代的 rsync</span></span><br><span class=\"line\">rsync -avz -e <span class=\"string\">&quot;ssh -J user@jumpbox-ip&quot;</span> ./dist/ user@target-server-ip:/path/to/nginx/html/</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"3\">\n<li><strong>通过跳板机执行远程命令</strong>（如果需要）：</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 登录跳板机，再从跳板机SSH到目标服务器</span></span><br><span class=\"line\">ssh user@jumpbox-ip</span><br><span class=\"line\"><span class=\"comment\"># 然后，在跳板机上执行</span></span><br><span class=\"line\">ssh user@target-server-ip <span class=\"string\">&quot;sudo nginx -s reload&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"模式二：自动化部署（推荐，适合成熟团队）\"><a href=\"#模式二：自动化部署（推荐，适合成熟团队）\" class=\"headerlink\" title=\"模式二：自动化部署（推荐，适合成熟团队）\"></a>模式二：自动化部署（推荐，适合成熟团队）</h3><p><strong>流程：</strong> CI&#x2F;CD 工具（如 Jenkins、GitLab CI）在检测到 Git 标签或特定分支更新后，自动完成所有步骤。</p>\n<p>这是一个在 GitLab 中实现的自动化部署流程示例：</p>\n<div class=\"code-container\" data-rel=\"Yaml\"><figure class=\"iseeu highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># .gitlab-ci.yml</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">stages:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">deploy</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">build_production:</span></span><br><span class=\"line\">  <span class=\"attr\">stage:</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"attr\">image:</span> <span class=\"string\">node:16</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">if:</span> <span class=\"string\">$CI_COMMIT_TAG</span> <span class=\"comment\"># 通常在打标签时触发生产环境部署</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"attr\">artifacts:</span></span><br><span class=\"line\">    <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">dist/</span> <span class=\"comment\"># 将构建产物传递给下一个阶段</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">deploy_to_production:</span></span><br><span class=\"line\">  <span class=\"attr\">stage:</span> <span class=\"string\">deploy</span></span><br><span class=\"line\">  <span class=\"attr\">image:</span> <span class=\"string\">alpine</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">if:</span> <span class=\"string\">$CI_COMMIT_TAG</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">apk</span> <span class=\"string\">add</span> <span class=\"string\">--no-cache</span> <span class=\"string\">openssh-client</span> <span class=\"string\">rsync</span></span><br><span class=\"line\">    <span class=\"comment\"># 使用 SSH 通过跳板机部署 (-o ProxyJump)</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">rsync</span> <span class=\"string\">-avz</span> <span class=\"string\">--delete</span> <span class=\"string\">-e</span> <span class=\"string\">&quot;ssh -o StrictHostKeyChecking=no -J $JUMPBOX_USER@$JUMPBOX_IP&quot;</span> <span class=\"string\">dist/</span> <span class=\"string\">$TARGET_SERVER_USER@$TARGET_SERVER_IP:/app/frontend/</span></span><br><span class=\"line\">    <span class=\"comment\"># 通过跳板机执行远程命令，重启服务</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ssh</span> <span class=\"string\">-J</span> <span class=\"string\">$JUMPBOX_USER@$JUMPBOX_IP</span> <span class=\"string\">$TARGET_SERVER_USER@$TARGET_SERVER_IP</span> <span class=\"string\">&quot;sudo systemctl reload nginx&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>$JUMPBOX_IP</code>, <code>$TARGET_SERVER_IP</code> 等变量在 GitLab 的 <strong>CI&#x2F;CD 设置</strong>中配置，避免写在代码里。</li>\n<li><code>-J</code> 参数是 SSH 的 <strong>代理跳跃</strong>，让 SSH 连接自动通过跳板机。</li>\n<li>堡垒机上需要存放 CI&#x2F;CD 工具的 <strong>SSH 私钥</strong>，并且该密钥对目标服务器有访问权限。</li>\n</ul>\n<hr>\n<h2 id=\"⚙️-部署前的重要准备工作\"><a href=\"#⚙️-部署前的重要准备工作\" class=\"headerlink\" title=\"⚙️ 部署前的重要准备工作\"></a>⚙️ 部署前的重要准备工作</h2><ol>\n<li><strong>网络与权限配置</strong>：<ul>\n<li>确保 OpenVPN 服务器配置的路由规则，能让客户端访问到跳板机和目标服务器。</li>\n<li>在跳板机上为每个开发者或CI&#x2F;CD服务创建账号，并配置严格的 SSH 密钥认证。</li>\n<li>配置跳板机的权限控制，确保用户只能访问特定的目标服务器。</li>\n</ul>\n</li>\n<li><strong>堡垒机审计</strong>：<ul>\n<li>开启堡垒机的会话录制功能，记录所有通过它执行的部署命令和文件传输操作。一旦出问题，可以快速回放定位。</li>\n</ul>\n</li>\n<li><strong>目标服务器配置</strong>：<ul>\n<li><strong>Nginx 配置示例</strong>：</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Nginx\"><figure class=\"iseeu highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> your-app.com;</span><br><span class=\"line\">  <span class=\"attribute\">root</span> /app/frontend; <span class=\"comment\"># 前端文件部署的目录</span></span><br><span class=\"line\">  <span class=\"attribute\">index</span> index.html;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 处理 SPA 路由（如 Vue Router 的 history 模式）</span></span><br><span class=\"line\">  <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">    <span class=\"attribute\">try_files</span> <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.html;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 启用 gzip 压缩</span></span><br><span class=\"line\">  <span class=\"attribute\">gzip</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\">  <span class=\"attribute\">gzip_types</span> text/css application/javascript;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h2 id=\"✅-这种架构的优势\"><a href=\"#✅-这种架构的优势\" class=\"headerlink\" title=\"✅ 这种架构的优势\"></a>✅ 这种架构的优势</h2><ol>\n<li><strong>极致安全</strong>：<ul>\n<li>内部服务器<strong>完全不用暴露到公网</strong>，攻击者无法直接扫描到。</li>\n<li>所有部署操作都经过<strong>加密隧道</strong>和<strong>严格审计</strong>。</li>\n</ul>\n</li>\n<li><strong>权限清晰</strong>：<ul>\n<li>开发者可能根本不知道目标服务器的密码，而是通过堡垒机的授权来访问，实现了权限最小化原则。</li>\n</ul>\n</li>\n<li><strong>流程标准化</strong>：<ul>\n<li>无论是谁部署，都必须走同一个通道，执行相同的流程，减少了人为出错的可能。</li>\n</ul>\n</li>\n<li><strong>可追溯性</strong>：<ul>\n<li>结合堡垒机的录像功能，可以清晰看到<strong>谁</strong>、在<strong>什么时间</strong>、<strong>部署了什么</strong>、<strong>执行了什么命令</strong>，便于故障排查和审计。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"⚠️-注意事项\"><a href=\"#⚠️-注意事项\" class=\"headerlink\" title=\"⚠️ 注意事项\"></a>⚠️ 注意事项</h2><ul>\n<li><strong>复杂度</strong>：初始设置比直接部署到公网服务器要复杂，但长期来看收益巨大。</li>\n<li><strong>性能</strong>：如果 CI&#x2F;CD 服务器在海外，而跳板机和目标服务器在国内，传输大量文件可能会慢，可以考虑在目标服务器上直接构建。</li>\n<li><strong>成本</strong>：需要维护额外的跳板机&#x2F;堡垒机组件。</li>\n</ul>\n<p><strong>总结：</strong> <strong>OpenVPN + 跳板机&#x2F;堡垒机的部署模式，是企业级前端工程部署的最佳实践之一。</strong> 它通过牺牲一点点部署的便利性，换来了极高的安全性和规范性，非常适合对安全有要求的中大型项目。</p>\n<h1 id=\"SaaS使用的部署方式到底叫什么呢？\"><a href=\"#SaaS使用的部署方式到底叫什么呢？\" class=\"headerlink\" title=\"SaaS使用的部署方式到底叫什么呢？\"></a>SaaS使用的部署方式到底叫什么呢？</h1><p>描述：没有使用jenkins，开发者通过堡垒机连入目标网络中通过git拉取代码并执行打包命令后生成dist或build文件夹，执行shell脚本将打包后的静态资源放到对应的目标服务器的路径下。</p>\n<p><strong>手动或半自动的基于堡垒机的 Git 拉取部署。</strong></p>\n<p>更具体地说，它属于 <strong>“Git-Based Deployment”</strong> 的一种演变形式，核心特点是<strong>通过安全堡垒机作为跳板，直接在目标环境或邻近网络中执行构建和部署</strong>。</p>\n<h2 id=\"🧩-这种部署模式的详细流程拆解\"><a href=\"#🧩-这种部署模式的详细流程拆解\" class=\"headerlink\" title=\"🧩 这种部署模式的详细流程拆解\"></a>🧩 这种部署模式的详细流程拆解</h2><p>:::tips<br><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756747641121-afeda975-ab3a-4be8-a945-8b803dd7b2bd.svg\"\n                     \n                ></p>\n<p>:::</p>\n<p>它与纯CI&#x2F;CD自动化部署的<strong>核心区别</strong>在于，流程图中<strong>黄色框线</strong>的部分（从 <code>git push</code> 到 <code>重启服务</code>）完全由<strong>开发者手动触发和执行</strong>，而非由CI&#x2F;CD工具（如Jenkins、GitLab CI）自动触发。</p>\n<hr>\n<h2 id=\"⚙️-这种模式的特点\"><a href=\"#⚙️-这种模式的特点\" class=\"headerlink\" title=\"⚙️ 这种模式的特点\"></a>⚙️ 这种模式的特点</h2><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li><strong>环境高度一致</strong>：在<strong>目标网络内</strong>进行构建，可以有效避免“在我本地是好的”这类问题。构建环境与生产环境一致（操作系统、Node版本等）。</li>\n<li><strong>安全性高</strong>：所有操作都通过受审计的堡垒机进行，目标服务器无需暴露到公网，也无需在本地和服务器之间开放额外的端口。</li>\n<li><strong>简单直接，无需复杂配置</strong>：不需要搭建和维护一整套CI&#x2F;CD系统（如Jenkins），对于小团队或项目初期来说，成本更低，更轻量。</li>\n<li><strong>依赖少</strong>：只需要目标服务器上有Git和Node.js环境即可，不需要安装CI&#x2F;CD的Agent。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li><strong>自动化程度低</strong>：严重依赖人工操作。开发者需要手动登录、执行一系列命令。容易因操作失误（比如忘了拉最新代码、在错误目录执行）导致部署失败。</li>\n<li><strong>无法实现真正的持续交付</strong>：部署过程不是自动触发的，通常需要人工干预，无法做到代码一提交就自动测试和部署。</li>\n<li><strong>可追溯性较差</strong>：虽然堡垒机会记录执行了哪些命令，但**“谁在什么时候部署了哪个版本的代码”** 这一信息没有与代码提交（Git Tag&#x2F;Commit ID）强关联地记录下来。出问题时，需要回溯堡垒机日志。</li>\n<li><strong>效率较低</strong>：每次部署都需要在服务器上重新执行完整的构建过程，占用服务器资源，如果服务器性能不佳，构建时间会很长。</li>\n</ol>\n<hr>\n<h2 id=\"🚀-如何优化这种模式？\"><a href=\"#🚀-如何优化这种模式？\" class=\"headerlink\" title=\"🚀 如何优化这种模式？\"></a>🚀 如何优化这种模式？</h2><p>即使不引入Jenkins，也可以让这个流程变得更高效、更可靠：</p>\n<h3 id=\"1-编写自动化部署脚本\"><a href=\"#1-编写自动化部署脚本\" class=\"headerlink\" title=\"1. 编写自动化部署脚本\"></a>1. 编写自动化部署脚本</h3><p>将一系列手动命令写成一个Shell脚本，例如 <code>deploy.sh</code>，放在代码库根目录。</p>\n<p><strong>（这就是SaaS的做法）</strong></p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># deploy.sh</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> -e <span class=\"comment\"># 遇到错误就退出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;1. Pulling latest code...&quot;</span></span><br><span class=\"line\">git pull origin main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;2. Installing dependencies...&quot;</span></span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;3. Building project...&quot;</span></span><br><span class=\"line\">npm run build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;4. Backing up old version...&quot;</span></span><br><span class=\"line\">tar -czf /app/backup/frontend-$(<span class=\"built_in\">date</span> +%Y%m%d-%H%M%S).tar.gz /usr/share/nginx/html/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;5. Deploying new version...&quot;</span></span><br><span class=\"line\">rsync -av --delete ./dist/ /usr/share/nginx/html/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;6. Reloading Nginx...&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl reload nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Deployment completed successfully!&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>使用方式：</strong> 开发者登录后，只需要执行一条命令：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash deploy.sh</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"2-使用-Git-Hooks（简单CI）\"><a href=\"#2-使用-Git-Hooks（简单CI）\" class=\"headerlink\" title=\"2. 使用 Git Hooks（简单CI）\"></a>2. 使用 Git Hooks（简单CI）</h3><p>在<strong>代码服务器的Git仓库</strong>上配置 <code>post-receive</code> Hook（例如使用Gitea），当收到<code>push</code>时，自动通知目标服务器执行拉取和部署脚本。这实现了简单的自动触发。</p>\n<h3 id=\"3-使用-SSH-直接执行远程命令\"><a href=\"#3-使用-SSH-直接执行远程命令\" class=\"headerlink\" title=\"3. 使用 SSH 直接执行远程命令\"></a>3. 使用 SSH 直接执行远程命令</h3><p>开发者可以在本地电脑上通过一条命令完成部署，无需手动登录。</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -J user@jumpbox-ip user@target-server-ip <span class=\"string\">&quot;cd /path/to/project &amp;&amp; bash deploy.sh&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"4-引入版本标记\"><a href=\"#4-引入版本标记\" class=\"headerlink\" title=\"4. 引入版本标记\"></a>4. 引入版本标记</h3><p>在脚本中加入步骤，在部署成功后，给当前的提交打上一个Tag。</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag deploy-$(<span class=\"built_in\">date</span> +%Y%m%d-%H%M%S)</span><br><span class=\"line\">git push origin --tags</span><br></pre></td></tr></table></figure></div>\n\n<p>这样就能清晰地知道生产环境对应的是哪个代码版本。</p>\n<hr>\n<h2 id=\"✅-总结-1\"><a href=\"#✅-总结-1\" class=\"headerlink\" title=\"✅ 总结\"></a>✅ 总结</h2><p>这是一种 <strong>“基于堡垒机的半自动 Git 拉取部署”</strong>。</p>\n<ul>\n<li><strong>它不是什么？</strong> 它不是全自动的CI&#x2F;CD（如Jenkins Pipeline），也不是传统的FTP上传部署。</li>\n<li><strong>它是什么？</strong> 它是一种在<strong>安全约束条件下</strong>、<strong>介于手动部署和全自动部署之间</strong>的实用型方案。</li>\n</ul>\n<p><strong>适用场景：</strong></p>\n<ul>\n<li>内部系统、管理后台等对发布频率要求不高的项目。</li>\n<li>团队规模较小，尚未引入完整CI&#x2F;CD工具链的初期阶段。</li>\n<li>对安全性要求极高，所有内部网络访问必须通过堡垒机的环境。</li>\n</ul>\n<p>对于很多项目来说，这是一个非常好的起点。随着项目发展，当您觉得每次手动运行脚本也很麻烦时，就是考虑引入 <strong>GitLab CI&#x2F;CD、Github Actions</strong> 等真正自动化工具的时候了。</p>\n<h1 id=\"待完善内容\"><a href=\"#待完善内容\" class=\"headerlink\" title=\" 待完善内容 \"></a><font style=\"color:#FFFFFF;background-color:#ED740C;\"> 待完善内容 </font></h1><ul>\n<li><input disabled=\"\" type=\"checkbox\"> CI&#x2F;CD工具：jekins</li>\n<li><input disabled=\"\" type=\"checkbox\"> Docker</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"CI-CD\"><a href=\"#CI-CD\" class=\"headerlink\" title=\"CI&#x2F;CD\"></a>CI&#x2F;CD</h1><h2 id=\"🧠-核心概念：CI-CD是什么？\"><a href=\"#🧠-核心概念：CI-CD是什么？\" class=\"headerlink\" title=\"🧠 核心概念：CI&#x2F;CD是什么？\"></a>🧠 核心概念：CI&#x2F;CD是什么？</h2><p>CI&#x2F;CD 是现代软件工程中的一套最佳实践和方法论，旨在自动化软件的集成、测试和部署流程。它由两个部分组成：</p>\n<p>CI - 持续集成 (Continuous Integration)</p>\n<p>CD - 持续交付&#x2F;持续部署 (Continuous Delivery &#x2F; Continuous Deployment)</p>\n<p>可以把 CI&#x2F;CD 想象成一个全自动的软件装配流水线。开发者提交代码（如同送上原料），流水线会自动进行一系列质量检测、打包和发布，最终将合格的产品交付给用户。</p>\n<h2 id=\"🔧-详解两个部分\"><a href=\"#🔧-详解两个部分\" class=\"headerlink\" title=\"🔧 详解两个部分\"></a>🔧 详解两个部分</h2><h3 id=\"1-CI-持续集成\"><a href=\"#1-CI-持续集成\" class=\"headerlink\" title=\"1. CI - 持续集成\"></a>1. CI - 持续集成</h3><p><strong>核心思想：</strong> 开发者频繁地将代码更改合并到共享的主干分支（如每天多次）。每次合并都会自动触发一系列构建和测试，以便快速发现和修复错误。</p>\n<p>:::tips<br><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756740541342-f73ad130-61e5-4ba6-9386-4bd47fda11ff.svg\"\n                     \n                ></p>\n<p>:::</p>\n<p><strong>好处：</strong></p>\n<ul>\n<li>✅ <strong>快速发现错误</strong>：问题在引入后几分钟内就能被发现。</li>\n<li>✅ <strong>减少集成冲突</strong>：频繁合并小批量代码，避免在发布前一次性合并大量代码带来的巨大冲突。</li>\n<li>✅ 提高代码质量**：自动化测试保障了代码标准。</li>\n</ul>\n<h3 id=\"2-CD-持续交付-持续部署\"><a href=\"#2-CD-持续交付-持续部署\" class=\"headerlink\" title=\"2. CD - 持续交付 &#x2F; 持续部署\"></a>2. CD - 持续交付 &#x2F; 持续部署</h3><p><strong>CD 有两种细微差别的含义：</strong></p>\n<h4 id=\"a-持续交付-Continuous-Delivery\"><a href=\"#a-持续交付-Continuous-Delivery\" class=\"headerlink\" title=\"a) 持续交付 (Continuous Delivery)\"></a>a) 持续交付 (Continuous Delivery)</h4><p><strong>核心思想：</strong> CI流程结束后，代码总是处于<strong>可随时、一键手动部署</strong>到生产环境的状态。</p>\n<p><strong>流程：</strong> <code>代码 -&gt; CI -&gt; 生成制品 -&gt; 等待手动点击部署</code></p>\n<h4 id=\"b-持续部署-Continuous-Deployment\"><a href=\"#b-持续部署-Continuous-Deployment\" class=\"headerlink\" title=\"b) 持续部署 (Continuous Deployment)\"></a>b) 持续部署 (Continuous Deployment)</h4><p><strong>核心思想：</strong> 这是持续交付的更高阶段。只要代码通过所有测试流程，就<strong>自动地、无需人工干预地</strong>部署到生产环境。</p>\n<p><strong>流程：</strong> <code>代码 -&gt; CI -&gt; 生成制品 -&gt; 自动部署到生产环境</code></p>\n<p>可以这样理解：</p>\n<ul>\n<li><strong>持续交付</strong> &#x3D; “软件已经打包好放在门口了，你随时可以签收（手动部署）。”</li>\n<li><strong>持续部署</strong> &#x3D; “软件通过质检后，快递机器人自动送货上门（自动部署）。”</li>\n</ul>\n<h2 id=\"🛠️-CI-CD-工具链\"><a href=\"#🛠️-CI-CD-工具链\" class=\"headerlink\" title=\"🛠️ CI&#x2F;CD 工具链\"></a>🛠️ CI&#x2F;CD 工具链</h2><p>整个流程依赖于一系列自动化工具，常见的工具有：</p>\n<table>\n<thead>\n<tr>\n<th><strong>阶段</strong></th>\n<th><strong>流行工具</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>源代码管理</strong>****</td>\n<td>Git (GitLab, GitHub, Gitee)</td>\n</tr>\n<tr>\n<td><strong>CI&#x2F;CD 流水线引擎</strong></td>\n<td><strong>Jenkins</strong>, GitLab CI&#x2F;CD, GitHub Actions, Drone</td>\n</tr>\n<tr>\n<td><strong>构建工具</strong></td>\n<td>Maven, Gradle (Java), npm, Webpack (JS), Make</td>\n</tr>\n<tr>\n<td><strong>测试工具</strong></td>\n<td>JUnit, Selenium, Jest, Cypress</td>\n</tr>\n<tr>\n<td><strong>部署工具</strong></td>\n<td>Ansible, Kubernetes, Docker, Terraform</td>\n</tr>\n<tr>\n<td><strong>监控工具</strong></td>\n<td>Prometheus, Grafana, ELK Stack</td>\n</tr>\n</tbody></table>\n<h2 id=\"💡-为什么需要-CI-CD？它的价值是什么？\"><a href=\"#💡-为什么需要-CI-CD？它的价值是什么？\" class=\"headerlink\" title=\"💡 为什么需要 CI&#x2F;CD？它的价值是什么？\"></a>💡 为什么需要 CI&#x2F;CD？它的价值是什么？</h2><ol>\n<li><strong>加速开发流程</strong><ul>\n<li>自动化代替手动操作，释放开发者的生产力。</li>\n<li>快速反馈，开发者能立即知道这次提交是否破坏了系统。</li>\n</ul>\n</li>\n<li><strong>提高软件质量</strong><ul>\n<li>通过自动化测试在早期发现缺陷，修复成本远低于生产环境才发现。</li>\n<li>代码规范、安全漏洞扫描等流程被标准化。</li>\n</ul>\n</li>\n<li><strong>降低发布风险</strong><ul>\n<li>小批量、频繁的发布使得每次变更的内容很少。如果出现问题，可以快速定位和回滚。</li>\n<li>传统的”半年发布一次，一次改动500个功能”的方式风险极高。</li>\n</ul>\n</li>\n<li><strong>增强项目可见性</strong><ul>\n<li>每个人都能清晰地看到代码从提交到部署的整个状态，构建是否成功、测试是否通过。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"✅-总结\"><a href=\"#✅-总结\" class=\"headerlink\" title=\"✅ 总结\"></a>✅ 总结</h2><p><strong>CI&#x2F;CD</strong> 是一套通过<strong>自动化</strong>来<strong>优化软件开发生命周期</strong>的实践，其核心目标是：</p>\n<ul>\n<li><strong>更快的发布速度</strong></li>\n<li><strong>更高质量的软件</strong></li>\n<li><strong>更低的发布风险</strong></li>\n</ul>\n<p>它不是某个特定的工具，而是一种文化和流程的变革，是现代DevOps理念的核心支柱，已经成为中大型软件开发团队的标配。</p>\n<h1 id=\"OpenVpn与跳板机-堡垒机\"><a href=\"#OpenVpn与跳板机-堡垒机\" class=\"headerlink\" title=\"OpenVpn与跳板机&#x2F;堡垒机\"></a>OpenVpn与跳板机&#x2F;堡垒机</h1><h2 id=\"🔧-什么是-OpenVPN-客户端？\"><a href=\"#🔧-什么是-OpenVPN-客户端？\" class=\"headerlink\" title=\"🔧 什么是 OpenVPN 客户端？\"></a>🔧 什么是 OpenVPN 客户端？</h2><p><strong>OpenVPN 客户端</strong>是一个安装在您本地设备（如电脑、手机）上的<strong>软件程序</strong>。</p>\n<p>它的核心功能是：<strong>根据配置文件（.ovpn 文件），与远端的 OpenVPN 服务器建立一条加密的、安全的隧道连接。</strong></p>\n<ul>\n<li><strong>它是什么？</strong> 一个软件（例如：OpenVPN Connect、Tunnelblick等）。</li>\n<li><strong>它在哪里运行？</strong> 在你的个人设备上（Windows PC, Mac, Linux, 手机）。</li>\n<li><strong>它的作用？</strong> 创建加密通道，让你的所有或指定网络流量都通过这个通道流向VPN服务器。</li>\n</ul>\n<p><strong>就像一个专门的电话（客户端），用于拨打一个安全的号码（服务器）。</strong></p>\n<hr>\n<h2 id=\"🖥️-什么是跳板机？\"><a href=\"#🖥️-什么是跳板机？\" class=\"headerlink\" title=\"🖥️ 什么是跳板机？\"></a>🖥️ 什么是跳板机？</h2><p><strong>跳板机</strong>（Jump Server &#x2F; Bastion Host）是一台位于某个特定网络区域（如公司内网）的<strong>服务器</strong>。</p>\n<p>它的核心功能是：<strong>作为一个唯一的、受严格控制的访问入口，所有外部人员必须先连接到这台服务器，才能进一步访问目标网络内部的其他设备。</strong></p>\n<ul>\n<li><strong>它是什么？</strong> 一台物理或虚拟的服务器&#x2F;计算机。</li>\n<li><strong>它在哪里运行？</strong> 在目标网络的入口处（例如公司机房或公有云上）。</li>\n<li><strong>它的作用？</strong> 提供访问桥梁和安全审计。所有操作都通过它进行，便于监控和记录日志。</li>\n</ul>\n<p><strong>就像是大楼的门卫室（跳板机），所有访客（用户）必须先在门卫室登记、核实身份，由门卫带领才能进入大楼内部（内网）。</strong></p>\n<hr>\n<h2 id=\"🔄-它们如何协同工作？（两者的关系）\"><a href=\"#🔄-它们如何协同工作？（两者的关系）\" class=\"headerlink\" title=\"🔄 它们如何协同工作？（两者的关系）\"></a>🔄 它们如何协同工作？（两者的关系）</h2><p>OpenVPN 客户端和跳板机通常<strong>配合使用</strong>，但它们扮演完全不同的角色。</p>\n<h3 id=\"工作流程分解：\"><a href=\"#工作流程分解：\" class=\"headerlink\" title=\"工作流程分解：\"></a>工作流程分解：</h3><h4 id=\"阶段一：建立安全隧道（认证与连接）\"><a href=\"#阶段一：建立安全隧道（认证与连接）\" class=\"headerlink\" title=\"阶段一：建立安全隧道（认证与连接）\"></a>阶段一：建立安全隧道（认证与连接）</h4><ol>\n<li><strong>配置加载</strong>：用户在自己的电脑上启动OpenVPN客户端软件，并加载管理员提供的 <code>.ovpn</code>配置文件。这个文件包含了连接所需的所有信息：<ul>\n<li><strong>跳板机的公网IP&#x2F;域名</strong></li>\n<li>加密算法和协议类型</li>\n<li><strong>CA根证书</strong>（用于验证服务器身份）</li>\n<li><strong>客户端证书和私钥</strong>（用于向服务器证明自身身份）</li>\n<li>其他参数（如使用的端口、是否使用密码等）</li>\n</ul>\n</li>\n<li><strong>发起连接</strong>：客户端根据配置，向跳板机的公网IP和指定端口发起TCP&#x2F;UDP连接请求。</li>\n<li><strong>TLS双向认证</strong>（最关键的安全步骤）：<ul>\n<li><strong>服务器认证</strong>：跳板机上的OpenVPN服务端将自己的证书发给客户端。客户端用CA根证书验证服务器证书的有效性，<strong>确保连接的是真正的公司跳板机，而不是钓鱼服务器</strong>。</li>\n<li><strong>客户端认证</strong>：客户端将自己的证书和私钥签名发给服务器。服务器用CA根证书验证客户端证书，<strong>确保连接的是授权员工，而不是外人</strong>。</li>\n<li>这个过程通常还辅以用户名&#x2F;密码认证。</li>\n</ul>\n</li>\n<li><strong>隧道建立</strong>：认证通过后，双方利用协商好的密钥，建立一条<strong>加密隧道</strong>。跳板机为客户端分配一个内网IP地址（如 <code>10.8.0.100</code>）。此时，用户的电脑在逻辑上已经“接入”了公司内网。</li>\n</ol>\n<h4 id=\"阶段二：访问内部资源（路由与转发）\"><a href=\"#阶段二：访问内部资源（路由与转发）\" class=\"headerlink\" title=\"阶段二：访问内部资源（路由与转发）\"></a>阶段二：访问内部资源（路由与转发）</h4><ol>\n<li><strong>发起访问请求</strong>：用户需要访问内网的一台Web服务器（<code>192.168.1.100</code>）。他在本地使用SSH命令：<code>ssh developer@192.168.1.100</code>。</li>\n<li><strong>流量封装与路由</strong>：<ul>\n<li>客户端的操作系统会根据路由表规则，将所有发往 <code>192.168.1.0/24</code> 网段的流量，都指向OpenVPN创建的虚拟网卡。</li>\n<li>OpenVPN客户端将原始的SSH数据包（TCP协议）<strong>整个加密并包裹（封装）</strong> 在一个新的数据包内，这个新数据包的目的地是跳板机的公网IP。</li>\n<li>这个加密后的数据包通过互联网发送到跳板机。</li>\n</ul>\n</li>\n<li><strong>跳板机处理</strong>（流量枢纽）：<ul>\n<li>跳板机上的OpenVPN服务端<strong>解密</strong>收到的数据包，<strong>解出</strong>原始的SSH请求数据包。</li>\n<li>跳板机的<strong>操作系统内核</strong>根据其自身的路由表，发现这个目标是 <code>192.168.1.100</code> 的数据包需要从其内部网卡（如 <code>eth0</code>）发出。</li>\n<li><strong>防火墙和访问控制</strong>：在转发前，跳板机上的防火墙规则（如 <code>iptables</code>）会进行检查，判断源IP（<code>10.8.0.100</code>）是否有权限访问目标IP（<code>192.168.1.100</code>）的22端口。通过后，才将数据包转发给目标Web服务器。</li>\n</ul>\n</li>\n<li><strong>响应返回</strong>：<ul>\n<li>Web服务器处理SSH请求后，将响应包发回给跳板机（因为请求的来源IP是跳板机）。</li>\n<li>跳板机收到响应后，再将其加密，通过隧道发回给远端的用户客户端。</li>\n<li>客户端解密后，得到原始的SSH响应，完成一次完整的交互。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"🛡️-核心价值与优势\"><a href=\"#🛡️-核心价值与优势\" class=\"headerlink\" title=\"🛡️ 核心价值与优势\"></a>🛡️ 核心价值与优势</h4><p>这种架构的优势在于提供了<strong>双重安全性和极佳的可管理性</strong>：</p>\n<ol>\n<li><strong>强身份认证</strong>：通过证书方式，同时验证了服务器和客户端的身份，避免了密码泄露和中间人攻击。</li>\n<li><strong>通信加密</strong>：所有数据在公网上传输时都是加密的，保证机密性。</li>\n<li><strong>访问隔离</strong>：跳板机成为唯一的入口，外部无法直接访问任何其他内网机器，攻击面最小化。</li>\n<li><strong>集中审计与管控</strong>：所有对内网的访问都必须经过跳板机，便于<strong>记录完整的操作日志</strong>、<strong>监控会话</strong>和<strong>统一设置访问权限策略</strong>。管理员只需要在跳板机上修改规则，就可以控制所有用户的权限。</li>\n</ol>\n<h3 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h3><ul>\n<li><strong>OpenVPN客户端</strong>是您用来<strong>连接</strong>的<strong>软件</strong>。</li>\n<li><strong>跳板机</strong>是您<strong>连接上去</strong>的那台<strong>服务器</strong>。</li>\n<li>OpenVPN是<strong>实现安全连接的方式之一</strong>，而跳板机是<strong>一种网络访问策略和架构</strong>。</li>\n</ul>\n<p>您可以<strong>不使用OpenVPN</strong>而用其他方式（如SSH）登录跳板机；也可以<strong>使用OpenVPN</strong>连接到一台<strong>不是跳板机</strong>的服务器（例如只是为了加密咖啡店的公共Wi-Fi流量）。</p>\n<p>但当它们结合时，就构成了一个非常经典和强大的安全远程访问方案。</p>\n<h2 id=\"🧠-什么是堡垒机？\"><a href=\"#🧠-什么是堡垒机？\" class=\"headerlink\" title=\"🧠 什么是堡垒机？\"></a>🧠 什么是堡垒机？</h2><p>如果说「跳板机」是一个基础概念，那么「堡垒机」就是它的<strong>完全体、企业级、工业化</strong>的形态。</p>\n<p><strong>堡垒机</strong>（Bastion Host）是一种位于内部网络和外部网络之间的<strong>高性能、高安全性的专用服务器</strong>，其核心设计理念是 <strong>“网络要塞”</strong> 。所有内部设备的远程访问（如 SSH, RDP, SFTP）都必须通过它进行，它作为唯一的入口点，集中进行<strong>身份认证、授权、审计和监控</strong>。</p>\n<p>您可以把它想象成一个<strong>极其严格的银行金库门卫</strong>：</p>\n<ol>\n<li><strong>唯一入口</strong>：所有人都必须从这个门进出。</li>\n<li><strong>严格安检</strong>：需要多重身份验证（工牌、指纹、密码）。</li>\n<li><strong>权限分明</strong>：你只能进入你有权限进入的区域（金库、柜台、办公室）。</li>\n<li><strong>全程监控</strong>：你进去后的一举一动都被全程录像，说了什么话（执行的命令）、拿了什么东西（传输的文件）都有记录。</li>\n</ol>\n<hr>\n<h3 id=\"🆚-堡垒机-vs-简单跳板机：有何不同？\"><a href=\"#🆚-堡垒机-vs-简单跳板机：有何不同？\" class=\"headerlink\" title=\"🆚 堡垒机 vs. 简单跳板机：有何不同？\"></a>🆚 堡垒机 vs. 简单跳板机：有何不同？</h3><p>很多人会混用这两个词，但它们有本质上的区别：</p>\n<table>\n<thead>\n<tr>\n<th><strong>特性</strong></th>\n<th><strong>简单跳板机 (Jump Server)</strong></th>\n<th><strong>堡垒机 (Bastion Host)</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>核心功能</strong></td>\n<td><strong>网络转发</strong>、基础连接</td>\n<td><strong>4A管理</strong>：认证、授权、账号、审计</td>\n</tr>\n<tr>\n<td><strong>安全性</strong></td>\n<td>相对较低，依赖系统自身安全</td>\n<td><strong>极高</strong>，有专门的安全加固和防护</td>\n</tr>\n<tr>\n<td><strong>用户体验</strong></td>\n<td>命令行，原始</td>\n<td><strong>Web图形化界面</strong>，易于操作</td>\n</tr>\n<tr>\n<td><strong>权限控制</strong></td>\n<td>粗粒度（能&#x2F;不能登录某台机器）</td>\n<td><strong>细粒度</strong>（能登录，且只能执行某些命令）</td>\n</tr>\n<tr>\n<td><strong>审计能力</strong></td>\n<td>基础日志（谁什么时候登录了）</td>\n<td><strong>强大审计</strong><strong>：</strong>**   <strong><strong>-</strong></strong> **<strong>会话录像</strong>（全程录屏）   - <strong>命令记录</strong>（精确到每一条命令）   - <strong>文件传输记录</strong></td>\n</tr>\n<tr>\n<td><strong>账号管理</strong></td>\n<td>分散在各台服务器上</td>\n<td><strong>统一账号管理</strong>，单点登录（SSO）</td>\n</tr>\n<tr>\n<td><strong>本质</strong></td>\n<td><strong>一台功能单一的服务器</strong></td>\n<td><strong>一套完整的安全运维管控系统</strong></td>\n</tr>\n</tbody></table>\n<p><strong>简单说：跳板机主要解决“<strong>怎么进去</strong>”的问题，而堡垒机在此基础上，更解决了“<strong>谁能进</strong>”、“<strong>能干什么</strong>”和“<strong>干了什么</strong>”的问题。</strong></p>\n<hr>\n<h3 id=\"🛡️-堡垒机的核心功能（4A管理）\"><a href=\"#🛡️-堡垒机的核心功能（4A管理）\" class=\"headerlink\" title=\"🛡️ 堡垒机的核心功能（4A管理）\"></a>🛡️ 堡垒机的核心功能（4A管理）</h3><h4 id=\"1-认证-Authentication-：“你是谁？”\"><a href=\"#1-认证-Authentication-：“你是谁？”\" class=\"headerlink\" title=\"1. 认证 (Authentication)：“你是谁？”\"></a>1. 认证 (Authentication)：“你是谁？”</h4><ul>\n<li><strong>多种认证方式</strong>：支持密码、SSH密钥、动态令牌（如Google Authenticator）、LDAP&#x2F;AD域集成、生物识别等。</li>\n<li><strong>多因子认证 (MFA)</strong>：强制要求使用两种及以上方式验证身份，极大提升安全性。</li>\n</ul>\n<h4 id=\"2-授权-Authorization-：“你能干什么？”\"><a href=\"#2-授权-Authorization-：“你能干什么？”\" class=\"headerlink\" title=\"2. 授权 (Authorization)：“你能干什么？”\"></a>2. 授权 (Authorization)：“你能干什么？”</h4><ul>\n<li><strong>精细化的权限控制</strong>：<ul>\n<li><strong>主机权限</strong>：允许用户访问哪些服务器（如：只能访问Web服务器，不能访问数据库服务器）。</li>\n<li><strong>操作权限</strong>：允许用户执行哪些命令（如：可以执行 <code>systemctl restart nginx</code>，但不能执行 <code>rm -rf /</code>）。</li>\n<li><strong>时间权限</strong>：允许用户在什么时间段内访问（如：只能在工作时间访问）。</li>\n</ul>\n</li>\n<li><strong>临时权限申请与审批</strong>：如果需要临时获得更高权限，可以通过工单系统申请，由管理员审批后自动授权，过期自动回收。</li>\n</ul>\n<h4 id=\"3-账号-Account-：“你的身份是什么？”\"><a href=\"#3-账号-Account-：“你的身份是什么？”\" class=\"headerlink\" title=\"3. 账号 (Account)：“你的身份是什么？”\"></a>3. 账号 (Account)：“你的身份是什么？”</h4><ul>\n<li><strong>统一账号管理</strong>：在堡垒机上创建账号，即可映射到后端的多台服务器，无需在每个服务器上单独创建账号。实现了“一个堡垒机账号，访问所有授权资产”。</li>\n<li><strong>托管服务器账号</strong>：服务器账号和密码可以由堡垒机托管，用户无需知道目标服务器的真实密码。</li>\n</ul>\n<h4 id=\"4-审计-Audit-：“你干了什么？”（这是堡垒机的灵魂）\"><a href=\"#4-审计-Audit-：“你干了什么？”（这是堡垒机的灵魂）\" class=\"headerlink\" title=\"4. 审计 (Audit)：“你干了什么？”（这是堡垒机的灵魂）\"></a>4. 审计 (Audit)：“你干了什么？”（这是堡垒机的灵魂）</h4><ul>\n<li><strong><strong>会话录像 (Session Recording)</strong>：** 像录屏一样，完整记录用户在目标服务器上的**所有操作过程</strong>，包括敲打的命令、返回的结果。无法抵赖。</li>\n<li><strong>命令记录</strong>：详细记录执行过的每一条命令及其时间、来源IP。</li>\n<li><strong>文件传输审计</strong>：记录所有通过SFTP&#x2F;SCP&#x2F;RDP上传和下载的文件日志。</li>\n<li><strong>行为分析</strong>：对异常操作、危险命令（如 <code>rm</code>、<code>chmod</code>）进行实时告警。</li>\n</ul>\n<hr>\n<h3 id=\"🏗️-堡垒机的工作流程\"><a href=\"#🏗️-堡垒机的工作流程\" class=\"headerlink\" title=\"🏗️ 堡垒机的工作流程\"></a>🏗️ 堡垒机的工作流程</h3><p>下图以一个运维人员需要通过堡垒机修复网站为例，展示了其核心工作流程与4A功能：</p>\n<p>:::tips<br><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756749301182-aa40bc89-4556-4198-8134-31e398991d2f.svg\"\n                     \n                ></p>\n<p>:::</p>\n<hr>\n<h3 id=\"🚀-常见的堡垒机方案\"><a href=\"#🚀-常见的堡垒机方案\" class=\"headerlink\" title=\"🚀 常见的堡垒机方案\"></a>🚀 常见的堡垒机方案</h3><ol>\n<li><strong>开源方案</strong>：<ul>\n<li><strong>Jumpserver</strong>：国内最流行的开源堡垒机，功能全面，对中文支持好，社区活跃。</li>\n<li><strong>Teleport</strong>：现代、轻量级，对云原生和Kubernetes环境支持良好。</li>\n<li><strong>Apache Guacamole</strong>：无客户端堡垒机，通过浏览器即可实现RDP、SSH、VNC等连接。</li>\n</ul>\n</li>\n<li><strong>商业方案</strong>：<ul>\n<li><strong>齐治堡垒机</strong>：国内老牌商业产品，市场份额大。</li>\n<li>** Cisco Secure Access (前Duo)**、<strong>CyberArk</strong>：国际知名的商业解决方案，功能强大，价格昂贵。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"✅-总结：为什么需要堡垒机？\"><a href=\"#✅-总结：为什么需要堡垒机？\" class=\"headerlink\" title=\"✅ 总结：为什么需要堡垒机？\"></a>✅ 总结：为什么需要堡垒机？</h3><ol>\n<li><strong>安全第一</strong>：极大缩小了网络攻击面，保护了内部资产。</li>\n<li><strong>合规要求</strong>：满足等保2.0、ISO27001、GDPR等法规对运维审计的强制性要求。</li>\n<li><strong>权限清晰</strong>：实现最小权限原则，避免权限滥用。</li>\n<li><strong>责任界定</strong>：出现问题时，可以通过录像和日志快速定位责任人、还原事故现场。</li>\n<li><strong>运维效率</strong>：统一入口，简化了账号管理和访问流程。</li>\n</ol>\n<p>简而言之，堡垒机是企业IT基础设施中<strong>不可或缺的安全与审计基石</strong>，尤其对于金融、政府、互联网等对安全性和合规性要求极高的行业来说，是标配产品。</p>\n<h1 id=\"OpenVpn-跳板机-堡垒机实现前端部署\"><a href=\"#OpenVpn-跳板机-堡垒机实现前端部署\" class=\"headerlink\" title=\"OpenVpn+跳板机&#x2F;堡垒机实现前端部署\"></a>OpenVpn+跳板机&#x2F;堡垒机实现前端部署</h1><p>这是一个非常经典的DevOps场景：OpenVpn+跳板机&#x2F;堡垒机与前端工程部署结合起来，可以构建一个既安全又高效的部署流程。</p>\n<p>这种架构的核心思想是：通过 OpenVPN 建立安全通道，通过跳板机&#x2F;堡垒机作为统一、受控的入口，来执行部署操作。</p>\n<h2 id=\"🧩-核心架构与角色分工\"><a href=\"#🧩-核心架构与角色分工\" class=\"headerlink\" title=\"🧩 核心架构与角色分工\"></a>🧩 核心架构与角色分工</h2><p>在这种架构下，各个组件的职责非常清晰：</p>\n<ol>\n<li><strong>OpenVPN Server</strong>：<strong>负责建“路”</strong>。建立一条从开发者本地到部署环境的加密隧道，确保传输安全。</li>\n<li><strong>跳板机&#x2F;堡垒机 (Bastion Host)</strong>：<strong>负责管“门”和看“人”</strong>。它是唯一的部署操作入口，负责身份验证、权限控制和操作审计。</li>\n<li><strong>部署目标服务器</strong>：<strong>负责住“应用”</strong>。这是最终运行前端项目（Nginx, Node.js 等）的服务器。</li>\n<li><strong>CI&#x2F;CD 工具 (可选但推荐)</strong>：<strong>负责自动“开车”</strong>。例如 Jenkins、GitLab Runner 等，它们可以自动从仓库拉取代码、构建，并通过跳板机执行部署脚本。</li>\n</ol>\n<p>整个从前端代码到部署上线的安全部署流程，如图所述：</p>\n<p>:::tips<br><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756747253378-aa010295-0b0b-4500-a839-7162fc66eaa3.svg\"\n                     \n                ></p>\n<p>:::</p>\n<h2 id=\"🛠️-两种常见的部署模式\"><a href=\"#🛠️-两种常见的部署模式\" class=\"headerlink\" title=\"🛠️ 两种常见的部署模式\"></a>🛠️ 两种常见的部署模式</h2><h3 id=\"模式一：手动部署（适合小团队或初期）\"><a href=\"#模式一：手动部署（适合小团队或初期）\" class=\"headerlink\" title=\"模式一：手动部署（适合小团队或初期）\"></a>模式一：手动部署（适合小团队或初期）</h3><p><strong>流程：</strong> 开发者本地构建，然后通过跳板机手动上传文件。</p>\n<p><strong>本地构建</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run build</span><br></pre></td></tr></table></figure>\n\n<p>这会在项目根目录生成 <code>dist</code> 或 <code>build</code> 文件夹，里面是静态文件（HTML, CSS, JS）。</p>\n<ol>\n<li><strong>连接VPN</strong>：确保 OpenVPN 客户端已连接，获得访问内网的权限。</li>\n<li><strong>通过跳板机上传文件</strong>：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用 scp 命令，通过跳板机转发到目标服务器</span></span><br><span class=\"line\"><span class=\"comment\"># 注意：跳板机需要配置SSH代理转发或用户有直接权限</span></span><br><span class=\"line\">scp -r -o <span class=\"string\">&#x27;ProxyJump user@jumpbox-ip&#x27;</span> ./dist/* user@target-server-ip:/path/to/nginx/html/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 或者使用更现代的 rsync</span></span><br><span class=\"line\">rsync -avz -e <span class=\"string\">&quot;ssh -J user@jumpbox-ip&quot;</span> ./dist/ user@target-server-ip:/path/to/nginx/html/</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>通过跳板机执行远程命令</strong>（如果需要）：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 登录跳板机，再从跳板机SSH到目标服务器</span></span><br><span class=\"line\">ssh user@jumpbox-ip</span><br><span class=\"line\"><span class=\"comment\"># 然后，在跳板机上执行</span></span><br><span class=\"line\">ssh user@target-server-ip <span class=\"string\">&quot;sudo nginx -s reload&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模式二：自动化部署（推荐，适合成熟团队）\"><a href=\"#模式二：自动化部署（推荐，适合成熟团队）\" class=\"headerlink\" title=\"模式二：自动化部署（推荐，适合成熟团队）\"></a>模式二：自动化部署（推荐，适合成熟团队）</h3><p><strong>流程：</strong> CI&#x2F;CD 工具（如 Jenkins、GitLab CI）在检测到 Git 标签或特定分支更新后，自动完成所有步骤。</p>\n<p>这是一个在 GitLab 中实现的自动化部署流程示例：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># .gitlab-ci.yml</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">stages:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">deploy</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">build_production:</span></span><br><span class=\"line\">  <span class=\"attr\">stage:</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"attr\">image:</span> <span class=\"string\">node:16</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">if:</span> <span class=\"string\">$CI_COMMIT_TAG</span> <span class=\"comment\"># 通常在打标签时触发生产环境部署</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">install</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">npm</span> <span class=\"string\">run</span> <span class=\"string\">build</span></span><br><span class=\"line\">  <span class=\"attr\">artifacts:</span></span><br><span class=\"line\">    <span class=\"attr\">paths:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">dist/</span> <span class=\"comment\"># 将构建产物传递给下一个阶段</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">deploy_to_production:</span></span><br><span class=\"line\">  <span class=\"attr\">stage:</span> <span class=\"string\">deploy</span></span><br><span class=\"line\">  <span class=\"attr\">image:</span> <span class=\"string\">alpine</span></span><br><span class=\"line\">  <span class=\"attr\">rules:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">if:</span> <span class=\"string\">$CI_COMMIT_TAG</span></span><br><span class=\"line\">  <span class=\"attr\">script:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">apk</span> <span class=\"string\">add</span> <span class=\"string\">--no-cache</span> <span class=\"string\">openssh-client</span> <span class=\"string\">rsync</span></span><br><span class=\"line\">    <span class=\"comment\"># 使用 SSH 通过跳板机部署 (-o ProxyJump)</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">rsync</span> <span class=\"string\">-avz</span> <span class=\"string\">--delete</span> <span class=\"string\">-e</span> <span class=\"string\">&quot;ssh -o StrictHostKeyChecking=no -J $JUMPBOX_USER@$JUMPBOX_IP&quot;</span> <span class=\"string\">dist/</span> <span class=\"string\">$TARGET_SERVER_USER@$TARGET_SERVER_IP:/app/frontend/</span></span><br><span class=\"line\">    <span class=\"comment\"># 通过跳板机执行远程命令，重启服务</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">ssh</span> <span class=\"string\">-J</span> <span class=\"string\">$JUMPBOX_USER@$JUMPBOX_IP</span> <span class=\"string\">$TARGET_SERVER_USER@$TARGET_SERVER_IP</span> <span class=\"string\">&quot;sudo systemctl reload nginx&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>关键点：</strong></p>\n<ul>\n<li><code>$JUMPBOX_IP</code>, <code>$TARGET_SERVER_IP</code> 等变量在 GitLab 的 <strong>CI&#x2F;CD 设置</strong>中配置，避免写在代码里。</li>\n<li><code>-J</code> 参数是 SSH 的 <strong>代理跳跃</strong>，让 SSH 连接自动通过跳板机。</li>\n<li>堡垒机上需要存放 CI&#x2F;CD 工具的 <strong>SSH 私钥</strong>，并且该密钥对目标服务器有访问权限。</li>\n</ul>\n<hr>\n<h2 id=\"⚙️-部署前的重要准备工作\"><a href=\"#⚙️-部署前的重要准备工作\" class=\"headerlink\" title=\"⚙️ 部署前的重要准备工作\"></a>⚙️ 部署前的重要准备工作</h2><ol>\n<li><strong>网络与权限配置</strong>：<ul>\n<li>确保 OpenVPN 服务器配置的路由规则，能让客户端访问到跳板机和目标服务器。</li>\n<li>在跳板机上为每个开发者或CI&#x2F;CD服务创建账号，并配置严格的 SSH 密钥认证。</li>\n<li>配置跳板机的权限控制，确保用户只能访问特定的目标服务器。</li>\n</ul>\n</li>\n<li><strong>堡垒机审计</strong>：<ul>\n<li>开启堡垒机的会话录制功能，记录所有通过它执行的部署命令和文件传输操作。一旦出问题，可以快速回放定位。</li>\n</ul>\n</li>\n<li><strong>目标服务器配置</strong>：<ul>\n<li><strong>Nginx 配置示例</strong>：</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\">  <span class=\"attribute\">server_name</span> your-app.com;</span><br><span class=\"line\">  <span class=\"attribute\">root</span> /app/frontend; <span class=\"comment\"># 前端文件部署的目录</span></span><br><span class=\"line\">  <span class=\"attribute\">index</span> index.html;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 处理 SPA 路由（如 Vue Router 的 history 模式）</span></span><br><span class=\"line\">  <span class=\"section\">location</span> / &#123;</span><br><span class=\"line\">    <span class=\"attribute\">try_files</span> <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.html;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># 启用 gzip 压缩</span></span><br><span class=\"line\">  <span class=\"attribute\">gzip</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\">  <span class=\"attribute\">gzip_types</span> text/css application/javascript;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"✅-这种架构的优势\"><a href=\"#✅-这种架构的优势\" class=\"headerlink\" title=\"✅ 这种架构的优势\"></a>✅ 这种架构的优势</h2><ol>\n<li><strong>极致安全</strong>：<ul>\n<li>内部服务器<strong>完全不用暴露到公网</strong>，攻击者无法直接扫描到。</li>\n<li>所有部署操作都经过<strong>加密隧道</strong>和<strong>严格审计</strong>。</li>\n</ul>\n</li>\n<li><strong>权限清晰</strong>：<ul>\n<li>开发者可能根本不知道目标服务器的密码，而是通过堡垒机的授权来访问，实现了权限最小化原则。</li>\n</ul>\n</li>\n<li><strong>流程标准化</strong>：<ul>\n<li>无论是谁部署，都必须走同一个通道，执行相同的流程，减少了人为出错的可能。</li>\n</ul>\n</li>\n<li><strong>可追溯性</strong>：<ul>\n<li>结合堡垒机的录像功能，可以清晰看到<strong>谁</strong>、在<strong>什么时间</strong>、<strong>部署了什么</strong>、<strong>执行了什么命令</strong>，便于故障排查和审计。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"⚠️-注意事项\"><a href=\"#⚠️-注意事项\" class=\"headerlink\" title=\"⚠️ 注意事项\"></a>⚠️ 注意事项</h2><ul>\n<li><strong>复杂度</strong>：初始设置比直接部署到公网服务器要复杂，但长期来看收益巨大。</li>\n<li><strong>性能</strong>：如果 CI&#x2F;CD 服务器在海外，而跳板机和目标服务器在国内，传输大量文件可能会慢，可以考虑在目标服务器上直接构建。</li>\n<li><strong>成本</strong>：需要维护额外的跳板机&#x2F;堡垒机组件。</li>\n</ul>\n<p><strong>总结：</strong> <strong>OpenVPN + 跳板机&#x2F;堡垒机的部署模式，是企业级前端工程部署的最佳实践之一。</strong> 它通过牺牲一点点部署的便利性，换来了极高的安全性和规范性，非常适合对安全有要求的中大型项目。</p>\n<h1 id=\"SaaS使用的部署方式到底叫什么呢？\"><a href=\"#SaaS使用的部署方式到底叫什么呢？\" class=\"headerlink\" title=\"SaaS使用的部署方式到底叫什么呢？\"></a>SaaS使用的部署方式到底叫什么呢？</h1><p>描述：没有使用jenkins，开发者通过堡垒机连入目标网络中通过git拉取代码并执行打包命令后生成dist或build文件夹，执行shell脚本将打包后的静态资源放到对应的目标服务器的路径下。</p>\n<p><strong>手动或半自动的基于堡垒机的 Git 拉取部署。</strong></p>\n<p>更具体地说，它属于 <strong>“Git-Based Deployment”</strong> 的一种演变形式，核心特点是<strong>通过安全堡垒机作为跳板，直接在目标环境或邻近网络中执行构建和部署</strong>。</p>\n<h2 id=\"🧩-这种部署模式的详细流程拆解\"><a href=\"#🧩-这种部署模式的详细流程拆解\" class=\"headerlink\" title=\"🧩 这种部署模式的详细流程拆解\"></a>🧩 这种部署模式的详细流程拆解</h2><p>:::tips<br><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://cdn.nlark.com/yuque/0/2025/svg/55999631/1756747641121-afeda975-ab3a-4be8-a945-8b803dd7b2bd.svg\"\n                     \n                ></p>\n<p>:::</p>\n<p>它与纯CI&#x2F;CD自动化部署的<strong>核心区别</strong>在于，流程图中<strong>黄色框线</strong>的部分（从 <code>git push</code> 到 <code>重启服务</code>）完全由<strong>开发者手动触发和执行</strong>，而非由CI&#x2F;CD工具（如Jenkins、GitLab CI）自动触发。</p>\n<hr>\n<h2 id=\"⚙️-这种模式的特点\"><a href=\"#⚙️-这种模式的特点\" class=\"headerlink\" title=\"⚙️ 这种模式的特点\"></a>⚙️ 这种模式的特点</h2><h3 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h3><ol>\n<li><strong>环境高度一致</strong>：在<strong>目标网络内</strong>进行构建，可以有效避免“在我本地是好的”这类问题。构建环境与生产环境一致（操作系统、Node版本等）。</li>\n<li><strong>安全性高</strong>：所有操作都通过受审计的堡垒机进行，目标服务器无需暴露到公网，也无需在本地和服务器之间开放额外的端口。</li>\n<li><strong>简单直接，无需复杂配置</strong>：不需要搭建和维护一整套CI&#x2F;CD系统（如Jenkins），对于小团队或项目初期来说，成本更低，更轻量。</li>\n<li><strong>依赖少</strong>：只需要目标服务器上有Git和Node.js环境即可，不需要安装CI&#x2F;CD的Agent。</li>\n</ol>\n<h3 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h3><ol>\n<li><strong>自动化程度低</strong>：严重依赖人工操作。开发者需要手动登录、执行一系列命令。容易因操作失误（比如忘了拉最新代码、在错误目录执行）导致部署失败。</li>\n<li><strong>无法实现真正的持续交付</strong>：部署过程不是自动触发的，通常需要人工干预，无法做到代码一提交就自动测试和部署。</li>\n<li><strong>可追溯性较差</strong>：虽然堡垒机会记录执行了哪些命令，但**“谁在什么时候部署了哪个版本的代码”** 这一信息没有与代码提交（Git Tag&#x2F;Commit ID）强关联地记录下来。出问题时，需要回溯堡垒机日志。</li>\n<li><strong>效率较低</strong>：每次部署都需要在服务器上重新执行完整的构建过程，占用服务器资源，如果服务器性能不佳，构建时间会很长。</li>\n</ol>\n<hr>\n<h2 id=\"🚀-如何优化这种模式？\"><a href=\"#🚀-如何优化这种模式？\" class=\"headerlink\" title=\"🚀 如何优化这种模式？\"></a>🚀 如何优化这种模式？</h2><p>即使不引入Jenkins，也可以让这个流程变得更高效、更可靠：</p>\n<h3 id=\"1-编写自动化部署脚本\"><a href=\"#1-编写自动化部署脚本\" class=\"headerlink\" title=\"1. 编写自动化部署脚本\"></a>1. 编写自动化部署脚本</h3><p>将一系列手动命令写成一个Shell脚本，例如 <code>deploy.sh</code>，放在代码库根目录。</p>\n<p><strong>（这就是SaaS的做法）</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"comment\"># deploy.sh</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">set</span> -e <span class=\"comment\"># 遇到错误就退出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;1. Pulling latest code...&quot;</span></span><br><span class=\"line\">git pull origin main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;2. Installing dependencies...&quot;</span></span><br><span class=\"line\">npm install</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;3. Building project...&quot;</span></span><br><span class=\"line\">npm run build</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;4. Backing up old version...&quot;</span></span><br><span class=\"line\">tar -czf /app/backup/frontend-$(<span class=\"built_in\">date</span> +%Y%m%d-%H%M%S).tar.gz /usr/share/nginx/html/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;5. Deploying new version...&quot;</span></span><br><span class=\"line\">rsync -av --delete ./dist/ /usr/share/nginx/html/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;6. Reloading Nginx...&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">sudo</span> systemctl reload nginx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;Deployment completed successfully!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>使用方式：</strong> 开发者登录后，只需要执行一条命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bash deploy.sh</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-使用-Git-Hooks（简单CI）\"><a href=\"#2-使用-Git-Hooks（简单CI）\" class=\"headerlink\" title=\"2. 使用 Git Hooks（简单CI）\"></a>2. 使用 Git Hooks（简单CI）</h3><p>在<strong>代码服务器的Git仓库</strong>上配置 <code>post-receive</code> Hook（例如使用Gitea），当收到<code>push</code>时，自动通知目标服务器执行拉取和部署脚本。这实现了简单的自动触发。</p>\n<h3 id=\"3-使用-SSH-直接执行远程命令\"><a href=\"#3-使用-SSH-直接执行远程命令\" class=\"headerlink\" title=\"3. 使用 SSH 直接执行远程命令\"></a>3. 使用 SSH 直接执行远程命令</h3><p>开发者可以在本地电脑上通过一条命令完成部署，无需手动登录。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -J user@jumpbox-ip user@target-server-ip <span class=\"string\">&quot;cd /path/to/project &amp;&amp; bash deploy.sh&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-引入版本标记\"><a href=\"#4-引入版本标记\" class=\"headerlink\" title=\"4. 引入版本标记\"></a>4. 引入版本标记</h3><p>在脚本中加入步骤，在部署成功后，给当前的提交打上一个Tag。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git tag deploy-$(<span class=\"built_in\">date</span> +%Y%m%d-%H%M%S)</span><br><span class=\"line\">git push origin --tags</span><br></pre></td></tr></table></figure>\n\n<p>这样就能清晰地知道生产环境对应的是哪个代码版本。</p>\n<hr>\n<h2 id=\"✅-总结-1\"><a href=\"#✅-总结-1\" class=\"headerlink\" title=\"✅ 总结\"></a>✅ 总结</h2><p>这是一种 <strong>“基于堡垒机的半自动 Git 拉取部署”</strong>。</p>\n<ul>\n<li><strong>它不是什么？</strong> 它不是全自动的CI&#x2F;CD（如Jenkins Pipeline），也不是传统的FTP上传部署。</li>\n<li><strong>它是什么？</strong> 它是一种在<strong>安全约束条件下</strong>、<strong>介于手动部署和全自动部署之间</strong>的实用型方案。</li>\n</ul>\n<p><strong>适用场景：</strong></p>\n<ul>\n<li>内部系统、管理后台等对发布频率要求不高的项目。</li>\n<li>团队规模较小，尚未引入完整CI&#x2F;CD工具链的初期阶段。</li>\n<li>对安全性要求极高，所有内部网络访问必须通过堡垒机的环境。</li>\n</ul>\n<p>对于很多项目来说，这是一个非常好的起点。随着项目发展，当您觉得每次手动运行脚本也很麻烦时，就是考虑引入 <strong>GitLab CI&#x2F;CD、Github Actions</strong> 等真正自动化工具的时候了。</p>\n<h1 id=\"待完善内容\"><a href=\"#待完善内容\" class=\"headerlink\" title=\" 待完善内容 \"></a><font style=\"color:#FFFFFF;background-color:#ED740C;\"> 待完善内容 </font></h1><ul>\n<li><input disabled=\"\" type=\"checkbox\"> CI&#x2F;CD工具：jekins</li>\n<li><input disabled=\"\" type=\"checkbox\"> Docker</li>\n</ul>\n","_processedHighlight":true}],"PostAsset":[],"PostCategory":[{"post_id":"cmfjktvt00000tx5w8wom0bev","category_id":"cmfjktvt50001tx5w3zva8wch","_id":"cmfjktvt70004tx5w10m3hf09"},{"post_id":"cmfjkpz9g0000ma5wfkkshevh","category_id":"cmfjkx02r0000y35w563tb1n6","_id":"cmfjkx02t0003y35wbmejcfhu"},{"post_id":"cmfjk7nik0000d65w4wct3bto","category_id":"cmfjlykvk0000h65whul24ryt","_id":"cmfjlykvp0003h65wcsyr2eef"}],"PostTag":[{"post_id":"cmfjktvt00000tx5w8wom0bev","tag_id":"cmfjktvt60002tx5wezongbu3","_id":"cmfjktvt80006tx5wb64m73k0"},{"post_id":"cmfjktvt00000tx5w8wom0bev","tag_id":"cmfjktvt70003tx5wf5mihu0d","_id":"cmfjktvt80007tx5wacu11ze1"},{"post_id":"cmfjktvt00000tx5w8wom0bev","tag_id":"cmfjktvt70005tx5wclga6jlz","_id":"cmfjktvt80008tx5wbw2c40fg"},{"post_id":"cmfjkpz9g0000ma5wfkkshevh","tag_id":"cmfjkx02s0001y35wg3vj9tc5","_id":"cmfjkx02u0006y35w7mia5gcw"},{"post_id":"cmfjkpz9g0000ma5wfkkshevh","tag_id":"cmfjkx02t0002y35wfkq4b4r2","_id":"cmfjkx02u0007y35wf101b8we"},{"post_id":"cmfjkpz9g0000ma5wfkkshevh","tag_id":"cmfjkx02t0004y35wb7o3c9jb","_id":"cmfjkx02u0008y35wbptd2ofd"},{"post_id":"cmfjkpz9g0000ma5wfkkshevh","tag_id":"cmfjkx02u0005y35w011ketrh","_id":"cmfjkx02u0009y35w3giv22mi"},{"post_id":"cmfjk7nik0000d65w4wct3bto","tag_id":"cmfjlykvn0001h65w4wic4945","_id":"cmfjlykvp0004h65w58qcc58o"},{"post_id":"cmfjk7nik0000d65w4wct3bto","tag_id":"cmfjlykvo0002h65wbbenfmqt","_id":"cmfjlykvp0005h65w1y822ho3"}],"Tag":[{"name":"部署","_id":"cmfjktvt60002tx5wezongbu3"},{"name":"前端","_id":"cmfjktvt70003tx5wf5mihu0d"},{"name":"CI/CD","_id":"cmfjktvt70005tx5wclga6jlz"},{"name":"微前端","_id":"cmfjkx02s0001y35wg3vj9tc5"},{"name":"qiankun","_id":"cmfjkx02t0002y35wfkq4b4r2"},{"name":"single-spa","_id":"cmfjkx02t0004y35wb7o3c9jb"},{"name":"Module Federation","_id":"cmfjkx02u0005y35w011ketrh"},{"name":"Nuxt","_id":"cmfjlykvn0001h65w4wic4945"},{"name":"服务端渲染","_id":"cmfjlykvo0002h65wbbenfmqt"}]}}